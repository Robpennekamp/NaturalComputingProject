[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/Canvas.js",
    "content": "\n\"use strict\"\n\nimport GridBasedModel from \"./models/GridBasedModel.js\"\nimport CPM from \"./models/CPM.js\"\nimport Grid2D from \"./grid/Grid2D.js\"\nimport CoarseGrid from \"./grid/CoarseGrid.js\"\nimport PixelsByCell from \"./stats/PixelsByCell.js\"\nimport ActivityConstraint from \"./hamiltonian/ActivityConstraint.js\"\nimport ActivityMultiBackground from \"./hamiltonian/ActivityMultiBackground.js\"\n\n/**\n * Class for taking a CPM grid and displaying it in either browser or with\n *  nodejs.\n * Note: when using this class from outside the module, you don't need to import\n *  it separately but can access it from CPM.Canvas. */\nclass Canvas {\n\t/** The Canvas constructor accepts a CPM object C or a Grid2D object.\n\t@param {GridBasedModel|Grid2D|CoarseGrid} C - the object to draw, which must\n\t be an object of class {@link GridBasedModel} (or its subclasses {@link CPM}\n\t and {@link CA}), or a 2D grid ({@link Grid2D} or {@link CoarseGrid}).\n\t Drawing of other grids is currently not supported.\n\t@param {object} [options = {}] - Configuration settings\n\t@param {number} [options.zoom = 1]- positive number specifying the zoom\n\t level to draw with.\n\t@param {number[]} [options.wrap = [0,0,0]] - if nonzero: 'wrap' the grid to\n\t these dimensions; eg a pixel with x coordinate 201 and wrap[0] = 200 is\n\t displayed at x = 1.\n\t@param {string} [options.parentElement = document.body] - the element on\n\t the html page where the canvas will be appended.\n\n\t@example <caption>A CPM with Canvas</caption>\n\t* let CPM = require( \"path/to/build\" )\n\t*\n\t* // Create a CPM, corresponding Canvas and GridManipulator\n\t* // (Use CPM. prefix from outside the module)\n\t* let C = new CPM.CPM( [200,200], {\n\t* \tT : 20,\n\t* \tJ : [[0,20][20,10]],\n\t* \tV:[0,500],\n\t* \tLAMBDA_V:[0,5]\n\t* } )\n\t* let Cim = new CPM.Canvas( C, {zoom:2} )\n\t* let gm = new CPM.GridManipulator( C )\n\t*\n\t* // Seed a cell at [x=100,y=100] and run 100 MCS.\n\t* gm.seedCellAt( 1, [100,100] )\n\t* for( let t = 0; t < 100; t++ ){\n\t* \tC.timeStep()\n\t* }\n\t*\n\t* // Draw the cell and save an image\n\t* Cim.drawCells( 1, \"FF0000\" )\t\t\t// draw cells of CellKind 1 in red\n\t* Cim.writePNG( \"my-cell-t100.png\" )\n\t*/\n\tconstructor( C, options ){\n\t\tif( C instanceof GridBasedModel ){\n\t\t\t/**\n\t\t\t * The underlying model that is drawn on the canvas.\n\t\t\t * @type {GridBasedModel|CPM|CA}\n\t\t\t */\n\t\t\tthis.C = C\n\t\t\t/**\n\t\t\t * The underlying grid that is drawn on the canvas.\n\t\t\t * @type {Grid2D|CoarseGrid}\n\t\t\t */\n\t\t\tthis.grid = this.C.grid\n\n\t\t\t/** Grid size in each dimension, taken from the CPM or grid object\n\t\t\t * to draw.\n\t\t\t * @type {GridSize} each element is the grid size in that dimension\n\t\t\t * in pixels */\n\t\t\tthis.extents = C.extents\n\t\t} else if( C instanceof Grid2D  ||  C instanceof CoarseGrid ){\n\n\t\t\tthis.grid = C\n\t\t\tthis.extents = C.extents\n\t\t}\n\t\t/** Zoom level to draw the canvas with, set to options.zoom or its\n\t\t * default value 1.\n\t\t * @type {number}*/\n\t\tthis.zoom = (options && options.zoom) || 1\n\t\t/** if nonzero: 'wrap' the grid to these dimensions; eg a pixel with x\n\t\t * coordinate 201 and wrap[0] = 200 is displayed at x = 1.\n\t\t * @type {number[]} */\n\t\tthis.wrap = (options && options.wrap) || [0,0,0]\n\n\t\t/** Width of the canvas in pixels (in its unzoomed state)\n\t\t * @type {number}*/\n\t\tthis.width = this.wrap[0]\n\t\t/** Height of the canvas in pixels (in its unzoomed state)\n\t\t * @type {number}*/\n\t\tthis.height = this.wrap[1]\n\n\t\tif( this.width === 0 || this.extents[0] < this.width ){\n\t\t\tthis.width = this.extents[0]\n\t\t}\n\t\tif( this.height === 0 || this.extents[1] < this.height ){\n\t\t\tthis.height = this.extents[1]\n\t\t}\n\n\t\tif( typeof document !== \"undefined\" ){\n\t\t\t/** @ignore */\n\t\t\tthis.el = document.createElement(\"canvas\")\n\t\t\tthis.el.width = this.width*this.zoom\n\t\t\tthis.el.height = this.height*this.zoom//extents[1]*this.zoom\n\t\t\tlet parent_element = (options && options.parentElement) || document.body\n\t\t\tparent_element.appendChild( this.el )\n\t\t} else {\n\t\t\tconst {createCanvas} = require(\"canvas\")\n\t\t\t/** @ignore */\n\t\t\tthis.el = createCanvas( this.width*this.zoom,\n\t\t\t\tthis.height*this.zoom )\n\t\t\t/** @ignore */\n\t\t\tthis.fs = require(\"fs\")\n\t\t}\n\n\t\t/** @ignore */\n\t\tthis.ctx = this.el.getContext(\"2d\")\n\t\tthis.ctx.lineWidth = .2\n\t\tthis.ctx.lineCap=\"butt\"\n\t}\n\n\t/** Give the canvas element an ID supplied as argument. Useful for building\n\t * an HTML page where you want to get this canvas by its ID.\n\t * @param {string} idString - the name to give the canvas element.\n\t * */\n\tsetCanvasId( idString ){\n\t\tthis.el.id = idString\n\t}\n\n\n\t/* Several internal helper functions (used by drawing functions below) : */\n\n\t/** @private\n\t * @ignore*/\n\tpxf( p ){\n\t\tthis.ctx.fillRect( this.zoom*p[0], this.zoom*p[1], this.zoom, this.zoom )\n\t}\n\n\t/** @private\n\t * @ignore */\n\tpxfi( p, alpha=1 ){\n\t\tconst dy = this.zoom*this.width\n\t\tconst off = (this.zoom*p[1]*dy + this.zoom*p[0])*4\n\t\tfor( let i = 0 ; i < this.zoom*4 ; i += 4 ){\n\t\t\tfor( let j = 0 ; j < this.zoom*dy*4 ; j += dy*4 ){\n\t\t\t\tthis.px[i+j+off] = this.col_r\n\t\t\t\tthis.px[i+j+off + 1] = this.col_g\n\t\t\t\tthis.px[i+j+off + 2] = this.col_b\n\t\t\t\tthis.px[i+j+off + 3] = alpha*255\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @private\n\t * @ignore */\n\tpxfir( p ){\n\t\tconst dy = this.zoom*this.width\n\t\tconst off = (p[1]*dy + p[0])*4\n\t\tthis.px[off] = this.col_r\n\t\tthis.px[off + 1] = this.col_g\n\t\tthis.px[off + 2] = this.col_b\n\t\tthis.px[off + 3] = 255\n\t}\n\n\t/** @private\n\t * @ignore*/\n\tgetImageData(){\n\t\t/** @ignore */\n\t\tthis.image_data = this.ctx.getImageData(0, 0, this.width*this.zoom, this.height*this.zoom)\n\t\t/** @ignore */\n\t\tthis.px = this.image_data.data\n\t}\n\n\t/** @private\n\t * @ignore*/\n\tputImageData(){\n\t\tthis.ctx.putImageData(this.image_data, 0, 0)\n\t}\n\n\t/** @private\n\t * @ignore*/\n\tpxfnozoom( p ){\n\t\tthis.ctx.fillRect( this.zoom*p[0], this.zoom*p[1], 1, 1 )\n\t}\n\n\t/** draw a line left (l), right (r), down (d), or up (u) of pixel p\n\t * @private\n\t * @ignore */\n\tpxdrawl( p ){\n\t\tfor( let i = this.zoom*p[1] ; i < this.zoom*(p[1]+1) ; i ++ ){\n\t\t\tthis.pxfir( [this.zoom*p[0],i] )\n\t\t}\n\t}\n\n\t/** @private\n\t * @ignore */\n\tpxdrawr( p ){\n\t\tfor( let i = this.zoom*p[1] ; i < this.zoom*(p[1]+1) ; i ++ ){\n\t\t\tthis.pxfir( [this.zoom*(p[0]+1),i] )\n\t\t}\n\t}\n\t/** @private\n\t * @ignore */\n\tpxdrawd( p ){\n\t\tfor( let i = this.zoom*p[0] ; i < this.zoom*(p[0]+1) ; i ++ ){\n\t\t\tthis.pxfir( [i,this.zoom*(p[1]+1)] )\n\t\t}\n\t}\n\t/** @private\n\t * @ignore */\n\tpxdrawu( p ){\n\t\tfor( let i = this.zoom*p[0] ; i < this.zoom*(p[0]+1) ; i ++ ){\n\t\t\tthis.pxfir( [i,this.zoom*p[1]] )\n\t\t}\n\t}\n\n\t/** For easier color naming\n\t * @private\n\t * @ignore */\n\tcol( hex ){\n\t\tthis.ctx.fillStyle=\"#\"+hex\n\t\t/** @ignore */\n\t\tthis.col_r = parseInt( hex.substr(0,2), 16 )\n\t\t/** @ignore */\n\t\tthis.col_g = parseInt( hex.substr(2,2), 16 )\n\t\t/** @ignore */\n\t\tthis.col_b = parseInt( hex.substr(4,2), 16 )\n\t}\n\n\t/** Hex code string for a color.\n\t * @typedef {string} HexColor*/\n\n\t/** Color the whole grid in color [col], or in black if no argument is given.\n\t * @param {HexColor} [col = \"000000\"] -hex code for the color to use, defaults to black.\n\t */\n\tclear( col ){\n\t\tcol = col || \"000000\"\n\t\tthis.ctx.fillStyle=\"#\"+col\n\t\tthis.ctx.fillRect( 0,0, this.el.width, this.el.height )\n\t}\n\n\t/** Rendering context of canvas.\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D\n\t * @typedef {object} CanvasRenderingContext2D\n\t * */\n\n\t/** Return the current drawing context.\n\t * @return {CanvasRenderingContext2D} current drawing context on the canvas.\n\t * */\n\tcontext(){\n\t\treturn this.ctx\n\t}\n\t/** @private\n\t * @ignore */\n\tp2pdraw( p ){\n\t\tfor( let dim = 0; dim < p.length; dim++ ){\n\t\t\tif( this.wrap[dim] !== 0 ){\n\t\t\t\tp[dim] = p[dim] % this.wrap[dim]\n\t\t\t}\n\t\t}\n\t\treturn p\n\t}\n\n\t/* DRAWING FUNCTIONS ---------------------- */\n\n\t/** Use to color a grid according to its values. High values are colored in\n\t * a brighter color.\n\t * @param {Grid2D|CoarseGrid} [cc] - the grid to draw values for. If left\n\t * unspecified, the grid that was originally supplied to the Canvas\n\t * constructor is used.\n\t * @param {HexColor} [col = \"0000FF\"] - the color to draw the chemokine in.\n\t * */\n\tdrawField( cc, col = \"0000FF\" ){\n\t\tif( !cc ){\n\t\t\tcc = this.grid\n\t\t}\n\t\tthis.col(col)\n\t\tlet maxval = 0\n\t\tfor( let i = 0 ; i < cc.extents[0] ; i ++ ){\n\t\t\tfor( let j = 0 ; j < cc.extents[1] ; j ++ ){\n\t\t\t\tlet p = Math.log(.1+cc.pixt([i,j]))\n\t\t\t\tif( maxval < p ){\n\t\t\t\t\tmaxval = p\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.getImageData()\n\t\t//this.col_g = 0\n\t\t//this.col_b = 0\n\t\tfor( let i = 0 ; i < cc.extents[0] ; i ++ ){\n\t\t\tfor( let j = 0 ; j < cc.extents[1] ; j ++ ){\n\t\t\t\t//let colval = 255*(Math.log(.1+cc.pixt( [i,j] ))/maxval)\n\t\t\t\tlet alpha = (Math.log(.1+cc.pixt( [i,j] ))/maxval)\n\t\t\t\t//this.col_r = colval\n\t\t\t\t//this.col_g = colval\n\t\t\t\tthis.pxfi([i,j], alpha)\n\t\t\t}\n\t\t}\n\t\tthis.putImageData()\n\t\tthis.ctx.globalAlpha = 1\n\t}\n\t/** Use to color a grid according to its values. High values are colored in\n\t * a brighter color.\n\t * @param {Grid2D|CoarseGrid} [cc] - the grid to draw values for. If left\n\t * unspecified, the grid that was originally supplied to the Canvas\n\t * constructor is used.\n\t * @param {number} [nsteps = 10] - the number of contour lines to draw.\n\t * Contour lines are evenly spaced between the min and max log10 of the\n\t * chemokine.\n\t * @param {HexColor} [col = \"FFFF00\"] - the color to draw contours with.\n\t * */\n\tdrawFieldContour( cc, nsteps = 10, col = \"FFFF00\" ){\n\t\tif( !cc ){\n\t\t\tcc = this.grid\n\t\t}\n\t\tthis.col(col)\n\t\tlet maxval = 0\n\t\tlet minval = Math.log(0.1)\n\t\tfor( let i = 0 ; i < cc.extents[0] ; i ++ ){\n\t\t\tfor( let j = 0 ; j < cc.extents[1] ; j ++ ){\n\t\t\t\tlet p = Math.log(.1+cc.pixt([i,j]))\n\t\t\t\tif( maxval < p ){\n\t\t\t\t\tmaxval = p\n\t\t\t\t}\n\t\t\t\tif( minval > p ){\n\t\t\t\t\tminval = p\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tthis.getImageData()\n\t\t//this.col_g = 0\n\t\t//this.col_b = 0\n\t\t//this.col_r = 255\n\n\t\tlet step = (maxval-minval)/nsteps\n\t\tfor( let v = minval; v < maxval; v+= step ){\n\n\t\t\tfor( let i = 0 ; i < cc.extents[0] ; i ++ ){\n\t\t\t\tfor( let j = 0 ; j < cc.extents[1] ; j ++ ){\n\n\t\t\t\t\tlet pixelval = Math.log( .1 + cc.pixt( [i,j] ) )\n\t\t\t\t\tif( Math.abs( v - pixelval ) < 0.05*maxval ){\n\t\t\t\t\t\tlet below = false, above = false\n\t\t\t\t\t\tfor( let n of this.grid.neighNeumanni( this.grid.p2i( [i,j] ) ) ){\n\n\t\t\t\t\t\t\tlet nval = Math.log(0.1 + cc.pixt(this.grid.i2p(n)) )\n\t\t\t\t\t\t\tif( nval < v ){\n\t\t\t\t\t\t\t\tbelow = true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( nval >= v ){\n\t\t\t\t\t\t\t\tabove = true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( above && below ){\n\t\t\t\t\t\t\t\t//this.col_r = 150*((v-minval)/(maxval-minval)) + 105\n\t\t\t\t\t\t\t\tlet alpha = 0.7*((v-minval)/(maxval-minval)) + 0.3\n\t\t\t\t\t\t\t\tthis.pxfi( [i,j], alpha )\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\n\n\n\n\t\tthis.putImageData()\n\t}\n\n\n\n\t/** @desc Method for drawing the cell borders for a given cellkind in the\n\t * color specified in \"col\" (hex format). This function draws a line around\n\t * the cell (rather than coloring the outer pixels). If [kind] is negative,\n\t * simply draw all borders.\n\t *\n\t * See {@link drawOnCellBorders} to color the outer pixels of the cell.\n\t *\n\t * @param {CellKind} kind - Integer specifying the cellkind to color.\n\t * Should be a positive integer as 0 is reserved for the background.\n\t * @param {HexColor}  [col = \"000000\"] - hex code for the color to use,\n\t * defaults to black.\n   */\n\tdrawCellBorders( kind, col ){\n\n\t\tlet isCPM = ( this.C instanceof CPM ), C = this.C\n\t\tlet getBorderPixels = function*(){\n\t\t\tfor( let p of C.cellBorderPixels() ){\n\t\t\t\tyield p\n\t\t\t}\n\t\t}\n\t\tif( !isCPM ){\n\t\t\t// in a non-cpm, simply draw borders of all pixels\n\t\t\tgetBorderPixels = function*(){\n\t\t\t\tfor( let p of C.grid.pixels() ){\n\t\t\t\t\tyield p\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\t\tcol = col || \"000000\"\n\t\tlet pc, pu, pd, pl, pr, pdraw\n\t\tthis.col( col )\n\t\tthis.getImageData()\n\t\t// cst contains indices of pixels at the border of cells\n\t\tfor( let x of getBorderPixels() ){\n\n\t\t\tlet pKind\n\t\t\tif( isCPM ){\n\t\t\t\tpKind = this.C.cellKind( x[1] )\n\t\t\t} else {\n\t\t\t\tpKind = x[1]\n\t\t\t}\n\n\t\t\tlet p = x[0]\n\t\t\tif( kind < 0 || pKind === kind ){\n\t\t\t\tpdraw = this.p2pdraw( p )\n\n\t\t\t\tpc = this.C.pixt( [p[0],p[1]] )\n\t\t\t\tpr = this.C.pixt( [p[0]+1,p[1]] )\n\t\t\t\tpl = this.C.pixt( [p[0]-1,p[1]] )\n\t\t\t\tpd = this.C.pixt( [p[0],p[1]+1] )\n\t\t\t\tpu = this.C.pixt( [p[0],p[1]-1] )\n\n\t\t\t\tif( pc !== pl  ){\n\t\t\t\t\tthis.pxdrawl( pdraw )\n\t\t\t\t}\n\t\t\t\tif( pc !== pr ){\n\t\t\t\t\tthis.pxdrawr( pdraw )\n\t\t\t\t}\n\t\t\t\tif( pc !== pd ){\n\t\t\t\t\tthis.pxdrawd( pdraw )\n\t\t\t\t}\n\t\t\t\tif( pc !== pu ){\n\t\t\t\t\tthis.pxdrawu( pdraw )\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tthis.putImageData()\n\t}\n\n\t/** Use to show activity values of the act model using a color gradient, for\n\t * cells in the grid of cellkind \"kind\". The constraint holding the activity\n\t * values can be supplied as an argument. Otherwise, the current CPM is\n\t * searched for the first registered activity constraint and that is then\n\t * used.\n\t *\n\t * @param {CellKind} kind - Integer specifying the cellkind to color.\n\t * If negative, draw values for all cellkinds.\n\t * @param {ActivityConstraint|ActivityMultiBackground} [A] - the constraint\n\t * object to use, which must be of class {@link ActivityConstraint} or\n\t * {@link ActivityMultiBackground} If left unspecified, this is the first\n\t * instance of an ActivityConstraint or ActivityMultiBackground object found\n\t * in the soft_constraints of the attached CPM.\n\t * @param {Function} [col] - a function that returns a color for a number\n\t * in [0,1] as an array of red/green/blue values, for example, [255,0,0]\n\t * would be the color red. If unspecified, a green-to-red heatmap is used.\n\t * */\n\tdrawActivityValues( kind, A, col ){\n\t\tif( !( this.C instanceof CPM) ){\n\t\t\tthrow(\"You cannot use the drawActivityValues method on a non-CPM model!\")\n\t\t}\n\t\tif( !A ){\n\t\t\tfor( let c of this.C.soft_constraints ){\n\t\t\t\tif( c instanceof ActivityConstraint || c instanceof ActivityMultiBackground ){\n\t\t\t\t\tA = c; break\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( !A ){\n\t\t\tthrow(\"Cannot find activity values to draw!\")\n\t\t}\n\t\tif( !col ){\n\t\t\tcol = function(a){\n\t\t\t\tlet r = [0,0,0]\n\t\t\t\tif( a > 0.5 ){\n\t\t\t\t\tr[0] = 255\n\t\t\t\t\tr[1] = (2-2*a)*255\n\t\t\t\t} else {\n\t\t\t\t\tr[0] = (2*a)*255\n\t\t\t\t\tr[1] = 255\n\t\t\t\t}\n\t\t\t\treturn r\n\t\t\t}\n\t\t}\n\t\t// cst contains the pixel ids of all non-background/non-stroma cells in\n\t\t// the grid. \n\t\tlet ii, sigma, a, k\n\t\t// loop over all pixels belonging to non-background, non-stroma\n\t\tthis.col(\"FF0000\")\n\t\tthis.getImageData()\n\t\tthis.col_b = 0\n\t\t//this.col_g = 0\n\t\tfor( let x of this.C.cellPixels() ){\n\t\t\tii = x[0]\n\t\t\tsigma = x[1]\n\t\t\tk = this.C.cellKind(sigma)\n\n\t\t\t// For all pixels that belong to the current kind, compute\n\t\t\t// color based on activity values, convert to hex, and draw.\n\t\t\tif( ( kind < 0 && A.conf[\"MAX_ACT\"][k] > 0 ) || k === kind ){\n\t\t\t\ta = A.pxact( this.C.grid.p2i( ii ) )/A.conf[\"MAX_ACT\"][k]\n\t\t\t\tif( a > 0 ){\n\t\t\t\t\tif( a > 0.5 ){\n\t\t\t\t\t\tthis.col_r = 255\n\t\t\t\t\t\tthis.col_g = (2-2*a)*255\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.col_r = (2*a)*255\n\t\t\t\t\t\tthis.col_g = 255\n\t\t\t\t\t}\n\t\t\t\t\tlet r = col( a )\n\t\t\t\t\tthis.col_r = r[0]\n\t\t\t\t\tthis.col_g = r[1]\n\t\t\t\t\tthis.col_b = r[2]\n\t\t\t\t\tthis.pxfi( ii )\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.putImageData()\n\t}\n\n\t/** Color outer pixel of all cells of kind [kind] in col [col].\n\t * See {@link drawCellBorders} to actually draw around the cell rather than\n\t * coloring the outer pixels. If you're using this model on a CA,\n\t * {@link CellKind} is not defined and the parameter \"kind\" is instead\n\t * interpreted as {@link CellId}.\n\t *\n\t * @param {CellKind} kind - Integer specifying the cellkind to color.\n\t * Should be a positive integer as 0 is reserved for the background.\n\t * @param {HexColor|function} col - Optional: hex code for the color to use.\n\t * If left unspecified, it gets the default value of black (\"000000\").\n\t * col can also be a function that returns a hex value for a cell id. */\n\tdrawOnCellBorders( kind, col ){\n\t\tcol = col || \"000000\"\n\n\t\tlet isCPM = ( this.C instanceof CPM ), C = this.C\n\t\tlet getBorderPixels = function*(){\n\t\t\tfor( let p of C.cellBorderPixels() ){\n\t\t\t\tyield p\n\t\t\t}\n\t\t}\n\t\tif( !isCPM ){\n\t\t\t// in a non-cpm, simply draw borders of all pixels\n\t\t\tgetBorderPixels = this.C.pixels\n\t\t}\n\n\t\tthis.getImageData()\n\t\tthis.col( col )\n\t\tfor( let p of getBorderPixels() ){\n\n\t\t\tlet pKind\n\t\t\tif( isCPM ){\n\t\t\t\tpKind = this.C.cellKind( p[1] )\n\t\t\t} else {\n\t\t\t\tpKind = p[1]\n\t\t\t}\n\n\t\t\tif( kind < 0 || pKind === kind ){\n\t\t\t\tif( typeof col == \"function\" ){\n\t\t\t\t\tthis.col( col(p[1]) )\n\t\t\t\t}\n\t\t\t\tthis.pxfi( p[0] )\n\t\t\t}\n\t\t}\n\t\tthis.putImageData()\n\t}\n\n\t/**\n\t * Draw all cells of cellid \"id\" in color col (hex). Note that this function\n\t * also works for CA. However, it has not yet been optimised and is very slow\n\t * if called many times. For multicellular CPMs, you are better off using\n\t * {@link drawCells} with an appropriate coloring function (see that method's\n\t * documentation).\n\t *\n\t * @param {CellId} id - id of the cell to color.\n\t * @param {HexColor} col - Optional: hex code for the color to use.\n\t * If left unspecified, it gets the default value of black (\"000000\").\n\t *\n\t * */\n\tdrawCellsOfId( id, col ){\n\t\tif( !col ){\n\t\t\tcol = \"000000\"\n\t\t}\n\t\tif( typeof col == \"string\" ){\n\t\t\tthis.col(col)\n\t\t}\n\n\n\t\t// Use the pixels() iterator to get the id of all non-background pixels.\n\t\tthis.getImageData()\n\t\t// this currently just loops over all pixels on the grid, which makes it slow\n\t\t// if you repeat this process for many cells. Optimise later.\n\t\tfor( let x of this.C.pixels() ){\n\t\t\tif( x[1] === id ){\n\n\t\t\t\tthis.pxfi( x[0] )\n\n\t\t\t}\n\t\t}\n\n\t\tthis.putImageData()\n\t}\n\n\t/** Draw all cells of cellkind \"kind\" in color col (hex). This method is\n\t * meant for models of class {@link CPM}, where the {@link CellKind} is\n\t * defined. If you apply this method on a {@link CA} model, this method\n\t * will internally call {@link drawCellsOfId} by just supplying the\n\t * \"kind\" parameter as {@link CellId}.\n\t *\n\t * @param {CellKind} kind - Integer specifying the cellkind to color.\n\t * Should be a positive integer as 0 is reserved for the background.\n\t * @param {HexColor|function} col - Optional: hex code for the color to use.\n\t * If left unspecified, it gets the default value of black (\"000000\").\n\t * col can also be a function that returns a hex value for a cell id, but\n\t * this is only supported for CPMs.\n\t *\n\t * @example <caption>Drawing cells by \"kind\" or \"ID\"</caption>\n\t *\n\t * // Draw all cells of kind 1 in red\n\t * Cim.drawCells( 1, \"FF0000\" )\n\t *\n\t * // To color cells by their ID instead of their kind, we can parse\n\t * // a function to 'col' instead of a string. The example function\n\t * // below reads the color for each cellID from an object of keys (ids)\n\t * // and values (colors):\n\t * Cim.colFun = function( cid ){\n\t *\n\t * \t// First time function is called, attach an empty object 'cellColorMap' to\n\t * \t// simulation object; this tracks the color for each cellID on the grid.\n\t * \tif( !Cim.hasOwnProperty( \"cellColorMap\" ) ){\n\t * \t\tCim.cellColorMap = {}\n\t * \t}\n\t *\n\t * \t// Check if the current cellID already has a color, otherwise put a random\n\t * \t// color in the cellColorMap object\n\t * \tif( !Cim.cellColorMap.hasOwnProperty(cid) ){\n\t * \t\t// this cell gets a random color\n\t * \t\tCim.cellColorMap[cid] = Math.floor(Math.random()*16777215).toString(16).toUpperCase()\n\t * \t}\n\t *\n\t * \t// now return the color assigned to this cellID.\n\t * \treturn Cim.cellColorMap[cid]\n\t * }\n\t * // Now use this function to draw the cells, colored by their ID\n\t * Cim.drawCells( 1, Cim.colFun )\n\t */\n\tdrawCells( kind, col ){\n\t\tif( !( this.C instanceof CPM ) ){\n\t\t\tif( typeof col != \"string\" ){\n\t\t\t\tthrow(\"If you use the drawCells method on a CA, you cannot \" +\n\t\t\t\t\t\"specify the color as function! Please specify a single string.\")\n\t\t\t}\n\t\t\tthis.drawCellsOfId( kind, col )\n\t\t} else {\n\t\t\tif (!col) {\n\t\t\t\tcol = \"000000\"\n\t\t\t}\n\t\t\tif (typeof col == \"string\") {\n\t\t\t\tthis.col(col)\n\t\t\t}\n\t\t\t// Object contains all pixels belonging to non-background,\n\t\t\t// non-stroma cells.\n\t\t\tlet cellpixelsbyid = this.C.getStat(PixelsByCell)\n\n\t\t\tthis.getImageData()\n\t\t\tfor (let cid of Object.keys(cellpixelsbyid)) {\n\t\t\t\tif (kind < 0 || this.C.cellKind(cid) === kind) {\n\t\t\t\t\tif (typeof col == \"function\") {\n\t\t\t\t\t\tthis.col(col(cid))\n\t\t\t\t\t}\n\t\t\t\t\tfor (let cp of cellpixelsbyid[cid]) {\n\t\t\t\t\t\tthis.pxfi(cp)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.putImageData()\n\t\t}\n\t}\n\n\t/** General drawing function to draw all pixels in a supplied set in a given\n\t * color.\n\t * @param {ArrayCoordinate[]} pixelarray - an array of\n\t * {@link ArrayCoordinate}s of pixels to color.\n\t * @param {HexColor|function} col - Optional: hex code for the color to use.\n\t * If left unspecified, it gets the default value of black (\"000000\").\n\t * col can also be a function that returns a hex value for a cell id.\n\t * */\n\tdrawPixelSet( pixelarray, col ){\n\t\tif( ! col ){\n\t\t\tcol = \"000000\"\n\t\t}\n\t\tif( typeof col == \"string\" ){\n\t\t\tthis.col(col)\n\t\t}\n\t\tthis.getImageData()\n\t\tfor( let p of pixelarray ){\n\t\t\tthis.pxfi( p )\n\t\t}\n\t\tthis.putImageData()\n\t}\n\n\t/** Draw grid to the png file \"fname\".\n\t *\n\t * @param {string} fname Path to the file to write. Any parent folders in\n\t * this path must already exist.*/\n\twritePNG( fname ){\n\n\t\ttry {\n\t\t\tthis.fs.writeFileSync(fname, this.el.toBuffer())\n\t\t}\n\t\tcatch (err) {\n\t\t\tif (err.code === \"ENOENT\") {\n\t\t\t\tlet message = \"Canvas.writePNG: cannot write to file \" + fname +\n\t\t\t\t\t\", are you sure the directory exists?\"\n\t\t\t\tthrow(message)\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nexport default Canvas\n\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/Canvas.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "Canvas",
    "memberof": "src/Canvas.js",
    "static": true,
    "longname": "src/Canvas.js~Canvas",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/Canvas.js",
    "importStyle": "Canvas",
    "description": "Class for taking a CPM grid and displaying it in either browser or with\n nodejs.\nNote: when using this class from outside the module, you don't need to import\n it separately but can access it from CPM.Canvas.",
    "lineNumber": 17,
    "interface": false
  },
  {
    "__docId__": 50,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Canvas.js~Canvas",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Canvas.js~Canvas#constructor",
    "access": "public",
    "description": "The Canvas constructor accepts a CPM object C or a Grid2D object.",
    "examples": [
      "<caption>A CPM with Canvas</caption>\nlet CPM = require( \"path/to/build\" )\n\n// Create a CPM, corresponding Canvas and GridManipulator\n// (Use CPM. prefix from outside the module)\nlet C = new CPM.CPM( [200,200], {\n\tT : 20,\n\tJ : [[0,20][20,10]],\n\tV:[0,500],\n\tLAMBDA_V:[0,5]\n} )\nlet Cim = new CPM.Canvas( C, {zoom:2} )\nlet gm = new CPM.GridManipulator( C )\n\n// Seed a cell at [x=100,y=100] and run 100 MCS.\ngm.seedCellAt( 1, [100,100] )\nfor( let t = 0; t < 100; t++ ){\n\tC.timeStep()\n}\n\n// Draw the cell and save an image\nCim.drawCells( 1, \"FF0000\" )\t\t\t// draw cells of CellKind 1 in red\nCim.writePNG( \"my-cell-t100.png\" )"
    ],
    "lineNumber": 56,
    "params": [
      {
        "nullable": null,
        "types": [
          "GridBasedModel",
          "Grid2D",
          "CoarseGrid"
        ],
        "spread": false,
        "optional": false,
        "name": "C",
        "description": "the object to draw, which must\nbe an object of class {@link GridBasedModel} (or its subclasses {@link CPM}\nand {@link CA}), or a 2D grid ({@link Grid2D} or {@link CoarseGrid}).\nDrawing of other grids is currently not supported."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " {}",
        "defaultRaw": {},
        "name": "options",
        "description": "Configuration settings"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " 1",
        "defaultRaw": 1,
        "name": "options.zoom",
        "description": "positive number specifying the zoom\nlevel to draw with."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " [0,0,0]",
        "defaultRaw": [
          0,
          0,
          0
        ],
        "name": "options.wrap",
        "description": "if nonzero: 'wrap' the grid to\nthese dimensions; eg a pixel with x coordinate 201 and wrap[0] = 200 is\ndisplayed at x = 1."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " document.body",
        "defaultRaw": " document.body",
        "name": "options.parentElement",
        "description": "the element on\nthe html page where the canvas will be appended."
      }
    ]
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "C",
    "memberof": "src/Canvas.js~Canvas",
    "static": false,
    "longname": "src/Canvas.js~Canvas#C",
    "access": "public",
    "description": "The underlying model that is drawn on the canvas.",
    "lineNumber": 62,
    "type": {
      "nullable": null,
      "types": [
        "GridBasedModel",
        "CPM",
        "CA"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 52,
    "kind": "member",
    "name": "grid",
    "memberof": "src/Canvas.js~Canvas",
    "static": false,
    "longname": "src/Canvas.js~Canvas#grid",
    "access": "public",
    "description": "The underlying grid that is drawn on the canvas.",
    "lineNumber": 67,
    "type": {
      "nullable": null,
      "types": [
        "Grid2D",
        "CoarseGrid"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 53,
    "kind": "member",
    "name": "extents",
    "memberof": "src/Canvas.js~Canvas",
    "static": false,
    "longname": "src/Canvas.js~Canvas#extents",
    "access": "public",
    "description": "Grid size in each dimension, taken from the CPM or grid object\nto draw.",
    "lineNumber": 73,
    "type": {
      "nullable": null,
      "types": [
        "GridSize"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 56,
    "kind": "member",
    "name": "zoom",
    "memberof": "src/Canvas.js~Canvas",
    "static": false,
    "longname": "src/Canvas.js~Canvas#zoom",
    "access": "public",
    "description": "Zoom level to draw the canvas with, set to options.zoom or its\ndefault value 1.",
    "lineNumber": 82,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 57,
    "kind": "member",
    "name": "wrap",
    "memberof": "src/Canvas.js~Canvas",
    "static": false,
    "longname": "src/Canvas.js~Canvas#wrap",
    "access": "public",
    "description": "if nonzero: 'wrap' the grid to these dimensions; eg a pixel with x\ncoordinate 201 and wrap[0] = 200 is displayed at x = 1.",
    "lineNumber": 86,
    "type": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 58,
    "kind": "member",
    "name": "width",
    "memberof": "src/Canvas.js~Canvas",
    "static": false,
    "longname": "src/Canvas.js~Canvas#width",
    "access": "public",
    "description": "Width of the canvas in pixels (in its unzoomed state)",
    "lineNumber": 90,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 59,
    "kind": "member",
    "name": "height",
    "memberof": "src/Canvas.js~Canvas",
    "static": false,
    "longname": "src/Canvas.js~Canvas#height",
    "access": "public",
    "description": "Height of the canvas in pixels (in its unzoomed state)",
    "lineNumber": 93,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 62,
    "kind": "member",
    "name": "el",
    "memberof": "src/Canvas.js~Canvas",
    "static": false,
    "longname": "src/Canvas.js~Canvas#el",
    "access": "public",
    "description": null,
    "lineNumber": 104,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "member",
    "name": "fs",
    "memberof": "src/Canvas.js~Canvas",
    "static": false,
    "longname": "src/Canvas.js~Canvas#fs",
    "access": "public",
    "description": null,
    "lineNumber": 115,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 65,
    "kind": "member",
    "name": "ctx",
    "memberof": "src/Canvas.js~Canvas",
    "static": false,
    "longname": "src/Canvas.js~Canvas#ctx",
    "access": "public",
    "description": null,
    "lineNumber": 119,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 66,
    "kind": "method",
    "name": "setCanvasId",
    "memberof": "src/Canvas.js~Canvas",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Canvas.js~Canvas#setCanvasId",
    "access": "public",
    "description": "Give the canvas element an ID supplied as argument. Useful for building\nan HTML page where you want to get this canvas by its ID.",
    "lineNumber": 128,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "idString",
        "description": "the name to give the canvas element."
      }
    ],
    "return": null
  },
  {
    "__docId__": 67,
    "kind": "method",
    "name": "pxf",
    "memberof": "src/Canvas.js~Canvas",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Canvas.js~Canvas#pxf",
    "access": "private",
    "description": null,
    "lineNumber": 137,
    "ignore": true,
    "params": [
      {
        "name": "p",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 68,
    "kind": "method",
    "name": "pxfi",
    "memberof": "src/Canvas.js~Canvas",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Canvas.js~Canvas#pxfi",
    "access": "private",
    "description": null,
    "lineNumber": 143,
    "ignore": true,
    "params": [
      {
        "name": "p",
        "types": [
          "*"
        ]
      },
      {
        "name": "alpha",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 1,
        "defaultValue": "1"
      }
    ],
    "return": null
  },
  {
    "__docId__": 69,
    "kind": "method",
    "name": "pxfir",
    "memberof": "src/Canvas.js~Canvas",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Canvas.js~Canvas#pxfir",
    "access": "private",
    "description": null,
    "lineNumber": 158,
    "ignore": true,
    "params": [
      {
        "name": "p",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 70,
    "kind": "method",
    "name": "getImageData",
    "memberof": "src/Canvas.js~Canvas",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Canvas.js~Canvas#getImageData",
    "access": "private",
    "description": null,
    "lineNumber": 169,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 71,
    "kind": "member",
    "name": "image_data",
    "memberof": "src/Canvas.js~Canvas",
    "static": false,
    "longname": "src/Canvas.js~Canvas#image_data",
    "access": "public",
    "description": null,
    "lineNumber": 171,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 72,
    "kind": "member",
    "name": "px",
    "memberof": "src/Canvas.js~Canvas",
    "static": false,
    "longname": "src/Canvas.js~Canvas#px",
    "access": "public",
    "description": null,
    "lineNumber": 173,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 73,
    "kind": "method",
    "name": "putImageData",
    "memberof": "src/Canvas.js~Canvas",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Canvas.js~Canvas#putImageData",
    "access": "private",
    "description": null,
    "lineNumber": 178,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 74,
    "kind": "method",
    "name": "pxfnozoom",
    "memberof": "src/Canvas.js~Canvas",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Canvas.js~Canvas#pxfnozoom",
    "access": "private",
    "description": null,
    "lineNumber": 184,
    "ignore": true,
    "params": [
      {
        "name": "p",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 75,
    "kind": "method",
    "name": "pxdrawl",
    "memberof": "src/Canvas.js~Canvas",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Canvas.js~Canvas#pxdrawl",
    "access": "private",
    "description": "draw a line left (l), right (r), down (d), or up (u) of pixel p",
    "lineNumber": 191,
    "ignore": true,
    "params": [
      {
        "name": "p",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 76,
    "kind": "method",
    "name": "pxdrawr",
    "memberof": "src/Canvas.js~Canvas",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Canvas.js~Canvas#pxdrawr",
    "access": "private",
    "description": null,
    "lineNumber": 199,
    "ignore": true,
    "params": [
      {
        "name": "p",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 77,
    "kind": "method",
    "name": "pxdrawd",
    "memberof": "src/Canvas.js~Canvas",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Canvas.js~Canvas#pxdrawd",
    "access": "private",
    "description": null,
    "lineNumber": 206,
    "ignore": true,
    "params": [
      {
        "name": "p",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 78,
    "kind": "method",
    "name": "pxdrawu",
    "memberof": "src/Canvas.js~Canvas",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Canvas.js~Canvas#pxdrawu",
    "access": "private",
    "description": null,
    "lineNumber": 213,
    "ignore": true,
    "params": [
      {
        "name": "p",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 79,
    "kind": "method",
    "name": "col",
    "memberof": "src/Canvas.js~Canvas",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Canvas.js~Canvas#col",
    "access": "private",
    "description": "For easier color naming",
    "lineNumber": 222,
    "ignore": true,
    "params": [
      {
        "name": "hex",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 80,
    "kind": "member",
    "name": "col_r",
    "memberof": "src/Canvas.js~Canvas",
    "static": false,
    "longname": "src/Canvas.js~Canvas#col_r",
    "access": "public",
    "description": null,
    "lineNumber": 225,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 81,
    "kind": "member",
    "name": "col_g",
    "memberof": "src/Canvas.js~Canvas",
    "static": false,
    "longname": "src/Canvas.js~Canvas#col_g",
    "access": "public",
    "description": null,
    "lineNumber": 227,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 82,
    "kind": "member",
    "name": "col_b",
    "memberof": "src/Canvas.js~Canvas",
    "static": false,
    "longname": "src/Canvas.js~Canvas#col_b",
    "access": "public",
    "description": null,
    "lineNumber": 229,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 83,
    "kind": "typedef",
    "name": "HexColor",
    "memberof": "src/Canvas.js~Canvas",
    "static": true,
    "longname": "src/Canvas.js~Canvas.HexColor",
    "access": "public",
    "description": "Hex code string for a color.",
    "type": {
      "types": [
        "string"
      ],
      "optional": false,
      "name": "HexColor"
    }
  },
  {
    "__docId__": 84,
    "kind": "method",
    "name": "clear",
    "memberof": "src/Canvas.js~Canvas",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Canvas.js~Canvas#clear",
    "access": "public",
    "description": "Color the whole grid in color [col], or in black if no argument is given.",
    "lineNumber": 238,
    "params": [
      {
        "nullable": null,
        "types": [
          "HexColor"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " \"000000\"",
        "defaultRaw": "000000",
        "name": "col",
        "description": "hex code for the color to use, defaults to black."
      }
    ],
    "return": null
  },
  {
    "__docId__": 85,
    "kind": "typedef",
    "name": "CanvasRenderingContext2D",
    "memberof": "src/Canvas.js~Canvas",
    "static": true,
    "longname": "src/Canvas.js~Canvas.CanvasRenderingContext2D",
    "access": "public",
    "description": "Rendering context of canvas.",
    "see": [
      "https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D"
    ],
    "type": {
      "types": [
        "object"
      ],
      "optional": false,
      "name": "CanvasRenderingContext2D"
    }
  },
  {
    "__docId__": 86,
    "kind": "method",
    "name": "context",
    "memberof": "src/Canvas.js~Canvas",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Canvas.js~Canvas#context",
    "access": "public",
    "description": "Return the current drawing context.",
    "lineNumber": 252,
    "return": {
      "nullable": null,
      "types": [
        "CanvasRenderingContext2D"
      ],
      "spread": false,
      "description": "current drawing context on the canvas."
    },
    "params": []
  },
  {
    "__docId__": 87,
    "kind": "method",
    "name": "p2pdraw",
    "memberof": "src/Canvas.js~Canvas",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Canvas.js~Canvas#p2pdraw",
    "access": "private",
    "description": null,
    "lineNumber": 257,
    "ignore": true,
    "params": [
      {
        "name": "p",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 88,
    "kind": "method",
    "name": "drawField",
    "memberof": "src/Canvas.js~Canvas",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Canvas.js~Canvas#drawField",
    "access": "public",
    "description": "Use to color a grid according to its values. High values are colored in\na brighter color.",
    "lineNumber": 275,
    "params": [
      {
        "nullable": null,
        "types": [
          "Grid2D",
          "CoarseGrid"
        ],
        "spread": false,
        "optional": true,
        "name": "cc",
        "description": "the grid to draw values for. If left\nunspecified, the grid that was originally supplied to the Canvas\nconstructor is used."
      },
      {
        "nullable": null,
        "types": [
          "HexColor"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " \"0000FF\"",
        "defaultRaw": "0000FF",
        "name": "col",
        "description": "the color to draw the chemokine in."
      }
    ],
    "return": null
  },
  {
    "__docId__": 89,
    "kind": "method",
    "name": "drawFieldContour",
    "memberof": "src/Canvas.js~Canvas",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Canvas.js~Canvas#drawFieldContour",
    "access": "public",
    "description": "Use to color a grid according to its values. High values are colored in\na brighter color.",
    "lineNumber": 314,
    "params": [
      {
        "nullable": null,
        "types": [
          "Grid2D",
          "CoarseGrid"
        ],
        "spread": false,
        "optional": true,
        "name": "cc",
        "description": "the grid to draw values for. If left\nunspecified, the grid that was originally supplied to the Canvas\nconstructor is used."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " 10",
        "defaultRaw": 10,
        "name": "nsteps",
        "description": "the number of contour lines to draw.\nContour lines are evenly spaced between the min and max log10 of the\nchemokine."
      },
      {
        "nullable": null,
        "types": [
          "HexColor"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " \"FFFF00\"",
        "defaultRaw": "FFFF00",
        "name": "col",
        "description": "the color to draw contours with."
      }
    ],
    "return": null
  },
  {
    "__docId__": 90,
    "kind": "method",
    "name": "drawCellBorders",
    "memberof": "src/Canvas.js~Canvas",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Canvas.js~Canvas#drawCellBorders",
    "access": "public",
    "description": "Method for drawing the cell borders for a given cellkind in the\ncolor specified in \"col\" (hex format). This function draws a line around\nthe cell (rather than coloring the outer pixels). If [kind] is negative,\nsimply draw all borders.\n\nSee {@link drawOnCellBorders} to color the outer pixels of the cell.",
    "lineNumber": 394,
    "params": [
      {
        "nullable": null,
        "types": [
          "CellKind"
        ],
        "spread": false,
        "optional": false,
        "name": "kind",
        "description": "Integer specifying the cellkind to color.\nShould be a positive integer as 0 is reserved for the background."
      },
      {
        "nullable": null,
        "types": [
          "HexColor"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " \"000000\"",
        "defaultRaw": "000000",
        "name": "col",
        "description": "hex code for the color to use,\ndefaults to black."
      }
    ],
    "return": null
  },
  {
    "__docId__": 91,
    "kind": "method",
    "name": "drawActivityValues",
    "memberof": "src/Canvas.js~Canvas",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Canvas.js~Canvas#drawActivityValues",
    "access": "public",
    "description": "Use to show activity values of the act model using a color gradient, for\ncells in the grid of cellkind \"kind\". The constraint holding the activity\nvalues can be supplied as an argument. Otherwise, the current CPM is\nsearched for the first registered activity constraint and that is then\nused.",
    "lineNumber": 472,
    "params": [
      {
        "nullable": null,
        "types": [
          "CellKind"
        ],
        "spread": false,
        "optional": false,
        "name": "kind",
        "description": "Integer specifying the cellkind to color.\nIf negative, draw values for all cellkinds."
      },
      {
        "nullable": null,
        "types": [
          "ActivityConstraint",
          "ActivityMultiBackground"
        ],
        "spread": false,
        "optional": true,
        "name": "A",
        "description": "the constraint\nobject to use, which must be of class {@link ActivityConstraint} or\n{@link ActivityMultiBackground} If left unspecified, this is the first\ninstance of an ActivityConstraint or ActivityMultiBackground object found\nin the soft_constraints of the attached CPM."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "col",
        "description": "a function that returns a color for a number\nin [0,1] as an array of red/green/blue values, for example, [255,0,0]\nwould be the color red. If unspecified, a green-to-red heatmap is used."
      }
    ],
    "return": null
  },
  {
    "__docId__": 100,
    "kind": "method",
    "name": "drawOnCellBorders",
    "memberof": "src/Canvas.js~Canvas",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Canvas.js~Canvas#drawOnCellBorders",
    "access": "public",
    "description": "Color outer pixel of all cells of kind [kind] in col [col].\nSee {@link drawCellBorders} to actually draw around the cell rather than\ncoloring the outer pixels. If you're using this model on a CA,\n{@link CellKind} is not defined and the parameter \"kind\" is instead\ninterpreted as {@link CellId}.",
    "lineNumber": 546,
    "params": [
      {
        "nullable": null,
        "types": [
          "CellKind"
        ],
        "spread": false,
        "optional": false,
        "name": "kind",
        "description": "Integer specifying the cellkind to color.\nShould be a positive integer as 0 is reserved for the background."
      },
      {
        "nullable": null,
        "types": [
          "HexColor",
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "col",
        "description": "Optional: hex code for the color to use.\nIf left unspecified, it gets the default value of black (\"000000\").\ncol can also be a function that returns a hex value for a cell id."
      }
    ],
    "return": null
  },
  {
    "__docId__": 101,
    "kind": "method",
    "name": "drawCellsOfId",
    "memberof": "src/Canvas.js~Canvas",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Canvas.js~Canvas#drawCellsOfId",
    "access": "public",
    "description": "Draw all cells of cellid \"id\" in color col (hex). Note that this function\nalso works for CA. However, it has not yet been optimised and is very slow\nif called many times. For multicellular CPMs, you are better off using\n{@link drawCells} with an appropriate coloring function (see that method's\ndocumentation).",
    "lineNumber": 593,
    "params": [
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "id of the cell to color."
      },
      {
        "nullable": null,
        "types": [
          "HexColor"
        ],
        "spread": false,
        "optional": false,
        "name": "col",
        "description": "Optional: hex code for the color to use.\nIf left unspecified, it gets the default value of black (\"000000\")."
      }
    ],
    "return": null
  },
  {
    "__docId__": 102,
    "kind": "method",
    "name": "drawCells",
    "memberof": "src/Canvas.js~Canvas",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Canvas.js~Canvas#drawCells",
    "access": "public",
    "description": "Draw all cells of cellkind \"kind\" in color col (hex). This method is\nmeant for models of class {@link CPM}, where the {@link CellKind} is\ndefined. If you apply this method on a {@link CA} model, this method\nwill internally call {@link drawCellsOfId} by just supplying the\n\"kind\" parameter as {@link CellId}.",
    "examples": [
      "<caption>Drawing cells by \"kind\" or \"ID\"</caption>\n\n// Draw all cells of kind 1 in red\nCim.drawCells( 1, \"FF0000\" )\n\n// To color cells by their ID instead of their kind, we can parse\n// a function to 'col' instead of a string. The example function\n// below reads the color for each cellID from an object of keys (ids)\n// and values (colors):\nCim.colFun = function( cid ){\n\n\t// First time function is called, attach an empty object 'cellColorMap' to\n\t// simulation object; this tracks the color for each cellID on the grid.\n\tif( !Cim.hasOwnProperty( \"cellColorMap\" ) ){\n\t\tCim.cellColorMap = {}\n\t}\n\n\t// Check if the current cellID already has a color, otherwise put a random\n\t// color in the cellColorMap object\n\tif( !Cim.cellColorMap.hasOwnProperty(cid) ){\n\t\t// this cell gets a random color\n\t\tCim.cellColorMap[cid] = Math.floor(Math.random()*16777215).toString(16).toUpperCase()\n\t}\n\n\t// now return the color assigned to this cellID.\n\treturn Cim.cellColorMap[cid]\n}\n// Now use this function to draw the cells, colored by their ID\nCim.drawCells( 1, Cim.colFun )"
    ],
    "lineNumber": 660,
    "params": [
      {
        "nullable": null,
        "types": [
          "CellKind"
        ],
        "spread": false,
        "optional": false,
        "name": "kind",
        "description": "Integer specifying the cellkind to color.\nShould be a positive integer as 0 is reserved for the background."
      },
      {
        "nullable": null,
        "types": [
          "HexColor",
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "col",
        "description": "Optional: hex code for the color to use.\nIf left unspecified, it gets the default value of black (\"000000\").\ncol can also be a function that returns a hex value for a cell id, but\nthis is only supported for CPMs."
      }
    ],
    "return": null
  },
  {
    "__docId__": 103,
    "kind": "method",
    "name": "drawPixelSet",
    "memberof": "src/Canvas.js~Canvas",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Canvas.js~Canvas#drawPixelSet",
    "access": "public",
    "description": "General drawing function to draw all pixels in a supplied set in a given\ncolor.",
    "lineNumber": 701,
    "params": [
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate[]"
        ],
        "spread": false,
        "optional": false,
        "name": "pixelarray",
        "description": "an array of\n{@link ArrayCoordinate}s of pixels to color."
      },
      {
        "nullable": null,
        "types": [
          "HexColor",
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "col",
        "description": "Optional: hex code for the color to use.\nIf left unspecified, it gets the default value of black (\"000000\").\ncol can also be a function that returns a hex value for a cell id."
      }
    ],
    "return": null
  },
  {
    "__docId__": 104,
    "kind": "method",
    "name": "writePNG",
    "memberof": "src/Canvas.js~Canvas",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Canvas.js~Canvas#writePNG",
    "access": "public",
    "description": "Draw grid to the png file \"fname\".",
    "lineNumber": 719,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "fname",
        "description": "Path to the file to write. Any parent folders in\nthis path must already exist."
      }
    ],
    "return": null
  },
  {
    "__docId__": 105,
    "kind": "file",
    "name": "src/DiceSet.js",
    "content": "\n\n\"use strict\"\n\n// pass in RNG\n\n/** This class implements a data structure with constant-time insertion, deletion, and random\n    sampling. That's crucial for the CPM metropolis algorithm, which repeatedly needs to sample\n    pixels at cell borders. Elements in this set must be unique.*/\nclass DiceSet{\n\n\t/** An object of class MersenneTwister. \n\t@see https://www.npmjs.com/package/mersenne-twister\n\t@typedef {object} MersenneTwister\n\t*/\n\n\t/** The constructor of class DiceSet takes a MersenneTwister object as input, to allow\n\tseeding of the random number generator used for random sampling.\n\t@param {MersenneTwister} mt MersenneTwister object used for random numbers.*/\n\tconstructor( mt ) {\n\n\t\t/** Object or hash map used to check in constant time whether a pixel is at the\n\t\tcell border. Keys are the actual values stored in the DiceSet, numbers are their\n\t\tlocation in the elements arrray.\n\t\tCurrently (Mar 6, 2019), it seems that vanilla objects perform BETTER than ES6 maps,\n\t\tat least in nodejs. This is weird given that in vanilla objects, all keys are \n\t\tconverted to strings, which does not happen for Maps.\n\t\t@type {object}\n\t\t*/\n\t\tthis.indices = {} //new Map() // {}\n\t\t//this.indices = {}\n\n\t\t/** Use an array for constant time random sampling of pixels at the border of cells.\n\t\t@type {number[]} */\n\t\tthis.elements = []\n\n\t\t/** The number of elements currently present in the DiceSet. \n\t\t@type {number}\n\t\t*/\n\t\tthis.length = 0\n\n\t\t/** @ignore */\n\t\tthis.mt = mt\n\t}\n\n\t/** Unique identifier of some element. This can be a number (integer) or a string,\n\tbut it must uniquely identify one element in a set.\n\t@typedef {number|string} uniqueID*/\n\n\t/** Insert a new element. It is added as an index in the indices, and pushed\n\tto the end of the elements array.\n\t@param {uniqueID} v The element to add.\n\t*/\n\tinsert( v ){\n\t\tif( this.indices.hasOwnProperty( v ) ){\n\t\t\treturn\n\t\t}\n\t\t// Add element to both the hash map and the array.\n\t\t//this.indices.set( v, this.length )\n\t\tthis.indices[v] = this.length\n\t\n\t\tthis.elements.push( v )\n\t\tthis.length ++ \n\t}\n\n\t/** Remove element v.\n\t@param {uniqueID} v The element to remove. \n\t*/\n\tremove( v ){\n\t\t// Check whether element is present before it can be removed.\n\t\tif( !this.indices.hasOwnProperty( v ) ){\n\t\t\treturn\n\t\t}\n\t\t/* The hash map gives the index in the array of the value to be removed.\n\t\tThe value is removed directly from the hash map, but from the array we\n\t\tinitially remove the last element, which we then substitute for the \n\t\telement that should be removed.*/\n\t\t//const i = this.indices.get(v)\n\t\tconst i = this.indices[v]\n\n\t\t//this.indices.delete(v)\n\t\tdelete this.indices[v]\n\n\t\tconst e = this.elements.pop()\n\t\tthis.length --\n\t\tif( e == v ){\n\t\t\treturn\n\t\t}\n\t\tthis.elements[i] = e\n\n\t\t//this.indices.set(e,i)\n\t\tthis.indices[e] = i\n\t}\n\t/** Check if the DiceSet already contains element v. \n\t@param {uniqueID} v The element to check presence of. \n\t@return {boolean} true or false depending on whether the element is present or not.\n\t*/\n\tcontains( v ){\n\t\t//return this.indices.has(v)\n\t\treturn (v in this.indices)\n\t}\n\t\n\t/** Sample a random element from v.\n\t@return {uniqueID} the element sampled.\n\t*/\n\tsample(){\n\t\treturn this.elements[Math.floor(this.mt.random()*this.length)]\n\t}\n}\n\nexport default DiceSet\n\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/DiceSet.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 106,
    "kind": "class",
    "name": "DiceSet",
    "memberof": "src/DiceSet.js",
    "static": true,
    "longname": "src/DiceSet.js~DiceSet",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/DiceSet.js",
    "importStyle": "DiceSet",
    "description": "This class implements a data structure with constant-time insertion, deletion, and random\nsampling. That's crucial for the CPM metropolis algorithm, which repeatedly needs to sample\npixels at cell borders. Elements in this set must be unique.",
    "lineNumber": 10,
    "interface": false
  },
  {
    "__docId__": 107,
    "kind": "typedef",
    "name": "MersenneTwister",
    "memberof": "src/DiceSet.js~DiceSet",
    "static": true,
    "longname": "src/DiceSet.js~DiceSet.MersenneTwister",
    "access": "public",
    "description": "An object of class MersenneTwister. ",
    "see": [
      "https://www.npmjs.com/package/mersenne-twister"
    ],
    "type": {
      "types": [
        "object"
      ],
      "optional": false,
      "name": "MersenneTwister"
    }
  },
  {
    "__docId__": 108,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/DiceSet.js~DiceSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/DiceSet.js~DiceSet#constructor",
    "access": "public",
    "description": "The constructor of class DiceSet takes a MersenneTwister object as input, to allow\nseeding of the random number generator used for random sampling.",
    "lineNumber": 20,
    "params": [
      {
        "nullable": null,
        "types": [
          "MersenneTwister"
        ],
        "spread": false,
        "optional": false,
        "name": "mt",
        "description": "MersenneTwister object used for random numbers."
      }
    ]
  },
  {
    "__docId__": 109,
    "kind": "member",
    "name": "indices",
    "memberof": "src/DiceSet.js~DiceSet",
    "static": false,
    "longname": "src/DiceSet.js~DiceSet#indices",
    "access": "public",
    "description": "Object or hash map used to check in constant time whether a pixel is at the\ncell border. Keys are the actual values stored in the DiceSet, numbers are their\nlocation in the elements arrray.\nCurrently (Mar 6, 2019), it seems that vanilla objects perform BETTER than ES6 maps,\nat least in nodejs. This is weird given that in vanilla objects, all keys are \nconverted to strings, which does not happen for Maps.",
    "lineNumber": 30,
    "type": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 110,
    "kind": "member",
    "name": "elements",
    "memberof": "src/DiceSet.js~DiceSet",
    "static": false,
    "longname": "src/DiceSet.js~DiceSet#elements",
    "access": "public",
    "description": "Use an array for constant time random sampling of pixels at the border of cells.",
    "lineNumber": 35,
    "type": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 111,
    "kind": "member",
    "name": "length",
    "memberof": "src/DiceSet.js~DiceSet",
    "static": false,
    "longname": "src/DiceSet.js~DiceSet#length",
    "access": "public",
    "description": "The number of elements currently present in the DiceSet. ",
    "lineNumber": 40,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 112,
    "kind": "member",
    "name": "mt",
    "memberof": "src/DiceSet.js~DiceSet",
    "static": false,
    "longname": "src/DiceSet.js~DiceSet#mt",
    "access": "public",
    "description": null,
    "lineNumber": 43,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 113,
    "kind": "typedef",
    "name": "uniqueID",
    "memberof": "src/DiceSet.js~DiceSet",
    "static": true,
    "longname": "src/DiceSet.js~DiceSet.uniqueID",
    "access": "public",
    "description": "Unique identifier of some element. This can be a number (integer) or a string,\nbut it must uniquely identify one element in a set.",
    "type": {
      "types": [
        "number",
        "string"
      ],
      "optional": false,
      "name": "uniqueID"
    }
  },
  {
    "__docId__": 114,
    "kind": "method",
    "name": "insert",
    "memberof": "src/DiceSet.js~DiceSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/DiceSet.js~DiceSet#insert",
    "access": "public",
    "description": "Insert a new element. It is added as an index in the indices, and pushed\nto the end of the elements array.",
    "lineNumber": 54,
    "params": [
      {
        "nullable": null,
        "types": [
          "uniqueID"
        ],
        "spread": false,
        "optional": false,
        "name": "v",
        "description": "The element to add."
      }
    ],
    "return": null
  },
  {
    "__docId__": 115,
    "kind": "method",
    "name": "remove",
    "memberof": "src/DiceSet.js~DiceSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/DiceSet.js~DiceSet#remove",
    "access": "public",
    "description": "Remove element v.",
    "lineNumber": 69,
    "params": [
      {
        "nullable": null,
        "types": [
          "uniqueID"
        ],
        "spread": false,
        "optional": false,
        "name": "v",
        "description": "The element to remove."
      }
    ],
    "return": null
  },
  {
    "__docId__": 116,
    "kind": "method",
    "name": "contains",
    "memberof": "src/DiceSet.js~DiceSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/DiceSet.js~DiceSet#contains",
    "access": "public",
    "description": "Check if the DiceSet already contains element v. ",
    "lineNumber": 98,
    "params": [
      {
        "nullable": null,
        "types": [
          "uniqueID"
        ],
        "spread": false,
        "optional": false,
        "name": "v",
        "description": "The element to check presence of."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true or false depending on whether the element is present or not."
    }
  },
  {
    "__docId__": 117,
    "kind": "method",
    "name": "sample",
    "memberof": "src/DiceSet.js~DiceSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/DiceSet.js~DiceSet#sample",
    "access": "public",
    "description": "Sample a random element from v.",
    "lineNumber": 106,
    "return": {
      "nullable": null,
      "types": [
        "uniqueID"
      ],
      "spread": false,
      "description": "the element sampled."
    },
    "params": []
  },
  {
    "__docId__": 118,
    "kind": "file",
    "name": "src/cells/Cell.js",
    "content": "\nclass Cell {\n\t\n\t/** The constructor of class Cell.\n\t * @param {object} conf - configuration settings of the simulation, containing the\n\t * relevant parameters. Note: this should include all constraint parameters.\n\t * @param {CellKind} kind - the cellkind of this cell, the parameters of kind are used \n\t * when parameters are not explicitly overwritten\n\t * @param {CPMEvol} C - the CPM - used among others to draw random numbers\n\t * @param {CellId} id - the CellId of this cell (its key in the CPM.cells), unique identifier\n\t * */\n\tconstructor (conf, kind, id, C){\n\t\tthis.conf = conf\n\t\tthis.kind = kind\n\t\tthis.C = C\n\t\tthis.id = id\n\n\t\t/** The id of the parent cell, all seeded cells have parent -1, to overwrite this\n\t\t * this.birth(parent) needs to be called \n\t\t@type{number}*/\n\t\tthis.parentId = -1\n\t}\n\n\t/** Adds parentId number, and can be overwritten to execute functionality on \n\t * birth events. \n\t @param {Cell} parent - the parent Cell object\n\t */\n\tbirth (parent){\n\t\tthis.parentId = parent.id \n\t}\n\n\t/**\n\t * This is called upon death events. Can be redefined in subclasses\n\t */\n\tdeath () {\n\t}\n\n\t/**\n\t * Get the current volume of this cell\n\t * @return {Number} volume of this cell\n\t */\n\tget vol(){\n\t\treturn this.C.getVolume(this.id)\n\t}\n\n}\n\nexport default Cell\n\n\n\n\n\n\n\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/cells/Cell.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 119,
    "kind": "class",
    "name": "Cell",
    "memberof": "src/cells/Cell.js",
    "static": true,
    "longname": "src/cells/Cell.js~Cell",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/cells/Cell.js",
    "importStyle": "Cell",
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 120,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cells/Cell.js~Cell",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cells/Cell.js~Cell#constructor",
    "access": "public",
    "description": "The constructor of class Cell.",
    "lineNumber": 12,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "conf",
        "description": "configuration settings of the simulation, containing the\nrelevant parameters. Note: this should include all constraint parameters."
      },
      {
        "nullable": null,
        "types": [
          "CellKind"
        ],
        "spread": false,
        "optional": false,
        "name": "kind",
        "description": "the cellkind of this cell, the parameters of kind are used \nwhen parameters are not explicitly overwritten"
      },
      {
        "nullable": null,
        "types": [
          "CPMEvol"
        ],
        "spread": false,
        "optional": false,
        "name": "C",
        "description": "the CPM - used among others to draw random numbers"
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "the CellId of this cell (its key in the CPM.cells), unique identifier"
      }
    ]
  },
  {
    "__docId__": 121,
    "kind": "member",
    "name": "conf",
    "memberof": "src/cells/Cell.js~Cell",
    "static": false,
    "longname": "src/cells/Cell.js~Cell#conf",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 122,
    "kind": "member",
    "name": "kind",
    "memberof": "src/cells/Cell.js~Cell",
    "static": false,
    "longname": "src/cells/Cell.js~Cell#kind",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 123,
    "kind": "member",
    "name": "C",
    "memberof": "src/cells/Cell.js~Cell",
    "static": false,
    "longname": "src/cells/Cell.js~Cell#C",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 124,
    "kind": "member",
    "name": "id",
    "memberof": "src/cells/Cell.js~Cell",
    "static": false,
    "longname": "src/cells/Cell.js~Cell#id",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 125,
    "kind": "member",
    "name": "parentId",
    "memberof": "src/cells/Cell.js~Cell",
    "static": false,
    "longname": "src/cells/Cell.js~Cell#parentId",
    "access": "public",
    "description": "The id of the parent cell, all seeded cells have parent -1, to overwrite this\nthis.birth(parent) needs to be called \n@type{number}",
    "lineNumber": 21,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 126,
    "kind": "method",
    "name": "birth",
    "memberof": "src/cells/Cell.js~Cell",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cells/Cell.js~Cell#birth",
    "access": "public",
    "description": "Adds parentId number, and can be overwritten to execute functionality on \nbirth events. ",
    "lineNumber": 28,
    "params": [
      {
        "nullable": null,
        "types": [
          "Cell"
        ],
        "spread": false,
        "optional": false,
        "name": "parent",
        "description": "the parent Cell object"
      }
    ],
    "return": null
  },
  {
    "__docId__": 128,
    "kind": "method",
    "name": "death",
    "memberof": "src/cells/Cell.js~Cell",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cells/Cell.js~Cell#death",
    "access": "public",
    "description": "This is called upon death events. Can be redefined in subclasses",
    "lineNumber": 35,
    "params": [],
    "return": null
  },
  {
    "__docId__": 129,
    "kind": "get",
    "name": "vol",
    "memberof": "src/cells/Cell.js~Cell",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cells/Cell.js~Cell#vol",
    "access": "public",
    "description": "Get the current volume of this cell",
    "lineNumber": 42,
    "return": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": "volume of this cell"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 130,
    "kind": "file",
    "name": "src/cells/Divider.js",
    "content": "\nimport Cell from \"./Cell.js\" \n\n/**\n * Implements a basic holder for a model with internal products,\n * which can be stochastically divided between daughter cells. \n */\nclass Divider extends Cell {\n\n\tconstructor (conf, kind, id, C) {\n\t\tsuper(conf, kind, id, C)\n\n\t\t/** Arbitrary internal products\n\t\t * @type{Array}*/\n\t\tthis.products = conf[\"INIT_PRODUCTS\"][kind-1]\n\n\t\t/** Target Volume (overwrites V in volume constraint)\n\t\t * @type{Number}*/\n\t\tthis.V = conf[\"INIT_V\"][kind-1]\t\n\t}\n\n\t/**\n\t *  On birth the X and Y products are divided between the two daughters\n\t * This is equal between daughters if 'NOISE ' is 0, otherwise increases in \n\t * absolute quantities randomly with NOISE\n\t * @param {Cell} parent - the parent (or other daughter) cell\n\t */ \n\tbirth(parent){\n\t\tsuper.birth(parent) // sets ParentId\n\t\tfor (const [ix, product] of parent.products.entries()){\n\t\t\tlet fluct =  this.conf[\"NOISE\"][this.kind-1] * (2  *this.C.random() - 1)\n\t\t\tif ((product/2 - Math.abs(fluct)) < 0){\n\t\t\t\tfluct = product/2 \n\t\t\t\tif ( this.C.random() < 0.5){\n\t\t\t\t\tfluct *= -1\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.products[ix] = Math.max(0, product/2 - fluct)\n\t\t\tparent.products[ix] = Math.max(0, product/2 + fluct)\n\t\t}\n\t\tlet V = parent.V\n\t\tthis.V = V/2\n\t\tparent.V = V/2\n\t}\n}\n\nexport default Divider",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/cells/Divider.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 131,
    "kind": "class",
    "name": "Divider",
    "memberof": "src/cells/Divider.js",
    "static": true,
    "longname": "src/cells/Divider.js~Divider",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/cells/Divider.js",
    "importStyle": "Divider",
    "description": "Implements a basic holder for a model with internal products,\nwhich can be stochastically divided between daughter cells. ",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "src/cells/Cell.js~Cell"
    ]
  },
  {
    "__docId__": 132,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cells/Divider.js~Divider",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cells/Divider.js~Divider#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true
  },
  {
    "__docId__": 133,
    "kind": "member",
    "name": "products",
    "memberof": "src/cells/Divider.js~Divider",
    "static": false,
    "longname": "src/cells/Divider.js~Divider#products",
    "access": "public",
    "description": "Arbitrary internal products\n@type{Array}",
    "lineNumber": 15,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 134,
    "kind": "member",
    "name": "V",
    "memberof": "src/cells/Divider.js~Divider",
    "static": false,
    "longname": "src/cells/Divider.js~Divider#V",
    "access": "public",
    "description": "Target Volume (overwrites V in volume constraint)\n@type{Number}",
    "lineNumber": 19,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 135,
    "kind": "method",
    "name": "birth",
    "memberof": "src/cells/Divider.js~Divider",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cells/Divider.js~Divider#birth",
    "access": "public",
    "description": " On birth the X and Y products are divided between the two daughters\nThis is equal between daughters if 'NOISE ' is 0, otherwise increases in \nabsolute quantities randomly with NOISE",
    "lineNumber": 28,
    "params": [
      {
        "nullable": null,
        "types": [
          "Cell"
        ],
        "spread": false,
        "optional": false,
        "name": "parent",
        "description": "the parent (or other daughter) cell"
      }
    ],
    "return": null
  },
  {
    "__docId__": 137,
    "kind": "file",
    "name": "src/converter/ArtistooImport.js",
    "content": "import ModelDescription from \"./ModelDescription.js\"\nimport PixelsByCell from \"../stats/PixelsByCell.js\"\n\nclass ArtistooImport extends ModelDescription {\n\n\tconstructor( model ) {\n\n\t\tsuper()\n\n\t\tif( model.isCPM ){\n\t\t\tthis.C = model\n\t\t\tthis.simsettings = {}\n\t\t\tthis.mode = \"CPM\"\n\t\t} else if ( model.isSimulation ){\n\t\t\tthis.sim = model\n\t\t\tthis.C = model.C\n\t\t\tthis.simsettings = model.conf\n\t\t\tthis.mode = \"Simulation\"\n\t\t} else {\n\t\t\tthrow(\"Model must be a CPM or Simulation object!\")\n\t\t}\n\n\t\tthis.from = \"an Artistoo model (\" + this.mode + \" class)\"\n\t\tthis.generalWarning += \"\\nWarning: cannot automatically convert an entire \" +\n\t\t\t\"Artistoo script. This converter handles anything in the configuration \" +\n\t\t\t\"object of your \" + this.mode + \", such as spatial settings, time settings \" +\n\t\t\t\"and CPM parameters. It also handles the initial configuration. But \" +\n\t\t\t\"if you perform extra actions between steps \" +\n\t\t\t\"(such as dividing cells, killing cells, producing chemokines, etc.),\" +\n\t\t\t\" these are not automatically added to the converted model. \" +\n\t\t\t\"Please check your script manually for such actions; they should be \" +\n\t\t\t\"added manually in the destination framework (please consult that framework's \" +\n\t\t\t\"documentation to see how).\\n\\n\"\n\n\n\t\tthis.build()\n\t}\n\n\n\tsetModelInfo(){\n\t\tthis.modelInfo.title = \"ArtistooImport\"\n\t\tthis.modelInfo.desc = \"Please add a description of your model here.\"\n\t\tthis.conversionWarnings.modelInfo.push(\n\t\t\t\"Cannot set model title and description automatically from an HTML page; \" +\n\t\t\t\"please add these manually to your model.\"\n\t\t)\n\t}\n\n\tsetTimeInfo(){\n\n\n\t\tthis.timeInfo.start = 0\n\t\tif( this.simsettings.hasOwnProperty(\"BURNIN\") ){\n\t\t\tthis.timeInfo.start += this.simsettings[\"BURNIN\"]\n\t\t}\n\n\t\tif( this.simsettings.hasOwnProperty( \"RUNTIME\" ) ){\n\t\t\tthis.timeInfo.stop = this.timeInfo.start + this.simsettings.RUNTIME\n\t\t} else if (this.simsettings.hasOwnProperty( \"RUNTIME_BROWSER\" ) ){\n\t\t\tthis.timeInfo.stop = this.timeInfo.start + this.simsettings.RUNTIME_BROWSER\n\t\t} else {\n\t\t\tthis.timeInfo.stop = 100\n\t\t\tthis.conversionWarnings.time.push(\n\t\t\t\t\"Could not find any information of runtime; setting the simulation to \" +\n\t\t\t\t\"100 MCS for now. Please adjust manually.\"\n\t\t\t)\n\t\t}\n\n\t\tthis.timeInfo.duration = this.timeInfo.stop - this.timeInfo.start\n\t\tif( this.timeInfo.duration < 0 ){\n\t\t\tthrow( \"Error: I cannot go back in time; timeInfo.stop must be larger than timeInfo.start!\")\n\t\t}\n\t}\n\n\tsetGridInfo(){\n\t\tthis.grid.ndim = this.C.grid.extents.length\n\t\tthis.grid.extents = this.C.grid.extents\n\t\tthis.grid.geometry = \"square\"\n\t\tif( this.grid.ndim === 3 ){\n\t\t\tthis.grid.geometry = \"cubic\"\n\t\t}\n\t\tthis.grid.neighborhood = { order: 2 }\n\t\tconst torus = this.C.grid.torus\n\t\tlet bounds = []\n\t\tfor( let t of torus ){\n\t\t\tif(t){\n\t\t\t\tbounds.push( \"periodic\" )\n\t\t\t} else {\n\t\t\t\tbounds.push( \"noflux\" )\n\t\t\t}\n\t\t}\n\t\tthis.grid.boundaries = bounds\n\t}\n\n\tsetCellKindNames(){\n\n\t\tthis.cellKinds.count = undefined\n\n\t\t// If there are simsettings, NRCELLS contains info on number of cellkinds.\n\t\t/*if( this.simsettings.hasOwnProperty(\"NRCELLS\" ) ){\n\t\t\tthis.cellKinds.count = this.simsettings.NRCELLS.length + 1\n\n\t\t// Otherwise, try getting it from the constraint parameters.\n\t\t} else {*/\n\t\tlet found = false\n\t\tconst constraints = this.C.getAllConstraints()\n\n\t\t// If there's an adhesion constraint, we can get the info from the J matrix.\n\t\tif( constraints.hasOwnProperty( \"Adhesion\" ) ){\n\t\t\tfound = true\n\t\t\tthis.cellKinds.count = this.C.getConstraint(\"Adhesion\").conf.J.length\n\n\t\t// Otherwise, loop through constraints to find a parameter starting\n\t\t// with LAMBDA and use that.\n\t\t} else {\n\t\t\tfor( let cn of Object.keys( constraints ) ){\n\t\t\t\tlet cc = this.C.getConstraint(cn).conf\n\t\t\t\t// Find index of first param that starts with LAMBDA;\n\t\t\t\t// returns -1 if there are none.\n\t\t\t\tconst lambdaIndex = Object.keys(cc).findIndex(\n\t\t\t\t\tfunction (k) {\n\t\t\t\t\t\treturn ~k.indexOf(\"LAMBDA\")\n\t\t\t\t\t})\n\t\t\t\tif (lambdaIndex > -1) {\n\t\t\t\t\t// there is a lambda parameter, assume specified per cellkind\n\t\t\t\t\tfound = true\n\t\t\t\t\tconst parmName = Object.keys(cc)[lambdaIndex]\n\t\t\t\t\tthis.cellKinds.count = cc[parmName].length\n\t\t\t\t}\n\t\t\t\tif (found) {\n\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\t// if we get here, still no success. Now try to read how many\n\t\t\t// cellKinds there are from the initialized grid.\n\n\t\t\tlet kinds = {}\n\t\t\tfor( let cid of this.C.cellIDs() ){\n\t\t\t\tif( !kinds.hasOwnProperty( this.C.cellKind(cid) ) ){\n\t\t\t\t\tkinds[this.C.cellKind(cid)] = true\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.cellKinds.count = Object.keys( kinds ).length + 1\n\t\t\tthis.conversionWarnings.cells.push(\n\t\t\t\t\"Could not find how many CellKinds there are automatically! \" +\n\t\t\t\t\"Counting the number of cellKinds on the initialized grid, but \" +\n\t\t\t\t\"if the simulation introduces new cellKinds only after initialization \" +\n\t\t\t\t\"then the output will be wrong. Please check manually! \" +\n\t\t\t\t\"As a workaround, you can add an Adhesion constraint to the model\" +\n\t\t\t\t\"with all-zero contact energies; this will not change the model \" +\n\t\t\t\t\"but will define the number of cellkinds properly.\"\n\t\t\t)\n\n\n\t\t\t//}\n\t\t}\n\n\t\t// if still undefined, don't add any except background an add a warning.\n\t\tif( typeof this.cellKinds.count === \"undefined\" ){\n\t\t\tthis.cellKinds.count = 1\n\t\t\tthis.conversionWarnings.cells.push(\n\t\t\t\t\"Could not find how many CellKinds there are automatically! \" +\n\t\t\t\t\"Ignoring everything except background, output will be wrong. \" +\n\t\t\t\t\"As a workaround, you can add an Adhesion constraint to the model\" +\n\t\t\t\t\"with all-zero contact energies; this will not change the model \" +\n\t\t\t\t\"but will define the number of cellkinds properly.\"\n\t\t\t)\n\t\t}\n\n\t\tthis.cellKinds.index2name = {}\n\t\tthis.cellKinds.name2index = {}\n\t\tfor( let k = 0; k < this.cellKinds.count; k++ ){\n\t\t\tif( k === 0 ){\n\t\t\t\tthis.cellKinds.index2name[k] = \"medium\"\n\t\t\t\tthis.cellKinds.name2index[\"medium\"] = k\n\t\t\t} else {\n\t\t\t\tthis.cellKinds.index2name[k] = \"celltype\" + k\n\t\t\t\tthis.cellKinds.name2index[\"celltype\"+k ] = k\n\t\t\t}\n\t\t}\n\n\t\t// empty object for each cellkind.\n\t\tthis.cellKinds.properties = {}\n\t\tfor( let n of Object.keys( this.cellKinds.name2index ) ){\n\t\t\tthis.cellKinds.properties[n] = {}\n\t\t}\n\n\n\t}\n\n\tsetCPMGeneral(){\n\n\t\t// Random Seed\n\t\tthis.kinetics.seed = this.C.conf.seed\n\n\t\t// Temperature\n\t\tthis.kinetics.T = this.C.conf.T\n\n\t}\n\n\tsetConstraints(){\n\n\t\tconst constraints = this.C.getAllConstraints()\n\t\tfor( let cName of Object.keys( constraints ) ){\n\t\t\tthis.constraints.constraints[cName] = []\n\t\t\tlet index = 0\n\t\t\twhile( typeof this.C.getConstraint( cName, index ) !== \"undefined\"){\n\t\t\t\tlet cc = this.C.getConstraint( cName, index ).conf\n\t\t\t\tthis.constraints.constraints[cName].push( cc )\n\t\t\t\tindex++\n\t\t\t}\n\t\t}\n\t}\n\n\tsetGridConfiguration(){\n\n\t\t// If the supplied model is a Simulation; this is the most robust method\n\t\t// because we can reset the model and export the grid configuration\n\t\t// directly after initializeGrid has been called.\n\t\tif( typeof this.sim !== \"undefined\" ){\n\t\t\t// stop the simulation\n\t\t\tthis.sim.toggleRunning()\n\t\t\t// remove any cells from the grid and reinitialize\n\t\t\tthis.sim.C.reset()\n\t\t\tthis.sim.initializeGrid()\n\t\t\tthis.readPixelsByCell()\n\t\t\t// Reset time to just after initialisation\n\t\t\tthis.sim.C.time -= this.sim.time\n\t\t\tthis.sim.time -= this.sim.time\n\t\t\tthis.sim.runBurnin()\n\t\t\tthis.sim.toggleRunning()\n\t\t} else {\n\t\t\tthis.conversionWarnings.init.push(\n\t\t\t\t\"You have supplied a CPM rather than a Simulation object; \" +\n\t\t\t\t\"reading the initial settings directly from the CPM. This is \" +\n\t\t\t\t\"slightly less robust than reading it from the Simulation since \" +\n\t\t\t\t\"I cannot go back to time t = 0 to read the exact initial setup.\"\n\t\t\t)\n\t\t\tthis.readPixelsByCell()\n\t\t}\n\n\t}\n\n\treadPixelsByCell(){\n\n\t\tconst cellPix = this.C.getStat( PixelsByCell )\n\t\tfor( let cid of Object.keys( cellPix ) ){\n\t\t\tif( cellPix[cid].length > 0 ) {\n\t\t\t\tconst cki = this.C.cellKind(cid)\n\t\t\t\tthis.setup.init.push({\n\t\t\t\t\tsetter: \"pixelSet\",\n\t\t\t\t\tkind: cki,\n\t\t\t\t\tkindName: this.getKindName(cki),\n\t\t\t\t\tcid: cid,\n\t\t\t\t\tpixels: cellPix[cid]\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nexport default ArtistooImport",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/converter/ArtistooImport.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 138,
    "kind": "class",
    "name": "ArtistooImport",
    "memberof": "src/converter/ArtistooImport.js",
    "static": true,
    "longname": "src/converter/ArtistooImport.js~ArtistooImport",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/converter/ArtistooImport.js",
    "importStyle": "ArtistooImport",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/converter/ModelDescription.js~ModelDescription"
    ]
  },
  {
    "__docId__": 139,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/converter/ArtistooImport.js~ArtistooImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ArtistooImport.js~ArtistooImport#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true
  },
  {
    "__docId__": 140,
    "kind": "member",
    "name": "C",
    "memberof": "src/converter/ArtistooImport.js~ArtistooImport",
    "static": false,
    "longname": "src/converter/ArtistooImport.js~ArtistooImport#C",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 141,
    "kind": "member",
    "name": "simsettings",
    "memberof": "src/converter/ArtistooImport.js~ArtistooImport",
    "static": false,
    "longname": "src/converter/ArtistooImport.js~ArtistooImport#simsettings",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 142,
    "kind": "member",
    "name": "mode",
    "memberof": "src/converter/ArtistooImport.js~ArtistooImport",
    "static": false,
    "longname": "src/converter/ArtistooImport.js~ArtistooImport#mode",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 143,
    "kind": "member",
    "name": "sim",
    "memberof": "src/converter/ArtistooImport.js~ArtistooImport",
    "static": false,
    "longname": "src/converter/ArtistooImport.js~ArtistooImport#sim",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 147,
    "kind": "member",
    "name": "from",
    "memberof": "src/converter/ArtistooImport.js~ArtistooImport",
    "static": false,
    "longname": "src/converter/ArtistooImport.js~ArtistooImport#from",
    "access": "public",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 148,
    "kind": "member",
    "name": "generalWarning",
    "memberof": "src/converter/ArtistooImport.js~ArtistooImport",
    "static": false,
    "longname": "src/converter/ArtistooImport.js~ArtistooImport#generalWarning",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 149,
    "kind": "method",
    "name": "setModelInfo",
    "memberof": "src/converter/ArtistooImport.js~ArtistooImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ArtistooImport.js~ArtistooImport#setModelInfo",
    "access": "public",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 150,
    "kind": "method",
    "name": "setTimeInfo",
    "memberof": "src/converter/ArtistooImport.js~ArtistooImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ArtistooImport.js~ArtistooImport#setTimeInfo",
    "access": "public",
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 151,
    "kind": "method",
    "name": "setGridInfo",
    "memberof": "src/converter/ArtistooImport.js~ArtistooImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ArtistooImport.js~ArtistooImport#setGridInfo",
    "access": "public",
    "description": null,
    "lineNumber": 75,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 152,
    "kind": "method",
    "name": "setCellKindNames",
    "memberof": "src/converter/ArtistooImport.js~ArtistooImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ArtistooImport.js~ArtistooImport#setCellKindNames",
    "access": "public",
    "description": null,
    "lineNumber": 95,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 153,
    "kind": "method",
    "name": "setCPMGeneral",
    "memberof": "src/converter/ArtistooImport.js~ArtistooImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ArtistooImport.js~ArtistooImport#setCPMGeneral",
    "access": "public",
    "description": null,
    "lineNumber": 192,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 154,
    "kind": "method",
    "name": "setConstraints",
    "memberof": "src/converter/ArtistooImport.js~ArtistooImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ArtistooImport.js~ArtistooImport#setConstraints",
    "access": "public",
    "description": null,
    "lineNumber": 202,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 155,
    "kind": "method",
    "name": "setGridConfiguration",
    "memberof": "src/converter/ArtistooImport.js~ArtistooImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ArtistooImport.js~ArtistooImport#setGridConfiguration",
    "access": "public",
    "description": null,
    "lineNumber": 216,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 156,
    "kind": "method",
    "name": "readPixelsByCell",
    "memberof": "src/converter/ArtistooImport.js~ArtistooImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ArtistooImport.js~ArtistooImport#readPixelsByCell",
    "access": "public",
    "description": null,
    "lineNumber": 245,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 157,
    "kind": "file",
    "name": "src/converter/ArtistooWriter.js",
    "content": "import Writer from \"./Writer.js\"\n\nclass ArtistooWriter extends Writer {\n\n\tconstructor( model, config ){\n\t\tsuper( model, config )\n\n\t\tthis.mode = config.mode || \"html\"\n\t\tthis.out = \"\"\n\t\tthis.modelconfig = {}\n\t\tthis.custommethods = {}\n\t\tthis.methodDeclarations = \"\"\n\n\n\n\t\tthis.FPSMeterPath = config.FPSMeterPath || \"https://artistoo.net/examples/fpsmeter.min.js\"\n\t\tthis.browserLibrary = config.browserLibrary || \".artistoo.js\" // \"https://artistoo.net/examples/artistoo.js\"\n\t\tthis.nodeLibrary = config.nodeLibrary || \"https://raw.githubusercontent.com/ingewortel/artistoo/master/build/artistoo-cjs.js\"\n\t\tthis.styleSheet = config.styleSheet || \"./modelStyle.css\"\n\n\t\tthis.logString = \"Hi there! Converting \" + this.model.from + \" to Artistoo...\\n\\n\"\n\n\t}\n\n\twrite(){\n\t\tif( this.mode === \"html\" ){\n\t\t\t//console.log( this.writeHTML() )\n\t\t\tthis.target.innerHTML = this.writeHTML()\n\t\t}\n\t\tthis.writeLog()\n\t}\n\n\n\twriteHTML(){\n\t\treturn this.writeHTMLHead() +\n\t\t\tthis.writeConfig() +\n\t\t\tthis.setInitialisation() +\n\t\t\tthis.customMethodsString() +\n\t\t\tthis.writeBasicScript() +\n\t\t\tthis.writeHTMLBody()\n\t}\n\n\twriteNode(){\n\t\treturn \"let CPM = require(\\\"../../build/artistoo-cjs.js\\\")\" +\n\t\t\tthis.writeConfig() +\n\t\t\tthis.writeBasicScript()\n\t}\n\n\twriteHTMLHead( ){\n\n\t\tlet string = \"<html lang=\\\"en\\\"><head><meta http-equiv=\\\"Content-Type\\\" \" +\n\t\t\t\"content=\\\"text/html; charset=UTF-8\\\">\\n\" +\n\t\t\t\"\\t<title>\" + this.model.modelInfo.title + \"</title>\\n\"+\n\t\t\t\"\\t<link rel=\\\"stylesheet\\\" href=\\\"\" + this.styleSheet + \"\\\" />\" +\n\t\t\t/*\"\\t<style type=\\\"text/css\\\">\\n\" +\n\t\t\t\"\\t\\t body{\\n\"+\n\t\t\t\"\\t\\t\\t font-family: \\\"HelveticaNeue-Light\\\", \\\"Helvetica Neue Light\\\", \\\"Helvetica Neue\\\", \" +\n\t\t\t\"Helvetica, Arial, \\\"Lucida Grande\\\", sans-serif; \\n\" +\n\t\t\t\"\\t\\t\\t padding : 15px; \\n\" +\n\t\t\t\"\\t\\t} \\n\" +\n\t\t\t\"\\t\\t td { \\n\" +\n\t\t\t\"\\t\\t\\t padding: 10px; \\n\" +\n\t\t\t\"\\t\\t\\t vertical-align: top; \\n\" +\n\t\t\t\"\\t\\t } \\n\" +\n\t\t\t\"\\t </style> \\n\" +*/\n\t\t\t\"\\t\" + \"<script src=\\\"\" + this.browserLibrary + \"\\\"></script> \\n\" + //'\\t <script src=\"https://artistoo.net/examples/artistoo.js\"></script> \\n' +\n\t\t\t\"\\t\" + \"<script src=\\\"\" + this.FPSMeterPath + \"\\\"></script> \\n\\n\" +\n\t\t\t\"<script> \\n\\n\\n\" +\n\t\t\t\"\\\"use strict\\\" \\n\" +\n\t\t\t\"var sim, meter \\n\\n\"\n\n\t\treturn(string)\n\n\t}\n\n\twriteHTMLBody(){\n\n\t\tlet modelDesc = this.model.modelInfo.desc\n\t\tmodelDesc = this.htmlNewLine( modelDesc )\n\n\t\treturn \"</script> \\n\\n\" +\n\t\t\t\"</head>\\n\" +\n\t\t\t\"<body onload=\\\"initialize();parent.window.model = sim\\\"> \\n\" +\n\t\t\t\"<h1>\"+this.model.modelInfo.title + \"</h1> \\n\"+\n\t\t\t\"<p>\\n\\t\" + modelDesc + \"\\n\" +\n\t\t\t\"</p>\\n\" +\n\t\t\t\"</body> \\n\" +\n\t\t\t\"</html>\"\n\n\t}\n\n\twriteConfig(){\n\t\tthis.setModelConfig()\n\t\treturn \"let config = \" + this.objToString( this.modelconfig ) + \"\\n\\n\"\n\t}\n\n\tcustomMethodsString(){\n\t\tlet string = \"let custommethods = {\\n\"\n\t\tfor( let m of Object.keys( this.custommethods ) ){\n\t\t\tstring += \"\\t\" + m + \" : \" + m + \",\\n\"\n\t\t}\n\t\treturn string + \"}\"\n\t}\n\n\t/* TO DO */\n\tsetModelConfig(){\n\n\t\t// Initialize structure\n\t\tlet config = {\n\t\t\tconf : {},\n\t\t\tsimsettings : {\n\t\t\t\tzoom : 2,\n\t\t\t\tCANVASCOLOR : \"EEEEEE\"\n\t\t\t}\n\t\t}\n\n\t\t// Time information; warn if start time != 0\n\t\tif( this.model.timeInfo.start !== 0 ){\n\t\t\tthis.conversionWarnings.time.push(\n\t\t\t\t\"Morpheus model time starts at t = \" + this.model.timeInfo.start +\n\t\t\t\t\". Interpreting time before that as a burnin time, but in Artistoo \" +\n\t\t\t\t\" time will restart at t = 0 after this burnin.\"\n\t\t\t)\n\t\t}\n\t\tconfig.simsettings.BURNIN = parseInt( this.model.timeInfo.start )\n\t\tconfig.simsettings.RUNTIME = parseInt( this.model.timeInfo.duration )\n\t\tconfig.simsettings.RUNTIME_BROWSER = parseInt( this.model.timeInfo.duration )\n\n\t\t// Grid information, warn if grid has to be converted.\n\t\tconfig.ndim = this.model.grid.ndim\n\t\tconfig.field_size = this.model.grid.extents\n\t\tif( this.model.grid.geometry === \"hexagonal\" ){\n\t\t\tthis.conversionWarnings.grid.push(\n\t\t\t\t\"Grid of type 'hexagonal' is not yet supported in Artistoo. \" +\n\t\t\t\t\"Converting to square 2D lattice instead. You may have to adjust some parameters, \" +\n\t\t\t\t\"especially where neighborhood sizes matter (eg PerimeterConstraint, Adhesion).\"\n\t\t\t)\n\t\t}\n\t\tconfig.torus = []\n\t\tconst dimNames = [\"x\",\"y\",\"z\"]\n\t\tfor( let d = 0; d < config.ndim; d++ ){\n\t\t\tconst bound = this.model.grid.boundaries[d]\n\t\t\tswitch( bound ){\n\t\t\tcase \"periodic\" :\n\t\t\t\tconfig.torus.push( true )\n\t\t\t\tbreak\n\t\t\tcase \"noflux\" :\n\t\t\t\tconfig.torus.push( false )\n\t\t\t\tbreak\n\t\t\tdefault :\n\t\t\t\tconfig.torus.push( true )\n\t\t\t\tthis.conversionWarnings.grid.push(\n\t\t\t\t\t\"unknown boundary condition in \" + dimNames[d] + \"-dimension: \" +\n\t\t\t\t\tbound + \"; reverting to default periodic boundary.\"\n\t\t\t\t)\n\t\t\t}\n\n\t\t\t// special case for \"linear\" geometry, which in Artistoo is just\n\t\t\t// a 2D grid with a field_size [x,1] and torus = [x, false].\n\t\t\tif( this.model.grid.geometry === \"linear\" ){\n\t\t\t\tconfig.torus[1] = false\n\t\t\t}\n\t\t}\n\t\tif( !isNaN( this.model.grid.neighborhood.distance ) ){\n\t\t\tthis.conversionWarnings.grid.push(\n\t\t\t\t\"You are trying to set a neighborhood with distance = \" +\n\t\t\t\tthis.model.grid.neighborhood.distance + \", \" +\n\t\t\t\t\"but this is currently not supported in Artistoo. Reverting to\" +\n\t\t\t\t\"default (Moore) neighborhood; behaviour may change.\"\n\t\t\t)\n\t\t}\n\t\tif( !isNaN( this.model.grid.neighborhood.order ) &&  this.model.grid.neighborhood.order !== 2 ){\n\t\t\tthis.conversionWarnings.grid.push(\n\t\t\t\t\"You are trying to set a neighborhood with order = \" +\n\t\t\t\tthis.model.grid.neighborhood.order + \", \" +\n\t\t\t\t\"but this is currently not supported in Artistoo. Reverting to\" +\n\t\t\t\t\"default (Moore) neighborhood; behaviour may change.\"\n\t\t\t)\n\t\t}\n\n\t\t// CPM kinetics\n\t\tconfig.conf.T = this.model.kinetics.T\n\t\tconfig.conf.seed = this.model.kinetics.seed\n\n\t\tthis.modelconfig = config\n\n\t\t// CellKinds\n\t\tconfig.simsettings.NRCELLS = this.model.initCellKindVector( 0, false )\n\t\tconfig.simsettings.SHOWBORDERS = this.model.initCellKindVector( true, false )\n\t\tconfig.simsettings.CELLCOLOR = this.model.initCellKindVector( \"333333\", false )\n\t\tfor( let k = 1; k < this.model.cellKinds.count - 1; k++ ){\n\t\t\t// Overwrite cellcolors for all kinds except the first with a\n\t\t\t// randomly generated color.\n\t\t\tconfig.simsettings.CELLCOLOR[k] =\n\t\t\t\tMath.floor(Math.random()*16777215).toString(16).toUpperCase()\n\t\t}\n\n\t\t// Constraints\n\t\t// First constraints that can go in the main conf object (via auto-adder)\n\t\tlet constraintString = \"\"\n\t\tfor( let cName of Object.keys( this.model.constraints.constraints ) ){\n\t\t\tconst constraintArray = this.model.constraints.constraints[cName]\n\t\t\tfor( let ci = 0; ci < constraintArray.length; ci++ ){\n\t\t\t\tconst constraintConf = constraintArray[ci]\n\t\t\t\tconstraintString += this.addConstraintToConfig( cName, constraintConf )\n\t\t\t}\n\t\t}\n\t\tif( constraintString !== \"\" ){\n\t\t\tthis.addCustomMethod( \"addConstraints\", \"\", constraintString )\n\t\t}\n\t}\n\n\taddCustomMethod( methodName, args, contentString ){\n\t\tif( this.custommethods.hasOwnProperty( methodName ) ){\n\t\t\tthrow( \"Cannot add two custom methods of the same name!\" )\n\t\t}\n\t\tthis.custommethods[methodName] = methodName\n\t\tthis.methodDeclarations += \"function \" + methodName + \"( \" + args + \"){\\n\\n\\t\" +\n\t\t\tcontentString + \"\\n}\\n\\n\"\n\t}\n\n\taddConstraintToConfig( cName, cConf ){\n\n\t\tconst autoAdded = {\n\t\t\tActivityConstraint : true,\n\t\t\tAdhesion : true,\n\t\t\tVolumeConstraint : true,\n\t\t\tPerimeterConstraint : true,\n\t\t\tBarrierConstraint : true\n\t\t}\n\n\t\t// Constraints that can be directly added to config.conf:\n\t\tif( autoAdded.hasOwnProperty(cName) ) {\n\t\t\tfor (let parameter of Object.keys(cConf)) {\n\t\t\t\tthis.modelconfig.conf[parameter] = cConf[parameter]\n\t\t\t}\n\n\t\t\t// ActivityConstraint special case; set ACTCOLOR\n\t\t\tif (cName === \"ActivityConstraint\") {\n\t\t\t\t// check which kinds have activity; skip background\n\t\t\t\tlet hasAct = []\n\t\t\t\tfor (let k = 1; k < this.model.cellKinds.count; k++) {\n\t\t\t\t\tif (cConf.LAMBDA_ACT[k] > 0 && cConf.MAX_ACT[k] > 0) {\n\t\t\t\t\t\thasAct.push(true)\n\t\t\t\t\t} else {\n\t\t\t\t\t\thasAct.push(false)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.modelconfig.simsettings.ACTCOLOR = hasAct\n\t\t\t}\n\n\t\t\t// Another special case for the PerimeterConstraint, which may\n\t\t\t// have to be converted depending on 'mode' and the 'ShapeSurface'.\n\t\t\telse if (cName === \"PerimeterConstraint\") {\n\t\t\t\tswitch (cConf.mode) {\n\t\t\t\tcase \"surface\" :\n\t\t\t\t\t// do nothing\n\t\t\t\t\tbreak\n\t\t\t\tcase \"aspherity\" : {\n\t\t\t\t\t// correct the 'target' perimeter.\n\t\t\t\t\tlet P = cConf.P\n\t\t\t\t\tconst volume = this.modelconfig.conf.V\n\t\t\t\t\tfor (let i = 0; i < P.length; i++) {\n\t\t\t\t\t\tif (this.modelconfig.ndim === 2) {\n\t\t\t\t\t\t\tP[i] = 4 * P[i] * 2 * Math.sqrt(volume[i] * Math.PI)\n\t\t\t\t\t\t} else if (this.modelconfig.ndim === 3) {\n\t\t\t\t\t\t\tP[i] = P[i] * 4 * Math.PI * Math.pow((3 / 4) * volume[i] / Math.PI, 2 / 3)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tP[i] = parseFloat(P[i])\n\t\t\t\t\t}\n\t\t\t\t\tthis.conversionWarnings.constraints.push(\n\t\t\t\t\t\t\"Artistoo does not support the 'aspherity' mode of the Morpheus <SurfaceConstraint>.\" +\n\t\t\t\t\t\t\"Adding a regular PerimeterConstraint (mode 'surface') instead. I am converting the \" +\n\t\t\t\t\t\t\"target perimeter with an educated guess, but behaviour may be slightly different; \" +\n\t\t\t\t\t\t\"please check parameters.\"\n\t\t\t\t\t)\n\n\t\t\t\t\tthis.modelconfig.conf.P = P\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tdelete this.modelconfig.conf.mode\n\t\t\t}\n\n\t\t\treturn \"\"\n\t\t}\n\n\t\t// For the other constraints, add them by overwriting the\n\t\t// Simulation.addConstraints() method. Return the string of code\n\t\t// to add in this method.\n\t\tconst otherSupportedConstraints = {\n\t\t\tLocalConnectivityConstraint : true,\n\t\t\tPersistenceConstraint : true,\n\t\t\tPreferredDirectionConstraint : true,\n\t\t\tChemotaxisConstraint : true\n\t\t}\n\n\t\tif( !otherSupportedConstraints[cName] ){\n\t\t\tthis.conversionWarnings.constraints.push(\n\t\t\t\t\"Ignoring unknown constraint of type \" + cName + \". Behaviour may change.\")\n\t\t}\n\n\t\t// Special case for the PersistenceConstraint: warn if\n\t\t// protrusion/retraction setting does not correspond.\n\t\tif (cName === \"PersistenceConstraint\" || cName === \"PreferredDirectionConstraint\" ){\n\t\t\tconst protrude = cConf.PROTRUDE\n\t\t\tconst retract = cConf.RETRACT\n\t\t\tconst lambda = cConf.LAMBDA_DIR\n\n\t\t\tlet warn = false\n\t\t\tfor( let k = 0; k < protrude.length; k++ ){\n\n\t\t\t\tif( lambda[k] > 0 ) {\n\n\t\t\t\t\tif (!protrude[k]) {\n\t\t\t\t\t\twarn = true\n\t\t\t\t\t}\n\t\t\t\t\tif (retract[k]) {\n\t\t\t\t\t\twarn = true\n\t\t\t\t\t}\n\t\t\t\t\tif (warn) {\n\t\t\t\t\t\tthis.conversionWarnings.constraints.push(\n\t\t\t\t\t\t\t\"You are trying to set a PersistenceConstraint for cellkind \" +\n\t\t\t\t\t\t\tthis.model.getKindName(k) + \" with protrusion = \" +\n\t\t\t\t\t\t\tprotrude[k] + \" and retraction = \" + retract[k] + \", but Artistoo \" +\n\t\t\t\t\t\t\t\"only supports protrusion = true and retraction = false. \" +\n\t\t\t\t\t\t\t\"Reverting to these settings. Behaviour may change slightly; \" +\n\t\t\t\t\t\t\t\"if this is important, consider implementing your own constraint.\"\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdelete cConf.PROTRUDE\n\t\t\tdelete cConf.RETRACT\n\t\t}\n\n\t\treturn \"this.C.add( new CPM.\" + cName + \"( \" + this.objToString( cConf, 1 ) + \") )\\n\\n\\t\"\n\n\t}\n\n\twriteBasicScript(){\n\n\t\treturn \"\\n\\n\" +\n\t\t\t\"function initialize(){ \\n\" +\n\t\t\t\"\\t\" + \"sim = new CPM.Simulation( config, custommethods ) \\n\" +\n\t\t\t\"\\t\" + \"meter = new FPSMeter({left:\\\"auto\\\", right:\\\"5px\\\"}) \\n\\n\"+\n\t\t\t\"\\t\" + \"step() \\n\" +\n\t\t\t\"} \\n\\n\" +\n\t\t\t\"function step(){ \\n\\t\" +\n\t\t\t\"sim.step() \\n\\t\" +\n\t\t\t\"meter.tick() \\n\\n\\t\" +\n\t\t\t\"if( sim.conf[\\\"RUNTIME_BROWSER\\\"] == \\\"Inf\\\" | sim.time+1 < sim.conf[\\\"RUNTIME_BROWSER\\\"] ){ \\n\\t\" +\n\t\t\t\"\\t\\t\" + \"requestAnimationFrame( step ) \\n\" +\n\t\t\t\"\\t} \\n}\\n\\n\" + this.methodDeclarations\n\n\t}\n\n\tsetInitialisation(){\n\t\t// Initializers\n\t\tlet initString = \"\"\n\t\tfor( let initConf of this.model.setup.init ){\n\t\t\tinitString += this.addInitializer( initConf )\n\t\t}\n\t\tif( initString !== \"\" ){\n\t\t\tinitString = \"\" + \"this.addGridManipulator()\\n\\n\" + initString\n\t\t\tthis.addCustomMethod( \"initializeGrid\", \"\", initString )\n\t\t}\n\t\treturn \"\"\n\t}\n\n\taddInitializer( conf ){\n\n\t\tconst kindIndex = conf.kind\n\t\tswitch( conf.setter ){\n\n\t\tcase \"circleObject\" :\n\t\t\treturn \"\\t\" + \"this.gm.assignCellPixels( this.gm.makeCircle( [\" +\n\t\t\t\tconf.center.toString() + \"], \" + conf.radius +  \") , \" + kindIndex + \" )\\n\"\n\n\t\tcase \"boxObject\" :\n\t\t\treturn \"\\t\" + \"this.gm.assignCellPixels( this.gm.makeBox( [\" +\n\t\t\t\tconf.bottomLeft.toString() + \"], [\" + conf.boxSize.toString() +\n\t\t\t\t\"] ) , \" + kindIndex + \" )\\n\"\n\n\t\tcase \"cellCircle\" :\n\t\t\treturn \"\\t\" + \"this.gm.seedCellsInCircle( \" + kindIndex + \", \" +\n\t\t\t\tconf.nCells + \", [\" + conf.center.toString() + \"], \" +\n\t\t\t\tconf.radius + \" )\\n\"\n\n\t\tcase \"pixelSet\" : {\n\t\t\tlet out = \"[\\n\\t\\t\"\n\t\t\tfor (let i = 0; i < conf.pixels.length; i++ ) {\n\t\t\t\tconst p = conf.pixels[i]\n\t\t\t\tout += \"[\" + p.toString() + \"]\"\n\t\t\t\tif( i < conf.pixels.length - 1 ){ out += \",\" }\n\t\t\t}\n\t\t\treturn \"\\t\" + \"this.gm.assignCellPixels( \" + out +\n\t\t\t\t\" ], \" + kindIndex + \")\\n\"\n\n\t\t}\n\n\t\tdefault :\n\t\t\tthis.conversionWarnings.init.push( \"Unknown initializer \"\n\t\t\t+ conf.setter + \"; ignoring.\" )\n\t\t}\n\n\t}\n\n}\n\nexport default ArtistooWriter\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/converter/ArtistooWriter.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 158,
    "kind": "class",
    "name": "ArtistooWriter",
    "memberof": "src/converter/ArtistooWriter.js",
    "static": true,
    "longname": "src/converter/ArtistooWriter.js~ArtistooWriter",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/converter/ArtistooWriter.js",
    "importStyle": "ArtistooWriter",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/converter/Writer.js~Writer"
    ]
  },
  {
    "__docId__": 159,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/converter/ArtistooWriter.js~ArtistooWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ArtistooWriter.js~ArtistooWriter#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true
  },
  {
    "__docId__": 160,
    "kind": "member",
    "name": "mode",
    "memberof": "src/converter/ArtistooWriter.js~ArtistooWriter",
    "static": false,
    "longname": "src/converter/ArtistooWriter.js~ArtistooWriter#mode",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 161,
    "kind": "member",
    "name": "out",
    "memberof": "src/converter/ArtistooWriter.js~ArtistooWriter",
    "static": false,
    "longname": "src/converter/ArtistooWriter.js~ArtistooWriter#out",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 162,
    "kind": "member",
    "name": "modelconfig",
    "memberof": "src/converter/ArtistooWriter.js~ArtistooWriter",
    "static": false,
    "longname": "src/converter/ArtistooWriter.js~ArtistooWriter#modelconfig",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 163,
    "kind": "member",
    "name": "custommethods",
    "memberof": "src/converter/ArtistooWriter.js~ArtistooWriter",
    "static": false,
    "longname": "src/converter/ArtistooWriter.js~ArtistooWriter#custommethods",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 164,
    "kind": "member",
    "name": "methodDeclarations",
    "memberof": "src/converter/ArtistooWriter.js~ArtistooWriter",
    "static": false,
    "longname": "src/converter/ArtistooWriter.js~ArtistooWriter#methodDeclarations",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 165,
    "kind": "member",
    "name": "FPSMeterPath",
    "memberof": "src/converter/ArtistooWriter.js~ArtistooWriter",
    "static": false,
    "longname": "src/converter/ArtistooWriter.js~ArtistooWriter#FPSMeterPath",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 166,
    "kind": "member",
    "name": "browserLibrary",
    "memberof": "src/converter/ArtistooWriter.js~ArtistooWriter",
    "static": false,
    "longname": "src/converter/ArtistooWriter.js~ArtistooWriter#browserLibrary",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 167,
    "kind": "member",
    "name": "nodeLibrary",
    "memberof": "src/converter/ArtistooWriter.js~ArtistooWriter",
    "static": false,
    "longname": "src/converter/ArtistooWriter.js~ArtistooWriter#nodeLibrary",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 168,
    "kind": "member",
    "name": "styleSheet",
    "memberof": "src/converter/ArtistooWriter.js~ArtistooWriter",
    "static": false,
    "longname": "src/converter/ArtistooWriter.js~ArtistooWriter#styleSheet",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 169,
    "kind": "member",
    "name": "logString",
    "memberof": "src/converter/ArtistooWriter.js~ArtistooWriter",
    "static": false,
    "longname": "src/converter/ArtistooWriter.js~ArtistooWriter#logString",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 170,
    "kind": "method",
    "name": "write",
    "memberof": "src/converter/ArtistooWriter.js~ArtistooWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ArtistooWriter.js~ArtistooWriter#write",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 171,
    "kind": "method",
    "name": "writeHTML",
    "memberof": "src/converter/ArtistooWriter.js~ArtistooWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ArtistooWriter.js~ArtistooWriter#writeHTML",
    "access": "public",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 172,
    "kind": "method",
    "name": "writeNode",
    "memberof": "src/converter/ArtistooWriter.js~ArtistooWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ArtistooWriter.js~ArtistooWriter#writeNode",
    "access": "public",
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 173,
    "kind": "method",
    "name": "writeHTMLHead",
    "memberof": "src/converter/ArtistooWriter.js~ArtistooWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ArtistooWriter.js~ArtistooWriter#writeHTMLHead",
    "access": "public",
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 174,
    "kind": "method",
    "name": "writeHTMLBody",
    "memberof": "src/converter/ArtistooWriter.js~ArtistooWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ArtistooWriter.js~ArtistooWriter#writeHTMLBody",
    "access": "public",
    "description": null,
    "lineNumber": 76,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 175,
    "kind": "method",
    "name": "writeConfig",
    "memberof": "src/converter/ArtistooWriter.js~ArtistooWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ArtistooWriter.js~ArtistooWriter#writeConfig",
    "access": "public",
    "description": null,
    "lineNumber": 92,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 176,
    "kind": "method",
    "name": "customMethodsString",
    "memberof": "src/converter/ArtistooWriter.js~ArtistooWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ArtistooWriter.js~ArtistooWriter#customMethodsString",
    "access": "public",
    "description": null,
    "lineNumber": 97,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 177,
    "kind": "method",
    "name": "setModelConfig",
    "memberof": "src/converter/ArtistooWriter.js~ArtistooWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ArtistooWriter.js~ArtistooWriter#setModelConfig",
    "access": "public",
    "description": null,
    "lineNumber": 106,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 179,
    "kind": "method",
    "name": "addCustomMethod",
    "memberof": "src/converter/ArtistooWriter.js~ArtistooWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ArtistooWriter.js~ArtistooWriter#addCustomMethod",
    "access": "public",
    "description": null,
    "lineNumber": 213,
    "undocument": true,
    "params": [
      {
        "name": "methodName",
        "types": [
          "*"
        ]
      },
      {
        "name": "args",
        "types": [
          "*"
        ]
      },
      {
        "name": "contentString",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 181,
    "kind": "method",
    "name": "addConstraintToConfig",
    "memberof": "src/converter/ArtistooWriter.js~ArtistooWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ArtistooWriter.js~ArtistooWriter#addConstraintToConfig",
    "access": "public",
    "description": null,
    "lineNumber": 222,
    "undocument": true,
    "params": [
      {
        "name": "cName",
        "types": [
          "*"
        ]
      },
      {
        "name": "cConf",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 182,
    "kind": "method",
    "name": "writeBasicScript",
    "memberof": "src/converter/ArtistooWriter.js~ArtistooWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ArtistooWriter.js~ArtistooWriter#writeBasicScript",
    "access": "public",
    "description": null,
    "lineNumber": 342,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 183,
    "kind": "method",
    "name": "setInitialisation",
    "memberof": "src/converter/ArtistooWriter.js~ArtistooWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ArtistooWriter.js~ArtistooWriter#setInitialisation",
    "access": "public",
    "description": null,
    "lineNumber": 359,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 184,
    "kind": "method",
    "name": "addInitializer",
    "memberof": "src/converter/ArtistooWriter.js~ArtistooWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ArtistooWriter.js~ArtistooWriter#addInitializer",
    "access": "public",
    "description": null,
    "lineNumber": 372,
    "undocument": true,
    "params": [
      {
        "name": "conf",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 185,
    "kind": "file",
    "name": "src/converter/ModelDescription.js",
    "content": "//import GridManipulator from \"../grid/GridManipulator\"\n\n/** This class is meant as a bridge to convert between model frameworks.\n * It currently supports only conversion from Artistoo -> Morpheus and vice\n * versa.\n * @experimental\n */\nclass ModelDescription {\n\n\tconstructor( ){\n\n\n\t\t// Properties to obtain\n\t\tthis.modelInfo = {\n\t\t\ttitle : \"\",\n\t\t\tdesc : \"\"\n\t\t}\n\n\t\tthis.timeInfo = {\n\t\t\tstart : 0,\n\t\t\tstop : 0,\n\t\t\tduration : 0\n\t\t}\n\n\t\tthis.grid = {\n\t\t\tgeometry : \"\",\n\t\t\tndim : 0,\n\t\t\textents : [],\n\t\t\tboundaries : [],\n\t\t\tneighborhood : {\n\t\t\t\tdistance : NaN,\n\t\t\t\torder : NaN\n\t\t\t}\n\t\t}\n\n\t\tthis.kinetics = {\n\t\t\tT : 0,\n\t\t\tseed : undefined\n\t\t}\n\n\t\tthis.constraints = {\n\t\t\tconstraints : []\n\t\t}\n\n\t\tthis.cellKinds = {\n\t\t\tname2index : {},\n\t\t\tindex2name : {},\n\t\t\tproperties : {},\n\t\t\tcount : 0\n\t\t}\n\n\t\tthis.setup = {\n\t\t\tinit : []\n\t\t}\n\n\t\tthis.generalWarning = \"\"\n\n\t\tthis.conversionWarnings = {\n\t\t\tmodelInfo : [],\n\t\t\tgrid : [],\n\t\t\ttime : [],\n\t\t\tcells : [],\n\t\t\tkinetics : [],\n\t\t\tconstraints : [],\n\t\t\tinit : [],\n\t\t\tanalysis: []\n\t\t}\n\n\n\t}\n\n\tbuild(){\n\t\tthis.setModelInfo()\n\t\tthis.setGridInfo()\n\t\tthis.setTimeInfo()\n\t\tthis.setCellKindNames()\n\t\tthis.setCPMGeneral()\n\t\tthis.setConstraints()\n\t\tthis.setGridConfiguration()\n\t}\n\n\tgetKindIndex( kindName ){\n\t\tif( typeof this.cellKinds === \"undefined\" ){\n\t\t\tthrow( \"this.cellKinds needs to be set before getKindIndex() can be called!\" )\n\t\t}\n\t\treturn this.cellKinds.name2index[ kindName ]\n\t}\n\n\tgetKindName( kindIndex ){\n\t\tif( typeof this.cellKinds === \"undefined\" ){\n\t\t\tthrow( \"this.cellKinds needs to be set before getKindName() can be called!\" )\n\t\t}\n\t\treturn this.cellKinds.index2name[ kindIndex.toString() ]\n\t}\n\n\n\tinitDimensionVector( value = NaN ){\n\t\tlet vec = []\n\t\tif( !this.grid.ndim > 0 ){\n\t\t\tthrow( \"initDimensionVector cannot be called before this.grid.ndim is set!\" )\n\t\t}\n\t\tfor( let d = 0; d < this.grid.ndim; d++ ){\n\t\t\tvec.push( value )\n\t\t}\n\t\treturn vec\n\t}\n\n\tinitCellKindVector( value = NaN, includeBackground = true ){\n\n\t\tif( typeof this.cellKinds === \"undefined\" ){\n\t\t\tthrow( \"this.cellKinds needs to be set before initCellKindVector() can be called!\" )\n\t\t}\n\n\t\tlet nk = this.cellKinds.count\n\t\tif( !includeBackground ){ nk-- }\n\n\t\tlet vec = []\n\t\tfor( let k = 0; k < nk; k++ ){\n\t\t\tvec.push( value )\n\t\t}\n\t\treturn vec\n\t}\n\n\tinitCellKindMatrix( value = NaN, includeBackground = true ){\n\t\tif( typeof this.cellKinds === \"undefined\" ){\n\t\t\tthrow( \"this.cellKinds needs to be set before initCellKindVector() can be called!\" )\n\t\t}\n\n\t\tlet nk = this.cellKinds.count\n\t\tif( !includeBackground ){ nk-- }\n\n\t\tlet m = []\n\t\tfor( let k = 0; k < nk; k++ ){\n\t\t\tm.push( this.initCellKindVector( value, includeBackground ) )\n\t\t}\n\n\t\treturn m\n\t}\n\n\tsetGridGeometry( geomString ){\n\t\tswitch( geomString ){\n\t\tcase \"cubic\" :\n\t\t\tthis.grid.ndim = 3\n\t\t\tthis.grid.geometry = \"cubic\"\n\t\t\tbreak\n\t\tcase \"square\" :\n\t\t\tthis.grid.ndim = 2\n\t\t\tthis.grid.geometry = \"square\"\n\t\t\tbreak\n\t\tcase \"linear\" :\n\t\t\tthis.grid.ndim = 2\n\t\t\tthis.grid.geometry = \"linear\"\n\t\t\tbreak\n\t\tcase \"hexagonal\" :\n\t\t\tthis.grid.ndim = 2\n\t\t\tthis.grid.geometry = \"hexagonal\"\n\t\t\tbreak\n\t\tdefault :\n\t\t\tthis.grid.ndim = 2\n\t\t\tthis.grid.geometry = \"square\"\n\t\t\tthis.conversionWarnings.grid.push(\n\t\t\t\t\"Unknown grid geometry : \" + geomString +\n\t\t\t\t\". Continuing with default 2D square grid; but behavior may change!\"\n\t\t\t)\n\t\t\t// do nothing.\n\t\t}\n\t}\n\n\taddConstraint( name, conf ){\n\n\t\tif( !this.hasConstraint(name) ){\n\t\t\tthis.constraints.constraints[ name ] = []\n\t\t}\n\t\tthis.constraints.constraints[ name ].push( conf )\n\n\t}\n\n\thasConstraint( name ){\n\t\treturn this.constraints.constraints.hasOwnProperty( name )\n\t}\n\n\tgetConstraint( name, index = 0 ){\n\t\treturn this.constraints.constraints[name][index]\n\t}\n\n\tgetConstraintParameter( constraintName, paramName, index = 0 ){\n\t\treturn this.getConstraint( constraintName, index )[ paramName ]\n\t}\n\n\t/* ==========\tMETHODS TO OVERWRITE IN SUBCLASS =========== */\n\n\tcallerName() {\n\t\ttry {\n\t\t\tthrow new Error()\n\t\t}\n\t\tcatch (e) {\n\t\t\ttry {\n\t\t\t\treturn e.stack.split(\"at \")[3].split(\" \")[0]\n\t\t\t} catch (e) {\n\t\t\t\treturn \"\"\n\t\t\t}\n\t\t}\n\n\t}\n\tmethodOverwriteError(){\n\t\tthrow( \"Extensions of class ModelDescription must implement method: '\" +\n\t\t\tthis.callerName() + \"'!\" )\n\t}\n\n\tsetModelInfo(){\n\t\tthis.methodOverwriteError()\n\t}\n\n\tsetTimeInfo(){\n\t\tthis.methodOverwriteError()\n\t}\n\n\tsetGridInfo(){\n\t\tthis.methodOverwriteError()\n\t}\n\n\tsetCPMGeneral(){\n\t\tthis.methodOverwriteError()\n\t}\n\n\tsetConstraints(){\n\t\tthis.methodOverwriteError()\n\t}\n\n\tsetCellKindNames(){\n\t\tthis.methodOverwriteError()\n\t}\n\n\tsetGridConfiguration(){\n\t\tthis.methodOverwriteError()\n\t}\n\n}\n\n\n\n\nexport default ModelDescription\n\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/converter/ModelDescription.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 186,
    "kind": "class",
    "name": "ModelDescription",
    "memberof": "src/converter/ModelDescription.js",
    "static": true,
    "longname": "src/converter/ModelDescription.js~ModelDescription",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/converter/ModelDescription.js",
    "importStyle": "ModelDescription",
    "description": "This class is meant as a bridge to convert between model frameworks.\nIt currently supports only conversion from Artistoo -> Morpheus and vice\nversa.",
    "lineNumber": 8,
    "experimental": true,
    "interface": false
  },
  {
    "__docId__": 187,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true
  },
  {
    "__docId__": 188,
    "kind": "member",
    "name": "modelInfo",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#modelInfo",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "{\"title\": *, \"desc\": *}"
      ]
    }
  },
  {
    "__docId__": 189,
    "kind": "member",
    "name": "timeInfo",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#timeInfo",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "{\"start\": *, \"stop\": *, \"duration\": *}"
      ]
    }
  },
  {
    "__docId__": 190,
    "kind": "member",
    "name": "grid",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#grid",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "{\"geometry\": *, \"ndim\": *, \"extents\": *, \"boundaries\": *, \"neighborhood\": *}"
      ]
    }
  },
  {
    "__docId__": 191,
    "kind": "member",
    "name": "kinetics",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#kinetics",
    "access": "public",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "type": {
      "types": [
        "{\"T\": *, \"seed\": *}"
      ]
    }
  },
  {
    "__docId__": 192,
    "kind": "member",
    "name": "constraints",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#constraints",
    "access": "public",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "type": {
      "types": [
        "{\"constraints\": *}"
      ]
    }
  },
  {
    "__docId__": 193,
    "kind": "member",
    "name": "cellKinds",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#cellKinds",
    "access": "public",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "type": {
      "types": [
        "{\"name2index\": *, \"index2name\": *, \"properties\": *, \"count\": *}"
      ]
    }
  },
  {
    "__docId__": 194,
    "kind": "member",
    "name": "setup",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#setup",
    "access": "public",
    "description": null,
    "lineNumber": 52,
    "undocument": true,
    "type": {
      "types": [
        "{\"init\": *}"
      ]
    }
  },
  {
    "__docId__": 195,
    "kind": "member",
    "name": "generalWarning",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#generalWarning",
    "access": "public",
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 196,
    "kind": "member",
    "name": "conversionWarnings",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#conversionWarnings",
    "access": "public",
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "type": {
      "types": [
        "{\"modelInfo\": *, \"grid\": *, \"time\": *, \"cells\": *, \"kinetics\": *, \"constraints\": *, \"init\": *, \"analysis\": *}"
      ]
    }
  },
  {
    "__docId__": 197,
    "kind": "method",
    "name": "build",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#build",
    "access": "public",
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 198,
    "kind": "method",
    "name": "getKindIndex",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#getKindIndex",
    "access": "public",
    "description": null,
    "lineNumber": 82,
    "undocument": true,
    "params": [
      {
        "name": "kindName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 199,
    "kind": "method",
    "name": "getKindName",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#getKindName",
    "access": "public",
    "description": null,
    "lineNumber": 89,
    "undocument": true,
    "params": [
      {
        "name": "kindIndex",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 200,
    "kind": "method",
    "name": "initDimensionVector",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#initDimensionVector",
    "access": "public",
    "description": null,
    "lineNumber": 97,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "optional": true,
        "types": [
          "*"
        ],
        "defaultRaw": "NaN",
        "defaultValue": "NaN"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 201,
    "kind": "method",
    "name": "initCellKindVector",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#initCellKindVector",
    "access": "public",
    "description": null,
    "lineNumber": 108,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "optional": true,
        "types": [
          "*"
        ],
        "defaultRaw": "NaN",
        "defaultValue": "NaN"
      },
      {
        "name": "includeBackground",
        "optional": true,
        "types": [
          "boolean"
        ],
        "defaultRaw": true,
        "defaultValue": "true"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 202,
    "kind": "method",
    "name": "initCellKindMatrix",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#initCellKindMatrix",
    "access": "public",
    "description": null,
    "lineNumber": 124,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "optional": true,
        "types": [
          "*"
        ],
        "defaultRaw": "NaN",
        "defaultValue": "NaN"
      },
      {
        "name": "includeBackground",
        "optional": true,
        "types": [
          "boolean"
        ],
        "defaultRaw": true,
        "defaultValue": "true"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 203,
    "kind": "method",
    "name": "setGridGeometry",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#setGridGeometry",
    "access": "public",
    "description": null,
    "lineNumber": 140,
    "undocument": true,
    "params": [
      {
        "name": "geomString",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 204,
    "kind": "method",
    "name": "addConstraint",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#addConstraint",
    "access": "public",
    "description": null,
    "lineNumber": 169,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      },
      {
        "name": "conf",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 205,
    "kind": "method",
    "name": "hasConstraint",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#hasConstraint",
    "access": "public",
    "description": null,
    "lineNumber": 178,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 206,
    "kind": "method",
    "name": "getConstraint",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#getConstraint",
    "access": "public",
    "description": null,
    "lineNumber": 182,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      },
      {
        "name": "index",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 207,
    "kind": "method",
    "name": "getConstraintParameter",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#getConstraintParameter",
    "access": "public",
    "description": null,
    "lineNumber": 186,
    "undocument": true,
    "params": [
      {
        "name": "constraintName",
        "types": [
          "*"
        ]
      },
      {
        "name": "paramName",
        "types": [
          "*"
        ]
      },
      {
        "name": "index",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 208,
    "kind": "method",
    "name": "callerName",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#callerName",
    "access": "public",
    "description": null,
    "lineNumber": 192,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 209,
    "kind": "method",
    "name": "methodOverwriteError",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#methodOverwriteError",
    "access": "public",
    "description": null,
    "lineNumber": 205,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 210,
    "kind": "method",
    "name": "setModelInfo",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#setModelInfo",
    "access": "public",
    "description": null,
    "lineNumber": 210,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 211,
    "kind": "method",
    "name": "setTimeInfo",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#setTimeInfo",
    "access": "public",
    "description": null,
    "lineNumber": 214,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 212,
    "kind": "method",
    "name": "setGridInfo",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#setGridInfo",
    "access": "public",
    "description": null,
    "lineNumber": 218,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 213,
    "kind": "method",
    "name": "setCPMGeneral",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#setCPMGeneral",
    "access": "public",
    "description": null,
    "lineNumber": 222,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 214,
    "kind": "method",
    "name": "setConstraints",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#setConstraints",
    "access": "public",
    "description": null,
    "lineNumber": 226,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 215,
    "kind": "method",
    "name": "setCellKindNames",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#setCellKindNames",
    "access": "public",
    "description": null,
    "lineNumber": 230,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 216,
    "kind": "method",
    "name": "setGridConfiguration",
    "memberof": "src/converter/ModelDescription.js~ModelDescription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/ModelDescription.js~ModelDescription#setGridConfiguration",
    "access": "public",
    "description": null,
    "lineNumber": 234,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 217,
    "kind": "file",
    "name": "src/converter/MorpheusImport.js",
    "content": "import ModelDescription from \"./ModelDescription.js\"\n\n\nclass MorpheusImport extends ModelDescription {\n\n\tconstructor( config ){\n\n\t\tsuper( )\n\n\t\tthis.xml = config.xml\n\t\tthis.from = \"a Morpheus model\"\n\t\tthis.build()\n\n\t}\n\n\t/* ==========\tGENERAL HELPER FUNCTIONS =========== */\n\n\treadXMLTag( tag, xml, index = 0 ){\n\t\tif( typeof xml === \"undefined\" ){\n\t\t\txml = this.xml\n\t\t}\n\t\tconst tag2 = this.getXMLTag( tag, xml, index )\n\t\tif( typeof tag2 !== \"undefined\" ){\n\t\t\treturn tag2.innerHTML\n\t\t}\n\t\treturn undefined\n\t}\n\n\tgetXMLTag( tag, xml, index = 0 ){\n\t\tif( typeof xml === \"undefined\" ){\n\t\t\txml = this.xml\n\t\t}\n\t\tconst tags = xml.getElementsByTagName( tag )\n\t\tif( tags.length === 0 ){\n\t\t\treturn undefined\n\t\t}\n\t\treturn tags[index]\n\t}\n\n\treadVectorAttribute( xml, attrName ){\n\t\tconst attr = xml.getAttribute( attrName )\n\t\treturn attr.split( \",\" ).map( function(x){\n\t\t\treturn( parseInt(x) )\n\t\t})\n\t}\n\n\treadCoordinateAttribute( xml, attrName ){\n\t\tconst vec = this.readVectorAttribute( xml, attrName )\n\t\tlet outVec = []\n\t\tfor( let d = 0; d < this.grid.ndim; d++ ){\n\t\t\toutVec.push( vec[d] )\n\t\t}\n\t\treturn outVec\n\t}\n\n\ttoCoordinate( string ){\n\t\tconst vec = string.split( \",\" ).map( function(x){\n\t\t\treturn( parseInt(x) )\n\t\t})\n\t\tlet outVec = []\n\t\tfor( let d = 0; d < this.grid.ndim; d++ ){\n\t\t\toutVec.push( vec[d] )\n\t\t}\n\t\treturn outVec\n\t}\n\n\t/* ==========\tMORPHEUS READER FUNCTIONS =========== */\n\n\tsetModelInfo(){\n\n\t\t// Get title from XML\n\t\tconst title = this.readXMLTag( \"Title\" )\n\t\tif( typeof title === \"undefined\" ) {\n\t\t\tthis.conversionWarnings.modelInfo.push(\n\t\t\t\t\"Could not find model title.\"\n\t\t\t)\n\t\t} else {\n\t\t\tthis.modelInfo.title = title\n\t\t}\n\n\t\t// Get description from XML\n\t\tconst desc = this.readXMLTag( \"Details\" )\n\t\tif( typeof desc === \"undefined\" ) {\n\t\t\tthis.conversionWarnings.modelInfo.push(\n\t\t\t\t\"Could not find a model description.\"\n\t\t\t)\n\t\t} else {\n\t\t\tthis.modelInfo.desc = desc.toString()\n\t\t}\n\n\t}\n\n\tsetTimeInfo(){\n\n\t\tconst time = this.getXMLTag( \"Time\" )\n\n\t\tfor( let time_ch of time.children ) {\n\n\t\t\tswitch (time_ch.nodeName) {\n\n\t\t\tcase \"StartTime\" :\n\t\t\t\tthis.timeInfo.start = Number( time_ch.getAttribute(\"value\") )\n\t\t\t\tbreak\n\t\t\tcase \"StopTime\" :\n\t\t\t\tthis.timeInfo.stop = Number( time_ch.getAttribute(\"value\") )\n\t\t\t\tbreak\n\t\t\tcase \"RandomSeed\" :\n\t\t\t\tthis.kinetics.seed = parseInt( time_ch.getAttribute(\"value\") )\n\t\t\t\tbreak\n\t\t\tcase \"TimeSymbol\" :\n\t\t\t\tbreak\n\t\t\tdefault :\n\t\t\t\tthis.conversionWarnings.time.push(\n\t\t\t\t\t\"I don't know what to do with tag <\" + time_ch.nodeName + \"> in <Time>. Ignoring it.\"\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t\tthis.timeInfo.duration = this.timeInfo.stop - this.timeInfo.start\n\t\tif( this.timeInfo.duration < 0 ){\n\t\t\tthrow( \"Error: I cannot go back in time; timeInfo.stop must be larger than timeInfo.start!\")\n\t\t}\n\t}\n\n\tsetGridInfo(){\n\t\tconst space = this.getXMLTag( \"Space\" )\n\t\tfor( let space_ch of space.children ){\n\t\t\tswitch( space_ch.nodeName ) {\n\t\t\tcase \"Lattice\" :\n\t\t\t\tthis.readMorpheusLattice( space_ch )\n\t\t\t\tbreak\n\t\t\tcase \"SpaceSymbol\" :\n\t\t\t\tbreak\n\t\t\tdefault :\n\t\t\t\tthis.conversionWarnings.grid.push(\n\t\t\t\t\t\"Tags of type <\" + space_ch.nodeName + \"> are currently not supported. \" +\n\t\t\t\t\t\"Ignoring it for now.\"\n\t\t\t\t)\n\n\t\t\t}\n\t\t}\n\t}\n\n\treadMorpheusLattice( lattice ){\n\n\t\t// this.grid.geometry and this.grid.ndim\n\t\tthis.setGridGeometry( lattice.className )\n\n\t\t// declare some variables needed\n\t\tconst boundLookup = { x : 0, y : 1, z : 2 }\n\t\tlet order, bound, dimIndex, boundType\n\n\n\t\t// Read info in the lattice\n\t\tfor( let lattice_ch of lattice.children ){\n\n\t\t\tswitch( lattice_ch.nodeName ) {\n\t\t\tcase \"Size\" :\n\t\t\t\tthis.grid.extents = this.readCoordinateAttribute( lattice_ch, \"value\" )\n\t\t\t\tbreak\n\t\t\tcase \"Neighborhood\" :\n\t\t\t\tfor( let nn of lattice_ch.children ){\n\t\t\t\t\tswitch( nn.nodeName ){\n\t\t\t\t\tcase \"Order\" :\n\t\t\t\t\t\torder = parseInt( this.readXMLTag( \"Order\", lattice_ch ) )\n\t\t\t\t\t\tif( isNaN(order) ){\n\t\t\t\t\t\t\tthis.conversionWarnings.grid.push(\n\t\t\t\t\t\t\t\t\"Non-integer neighborhood order. Ignoring.\"\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.grid.neighborhood.order = order\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase \"Distance\" :\n\t\t\t\t\t\tthis.grid.neighborhood.distance = this.readXMLTag( \"Distance\", lattice_ch )\n\t\t\t\t\t\tbreak\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthis.conversionWarnings.grid.push(\n\t\t\t\t\t\t\t\"I don't know what to do with tag <\" + nn.nodeName +\n\t\t\t\t\t\t\t\"> in a <Neighborhood> of a <Space> <Lattice>. Ignoring.\"\n\t\t\t\t\t\t)\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\n\t\t\tcase \"BoundaryConditions\" :\n\n\t\t\t\tfor( let nn of lattice_ch.children ) {\n\t\t\t\t\tswitch (nn.nodeName) {\n\t\t\t\t\tcase \"Condition\" :\n\t\t\t\t\t\tbound = nn.getAttribute(\"boundary\")\n\t\t\t\t\t\tdimIndex = boundLookup[bound]\n\t\t\t\t\t\tboundType = nn.getAttribute(\"type\")\n\t\t\t\t\t\tthis.grid.boundaries[dimIndex] = boundType\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tdefault :\n\t\t\t\t\t\tthis.conversionWarnings.grid.push(\n\t\t\t\t\t\t\t\"I don't know what to do with tag <\" + nn.nodeName +\n\t\t\t\t\t\t\t\"> in the <BoundaryConditions> of a <Space> <Lattice>. Ignoring.\"\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\n\t\t\tcase \"Domain\" :\n\t\t\t\tthis.conversionWarnings.grid.push(\n\t\t\t\t\t\"Your MorpheusModel has specified a <\" + lattice_ch.nodeName + \"> : \\n\\t\\t\\t\" +\n\t\t\t\t\tlattice_ch.outerHTML + \"\\n\" +\n\t\t\t\t\t\"This is currently not supported, but you can mimic the behaviour \" +\n\t\t\t\t\t\"by adding a physical barrier using a BarrierConstraint; \" +\n\t\t\t\t\t\"e.g. see artistoo.net/examples/Microchannel.html.\"\n\t\t\t\t)\n\t\t\t\tbreak\n\n\t\t\tcase \"NodeLength\" :\n\t\t\t\tthis.conversionWarnings.grid.push(\n\t\t\t\t\t\"Your MorpheusModel has specified a <\" + lattice_ch.nodeName + \"> : \\n\\t\\t\\t\" +\n\t\t\t\t\tlattice_ch.outerHTML + \"\\n\" +\n\t\t\t\t\t\"This is currently not supported, so spatial scales in your model \" +\n\t\t\t\t\t\"are just measured in pixels. This shouldn't change behaviour as long as \" +\n\t\t\t\t\t\"(spatial) parameters are defined in units of pixels. Please check this.\"\n\t\t\t\t)\n\t\t\t\tbreak\n\n\t\t\tdefault :\n\t\t\t\tthis.conversionWarnings.grid.push(\n\t\t\t\t\t\"I don't know what to do with tag <\" + lattice_ch.nodeName +\n\t\t\t\t\t\"> in a <Space> <Lattice>. Ignoring.\"\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n\n\tsetCellKindNames(){\n\n\t\t// this counter will increase every time a new CellType is handled.\n\t\tlet indexNonBackground = 1\n\t\tfor( let ck of this.getXMLTag( \"CellTypes\" ).children ){\n\t\t\tif( ck.nodeName !== \"CellType\" ){\n\t\t\t\tthis.conversionWarnings.cells.push(\n\t\t\t\t\t\"Not expecting tag <\" + ck.nodeName + \"> inside CellTypes. Ignoring.\"\n\t\t\t\t)\n\t\t\t}\n\t\t\tconst kind_class = ck.className\n\t\t\tconst kind_name = ck.getAttribute( \"name\" )\n\n\t\t\t// special case for kind of class 'medium', the background;\n\t\t\t// this is always index 0 and there can be only one kind of this\n\t\t\t// class.\n\t\t\tif( kind_class === \"medium\" ){\n\t\t\t\tif( this.cellKinds.name2index.hasOwnProperty( kind_class ) ){\n\t\t\t\t\tthrow( \"There cannot be two CellTypes of class 'medium'! Aborting.\" )\n\t\t\t\t} else {\n\t\t\t\t\t// it gets index 0.\n\t\t\t\t\tthis.cellKinds.name2index[ kind_class ] = 0\n\t\t\t\t\tthis.cellKinds.index2name[ \"0\" ] = kind_class\n\t\t\t\t}\n\t\t\t} else if ( kind_class === \"biological\" ){\n\t\t\t\tif( this.cellKinds.name2index.hasOwnProperty( kind_name ) ){\n\t\t\t\t\tthrow( \"There cannot be two CellTypes with name '\" + kind_name +\n\t\t\t\t\t\t\"' Aborting.\" )\n\t\t\t\t} else {\n\t\t\t\t\tthis.cellKinds.name2index[ kind_name ] = indexNonBackground\n\t\t\t\t\tthis.cellKinds.index2name[ indexNonBackground.toString() ] = kind_name\n\t\t\t\t}\n\t\t\t\tindexNonBackground++\n\n\t\t\t} else {\n\t\t\t\tthrow( \"Don't know what to do with a CellType of class \" + kind_class + \". Aborting.\" )\n\t\t\t}\n\n\t\t\t// Also extract any <Property> or <PropertyVector>\n\t\t\tif( !this.cellKinds.properties.hasOwnProperty( kind_name ) ){\n\t\t\t\tthis.cellKinds.properties[ kind_name ] = {}\n\t\t\t}\n\t\t\tconst props = ck.getElementsByTagName( \"Property\" )\n\t\t\tfor( let p of props ){\n\t\t\t\tconst propName = p.getAttribute( \"symbol\" )\n\t\t\t\tconst propVal = p.getAttribute( \"value\" )\n\t\t\t\tthis.cellKinds.properties[ kind_name ][ propName ] = propVal\n\t\t\t}\n\t\t\tconst propVecs = ck.getElementsByTagName( \"PropertyVector\" )\n\t\t\tfor( let pv of propVecs ){\n\t\t\t\tconst propName = pv.getAttribute( \"symbol\" )\n\t\t\t\tconst propVal = this.readCoordinateAttribute( pv, \"value\" )\n\t\t\t\tthis.cellKinds.properties[ kind_name ][ propName ] = propVal\n\t\t\t}\n\t\t}\n\n\t\t// counter: number of cell kinds including medium/background.\n\t\tthis.cellKinds.count = indexNonBackground\n\t}\n\n\tsetCPMGeneral(){\n\n\t\t// Random Seed\n\t\t// Note that the random 'seed' in Morpheus is specified in <Time>,\n\t\t// and as such is handled by this.setTimeInfo().\n\n\t\t// Temperature\n\t\tconst cpm = this.getXMLTag( \"CPM\" )\n\t\tfor( let cpm_ch of cpm.children ) {\n\t\t\tswitch( cpm_ch.nodeName ){\n\t\t\tcase \"Interaction\" :\n\t\t\t\tthis.setAdhesionMorpheus( cpm_ch )\n\t\t\t\tbreak\n\n\t\t\tcase \"ShapeSurface\" :\n\t\t\t\tif( cpm_ch.getAttribute(\"scaling\") !== \"none\" ){\n\t\t\t\t\tthis.conversionWarnings.grid.push(\n\t\t\t\t\t\t\"You are trying to use a ShapeSurface with scaling '\" +\n\t\t\t\t\t\tcpm_ch.getAttribute(\"scaling\") +\n\t\t\t\t\t\t\"'. This is currently not supported in Artistoo; \" +\n\t\t\t\t\t\t\"Reverting to the default scaling = 'none' instead. You may have \" +\n\t\t\t\t\t\t\"to adapt parameters that involve cell-cell interfaces, such as \" +\n\t\t\t\t\t\t\"those of the CPM's Adhesion and Perimeter constraints.\"\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tif( typeof this.readXMLTag( \"Distance\", cpm_ch ) !== \"undefined\" ){\n\t\t\t\t\tthis.conversionWarnings.grid.push(\n\t\t\t\t\t\t\"You are trying to use a ShapeSurface with neighborhood distance '\" +\n\t\t\t\t\t\tthis.readXMLTag( \"Distance\", cpm_ch ) +\n\t\t\t\t\t\t\"'. This is currently not supported in Artistoo; \" +\n\t\t\t\t\t\t\"Reverting to the default Moore neighborhood instead. You may have \" +\n\t\t\t\t\t\t\"to adapt parameters that involve cell-cell interfaces, such as \" +\n\t\t\t\t\t\t\"those of the CPM's Adhesion and Perimeter constraints.\"\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tif( this.readXMLTag( \"Order\", cpm_ch ) !== \"2\" ){\n\t\t\t\t\tthis.conversionWarnings.grid.push(\n\t\t\t\t\t\t\"You are trying to use a ShapeSurface with neighborhood order '\" +\n\t\t\t\t\t\tthis.readXMLTag( \"Order\", cpm_ch ) +\n\t\t\t\t\t\t\"'. This is currently not supported in Artistoo; \" +\n\t\t\t\t\t\t\"Reverting to the default Moore neighborhood instead. You may have \" +\n\t\t\t\t\t\t\"to adapt parameters that involve cell-cell interfaces, such as \" +\n\t\t\t\t\t\t\"those of the CPM's Adhesion and Perimeter constraints.\"\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tbreak\n\n\t\t\tcase \"MonteCarloSampler\" : {\n\t\t\t\tconst stepper = cpm_ch.getAttribute(\"stepper\")\n\t\t\t\tif (stepper !== \"edgelist\") {\n\t\t\t\t\tthis.conversionWarnings.kinetics.push(\n\t\t\t\t\t\t\"Stepper '\" + stepper + \"' not supported. Switching to 'edgelist'.\"\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tfor (let nn of cpm_ch.children) {\n\n\t\t\t\t\tswitch (nn.nodeName) {\n\t\t\t\t\tcase \"MetropolisKinetics\": {\n\n\t\t\t\t\t\tconst kineticAttr = nn.getAttributeNames()\n\t\t\t\t\t\tfor (let k of kineticAttr) {\n\t\t\t\t\t\t\tswitch (k) {\n\t\t\t\t\t\t\tcase \"temperature\":\n\t\t\t\t\t\t\t\tthis.kinetics.T = parseFloat(nn.getAttribute(\"temperature\"))\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\tdefault :\n\t\t\t\t\t\t\t\tthis.conversionWarnings.kinetics.push(\n\t\t\t\t\t\t\t\t\t\"Unknown attribute of < MetropolisKinetics >: \" +\n\t\t\t\t\t\t\t\t\tk + \". Ignoring.\"\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\n\t\t\t\t\tcase \"Neighborhood\":\n\n\t\t\t\t\t\tfor (let nnn of nn.children) {\n\n\t\t\t\t\t\t\tswitch (nnn.nodeName) {\n\t\t\t\t\t\t\tcase \"Order\": {\n\t\t\t\t\t\t\t\tconst order = nnn.innerHTML\n\t\t\t\t\t\t\t\tif ( order !== \"2\" ) {\n\t\t\t\t\t\t\t\t\tthis.conversionWarnings.grid.push(\n\t\t\t\t\t\t\t\t\t\t\"Ignoring < Neighborhood > <Order> in <MetropolisKinetics>: \"\n\t\t\t\t\t\t\t\t\t\t+ order + \". \" +\n\t\t\t\t\t\t\t\t\t\t\"Using default order 2 (Moore-neighborhood) instead.\")\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdefault :\n\t\t\t\t\t\t\t\tthis.conversionWarnings.grid.push(\n\t\t\t\t\t\t\t\t\t\"I don't understand what you mean with a neighborhood \" +\n\t\t\t\t\t\t\t\t\tnnn.nodeName + \". Using the default (Moore) neighborhood instead.\"\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase \"MCSDuration\" :\n\t\t\t\t\t\tthis.conversionWarnings.kinetics.push(\n\t\t\t\t\t\t\t\"Ignoring unsupported tag <MCSDuration>; this should not change \" +\n\t\t\t\t\t\t\t\"behaviour of the model, but it means all time should be defined in units of MCS. \" +\n\t\t\t\t\t\t\t\"Please check if this is the case.\"\n\t\t\t\t\t\t)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tdefault :\n\t\t\t\t\t\tthis.conversionWarnings.kinetics.push(\n\t\t\t\t\t\t\t\"Unknown child of < MonteCarloSampler >: <\" +\n\t\t\t\t\t\t\tnn.nodeName + \">.\")\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tdefault :\n\t\t\t\tthis.conversionWarnings.kinetics.push(\n\t\t\t\t\t\"I don't know what to do with tag <\" + cpm_ch.nodeName + \">. Ignoring it for now.\"\n\t\t\t\t)\n\n\t\t\t}\n\t\t}\n\t}\n\n\tsetConstraints(){\n\n\t\t// Adhesion in Morpheus is stored under 'CPM' and is set by\n\t\t// setCPMGeneral().\n\t\tconst ct = this.getXMLTag( \"CellTypes\" )\n\n\t\tfor (let cc of ct.children ){\n\n\t\t\tconst kindIndex = this.getKindIndex( cc.getAttribute(\"name\") )\n\n\t\t\t// add constraints:\n\t\t\tfor( let constraint of cc.children ){\n\n\t\t\t\tswitch( constraint.nodeName ){\n\n\t\t\t\tcase \"VolumeConstraint\" :\n\t\t\t\t\tthis.setVolumeConstraintForKind( constraint, kindIndex )\n\t\t\t\t\tbreak\n\n\t\t\t\tcase \"SurfaceConstraint\" :\n\t\t\t\t\tthis.setPerimeterConstraintForKind( constraint, kindIndex )\n\t\t\t\t\tbreak\n\n\t\t\t\tcase \"Protrusion\" :\n\t\t\t\t\tthis.setActivityConstraintForKind( constraint, kindIndex )\n\t\t\t\t\tbreak\n\n\t\t\t\tcase \"ConnectivityConstraint\" :\n\t\t\t\t\tthis.setConnectivityConstraintForKind( constraint, kindIndex )\n\t\t\t\t\tbreak\n\n\t\t\t\tcase \"FreezeMotion\":\n\t\t\t\t\tthis.setBarrierConstraintForKind( constraint, kindIndex )\n\t\t\t\t\tbreak\n\n\t\t\t\tcase \"PersistentMotion\" :\n\t\t\t\t\tthis.setPersistenceConstraintForKind( constraint, kindIndex )\n\t\t\t\t\tbreak\n\n\t\t\t\tcase \"DirectedMotion\" :\n\t\t\t\t\tthis.setPreferredDirectionConstraintForKind( constraint, kindIndex )\n\t\t\t\t\tbreak\n\n\t\t\t\tcase \"Chemotaxis\" :\n\t\t\t\t\tthis.setChemotaxisConstraintForKind( constraint, kindIndex )\n\t\t\t\t\tbreak\n\n\t\t\t\tcase \"StarConvex\":\n\t\t\t\t\tthis.unknownConstraintWarning( constraint.nodeName )\n\t\t\t\t\tbreak\n\n\t\t\t\tcase \"Haptotaxis\" :\n\t\t\t\t\tthis.unknownConstraintWarning( constraint.nodeName )\n\t\t\t\t\tbreak\n\n\t\t\t\tcase \"LengthConstraint\" :\n\t\t\t\t\tthis.unknownConstraintWarning( constraint.nodeName )\n\t\t\t\t\tbreak\n\n\t\t\t\tcase \"Property\" :\n\t\t\t\t\t// Properties are handled by this.setCellKindNames\n\t\t\t\t\tbreak\n\n\t\t\t\tcase \"PropertyVector\" :\n\t\t\t\t\t// PropertyVectors are handled by this.setCellKindNames\n\t\t\t\t\tbreak\n\n\t\t\t\tdefault:\n\t\t\t\t\tthis.conversionWarnings.cells.push(\n\t\t\t\t\t\t\"I don't know what to do with <CellType> property <\" +\n\t\t\t\t\t\tconstraint.nodeName  + \"> for cell \" +\n\t\t\t\t\t\tcc.getAttribute(\"name\") + \". Ignoring it. \" )\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\n\t}\n\n\tunknownConstraintWarning( constraintName ){\n\t\tthis.conversionWarnings.constraints.push(\n\t\t\t\"Constraint '\" + constraintName +\n\t\t\t\"' is currently not supported in Artistoo. +\" +\n\t\t\t\"I am ignoring it for now, but model behaviour may change. \" +\n\t\t\t\"Check out the online manual at https://artistoo.net/manual/custommodules.html \" +\n\t\t\t\"to implement your own, or choose a similar constraint from available options \" +\n\t\t\t\"https://artistoo.net/identifiers.html#hamiltonian\"\n\t\t)\n\t}\n\n\tsetGridConfiguration(){\n\t\tconst pops = this.getXMLTag( \"CellPopulations\" )\n\t\tfor( let p of pops.children ){\n\n\t\t\t// Check if this is a Population.\n\t\t\tif( p.nodeName !== \"Population\" ){\n\t\t\t\tthis.conversionWarnings.init.push(\n\t\t\t\t\t\"Unexpected tag <\" + p.nodeName + \"> inside <CellPopulations>. Ignoring.\"\n\t\t\t\t)\n\t\t\t}\n\n\t\t\t// Check which cellKind this population is of\n\t\t\tconst kindName = p.getAttribute( \"type\" )\n\n\n\t\t\t// Handle the initialization depending on the type of child tags\n\t\t\tfor( let p_ch of p.children ){\n\n\t\t\t\tswitch( p_ch.nodeName ){\n\n\t\t\t\tcase \"Cell\":\n\t\t\t\t\tthis.setCellPixelList( p_ch, kindName )\n\t\t\t\t\tbreak\n\n\t\t\t\tcase \"InitCircle\" :\n\t\t\t\t\tthis.setInitCircle( p_ch, kindName )\n\t\t\t\t\tbreak\n\n\t\t\t\tcase \"InitCellObjects\":\n\t\t\t\t\tthis.setInitObjects( p_ch, kindName )\n\t\t\t\t\tbreak\n\n\t\t\t\t\t/*\n\t\t\t\tcase \"InitDistribute\":\n\t\t\t\t\tthis.setInitDistribute( p_ch, kindName )\n\t\t\t\t\tbreak\n\n\t\t\t\tcase \"InitHexLattice\":\n\t\t\t\t\tthis.setHexLattice( p_ch, kindName )\n\t\t\t\t\tbreak\n\n\t\t\t\tcase \"InitRectangle\" :\n\t\t\t\t\tthis.setInitRectangle (p_ch, kindName )\n\t\t\t\t\tbreak*/\n\n\t\t\t\tdefault: //InitProperty, InitVectorProperty, InitVoronoi, TIFFReader, InitPoissonDisc\n\t\t\t\t\tthis.conversionWarnings.init.push(\n\t\t\t\t\t\t\"Ignoring unsupported tag <\" + p_ch.nodeName + \"> inside \" +\n\t\t\t\t\t\t\"a <Population>.\"\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* ==========\tMORPHEUS POPULATION READERS =========== */\n\n\tsetInitObjects( initXML, kindName ){\n\t\tconst mode = initXML.getAttribute( \"mode\" )\n\t\tthis.conversionWarnings.init.push( \"In InitCellObjects: attribute 'mode' currently not supported. \" +\n\t\t\t\"Ignoring mode = '\" + mode + \"' setting. \" +\n\t\t\t\"If conflicts arise during cell seeding, the pixel gets the value of the last cell\" +\n\t\t\t\" trying to occupy it. Adjust the script manually if this is not what you want.\")\n\n\t\tconst arr = initXML.getElementsByTagName( \"Arrangement\" )[0]\n\t\tconst disp = this.readCoordinateAttribute( arr, \"displacements\" )\n\t\tconst reps = this.readCoordinateAttribute( arr, \"repetitions\" )\n\n\t\tconst obj = arr.children[0]\n\n\t\tfor( let xi = 0; xi < reps[0]; xi++ ){\n\t\t\tconst dx = xi*disp[0]\n\t\t\tfor( let yi = 0; yi < reps[1]; yi++ ){\n\n\t\t\t\tconst dy = yi*disp[1]\n\t\t\t\tif( this.grid.ndim === 3 ){\n\t\t\t\t\tfor( let zi = 0; zi < reps[2]; zi++ ){\n\n\t\t\t\t\t\tconst dz = zi*disp[2]\n\t\t\t\t\t\tthis.addInitObject( [dx,dy,dz], obj, kindName )\n\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.addInitObject( [dx,dy], obj, kindName )\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\taddInitObject( disp, objXML, kindName ) {\n\n\t\tconst objType = objXML.nodeName\n\t\tconst ndim = disp.length\n\n\t\tlet pos\n\n\t\tswitch (objType) {\n\t\tcase \"Sphere\" : {\n\t\t\t// For a sphere, position is the center attribute; add the\n\t\t\t// displacement to that.\n\t\t\tpos = this.readCoordinateAttribute(objXML, \"center\")\n\t\t\tfor (let d = 0; d < ndim; d++) {\n\t\t\t\tpos[d] += disp[d]\n\t\t\t}\n\n\t\t\tthis.setup.init.push( {\n\t\t\t\tsetter : \"circleObject\",\n\t\t\t\tkind : this.getKindIndex( kindName ),\n\t\t\t\tkindName : kindName,\n\t\t\t\tradius : parseFloat(objXML.getAttribute(\"radius\")),\n\t\t\t\tcenter : pos\n\t\t\t} )\n\t\t\tbreak\n\t\t}\n\n\t\tcase \"Box\" : {\n\t\t\t// For a box, position is the origin attribute; add the\n\t\t\t// displacement to that.\n\t\t\tpos = this.readCoordinateAttribute(objXML, \"origin\")\n\t\t\tfor (let d = 0; d < ndim; d++) {\n\t\t\t\tpos[d] += disp[d]\n\t\t\t}\n\n\t\t\t// Read the box dimensions from the XML, this is the 'size' attribute.\n\t\t\tlet boxSize = this.readCoordinateAttribute(objXML, \"size\")\n\n\t\t\tthis.setup.init.push( {\n\t\t\t\tsetter : \"boxObject\",\n\t\t\t\tkind : this.getKindIndex( kindName ),\n\t\t\t\tkindName : kindName,\n\t\t\t\tbottomLeft: pos,\n\t\t\t\tboxSize: boxSize\n\t\t\t} )\n\t\t\tbreak\n\t\t}\n\n\t\tdefault :\n\t\t\tthis.conversionWarnings.init.push(\n\t\t\t\t\"No method to seed an object of type \" + objType + \". Ignoring.\"\n\t\t\t)\n\t\t}\n\t}\n\n\tsetInitCircle( initXML, kindName ){\n\n\t\tlet nCells\n\n\t\t// Get information from attributes\n\t\tfor( let attr of initXML.getAttributeNames() ){\n\t\t\tswitch( attr ){\n\t\t\tcase \"mode\" :\n\t\t\t\tif( initXML.getAttribute( \"mode\" ) !== \"random\" ){\n\t\t\t\t\tthis.conversionWarnings.init.push(\n\t\t\t\t\t\t\"In InitCircle: 'mode' \" + initXML.getAttribute( \"mode\" )  +\n\t\t\t\t\t\t\" currently not supported. \" +\n\t\t\t\t\t\t\"Seeding cells randomly in the circle; to change this, define your own\" +\n\t\t\t\t\t\t\"initialization function as e.g. in \" +\n\t\t\t\t\t\t\"https://artistoo.net/examples/DirectedMotionLinear.html.\" )\n\t\t\t\t}\n\t\t\t\tbreak\n\n\t\t\tcase \"number-of-cells\" :\n\t\t\t\t// get number of cells to seed\n\t\t\t\tnCells = initXML.getAttribute( \"number-of-cells\" )\n\n\t\t\t\t// in morpheus, this can also be a function -- but this is not supported. Check and warn.\n\t\t\t\tif( !isFinite( nCells ) ){\n\t\t\t\t\tthis.conversionWarnings.init.push(\n\t\t\t\t\t\t\"In InitCircle: it appears as if the number-of-cells attribute is \" +\n\t\t\t\t\t\t\"not a number but a function. Ignoring it for now. \" +\n\t\t\t\t\t\t\"Please change to a number or initialize the grid manually.\")\n\t\t\t\t}\n\t\t\t\tbreak\n\n\t\t\tdefault :\n\t\t\t\tthis.conversionWarnings.init.push(\n\t\t\t\t\t\"Attribute \" + attr + \" in <InitCircle> currently not \" +\n\t\t\t\t\t\"supported; ignoring it for now.\" )\n\n\t\t\t}\n\t\t}\n\n\t\t// Get the dimensions\n\t\tfor( let ch of initXML.children ){\n\t\t\tswitch( ch.nodeName ){\n\t\t\tcase \"Dimensions\" :\n\t\t\t\tthis.addInitCircle( ch, kindName, nCells )\n\t\t\t\tbreak\n\n\t\t\tdefault :\n\t\t\t\tthis.conversionWarnings.init.push(\n\t\t\t\t\t\"In <InitCircle> I don't know what to do with \" +\n\t\t\t\t\t\"tag <\" + ch.nodeName + \">. Ignoring it.\" )\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\taddInitCircle( initXML, kindName, nCells ){\n\t\tlet center, radius\n\n\t\tfor( let attr of initXML.getAttributeNames() ){\n\n\t\t\tswitch( attr ){\n\t\t\tcase \"center\" : {\n\n\t\t\t\tcenter = this.readCoordinateAttribute( initXML, \"center\" )\n\n\t\t\t\t// check if it's an array of numbers and correct dimensions so that\n\t\t\t\t// position has 2 coordinates for 2D grids.\n\t\t\t\tfor (let d = 0; d < this.grid.ndim; d++) {\n\t\t\t\t\tif (!isFinite(center[d])) {\n\t\t\t\t\t\tthis.conversionWarnings.init.push(\n\t\t\t\t\t\t\t\"In <InitCircle> <Dimensions>, 'center' does not appear to be a numeric vector:\" +\n\t\t\t\t\t\t\t\"center = \" + center + \". Ignoring it for now.\"\n\t\t\t\t\t\t)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tcase \"radius\" :\n\t\t\t\tradius = parseInt( initXML.getAttribute( \"radius\" ) )\n\t\t\t\tif( !isFinite(radius) ){\n\t\t\t\t\tthis.conversionWarnings.init.push(\n\t\t\t\t\t\t\"In <InitCircle> <Dimensions>, 'radius' does not appear to be a number:\" +\n\t\t\t\t\t\t\"radius = \" + radius + \". Ignoring it for now.\" )\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tbreak\n\n\t\t\tdefault :\n\t\t\t\tthis.conversionWarnings.init.push(\n\t\t\t\t\t\"In <InitCircle> <Dimensions>, I don't know what to do with attribute \" +\n\t\t\t\t\tattr + \". Ignoring.\" )\n\n\t\t\t}\n\t\t}\n\n\t\tif( typeof center === \"undefined\" || typeof radius === \"undefined\" ){\n\t\t\tthis.conversionWarnings.init.push(\n\t\t\t\t\"In <InitCircle> <Dimensions>, I cannot find a 'center' or a \" +\n\t\t\t\t\"'radius'. Ignoring.\" )\n\t\t\treturn\n\t\t}\n\n\n\t\t// If we get here, we have both center and radius now.\n\t\tthis.setup.init.push( {\n\t\t\tsetter : \"cellCircle\",\n\t\t\tkind : this.getKindIndex( kindName ),\n\t\t\tkindName : kindName,\n\t\t\tradius : radius,\n\t\t\tcenter : center,\n\t\t\tnCells : nCells\n\t\t} )\n\n\t}\n\n\tsetCellPixelList( cellXML, kindName ){\n\n\t\tconst kindIndex = this.getKindIndex( kindName )\n\t\tconst cid = cellXML.getAttribute( \"id\" )\n\t\tlet pixels = []\n\t\tfor( let n of cellXML.children ){\n\t\t\tif( n.nodeName !== \"Nodes\" ){\n\t\t\t\tthis.conversionWarnings.init.push(\n\t\t\t\t\t\"Ignoring unexpected tag <\" + n.nodeName + \"> inside a \" +\n\t\t\t\t\t\"<Population><Cell>.\"\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tpixels.push( this.toCoordinate( n.innerHTML ) )\n\t\t\t}\n\t\t}\n\n\t\tthis.setup.init.push( {\n\t\t\tsetter : \"pixelSet\",\n\t\t\tkind : kindIndex,\n\t\t\tkindName : kindName,\n\t\t\tcid : cid,\n\t\t\tpixels : pixels\n\t\t} )\n\n\t}\n\n\n\t/* ==========\tMORPHEUS CONSTRAINT READERS =========== */\n\n\tparameterFromXML( constraintXML, paramName, kindIndex, pType = \"int\" ){\n\n\t\tlet par = constraintXML.getAttribute( paramName )\n\t\tconst kindName = this.getKindName( kindIndex )\n\n\t\tlet parser\n\t\tif( pType === \"int\" ){\n\t\t\tparser = parseInt\n\t\t} else if (pType === \"float\" ){\n\t\t\tparser = parseFloat\n\t\t} else {\n\t\t\tthrow ( \"Unknown type of parameter : \" + pType )\n\t\t}\n\n\t\tif( !isNaN( parser(  par ) ) ){\n\t\t\tpar = parser( par )\n\t\t} else {\n\t\t\t// try if it is the name of one of the defined symbols.\n\t\t\tif( this.cellKinds.properties[ kindName ].hasOwnProperty( par ) ){\n\t\t\t\tpar = parser( this.cellKinds.properties[ this.getKindName( kindIndex ) ][ par ] )\n\t\t\t}\n\t\t}\n\n\t\t// Check if now okay, otherwise set to 0 and add a warning.\n\t\tif( isNaN( parser( par ) ) ){\n\t\t\tthis.conversionWarnings.constraints.push(\n\t\t\t\t\"Failed to interpret parameter \" + paramName + \" in \" +\n\t\t\t\tconstraintXML.nodeName + \" for cellKind \" + kindName +\n\t\t\t\t\". For now, this is set to 0; please correct manually.\"\n\t\t\t)\n\t\t\treturn 0\n\t\t}\n\t\treturn parser( par )\n\n\t}\n\n\tsetAdhesionMorpheus( interactionXML ){\n\n\t\tlet defValue = NaN, negative = false\n\t\tif( interactionXML.hasAttribute(\"default\" ) ){\n\t\t\tdefValue = parseFloat( interactionXML.getAttribute( \"default\" ) )\n\t\t}\n\t\tif( interactionXML.hasAttribute(\"negative\" ) ){\n\t\t\tnegative = ( interactionXML.getAttribute( \"negative\" ) === \"true\" )\n\t\t}\n\n\t\tlet J = this.initCellKindMatrix( defValue )\n\n\t\tfor( let contact of interactionXML.children ){\n\t\t\t// Check if child is indeed a contact energy\n\t\t\tif( contact.nodeName !== \"Contact\" ){\n\t\t\t\tthis.conversionWarnings.constraints.push( \"I don't know what to do with a tag <\" +\n\t\t\t\t\tcontact.nodeName + \"> inside the Adhesion <Interactions>. Ignoring. \" )\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// Get the types and convert to the corresponding number using the 'cellTypes' object used above\n\t\t\tconst type1 = this.getKindIndex( contact.getAttribute( \"type1\" ) )\n\t\t\tconst type2 = this.getKindIndex( contact.getAttribute( \"type2\" ) )\n\t\t\tconst energy = contact.getAttribute( \"value\" )\n\t\t\tlet energyNum = parseFloat( energy )\n\t\t\tif( isNaN(energyNum) ){\n\t\t\t\tthis.conversionWarnings.constraints.push( \"Contact energy value '\" +\n\t\t\t\t\tenergy.toString() + \"' inside Adhesion < Interactions > \" +\n\t\t\t\t\t\"seems not to be a number and will be ignored.\")\n\t\t\t}\n\n\t\t\t// set the value symmetrically\n\t\t\tif( negative ){ energyNum = -energyNum }\n\t\t\tJ[type1][type2] = energyNum\n\t\t\tJ[type2][type1] = energyNum\n\t\t}\n\n\t\t// Add the adhesion constraint to the model description.\n\t\tthis.addConstraint( \"Adhesion\", { J : J } )\n\n\n\t}\n\n\tsetVolumeConstraintForKind( constraintXML, kindIndex ){\n\n\t\tif( !this.hasConstraint( \"VolumeConstraint\" ) ){\n\t\t\tthis.addConstraint( \"VolumeConstraint\", {\n\t\t\t\tV : this.initCellKindVector( 0 ),\n\t\t\t\tLAMBDA_V : this.initCellKindVector( 0 )\n\t\t\t})\n\t\t}\n\t\tconst vol = this.parameterFromXML( constraintXML,\n\t\t\t\"target\", kindIndex,  \"int\" )\n\t\tconst lambda = this.parameterFromXML( constraintXML,\n\t\t\t\"strength\", kindIndex,  \"float\" )\n\n\t\tthis.getConstraintParameter( \"VolumeConstraint\",\n\t\t\t\"V\" )[kindIndex] = vol\n\t\tthis.getConstraintParameter( \"VolumeConstraint\",\n\t\t\t\"LAMBDA_V\" )[kindIndex] = lambda\n\n\t}\n\n\tsetPerimeterConstraintForKind( constraintXML, kindIndex ){\n\n\t\tif( !this.hasConstraint( \"PerimeterConstraint\" ) ){\n\t\t\tthis.addConstraint( \"PerimeterConstraint\", {\n\t\t\t\tP : this.initCellKindVector( 0 ),\n\t\t\t\tLAMBDA_P : this.initCellKindVector( 0 ),\n\t\t\t\tmode : \"surface\"\n\t\t\t})\n\t\t}\n\n\t\t// Get info from XML object\n\t\tlet perimeter, lambda, mode\n\t\tfor( let att of constraintXML.getAttributeNames() ) {\n\t\t\tswitch (att) {\n\t\t\tcase \"mode\":\n\t\t\t\tmode = constraintXML.getAttribute( \"mode\" )\n\t\t\t\tbreak\n\n\t\t\tcase \"target\" :\n\t\t\t\tperimeter = this.parameterFromXML( constraintXML,\n\t\t\t\t\t\"target\", kindIndex,  \"float\" )\n\t\t\t\tbreak\n\n\t\t\tcase \"strength\":\n\t\t\t\tlambda = this.parameterFromXML( constraintXML,\n\t\t\t\t\t\"strength\", kindIndex,  \"float\" )\n\t\t\t\tbreak\n\n\t\t\tdefault :\n\t\t\t\tthis.conversionWarnings.constraints.push(\n\t\t\t\t\t\"Ignoring unsupported attribute '\" + att +\n\t\t\t\t\t\"' of the < SurfaceConstraint >\")\n\n\t\t\t}\n\t\t}\n\n\t\t// Set (converted) values.\n\t\tthis.getConstraintParameter( \"PerimeterConstraint\",\n\t\t\t\"P\" )[kindIndex] = perimeter\n\t\tthis.getConstraintParameter( \"PerimeterConstraint\",\n\t\t\t\"LAMBDA_P\" )[kindIndex] = lambda\n\t\tthis.getConstraint( \"PerimeterConstraint\" ).mode = mode\n\n\t}\n\n\tsetActivityConstraintForKind( constraintXML, kindIndex ){\n\n\t\tif( !this.hasConstraint( \"ActivityConstraint\" ) ){\n\t\t\tthis.addConstraint( \"ActivityConstraint\", {\n\t\t\t\tMAX_ACT : this.initCellKindVector( 0 ),\n\t\t\t\tLAMBDA_ACT : this.initCellKindVector( 0 ),\n\t\t\t\tACT_MEAN : \"geometric\"\n\t\t\t})\n\t\t}\n\n\t\tconst lambda = this.parameterFromXML( constraintXML,\n\t\t\t\"strength\", kindIndex,  \"float\" )\n\t\tconst max = this.parameterFromXML( constraintXML,\n\t\t\t\"maximum\", kindIndex,  \"float\" )\n\n\t\tthis.getConstraintParameter( \"ActivityConstraint\",\n\t\t\t\"MAX_ACT\" )[kindIndex] = max\n\t\tthis.getConstraintParameter( \"ActivityConstraint\",\n\t\t\t\"LAMBDA_ACT\" )[kindIndex] = lambda\n\t}\n\n\tsetConnectivityConstraintForKind( constraintXML, kindIndex ){\n\t\tif( !this.hasConstraint( \"LocalConnectivityConstraint\" ) ){\n\t\t\tthis.addConstraint( \"LocalConnectivityConstraint\", {\n\t\t\t\tCONNECTED : this.initCellKindVector( false ),\n\t\t\t})\n\t\t}\n\n\t\tthis.getConstraintParameter( \"LocalConnectivityConstraint\",\n\t\t\t\"CONNECTED\" )[kindIndex] = true\n\n\t}\n\n\tsetBarrierConstraintForKind( constraintXML, kindIndex ){\n\n\t\tif( !this.hasConstraint( \"BarrierConstraint\" ) ){\n\t\t\tthis.addConstraint( \"BarrierConstraint\", {\n\t\t\t\tIS_BARRIER : this.initCellKindVector( false ),\n\t\t\t})\n\t\t}\n\n\t\tthis.getConstraintParameter( \"BarrierConstraint\",\n\t\t\t\"IS_BARRIER\" )[kindIndex] = true\n\n\t\t// The Morpheus <FreezeMotion> has an optional attribute/child 'Condition',\n\t\t// which Artistoo doesn't have. It defaults to true, but for anything different\n\t\t// the behaviour will be different; issue a warning.\n\t\tfor( let ch of constraintXML.children ){\n\t\t\tif( ch.nodeName === \"Condition\" ){\n\t\t\t\tif( this.readXMLTag( \"Condition\", constraintXML ) !== \"1\" ){\n\t\t\t\t\tthis.conversionWarnings.constraints.push(\n\t\t\t\t\t\t\"Converting a <FreezeMotion> constraint to an Artistoo 'BarrierConstraint', but \" +\n\t\t\t\t\t\t\"don't know how to handle a <Condition> other than '1'. Ignoring Condition.\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.conversionWarnings.constraints.push(\n\t\t\t\t\t\"I don't know what to do with <\" + ch.nodeName +\n\t\t\t\t\t\"> in a <FreezeMotion> constraint. Ignoring.\")\n\t\t\t}\n\t\t}\n\t\tfor( let ch of constraintXML.getAttributeNames() ){\n\t\t\tif( ch === \"condition\" ){\n\t\t\t\tif( constraintXML.getAttribute( \"condition\" ) !== \"1\" ){\n\t\t\t\t\tthis.conversionWarnings.constraints.push(\n\t\t\t\t\t\t\"Converting a <FreezeMotion> constraint to an Artistoo 'BarrierConstraint', but \" +\n\t\t\t\t\t\t\"don't know how to handle a <Condition> other than '1'. Ignoring Condition.\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.conversionWarnings.constraints.push(\n\t\t\t\t\t\"I don't know what to do with property '\" + ch +\n\t\t\t\t\t\"' in a <FreezeMotion> constraint. Ignoring.\")\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\tsetPersistenceConstraintForKind( constraintXML, kindIndex ){\n\t\tif( !this.hasConstraint( \"PersistenceConstraint\" ) ){\n\t\t\tthis.addConstraint( \"PersistenceConstraint\", {\n\t\t\t\tDELTA_T : this.initCellKindVector( 0 ),\n\t\t\t\tLAMBDA_DIR : this.initCellKindVector( 0 ),\n\t\t\t\t// Morpheus doesn't have this param and just uses the default 1.\n\t\t\t\tPERSIST : this.initCellKindVector( 1 ),\n\t\t\t\tPROTRUDE : this.initCellKindVector( true ),\n\t\t\t\tRETRACT : this.initCellKindVector( false )\n\t\t\t})\n\t\t}\n\n\t\tconst dt = this.parameterFromXML( constraintXML,\n\t\t\t\"decay-time\", kindIndex,  \"int\" )\n\t\tconst lambda = this.parameterFromXML( constraintXML,\n\t\t\t\"strength\", kindIndex, \"float\" )\n\n\n\t\t// Two other params specified in morpheus\n\t\tlet protrude = constraintXML.getAttribute( \"protrusion\" )\n\t\tif( typeof protrude === undefined ){\n\t\t\tprotrude = true\n\t\t} else {\n\t\t\tprotrude = ( protrude === \"true\" )\n\t\t}\n\t\tlet retract = constraintXML.getAttribute( \"retraction\" )\n\t\tif( typeof retract === undefined ){\n\t\t\tretract = false\n\t\t} else {\n\t\t\tretract = ( retract === \"true\" )\n\t\t}\n\n\t\tthis.getConstraintParameter( \"PersistenceConstraint\",\n\t\t\t\"DELTA_T\" )[kindIndex] = dt\n\t\tthis.getConstraintParameter( \"PersistenceConstraint\",\n\t\t\t\"LAMBDA_DIR\" )[kindIndex] = lambda\n\t\tthis.getConstraintParameter( \"PersistenceConstraint\",\n\t\t\t\"PROTRUDE\" )[kindIndex] = protrude\n\t\tthis.getConstraintParameter( \"PersistenceConstraint\",\n\t\t\t\"RETRACT\" )[kindIndex] = retract\n\t}\n\n\tsetPreferredDirectionConstraintForKind( constraintXML, kindIndex ){\n\t\tif( !this.hasConstraint( \"PreferredDirectionConstraint\" ) ){\n\t\t\tthis.addConstraint( \"PreferredDirectionConstraint\", {\n\t\t\t\tDIR : this.initCellKindVector( this.initDimensionVector(0) ),\n\t\t\t\tLAMBDA_DIR : this.initCellKindVector( 0 ),\n\t\t\t\tPROTRUDE : this.initCellKindVector( true ),\n\t\t\t\tRETRACT : this.initCellKindVector( false )\n\t\t\t})\n\t\t}\n\n\t\tconst kindName = this.getKindName( kindIndex )\n\t\tconst dirSymbol = constraintXML.getAttribute( \"direction\" )\n\t\tlet dir = undefined\n\t\tif( this.cellKinds.properties[kindName].hasOwnProperty( dirSymbol ) ){\n\t\t\t// read value of this parameter\n\t\t\tdir = this.cellKinds.properties[kindName][dirSymbol]\n\t\t}\n\t\tlet lambdaDir = this.parameterFromXML( constraintXML,\n\t\t\t\"strength\", kindIndex,  \"float\" )\n\n\t\t// Two other params specified in morpheus\n\t\tlet retract = constraintXML.getAttribute( \"retraction\" )\n\t\tif( typeof retract === undefined ){\n\t\t\tretract = false\n\t\t} else {\n\t\t\tretract = ( retract === \"true\" )\n\t\t}\n\t\tlet protrude = constraintXML.getAttribute( \"protrusion\" )\n\t\tif( typeof protrude === undefined ){\n\t\t\tprotrude = true\n\t\t} else {\n\t\t\tprotrude = ( protrude === \"true\" )\n\t\t}\n\n\t\tthis.getConstraintParameter( \"PreferredDirectionConstraint\",\n\t\t\t\"DIR\" )[kindIndex] = dir\n\t\tthis.getConstraintParameter( \"PreferredDirectionConstraint\",\n\t\t\t\"LAMBDA_DIR\" )[kindIndex] = lambdaDir\n\t\tthis.getConstraintParameter( \"PreferredDirectionConstraint\",\n\t\t\t\"PROTRUDE\" )[kindIndex] = protrude\n\t\tthis.getConstraintParameter( \"PreferredDirectionConstraint\",\n\t\t\t\"RETRACT\" )[kindIndex] = retract\n\t}\n}\n\n\nexport default MorpheusImport",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/converter/MorpheusImport.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 218,
    "kind": "class",
    "name": "MorpheusImport",
    "memberof": "src/converter/MorpheusImport.js",
    "static": true,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/converter/MorpheusImport.js",
    "importStyle": "MorpheusImport",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/converter/ModelDescription.js~ModelDescription"
    ]
  },
  {
    "__docId__": 219,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true
  },
  {
    "__docId__": 220,
    "kind": "member",
    "name": "xml",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#xml",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 221,
    "kind": "member",
    "name": "from",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#from",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 222,
    "kind": "method",
    "name": "readXMLTag",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#readXMLTag",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "params": [
      {
        "name": "tag",
        "types": [
          "*"
        ]
      },
      {
        "name": "xml",
        "types": [
          "*"
        ]
      },
      {
        "name": "index",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 223,
    "kind": "method",
    "name": "getXMLTag",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#getXMLTag",
    "access": "public",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "params": [
      {
        "name": "tag",
        "types": [
          "*"
        ]
      },
      {
        "name": "xml",
        "types": [
          "*"
        ]
      },
      {
        "name": "index",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 224,
    "kind": "method",
    "name": "readVectorAttribute",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#readVectorAttribute",
    "access": "public",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "params": [
      {
        "name": "xml",
        "types": [
          "*"
        ]
      },
      {
        "name": "attrName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 225,
    "kind": "method",
    "name": "readCoordinateAttribute",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#readCoordinateAttribute",
    "access": "public",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "params": [
      {
        "name": "xml",
        "types": [
          "*"
        ]
      },
      {
        "name": "attrName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 226,
    "kind": "method",
    "name": "toCoordinate",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#toCoordinate",
    "access": "public",
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "params": [
      {
        "name": "string",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 227,
    "kind": "method",
    "name": "setModelInfo",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#setModelInfo",
    "access": "public",
    "description": null,
    "lineNumber": 69,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 228,
    "kind": "method",
    "name": "setTimeInfo",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#setTimeInfo",
    "access": "public",
    "description": null,
    "lineNumber": 93,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 229,
    "kind": "method",
    "name": "setGridInfo",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#setGridInfo",
    "access": "public",
    "description": null,
    "lineNumber": 124,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 230,
    "kind": "method",
    "name": "readMorpheusLattice",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#readMorpheusLattice",
    "access": "public",
    "description": null,
    "lineNumber": 143,
    "undocument": true,
    "params": [
      {
        "name": "lattice",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 231,
    "kind": "method",
    "name": "setCellKindNames",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#setCellKindNames",
    "access": "public",
    "description": null,
    "lineNumber": 235,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 232,
    "kind": "method",
    "name": "setCPMGeneral",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#setCPMGeneral",
    "access": "public",
    "description": null,
    "lineNumber": 295,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 233,
    "kind": "method",
    "name": "setConstraints",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#setConstraints",
    "access": "public",
    "description": null,
    "lineNumber": 423,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 234,
    "kind": "method",
    "name": "unknownConstraintWarning",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#unknownConstraintWarning",
    "access": "public",
    "description": null,
    "lineNumber": 504,
    "undocument": true,
    "params": [
      {
        "name": "constraintName",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 235,
    "kind": "method",
    "name": "setGridConfiguration",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#setGridConfiguration",
    "access": "public",
    "description": null,
    "lineNumber": 515,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 236,
    "kind": "method",
    "name": "setInitObjects",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#setInitObjects",
    "access": "public",
    "description": null,
    "lineNumber": 572,
    "undocument": true,
    "params": [
      {
        "name": "initXML",
        "types": [
          "*"
        ]
      },
      {
        "name": "kindName",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 237,
    "kind": "method",
    "name": "addInitObject",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#addInitObject",
    "access": "public",
    "description": null,
    "lineNumber": 605,
    "undocument": true,
    "params": [
      {
        "name": "disp",
        "types": [
          "*"
        ]
      },
      {
        "name": "objXML",
        "types": [
          "*"
        ]
      },
      {
        "name": "kindName",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 238,
    "kind": "method",
    "name": "setInitCircle",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#setInitCircle",
    "access": "public",
    "description": null,
    "lineNumber": 659,
    "undocument": true,
    "params": [
      {
        "name": "initXML",
        "types": [
          "*"
        ]
      },
      {
        "name": "kindName",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 239,
    "kind": "method",
    "name": "addInitCircle",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#addInitCircle",
    "access": "public",
    "description": null,
    "lineNumber": 715,
    "undocument": true,
    "params": [
      {
        "name": "initXML",
        "types": [
          "*"
        ]
      },
      {
        "name": "kindName",
        "types": [
          "*"
        ]
      },
      {
        "name": "nCells",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 240,
    "kind": "method",
    "name": "setCellPixelList",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#setCellPixelList",
    "access": "public",
    "description": null,
    "lineNumber": 777,
    "undocument": true,
    "params": [
      {
        "name": "cellXML",
        "types": [
          "*"
        ]
      },
      {
        "name": "kindName",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 241,
    "kind": "method",
    "name": "parameterFromXML",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#parameterFromXML",
    "access": "public",
    "description": null,
    "lineNumber": 806,
    "undocument": true,
    "params": [
      {
        "name": "constraintXML",
        "types": [
          "*"
        ]
      },
      {
        "name": "paramName",
        "types": [
          "*"
        ]
      },
      {
        "name": "kindIndex",
        "types": [
          "*"
        ]
      },
      {
        "name": "pType",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "int",
        "defaultValue": "int"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 242,
    "kind": "method",
    "name": "setAdhesionMorpheus",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#setAdhesionMorpheus",
    "access": "public",
    "description": null,
    "lineNumber": 842,
    "undocument": true,
    "params": [
      {
        "name": "interactionXML",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 243,
    "kind": "method",
    "name": "setVolumeConstraintForKind",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#setVolumeConstraintForKind",
    "access": "public",
    "description": null,
    "lineNumber": 885,
    "undocument": true,
    "params": [
      {
        "name": "constraintXML",
        "types": [
          "*"
        ]
      },
      {
        "name": "kindIndex",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 244,
    "kind": "method",
    "name": "setPerimeterConstraintForKind",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#setPerimeterConstraintForKind",
    "access": "public",
    "description": null,
    "lineNumber": 905,
    "undocument": true,
    "params": [
      {
        "name": "constraintXML",
        "types": [
          "*"
        ]
      },
      {
        "name": "kindIndex",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 245,
    "kind": "method",
    "name": "setActivityConstraintForKind",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#setActivityConstraintForKind",
    "access": "public",
    "description": null,
    "lineNumber": 950,
    "undocument": true,
    "params": [
      {
        "name": "constraintXML",
        "types": [
          "*"
        ]
      },
      {
        "name": "kindIndex",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 246,
    "kind": "method",
    "name": "setConnectivityConstraintForKind",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#setConnectivityConstraintForKind",
    "access": "public",
    "description": null,
    "lineNumber": 971,
    "undocument": true,
    "params": [
      {
        "name": "constraintXML",
        "types": [
          "*"
        ]
      },
      {
        "name": "kindIndex",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 247,
    "kind": "method",
    "name": "setBarrierConstraintForKind",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#setBarrierConstraintForKind",
    "access": "public",
    "description": null,
    "lineNumber": 983,
    "undocument": true,
    "params": [
      {
        "name": "constraintXML",
        "types": [
          "*"
        ]
      },
      {
        "name": "kindIndex",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 248,
    "kind": "method",
    "name": "setPersistenceConstraintForKind",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#setPersistenceConstraintForKind",
    "access": "public",
    "description": null,
    "lineNumber": 1027,
    "undocument": true,
    "params": [
      {
        "name": "constraintXML",
        "types": [
          "*"
        ]
      },
      {
        "name": "kindIndex",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 249,
    "kind": "method",
    "name": "setPreferredDirectionConstraintForKind",
    "memberof": "src/converter/MorpheusImport.js~MorpheusImport",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusImport.js~MorpheusImport#setPreferredDirectionConstraintForKind",
    "access": "public",
    "description": null,
    "lineNumber": 1069,
    "undocument": true,
    "params": [
      {
        "name": "constraintXML",
        "types": [
          "*"
        ]
      },
      {
        "name": "kindIndex",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 250,
    "kind": "file",
    "name": "src/converter/MorpheusWriter.js",
    "content": "import Writer from \"./Writer.js\"\n\nclass MorpheusWriter extends Writer {\n\n\tconstructor( model, config ){\n\t\tsuper( model, config )\n\n\t\t// property set by initXML.\n\t\tthis.xml = undefined\n\t\tthis.initXML()\n\n\t\tthis.cellTypeTagIndex = {}\n\n\t\tthis.fieldsToDraw = []\n\n\t\tthis.logString = \"Hi there! Converting \" + this.model.from + \" to Morpheus XML...\\n\\n\"\n\n\t}\n\n\twrite(){\n\t\tif( typeof this.target !== undefined ){\n\t\t\tthis.target.innerHTML = this.writeXML()\n\t\t} else {\n\t\t\t//eslint-disable-next-line no-console\n\t\t\tconsole.log( this.writeXML() )\n\t\t}\n\t\tthis.writeLog()\n\t}\n\n\twriteXML(){\n\t\tthis.writeDescription()\n\t\tthis.writeGlobal()\n\t\tthis.writeSpace()\n\t\tthis.writeTime()\n\t\tthis.writeCellTypes()\n\t\tthis.writeCPM()\n\t\tthis.writeConstraints()\n\t\tthis.writeCellPopulations()\n\t\tthis.writeAnalysis()\n\t\treturn this.formatXml( new XMLSerializer().serializeToString(this.xml) )\n\t}\n\n\tformatXml(xml, tab) { // tab = optional indent value, default is tab (\\t)\n\t\tlet formatted = \"\", indent= \"\"\n\t\ttab = tab || \"\\t\"\n\t\txml.split(/>\\s*</).forEach(function(node) {\n\t\t\tif (node.match( /^\\/\\w/ )) indent = indent.substring(tab.length) // decrease indent by one 'tab'\n\t\t\tformatted += indent + \"<\" + node + \">\\r\\n\"\n\t\t\tif (node.match( /^<?\\w[^>]*[^/]$/ )) indent += tab             // increase indent\n\t\t})\n\t\treturn formatted.substring(1, formatted.length-3)\n\t}\n\n\tinitXML(){\n\t\tlet xmlString = \"<MorpheusModel></MorpheusModel>\"\n\t\tlet parser = new DOMParser()\n\t\tthis.xml = parser.parseFromString( xmlString, \"text/xml\" )\n\t\tthis.setAttributesOf( \"MorpheusModel\", {version: \"4\" } )\n\t}\n\n\t/* ==========\tMETHODS TO MANIPULATE XML STRUCTURE =========== */\n\n\tsetAttributesOf( node, attr, index = 0 ){\n\t\tfor( let a of Object.keys( attr ) ){\n\t\t\tthis.xml.getElementsByTagName( node )[index].setAttribute( a, attr[a] )\n\t\t}\n\t}\n\tattachNode( parentName, nodeName, value = undefined, attr= {}, index = 0 ){\n\t\tlet node = this.makeNode( nodeName, value, attr )\n\t\tthis.addNodeTo( node, parentName, index )\n\t}\n\tmakeNode( nodeName, value = undefined, attr= {} ){\n\t\tlet node = this.xml.createElement( nodeName )\n\t\tif( typeof value !== \"undefined\" ){\n\t\t\tnode.innerHTML = value\n\t\t}\n\t\tfor( let a of Object.keys( attr ) ){\n\t\t\tnode.setAttribute( a, attr[a] )\n\t\t}\n\t\treturn node\n\n\t}\n\taddNodeTo( node, parentName, index = 0 ){\n\t\tlet parent = this.xml.getElementsByTagName( parentName )[index]\n\t\tparent.appendChild(node)\n\t}\n\tsetNode( nodeName, value, index = 0 ){\n\t\tthis.xml.getElementsByTagName( nodeName )[index].innerHTML = value\n\t}\n\n\t/* ==========\tOTHER HELPER METHODS =========== */\n\n\ttoMorpheusCoordinate( coordinate, fillValue = 0 ){\n\t\twhile( coordinate.length < 3 ){\n\t\t\tcoordinate.push( fillValue )\n\t\t}\n\t\treturn coordinate.toString()\n\t}\n\n\t/* ==========\tWRITING THE MAIN XML MODEL COMPONENTS OF MORPHEUS =========== */\n\n\twriteDescription(){\n\t\tthis.attachNode( \"MorpheusModel\", \"Description\" )\n\t\tthis.attachNode( \"Description\", \"Title\",\n\t\t\tthis.model.modelInfo.title )\n\t\tthis.attachNode( \"Description\", \"Details\",\n\t\t\tthis.model.modelInfo.desc )\n\t}\n\n\twriteGlobal(){\n\t\tthis.attachNode( \"MorpheusModel\", \"Global\" )\n\t}\n\n\twriteSpace(){\n\t\t// Set <Space> tag and children\n\t\tthis.attachNode( \"MorpheusModel\", \"Space\" )\n\t\tthis.attachNode( \"Space\", \"Lattice\", undefined,\n\t\t\t{\"class\":this.model.grid.geometry } )\n\t\tthis.attachNode( \"Space\", \"SpaceSymbol\", undefined,\n\t\t\t{symbol: \"space\" } )\n\n\t\t// Set the lattice properties.\n\t\tthis.attachNode( \"Lattice\", \"Size\", undefined,\n\t\t\t{ symbol : \"size\",\n\t\t\t\tvalue : this.toMorpheusCoordinate( this.model.grid.extents ) } )\n\t\tthis.attachNode( \"Lattice\", \"Neighborhood\" )\n\n\t\tif( typeof this.model.grid.neighborhood.order !== \"undefined\" ){\n\t\t\tthis.attachNode( \"Neighborhood\", \"Order\",\n\t\t\t\tthis.model.grid.neighborhood.order )\n\t\t} else if ( typeof this.model.grid.neighborhood.distance !== \"undefined\") {\n\t\t\tthis.attachNode( \"Neighborhood\", \"Distance\",\n\t\t\t\tthis.model.grid.neighborhood.distance )\n\t\t} else {\n\t\t\tthis.conversionWarnings.grid.push( \"Unknown neighborhood order; \" +\n\t\t\t\t\"reverting to default order 2 instead.\" )\n\t\t\tthis.attachNode( \"Neighborhood\", \"Order\", 2 )\n\t\t}\n\n\t\tthis.attachNode( \"Lattice\", \"BoundaryConditions\" )\n\n\t\tconst dimNames = [\"x\",\"y\",\"z\"]\n\t\tconst knownBounds = { periodic: true, noflux : true, constant: true }\n\t\tfor( let d = 0; d < this.model.grid.boundaries.length; d++ ){\n\t\t\tlet bType = this.model.grid.boundaries[d]\n\t\t\tif( !knownBounds.hasOwnProperty( bType ) ){\n\n\t\t\t\tthis.conversionWarnings.grid.push(\n\t\t\t\t\t\"Unknown boundary type : \" + bType + \"; setting to\" +\n\t\t\t\t\t\"default 'periodic' instead.\"\n\t\t\t\t)\n\t\t\t\tbType = \"periodic\"\n\n\t\t\t}\n\t\t\tthis.attachNode( \"BoundaryConditions\", \"Condition\",\n\t\t\t\tundefined, { boundary: dimNames[d], type: bType } )\n\t\t}\n\t}\n\n\twriteTime(){\n\t\tthis.attachNode( \"MorpheusModel\", \"Time\" )\n\t\tthis.attachNode( \"Time\", \"StartTime\", undefined,\n\t\t\t{value: this.model.timeInfo.start } )\n\t\tthis.attachNode( \"Time\", \"StopTime\", undefined,\n\t\t\t{value: this.model.timeInfo.stop } )\n\n\t\tif( typeof this.model.kinetics.seed !== \"undefined\" ){\n\t\t\tthis.attachNode( \"Time\", \"RandomSeed\", undefined,\n\t\t\t\t{ value: this.model.kinetics.seed } )\n\t\t}\n\n\t\tthis.attachNode( \"Time\", \"TimeSymbol\", undefined,\n\t\t\t{ symbol: \"time\" } )\n\n\t}\n\n\twriteCellTypes(){\n\t\tthis.attachNode( \"MorpheusModel\", \"CellTypes\" )\n\t\tconst ck = this.model.cellKinds\n\n\t\tfor( let ki = 0; ki < ck.count; ki++ ){\n\t\t\t// Special case: background is always the first (index ki = 0 )\n\t\t\tif( ki === 0 ){\n\t\t\t\tthis.attachNode( \"CellTypes\", \"CellType\", undefined,\n\t\t\t\t\t{ class : \"medium\", name : ck.index2name[ ki.toString() ] } )\n\t\t\t} else {\n\t\t\t\tthis.attachNode( \"CellTypes\", \"CellType\", undefined,\n\t\t\t\t\t{ class : \"biological\", name : ck.index2name[ ki.toString() ] } )\n\t\t\t}\n\t\t\tthis.cellTypeTagIndex[ this.model.getKindName( ki ) ] =\n\t\t\t\tthis.xml.getElementsByTagName( \"CellType\" ).length - 1\n\t\t}\n\t}\n\n\twriteCPM(){\n\t\tthis.attachNode( \"MorpheusModel\", \"CPM\" )\n\n\t\tthis.attachNode( \"CPM\", \"Interaction\" )\n\t\tthis.setAdhesion()\n\n\t\tthis.attachNode( \"CPM\", \"MonteCarloSampler\", undefined,\n\t\t\t{stepper:\"edgelist\"})\n\t\tthis.attachNode( \"MonteCarloSampler\" , \"MCSDuration\", undefined,\n\t\t\t{value:1})\n\t\tthis.attachNode( \"MonteCarloSampler\", \"Neighborhood\" )\n\t\tlet neighIndex = this.xml.getElementsByTagName(\"Neighborhood\").length - 1\n\t\tthis.attachNode( \"Neighborhood\", \"Order\", 2, {}, neighIndex )\n\t\tthis.attachNode( \"MonteCarloSampler\", \"MetropolisKinetics\", undefined,\n\t\t\t{ temperature: this.model.kinetics.T } )\n\t\tthis.attachNode( \"CPM\", \"ShapeSurface\", undefined,\n\t\t\t{scaling: \"none\" } )\n\t\tthis.attachNode( \"ShapeSurface\", \"Neighborhood\" )\n\t\tneighIndex++\n\t\tthis.attachNode( \"Neighborhood\", \"Order\", 2, {}, neighIndex )\n\n\t}\n\n\twriteConstraints(){\n\t\tconst constraints = this.model.constraints.constraints\n\t\tfor (let cName of Object.keys( constraints ) ){\n\n\t\t\tswitch( cName ){\n\n\t\t\tcase \"Adhesion\" :\n\t\t\t\t// is actually handled by this.writeCPM()\n\t\t\t\tbreak\n\n\t\t\tcase \"VolumeConstraint\" :\n\t\t\t\tthis.setVolumeConstraint( constraints[cName] )\n\t\t\t\tbreak\n\n\t\t\tcase \"PerimeterConstraint\" :\n\t\t\t\tthis.setPerimeterConstraint( constraints[cName] )\n\t\t\t\tbreak\n\n\t\t\tcase \"ActivityConstraint\" :\n\t\t\t\tthis.setActivityConstraint( constraints[cName] )\n\t\t\t\tbreak\n\n\t\t\tcase \"LocalConnectivityConstraint\" :\n\t\t\t\tthis.setConnectivityConstraint( constraints[cName], cName )\n\t\t\t\tbreak\n\n\t\t\tcase \"ConnectivityConstraint\" :\n\t\t\t\tthis.setConnectivityConstraint( constraints[cName], cName )\n\t\t\t\tbreak\n\n\t\t\tcase \"SoftConnectivityConstraint\" :\n\t\t\t\tthis.setConnectivityConstraint( constraints[cName], cName )\n\t\t\t\tbreak\n\n\t\t\tcase \"SoftLocalConnectivityConstraint\" :\n\t\t\t\tthis.setConnectivityConstraint( constraints[cName], cName )\n\t\t\t\tbreak\n\n\t\t\tcase \"BarrierConstraint\" :\n\t\t\t\tthis.setBarrierConstraint( constraints[cName] )\n\t\t\t\tbreak\n\n\t\t\tcase \"PersistenceConstraint\" :\n\t\t\t\tthis.setPersistenceConstraint( constraints[cName] )\n\t\t\t\tbreak\n\n\t\t\tcase \"PreferredDirectionConstraint\" :\n\t\t\t\tthis.setPreferredDirectionConstraint( constraints[cName] )\n\t\t\t\tbreak\n\n\t\t\tcase \"ChemotaxisConstraint\" :\n\t\t\t\tthis.setChemotaxisConstraint( constraints[cName] )\n\t\t\t\tbreak\n\n\t\t\tdefault :\n\t\t\t\tthis.conversionWarnings.constraints.push( \"Constraint :\" +\n\t\t\t\t\tcName + \" doesn't exist in Morpheus. Making the model anyway \" +\n\t\t\t\t\t\"without it; behaviour of the model may change so please \" +\n\t\t\t\t\t\"check manually for alternatives in Morpheus.\"\n\t\t\t\t)\n\t\t\t}\n\n\t\t}\n\n\n\t}\n\n\tmultipleConstraintsWarning( constraintName ){\n\t\tthis.conversionWarnings.constraints.push(\n\t\t\t\"It appears as if your model has multiple constraints of type \" +\n\t\t\tconstraintName + \"; ignoring all but the first.\"\n\t\t)\n\t}\n\n\tsetAdhesion( ){\n\t\tif( this.model.constraints.constraints.hasOwnProperty(\"Adhesion\")) {\n\t\t\tconst JMatrix = this.model.constraints.constraints.Adhesion[0].J\n\t\t\tfor (let ki = 0; ki < this.model.cellKinds.count; ki++) {\n\t\t\t\tfor (let kj = 0; kj <= ki; kj++) {\n\t\t\t\t\tconst j1 = JMatrix[ki][kj], j2 = JMatrix[kj][ki]\n\t\t\t\t\tif (!isNaN(j1) && (j1 !== j2)) {\n\t\t\t\t\t\tthis.conversionWarnings.constraints.push(\n\t\t\t\t\t\t\t\"Your adhesion matrix is not symmetrical, which is not\" +\n\t\t\t\t\t\t\t\"supported by Morpheus. Please check <Interaction> <Contact> values and \" +\n\t\t\t\t\t\t\t\"modify if required.\"\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\tlet J = j1\n\t\t\t\t\tif (isNaN(J)) {\n\t\t\t\t\t\tJ = 0\n\t\t\t\t\t}\n\t\t\t\t\tconst iName = this.model.getKindName(ki)\n\t\t\t\t\tconst jName = this.model.getKindName(kj)\n\t\t\t\t\tthis.attachNode(\"Interaction\", \"Contact\", undefined,\n\t\t\t\t\t\t{type1: iName, type2: jName, value: J})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsetVolumeConstraint( confArray ){\n\t\tif( confArray.length > 1 ){\n\t\t\tthis.multipleConstraintsWarning( \"VolumeConstraint\" )\n\t\t}\n\t\tconst conf = confArray[0]\n\t\tconst lambda = conf.LAMBDA_V\n\t\tconst target = conf.V\n\n\t\tfor( let k = 0; k < lambda.length; k++ ){\n\t\t\t// only add constraint to CellType for which it is non-zero.\n\t\t\tif( lambda[k] > 0 ){\n\t\t\t\tconst kName = this.model.getKindName(k)\n\t\t\t\tlet constraintNode = this.makeNode( \"VolumeConstraint\",\n\t\t\t\t\tundefined, {target: target[k], strength: lambda[k]})\n\t\t\t\tthis.addNodeTo( constraintNode, \"CellType\", this.cellTypeTagIndex[kName] )\n\t\t\t}\n\t\t}\n\t}\n\n\tsetPerimeterConstraint( confArray ){\n\t\tif( confArray.length > 1 ){\n\t\t\tthis.multipleConstraintsWarning( \"PerimeterConstraint\" )\n\t\t}\n\t\tconst conf = confArray[0]\n\t\tconst lambda = conf.LAMBDA_P\n\t\tconst target = conf.P\n\n\t\tfor( let k = 0; k < lambda.length; k++ ){\n\t\t\t// only add constraint to CellType for which it is non-zero.\n\t\t\tif( lambda[k] > 0 ){\n\t\t\t\tconst kName = this.model.getKindName(k)\n\t\t\t\tlet constraintNode = this.makeNode( \"SurfaceConstraint\",\n\t\t\t\t\tundefined, {mode: \"surface\", target: target[k], strength: lambda[k]})\n\t\t\t\tthis.addNodeTo( constraintNode, \"CellType\", this.cellTypeTagIndex[kName] )\n\t\t\t}\n\t\t}\n\t}\n\n\tsetActivityConstraint( confArray ){\n\t\tif( confArray.length > 1 ){\n\t\t\tthis.multipleConstraintsWarning( \"ActivityConstraint\" )\n\t\t}\n\t\tconst conf = confArray[0]\n\t\tconst lambda = conf.LAMBDA_ACT\n\t\tconst maximum = conf.MAX_ACT\n\t\tconst actMean = conf.ACT_MEAN\n\t\tif( actMean !== \"geometric\" ){\n\t\t\tthis.conversionWarnings.constraints.push( \"You have an ActivityConstraint with\" +\n\t\t\t\t\" ACT_MEAN = 'arithmetic', but this is not supported in Morpheus. \" +\n\t\t\t\t\"Switching to 'geometric'. Behaviour may change slightly; please \" +\n\t\t\t\t\"check if this is a problem and adjust parameters if this is the case.\" )\n\t\t}\n\n\t\tfor( let k = 0; k < lambda.length; k++ ){\n\t\t\t// only add constraint to CellType for which it is non-zero.\n\t\t\tif( lambda[k] > 0 ){\n\t\t\t\tconst kName = this.model.getKindName(k)\n\t\t\t\t// Add the protrusion plugin to the celltype\n\t\t\t\tlet constraintNode = this.makeNode( \"Protrusion\",\n\t\t\t\t\tundefined, {field: \"act\", maximum: maximum[k], strength: lambda[k]})\n\t\t\t\tthis.addNodeTo( constraintNode, \"CellType\", this.cellTypeTagIndex[kName] )\n\t\t\t\t// We also need to add an activity Field to the <Global> tag.\n\n\t\t\t\tlet actField = this.makeNode( \"Field\", undefined,\n\t\t\t\t\t{symbol: \"act\", value: \"0\", name: \"actin-activity\" } )\n\t\t\t\tlet diff = this.makeNode( \"Diffusion\", undefined, {rate:\"0\"})\n\t\t\t\tactField.appendChild( diff )\n\t\t\t\tthis.addNodeTo( actField, \"Global\" )\n\t\t\t}\n\t\t}\n\n\t\tthis.fieldsToDraw.push( \"act\" )\n\t}\n\n\tsetConnectivityConstraint( confArray, cName ){\n\t\tif( confArray.length > 1 ){\n\t\t\tthis.multipleConstraintsWarning( \"ConnectivityConstraint\" )\n\t\t}\n\t\tconst conf = confArray[0]\n\n\t\t// Hard constraint\n\t\tif( conf.hasOwnProperty( \"CONNECTED\" ) ){\n\t\t\tconst conn = conf.CONNECTED\n\n\t\t\tfor( let k = 0; k < conn.length; k++ ){\n\t\t\t\tif( conn[k] ){\n\t\t\t\t\tlet constraintNode = this.makeNode( \"ConnectivityConstraint\" )\n\t\t\t\t\tthis.addNodeTo( constraintNode, \"CellType\",\n\t\t\t\t\t\tthis.cellTypeTagIndex[this.model.getKindName(k)] )\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( cName === \"LocalConnectivityConstraint\" ){\n\t\t\t\tthis.conversionWarnings.constraints.push( \"Your artistoo \" +\n\t\t\t\t\t\"model has a LocalConnectivityConstraint, which is not \" +\n\t\t\t\t\t\"supported in Morpheus. Converting to the Morpheus \" +\n\t\t\t\t\t\"ConnectivityConstraint; behaviour may change slightly \" +\n\t\t\t\t\t\"so please check your model.\" )\n\t\t\t}\n\t\t}\n\n\t\t// Or the soft constraint\n\t\telse if ( conf.hasOwnProperty ( \"LAMBDA_CONNECTIVITY\" ) ){\n\n\t\t\t// add only to the cells for which it is non-zero.\n\t\t\tconst lambda = conf.LAMBDA_CONNECTIVITY\n\t\t\tfor( let k = 0; k < lambda.length; k++ ){\n\t\t\t\tif( lambda[k] > 0 ){\n\t\t\t\t\tlet constraintNode = this.makeNode( \"ConnectivityConstraint\" )\n\t\t\t\t\tthis.addNodeTo( constraintNode, \"CellType\",\n\t\t\t\t\t\tthis.cellTypeTagIndex[this.model.getKindName(k)] )\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.conversionWarnings.constraints.push( \"Your artistoo \" +\n\t\t\t\t\"model has a \" + cName + \", which is not \" +\n\t\t\t\t\"supported in Morpheus. Converting to the Morpheus \" +\n\t\t\t\t\"ConnectivityConstraint; this is a hard constraint so \" +\n\t\t\t\t\" behaviour may change slightly -- please check your model.\" )\n\t\t}\n\n\t}\n\n\tsetBarrierConstraint( confArray ){\n\t\tif( confArray.length > 1 ){\n\t\t\tthis.multipleConstraintsWarning( \"BarrierConstraint\" )\n\t\t}\n\t\tconst conf = confArray[0]\n\t\tconst barr = conf.IS_BARRIER\n\n\t\t// Add to cells for which it is set to true.\n\t\tfor( let k = 0; k < barr.length; k++ ){\n\t\t\tif( barr[k] ){\n\t\t\t\tlet constraintNode = this.makeNode( \"FreezeMotion\",\n\t\t\t\t\tundefined, { condition: \"1\"})\n\t\t\t\tthis.addNodeTo( constraintNode, \"CellType\",\n\t\t\t\t\tthis.cellTypeTagIndex[this.model.getKindName(k)] )\n\t\t\t}\n\t\t}\n\t}\n\n\tsetPersistenceConstraint( confArray ){\n\t\tif( confArray.length > 1 ){\n\t\t\tthis.multipleConstraintsWarning( \"PersistenceConstraint\" )\n\t\t}\n\t\tconst conf = confArray[0]\n\t\tconst lambda = conf.LAMBDA_DIR\n\t\tconst dt = conf.DELTA_T || this.model.initCellKindVector(10)\n\t\tconst prob = conf.PERSIST\n\n\t\tfor( let k = 0; k < lambda.length; k++ ){\n\t\t\t// only add constraint to CellType for which it is non-zero.\n\t\t\tif( lambda[k] > 0 ){\n\t\t\t\tconst kName = this.model.getKindName(k)\n\t\t\t\tlet constraintNode = this.makeNode( \"PersistentMotion\",\n\t\t\t\t\tundefined, {decaytime: dt[k], strength: lambda[k]})\n\t\t\t\tthis.addNodeTo( constraintNode, \"CellType\", this.cellTypeTagIndex[kName] )\n\t\t\t\tif( prob[k] !== 1 ){\n\t\t\t\t\tthis.conversionWarnings.constraints.push( \"Your model has a \" +\n\t\t\t\t\t\t\"PersistenceConstraint with PERSIST = \" + prob[k] + \", but \" +\n\t\t\t\t\t\t\"Morpheus only supports PERSIST = 1. Reverting to this setting \" +\n\t\t\t\t\t\t\"instead, please check your model carefully.\" )\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsetPreferredDirectionConstraint( confArray ){\n\t\tif( confArray.length > 1 ){\n\t\t\tthis.multipleConstraintsWarning( \"PreferredDirectionConstraint\" )\n\t\t}\n\t\tconst conf = confArray[0]\n\t\tconst lambda = conf.LAMBDA_DIR\n\t\tconst dir = conf.DIR\n\n\t\tfor( let k = 0; k < lambda.length; k++ ){\n\t\t\t// only add constraint to CellType for which it is non-zero.\n\t\t\tif( lambda[k] > 0 ){\n\t\t\t\tconst kName = this.model.getKindName(k)\n\t\t\t\tconst direction = this.toMorpheusCoordinate( dir[k] )\n\t\t\t\tlet constraintNode = this.makeNode( \"DirectedMotion\",\n\t\t\t\t\tundefined, {direction: direction, strength: lambda[k]})\n\t\t\t\tthis.addNodeTo( constraintNode, \"CellType\", this.cellTypeTagIndex[kName] )\n\t\t\t}\n\t\t}\n\n\t}\n\n\tsetChemotaxisConstraint( confArray ){\n\n\t\tfor( let i = 0; i < confArray.length; i++ ){\n\n\t\t\tconst conf = confArray[i]\n\t\t\tconst index = i+1\n\t\t\tconst fieldName = \"U\" + index\n\n\t\t\tconst lambda = conf.LAMBDA_CH\n\t\t\tconst field = conf.CH_FIELD\n\n\t\t\t// Warn for a CoarseGrid\n\t\t\tif( typeof field.upscale !== \"undefined\" && field.upscale !== 1 ){\n\t\t\t\tthis.conversionWarnings.constraints.push(\n\t\t\t\t\t\"Your ChemotaxisConstraint is linked to a 'CoarseGrid' with \" +\n\t\t\t\t\t\"a different resolution than the original CPM grid. This is not \" +\n\t\t\t\t\t\"supported in Morpheus. Adding a Field anyway, but you may have \" +\n\t\t\t\t\t\"to check and scale the diffusion rate.\"\n\t\t\t\t)\n\t\t\t}\n\n\t\t\t// Add the constraint to celltypes for which lambda nonzero.\n\t\t\tfor( let k = 0; k < lambda.length; k++ ){\n\t\t\t\tif( lambda[k] > 0 ){\n\t\t\t\t\tconst kName = this.model.getKindName(k)\n\t\t\t\t\tlet constraintNode = this.makeNode( \"Chemotaxis\",\n\t\t\t\t\t\tundefined, {field: fieldName, strength: lambda[k]})\n\t\t\t\t\tthis.addNodeTo( constraintNode, \"CellType\", this.cellTypeTagIndex[kName] )\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// For this to work, the concentration field 'U' needs to exist in 'global'.\n\t\t\tlet fieldNode = this.makeNode( \"Field\", undefined,\n\t\t\t\t{symbol: fieldName, value : 0 } )\n\t\t\tlet diffNode = this.makeNode( \"Diffusion\", undefined,\n\t\t\t\t{rate:0.1} )\n\t\t\tthis.conversionWarnings.constraints.push( \"Adding a ChemotaxisConstraint \" +\n\t\t\t\t\"with an attached field, but cannot find parameters like diffusion rate, \" +\n\t\t\t\t\"chemokine production rate, and decay rate automatically. Adding some \" +\n\t\t\t\t\"default values; please adapt these manually (by configuring constants \" +\n\t\t\t\t\"and properties under 'Global' and where \" +\n\t\t\t\t\"relevant under the 'CellTypes')\" )\n\t\t\tfieldNode.appendChild( diffNode )\n\t\t\tthis.addNodeTo( fieldNode, \"Global\" )\n\n\t\t\t// Also add the production/decay equation in a system\n\t\t\tlet sysNode = this.makeNode( \"System\", undefined,\n\t\t\t\t{solver: \"Euler [fixed, O(1)]\", \"time-step\":1 } )\n\t\t\tlet eqnNode = this.makeNode( \"DiffEqn\", undefined,\n\t\t\t\t{ \"symbol-ref\" : fieldName })\n\t\t\tlet expr = \"P\" + index + \" - d\" + index +\"*\" + fieldName\n\t\t\tlet exprNode = this.makeNode( \"Expression\", expr )\n\t\t\teqnNode.appendChild( exprNode )\n\t\t\tsysNode.appendChild( eqnNode )\n\n\t\t\t// Add the constant degradation used in the equation\n\t\t\tlet constNode = this.makeNode( \"Constant\", undefined,\n\t\t\t\t{ symbol: \"d\"+index, value : \"0\", name: \"degradation \"+fieldName } )\n\t\t\tsysNode.appendChild( constNode )\n\n\t\t\t// Add the production, space-dependent so use a field\n\t\t\tlet productionField = this.makeNode( \"Field\", undefined,\n\t\t\t\t{\"symbol\": \"P\"+index, value : 0} )\n\t\t\tlet eqn2Node = this.makeNode( \"Equation\", undefined,\n\t\t\t\t{ \"symbol-ref\" : \"P\"+index, name: \"production \"+fieldName })\n\t\t\tconst randX = Math.floor( Math.random() * this.model.grid.extents[0] )\n\t\t\tconst randY = Math.floor( Math.random() * this.model.grid.extents[1] )\n\t\t\tlet expr2Node = this.makeNode( \"Expression\",\n\t\t\t\t\"if( space.x == \"+randX+\" and space.y == \"+randY+\", 10, 0 )\" )\n\t\t\teqn2Node.appendChild( expr2Node )\n\t\t\tthis.addNodeTo( eqn2Node, \"Global\" )\n\t\t\tthis.addNodeTo( productionField, \"Global\" )\n\t\t\tthis.addNodeTo( sysNode, \"Global\" )\n\n\t\t\tthis.fieldsToDraw.push( fieldName )\n\n\t\t}\n\n\n\n\t}\n\n\twriteCellPopulations(){\n\t\tthis.attachNode( \"MorpheusModel\", \"CellPopulations\" )\n\n\t\tlet objects = {} // key for each kind, array of objects in InitCellObjects as value.\n\t\tlet ID = 1\n\n\t\tfor( let init of this.model.setup.init ){\n\t\t\tconst k = init.kindName\n\t\t\tif( !objects.hasOwnProperty(k) ){ objects[k] = [] }\n\n\t\t\tswitch( init.setter ){\n\t\t\tcase \"circleObject\" :\n\t\t\t\t// objects added per cellkind below the loop.\n\t\t\t\tobjects[k].push(this.makeNode(\"Sphere\", undefined,\n\t\t\t\t\t{center: this.toMorpheusCoordinate( init.center ),\n\t\t\t\t\t\tradius: init.radius}))\n\t\t\t\tbreak\n\n\t\t\tcase \"boxObject\" :\n\t\t\t\t// objects added per cellkind below the loop.\n\t\t\t\tobjects[k].push(this.makeNode(\"Box\", undefined,\n\t\t\t\t\t{origin: this.toMorpheusCoordinate( init.bottomLeft ),\n\t\t\t\t\t\tsize: this.toMorpheusCoordinate( init.boxSize ) } ) )\n\t\t\t\tbreak\n\n\t\t\tcase \"cellCircle\" : {\n\t\t\t\tlet popNode = this.makeNode( \"Population\", undefined, {type:k } )\n\t\t\t\tlet initNode = this.makeNode( \"InitCircle\",\n\t\t\t\t\tundefined, { mode: \"random\", \"number-of-cells\": init.nCells })\n\t\t\t\tlet dimNode = this.makeNode( \"Dimensions\", undefined,\n\t\t\t\t\t{center : this.toMorpheusCoordinate( init.center ),\n\t\t\t\t\t\tradius: init.radius} )\n\t\t\t\tinitNode.appendChild( dimNode )\n\t\t\t\tpopNode.appendChild( initNode )\n\t\t\t\tthis.addNodeTo( popNode, \"CellPopulations\" )\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tcase \"pixelSet\" : {\n\t\t\t\tlet popNode = this.makeNode( \"Population\", undefined, {type:k } )\n\t\t\t\tlet cellNode = this.makeNode( \"Cell\",\n\t\t\t\t\tundefined, { id: ID, name: ID })\n\t\t\t\tlet ww = this\n\t\t\t\tlet pixelList = init.pixels.map( function(p){\n\t\t\t\t\treturn ww.toMorpheusCoordinate(p)\n\t\t\t\t} )\n\t\t\t\tlet nodeNode = this.makeNode( \"Nodes\",\n\t\t\t\t\tpixelList.join(\";\") )\n\t\t\t\tID++\n\n\t\t\t\tcellNode.appendChild( nodeNode )\n\t\t\t\tpopNode.appendChild( cellNode )\n\t\t\t\tthis.addNodeTo( popNode, \"CellPopulations\" )\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tdefault :\n\t\t\t\tthis.conversionWarnings.init.push( \"Unknown initializer : \" + init.setter +\n\t\t\t\t\", ignoring; you may have to check the CellPopulations settings of your model\" +\n\t\t\t\t\t\"manually.\")\n\n\t\t\t}\n\t\t}\n\n\t\tfor( let k of Object.keys( objects ) ){\n\n\t\t\tif( objects[k].length > 0 ) {\n\n\t\t\t\tlet popNode = this.makeNode(\"Population\", undefined, {type: k})\n\t\t\t\tlet initNode = this.makeNode(\"InitCellObjects\",\n\t\t\t\t\tundefined, {mode: \"distance\"})\n\n\n\t\t\t\tlet objArr = objects[k]\n\t\t\t\tfor (let obj of objArr) {\n\t\t\t\t\tlet arrNode = this.makeNode(\"Arrangement\", undefined,\n\t\t\t\t\t\t{displacements: \"0,0,0\", repetitions: \"1,1,1\"})\n\t\t\t\t\tarrNode.appendChild(obj)\n\t\t\t\t\tinitNode.appendChild(arrNode)\n\t\t\t\t}\n\t\t\t\tpopNode.appendChild(initNode)\n\t\t\t\tthis.addNodeTo(popNode, \"CellPopulations\")\n\n\t\t\t}\n\t\t}\n\n\t}\n\n\twriteAnalysis(){\n\t\tthis.conversionWarnings.analysis.push(\n\t\t\t\"Auto-conversion of plots and other output is not (yet) supported.\" +\n\t\t\t\"Adding some default outputs, but please check and adjust these \" +\n\t\t\t\"manually.\"\n\t\t)\n\t\tthis.attachNode( \"MorpheusModel\", \"Analysis\" )\n\n\t\tlet gnuPlot = this.makeNode( \"Gnuplotter\", undefined, {\"time-step\":50} )\n\t\tgnuPlot.appendChild(\n\t\t\tthis.makeNode( \"Terminal\", undefined, {name:\"png\"})\n\t\t)\n\t\tlet plot = this.makeNode( \"Plot\" )\n\t\tplot.appendChild(\n\t\t\tthis.makeNode( \"Cells\", undefined,\n\t\t\t\t{opacity:\"0.2\", value: \"cell.type\" })\n\t\t)\n\n\t\t// Plot the fields to draw\n\t\tfor( let f of this.fieldsToDraw ){\n\t\t\tplot.appendChild( this.makeNode( \"Field\", undefined,\n\t\t\t\t{\"symbol-ref\": f } ) )\n\t\t}\n\n\t\tgnuPlot.appendChild( plot )\n\t\tthis.addNodeTo( gnuPlot, \"Analysis\" )\n\n\t}\n\n}\n\nexport default MorpheusWriter",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/converter/MorpheusWriter.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 251,
    "kind": "class",
    "name": "MorpheusWriter",
    "memberof": "src/converter/MorpheusWriter.js",
    "static": true,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/converter/MorpheusWriter.js",
    "importStyle": "MorpheusWriter",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/converter/Writer.js~Writer"
    ]
  },
  {
    "__docId__": 252,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true
  },
  {
    "__docId__": 253,
    "kind": "member",
    "name": "xml",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#xml",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 254,
    "kind": "member",
    "name": "cellTypeTagIndex",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#cellTypeTagIndex",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 255,
    "kind": "member",
    "name": "fieldsToDraw",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#fieldsToDraw",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 256,
    "kind": "member",
    "name": "logString",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#logString",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 257,
    "kind": "method",
    "name": "write",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#write",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 258,
    "kind": "method",
    "name": "writeXML",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#writeXML",
    "access": "public",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 259,
    "kind": "method",
    "name": "formatXml",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#formatXml",
    "access": "public",
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "params": [
      {
        "name": "xml",
        "types": [
          "*"
        ]
      },
      {
        "name": "tab",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 260,
    "kind": "method",
    "name": "initXML",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#initXML",
    "access": "public",
    "description": null,
    "lineNumber": 54,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 262,
    "kind": "method",
    "name": "setAttributesOf",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#setAttributesOf",
    "access": "public",
    "description": null,
    "lineNumber": 63,
    "undocument": true,
    "params": [
      {
        "name": "node",
        "types": [
          "*"
        ]
      },
      {
        "name": "attr",
        "types": [
          "*"
        ]
      },
      {
        "name": "index",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      }
    ],
    "return": null
  },
  {
    "__docId__": 263,
    "kind": "method",
    "name": "attachNode",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#attachNode",
    "access": "public",
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "params": [
      {
        "name": "parentName",
        "types": [
          "*"
        ]
      },
      {
        "name": "nodeName",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "optional": true,
        "types": [
          "*"
        ],
        "defaultRaw": "undefined",
        "defaultValue": "undefined"
      },
      {
        "name": "attr",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      },
      {
        "name": "index",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      }
    ],
    "return": null
  },
  {
    "__docId__": 264,
    "kind": "method",
    "name": "makeNode",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#makeNode",
    "access": "public",
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "params": [
      {
        "name": "nodeName",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "optional": true,
        "types": [
          "*"
        ],
        "defaultRaw": "undefined",
        "defaultValue": "undefined"
      },
      {
        "name": "attr",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 265,
    "kind": "method",
    "name": "addNodeTo",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#addNodeTo",
    "access": "public",
    "description": null,
    "lineNumber": 83,
    "undocument": true,
    "params": [
      {
        "name": "node",
        "types": [
          "*"
        ]
      },
      {
        "name": "parentName",
        "types": [
          "*"
        ]
      },
      {
        "name": "index",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      }
    ],
    "return": null
  },
  {
    "__docId__": 266,
    "kind": "method",
    "name": "setNode",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#setNode",
    "access": "public",
    "description": null,
    "lineNumber": 87,
    "undocument": true,
    "params": [
      {
        "name": "nodeName",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "index",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      }
    ],
    "return": null
  },
  {
    "__docId__": 267,
    "kind": "method",
    "name": "toMorpheusCoordinate",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#toMorpheusCoordinate",
    "access": "public",
    "description": null,
    "lineNumber": 93,
    "undocument": true,
    "params": [
      {
        "name": "coordinate",
        "types": [
          "*"
        ]
      },
      {
        "name": "fillValue",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 268,
    "kind": "method",
    "name": "writeDescription",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#writeDescription",
    "access": "public",
    "description": null,
    "lineNumber": 102,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 269,
    "kind": "method",
    "name": "writeGlobal",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#writeGlobal",
    "access": "public",
    "description": null,
    "lineNumber": 110,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 270,
    "kind": "method",
    "name": "writeSpace",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#writeSpace",
    "access": "public",
    "description": null,
    "lineNumber": 114,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 271,
    "kind": "method",
    "name": "writeTime",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#writeTime",
    "access": "public",
    "description": null,
    "lineNumber": 160,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 272,
    "kind": "method",
    "name": "writeCellTypes",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#writeCellTypes",
    "access": "public",
    "description": null,
    "lineNumber": 177,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 273,
    "kind": "method",
    "name": "writeCPM",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#writeCPM",
    "access": "public",
    "description": null,
    "lineNumber": 195,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 274,
    "kind": "method",
    "name": "writeConstraints",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#writeConstraints",
    "access": "public",
    "description": null,
    "lineNumber": 218,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 275,
    "kind": "method",
    "name": "multipleConstraintsWarning",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#multipleConstraintsWarning",
    "access": "public",
    "description": null,
    "lineNumber": 285,
    "undocument": true,
    "params": [
      {
        "name": "constraintName",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 276,
    "kind": "method",
    "name": "setAdhesion",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#setAdhesion",
    "access": "public",
    "description": null,
    "lineNumber": 292,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 277,
    "kind": "method",
    "name": "setVolumeConstraint",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#setVolumeConstraint",
    "access": "public",
    "description": null,
    "lineNumber": 318,
    "undocument": true,
    "params": [
      {
        "name": "confArray",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 278,
    "kind": "method",
    "name": "setPerimeterConstraint",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#setPerimeterConstraint",
    "access": "public",
    "description": null,
    "lineNumber": 337,
    "undocument": true,
    "params": [
      {
        "name": "confArray",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 279,
    "kind": "method",
    "name": "setActivityConstraint",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#setActivityConstraint",
    "access": "public",
    "description": null,
    "lineNumber": 356,
    "undocument": true,
    "params": [
      {
        "name": "confArray",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 280,
    "kind": "method",
    "name": "setConnectivityConstraint",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#setConnectivityConstraint",
    "access": "public",
    "description": null,
    "lineNumber": 392,
    "undocument": true,
    "params": [
      {
        "name": "confArray",
        "types": [
          "*"
        ]
      },
      {
        "name": "cName",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 281,
    "kind": "method",
    "name": "setBarrierConstraint",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#setBarrierConstraint",
    "access": "public",
    "description": null,
    "lineNumber": 440,
    "undocument": true,
    "params": [
      {
        "name": "confArray",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 282,
    "kind": "method",
    "name": "setPersistenceConstraint",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#setPersistenceConstraint",
    "access": "public",
    "description": null,
    "lineNumber": 458,
    "undocument": true,
    "params": [
      {
        "name": "confArray",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 283,
    "kind": "method",
    "name": "setPreferredDirectionConstraint",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#setPreferredDirectionConstraint",
    "access": "public",
    "description": null,
    "lineNumber": 484,
    "undocument": true,
    "params": [
      {
        "name": "confArray",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 284,
    "kind": "method",
    "name": "setChemotaxisConstraint",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#setChemotaxisConstraint",
    "access": "public",
    "description": null,
    "lineNumber": 505,
    "undocument": true,
    "params": [
      {
        "name": "confArray",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 285,
    "kind": "method",
    "name": "writeCellPopulations",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#writeCellPopulations",
    "access": "public",
    "description": null,
    "lineNumber": 587,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 286,
    "kind": "method",
    "name": "writeAnalysis",
    "memberof": "src/converter/MorpheusWriter.js~MorpheusWriter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/MorpheusWriter.js~MorpheusWriter#writeAnalysis",
    "access": "public",
    "description": null,
    "lineNumber": 675,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 287,
    "kind": "file",
    "name": "src/converter/Writer.js",
    "content": "\nclass Writer {\n\n\tconstructor( model, config ){\n\t\tthis.model = model\n\n\t\tthis.conversionWarnings = {\n\t\t\tgrid : [],\n\t\t\ttime : [],\n\t\t\tconstraints : [],\n\t\t\tinit : [],\n\t\t\tanalysis: []\n\t\t}\n\n\t\tthis.target = config.target || undefined\n\t\tthis.warningBox = config.warningBox || \"console\"\n\t\tthis.lineW = config.lineW || 80\n\n\t\tthis.logString = \"Unknown converter..\"\n\t}\n\n\twrite(){\n\n\t}\n\n\twriteLog(){\n\n\t\tlet log = this.logString + this.stringWrap(this.model.generalWarning\n\t\t\t, this.lineW, 2 ) + \"Notes on the conversion process: \\n\\n\"\n\n\t\tconst read = Object.keys( this.model.conversionWarnings )\n\t\tconst write = Object.keys( this.conversionWarnings )\n\t\tconst warnTitles = [...new Set([...read ,...write])]\n\n\t\tfor( let ch of warnTitles ){\n\t\t\tlog += \"\\t\" + ch.toUpperCase() + \" :\\n\\t\\t\"\n\t\t\t// Reader warnings\n\t\t\tif( this.model.conversionWarnings.hasOwnProperty( ch ) ){\n\t\t\t\tif( this.model.conversionWarnings[ch].length > 0 ){\n\t\t\t\t\tlet warnArray = [...new Set([...this.model.conversionWarnings[ch]]) ]\n\t\t\t\t\tlog += \"* Reading: \" +\n\t\t\t\t\t\tthis.stringWrap(warnArray.join(\n\t\t\t\t\t\t\t\"\\n\"+\"* \") + \"\\n\", this.lineW, 2 )\n\t\t\t\t} else {\n\t\t\t\t\tlog += \"* Reading: No warnings; success.\\n\\t\\t\"\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Writer warnings\n\t\t\tif( this.conversionWarnings.hasOwnProperty( ch ) ){\n\t\t\t\tconst warnings = this.conversionWarnings[ch]\n\t\t\t\tif( warnings.length === 0 ){\n\t\t\t\t\tlog += \"* Writing: No changes; success.\\n\\n\"\n\t\t\t\t} else {\n\t\t\t\t\tlog += \"* Writing: \" + this.stringWrap(\n\t\t\t\t\t\tthis.conversionWarnings[ch].join( \"\\n\"+\"* \") + \"\\n\\n\",\n\t\t\t\t\t\tthis.lineW, 2 )\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog += \"* Writing: No changes; success.\\n\\n\"\n\t\t\t}\n\n\t\t}\n\n\t\t/*for( let ch of Object.keys( this.conversionWarnings ) ){\n\t\t\tlog += \"\\t\" + ch.toUpperCase() + \" :\\n\\t\\t\"\n\n\t\t\tconst warnings = this.conversionWarnings[ch]\n\t\t\tif( warnings.length === 0 ){\n\t\t\t\tlog += \"No changes; success!\\n\\n\"\n\t\t\t} else {\n\t\t\t\tlog += \"* \" + this.stringWrap(\n\t\t\t\t\tthis.conversionWarnings[ch].join( \"\\n\"+\"* \") + \"\\n\\n\",\n\t\t\t\t\tthis.lineW, 2 )\n\t\t\t}\n\t\t}\n\n\t\tlog += \"\\n\\nThere were also some properties I could not include: \\n\\n\"\n\n\t\tfor( let ch of Object.keys( this.model ) ){\n\t\t\tif( this.model[ch].hasOwnProperty( \"warnings\" ) && this.model[ch].warnings.length > 0 ){\n\t\t\t\tlog += \"\\t\" + ch.toUpperCase() + \" :\\n\\t\\t\" +\n\t\t\t\t\t\"* \" +\n\t\t\t\t\tthis.stringWrap(this.model[ch].warnings.join(\n\t\t\t\t\t\t\"\\n\"+\"* \") + \"\\n\\n\", this.lineW, 2 )\n\t\t\t}\n\t\t}*/\n\n\n\t\tif( this.warningBox === \"console\" ){\n\t\t\t//eslint-disable-next-line no-console\n\t\t\tconsole.log(log)\n\t\t} else {\n\t\t\tthis.warningBox.innerHTML = log\n\t\t}\n\n\t}\n\n\thtmlNewLine( string ){\n\t\tlet re = /\\n/gi\n\t\tstring = string.replace( re, \"<br>\\n\")\n\t\treturn string\n\t}\n\n\trecursiveArrayStringFix( obj ){\n\t\tfor ( let k of Object.keys( obj ) )\n\t\t{\n\n\t\t\tif ( typeof obj[k] == \"object\" && obj[k] !== null && !Array.isArray( obj[k] ) )\n\t\t\t\tthis.recursiveArrayStringFix(obj[k])\n\t\t\telse\n\t\t\tif( Array.isArray( obj[k] ) ){\n\t\t\t\tobj[k] = JSON.stringify( obj[k])\n\t\t\t}\n\t\t}\n\n\t\treturn(obj)\n\t}\n\n\tobjToString( obj, indent = 0 ){\n\n\t\tlet indentStr = \"\\n\"\n\t\tfor( let i = 0; i < indent; i++ ){\n\t\t\tindentStr += \"\\t\"\n\t\t}\n\n\t\t// Trick to print object nicely: we'll use JSON.stringify with option '\\t'\n\t\t// to insert whitespace between entries, but this function is a little too\n\t\t// enthusiastic when it comes to arrays ( each element printed on a new line ).\n\t\t// So we first convert arrays [...] in the config object to strings \"[...]\",\n\t\t// which JSON.stringify sees as a single element and therefore prints on one line.\n\t\t// After this step, we remove the quotes again using string.replace() with a regexp\n\t\t// so that the stringified arrays once again become actual arrays.\n\t\tlet obj2 = this.recursiveArrayStringFix( obj )\n\t\tlet objString = JSON.stringify( obj2, null, \"\\t\" )\n\t\tlet re = /\"\\[/gi\n\t\tobjString = objString.replace( re, \"[\" )\n\t\tre = /]\"/gi\n\t\tobjString = objString.replace( re, \"]\" )\n\t\tre = /\\n/gi\n\t\tobjString = objString.replace( re, indentStr )\n\t\tre = /\\\\\"/gi\n\t\tobjString = objString.replace( re, \"\\\"\" )\n\t\tobjString = objString.replace( /null/gi, \"NaN\" )\n\t\treturn objString\n\t}\n\n\tstringWrap( string, width = 60, indent = 1 ){\n\n\t\tlet indentString = \"\"\n\t\tfor( let i = 0; i < indent; i++ ){\n\t\t\tindentString += \"\\t\"\n\t\t}\n\n\t\t// Dynamic Width (Build Regex)\n\t\tconst wrap = (s, w) => s.replace(\n\t\t\tnew RegExp(`(?![^\\\\n]{1,${w}}$)([^\\\\n]{1,${w}})\\\\s`, \"g\"), \"$1\\n\" + indentString\n\t\t)\n\t\treturn wrap( string, width )\n\t}\n\n}\n\nexport default Writer",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/converter/Writer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 288,
    "kind": "class",
    "name": "Writer",
    "memberof": "src/converter/Writer.js",
    "static": true,
    "longname": "src/converter/Writer.js~Writer",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/converter/Writer.js",
    "importStyle": "Writer",
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 289,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/converter/Writer.js~Writer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/Writer.js~Writer#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 4,
    "undocument": true
  },
  {
    "__docId__": 290,
    "kind": "member",
    "name": "model",
    "memberof": "src/converter/Writer.js~Writer",
    "static": false,
    "longname": "src/converter/Writer.js~Writer#model",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 291,
    "kind": "member",
    "name": "conversionWarnings",
    "memberof": "src/converter/Writer.js~Writer",
    "static": false,
    "longname": "src/converter/Writer.js~Writer#conversionWarnings",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "{\"grid\": *, \"time\": *, \"constraints\": *, \"init\": *, \"analysis\": *}"
      ]
    }
  },
  {
    "__docId__": 292,
    "kind": "member",
    "name": "target",
    "memberof": "src/converter/Writer.js~Writer",
    "static": false,
    "longname": "src/converter/Writer.js~Writer#target",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 293,
    "kind": "member",
    "name": "warningBox",
    "memberof": "src/converter/Writer.js~Writer",
    "static": false,
    "longname": "src/converter/Writer.js~Writer#warningBox",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 294,
    "kind": "member",
    "name": "lineW",
    "memberof": "src/converter/Writer.js~Writer",
    "static": false,
    "longname": "src/converter/Writer.js~Writer#lineW",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 295,
    "kind": "member",
    "name": "logString",
    "memberof": "src/converter/Writer.js~Writer",
    "static": false,
    "longname": "src/converter/Writer.js~Writer#logString",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 296,
    "kind": "method",
    "name": "write",
    "memberof": "src/converter/Writer.js~Writer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/Writer.js~Writer#write",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 297,
    "kind": "method",
    "name": "writeLog",
    "memberof": "src/converter/Writer.js~Writer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/Writer.js~Writer#writeLog",
    "access": "public",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 298,
    "kind": "method",
    "name": "htmlNewLine",
    "memberof": "src/converter/Writer.js~Writer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/Writer.js~Writer#htmlNewLine",
    "access": "public",
    "description": null,
    "lineNumber": 99,
    "undocument": true,
    "params": [
      {
        "name": "string",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 299,
    "kind": "method",
    "name": "recursiveArrayStringFix",
    "memberof": "src/converter/Writer.js~Writer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/Writer.js~Writer#recursiveArrayStringFix",
    "access": "public",
    "description": null,
    "lineNumber": 105,
    "undocument": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 300,
    "kind": "method",
    "name": "objToString",
    "memberof": "src/converter/Writer.js~Writer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/Writer.js~Writer#objToString",
    "access": "public",
    "description": null,
    "lineNumber": 120,
    "undocument": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      },
      {
        "name": "indent",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 301,
    "kind": "method",
    "name": "stringWrap",
    "memberof": "src/converter/Writer.js~Writer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/converter/Writer.js~Writer#stringWrap",
    "access": "public",
    "description": null,
    "lineNumber": 148,
    "undocument": true,
    "params": [
      {
        "name": "string",
        "types": [
          "*"
        ]
      },
      {
        "name": "width",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 60,
        "defaultValue": "60"
      },
      {
        "name": "indent",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 1,
        "defaultValue": "1"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 302,
    "kind": "file",
    "name": "src/grid/CoarseGrid.js",
    "content": "import Grid2D from \"./Grid2D.js\"\n\n/** This class encapsulates a lower-resolution grid and makes it\n   visible as a higher-resolution grid. Only exact subsampling by\n   a constant factor per dimension is supported. \n   \n   This class is useful when combining information of grids of\n   different sizes. This is often the case for chemotaxis, where\n   we let diffusion occur on a lower resolution grid to speed things up.\n   This class then allows you to obtain chemokine information from the \n   low resolution chemokine grid using coordinates from the linked,\n   higher resolution model grid.\n   \n   @example <caption>Linear interpolation on a low resolution chemokine grid</caption>\n   * let CPM = require( \"path/to/build\" )\n   * \n   * // Define a grid with float values for chemokine values, and set the middle pixel\n   * let chemogrid = new CPM.Grid2D( [50,50], [true,true], \"Float32\" )\n   * chemogrid.setpix( [99,99], 100 )\n   * \n   * // Make a coarse grid at 5x as high resolution, which is then 500x500 pixels.\n   * let coarsegrid = new CPM.CoarseGrid( chemogrid, 5 )\n   * \n   * // Use interpolation. Pixels close to the midpoint won't have the exact same\n   * // value of either 100 or 0, but something inbetween.\n   * let p1 = [250,250], p2 = [250,251]\n   * console.log( \"p1 : \" + coarsegrid.pixt(p1) + \", p2 : \" + coarsegrid.pixt(p2) )\n   * // p1 : 100, p2 : 80 \n   * \n   * // Or draw it to see this. Compare these two:\n   * let Cim1 = new CPM.Canvas( coarsegrid )\n   * Cim1.drawField()\n   * let Cim2 = new CPM.Canvas( chemogrid, {zoom:5} )\n   * Cim2.drawField()\n*/\nclass CoarseGrid extends Grid2D {\n\t/** The constructor of class CoarseGrid takes a low resolution grid as input\n\tand a factor 'upscale', which is how much bigger the dimensions of the high\n\tresolution grid are (must be a constant factor). \n\t@param {Grid2D} grid the grid to scale up; currently only supports the {@link Grid2D} class.\n\t@param {number} upscale The (integer) factor to magnify the original grid with. */\n\tconstructor( grid, upscale = 3 ){\n\t\n\t\tlet extents = new Array( grid.extents.length )\n\t\tfor( let i = 0 ; i < grid.extents.length ; i++ ){\n\t\t\textents[i] = upscale * grid.extents[i]\n\t\t}\n\t\tsuper( extents, grid.torus, \"Float32\" )\n\t\n\t\t/** Size of the new grid in all dimensions.\n\t\t@type {GridSize} with a non-negative integer number for each dimension. */\n\t\tthis.extents = extents\n\t\t/** The original, low-resolution grid. \n\t\t@type {Grid2D}*/\n\t\tthis.grid = grid\n\t\t\n\t\t/** The upscale factor (a positive integer number).\n\t\t@private\n\t\t@type {number} */\n\t\tthis.upscale = upscale\n\t}\n\n\t/** The pixt method takes as input a coordinate on the bigger grid, and maps it\n\tto the corresponding value on the resized small grid via bilinear interpolation.\n\tThis prevents artefacts from the lower resolution of the second grid: the \n\t[upscale x upscale] pixels that map to the same pixel in the low resolution grid\n\tdo not get the same value.\n\t@param {ArrayCoordinate} p array coordinates on the high resolution grid.\n\t@return {number} interpolated value from the low resolution grid at this position. */\n\tpixt( p ){\n\t\n\t\t// 2D bilinear interpolation. Find the 4 positions on the original, low resolution grid\n\t\t// that are closest to the requested position p: x-coordinate l,r (left/right) \n\t\t// and y-coordinate t,b (top/bottom)\n\t\n\t\tlet positions = this.positions(p) // [t,r,b,l,h,v]\n\t\tlet t = positions[0], r = positions[1], b = positions[2], l = positions[3],\n\t\t\th = positions[4], v = positions[5]\n\n\t\t// Get the values on those 4 positions\n\t\tlet f_lt = this.grid.pixt([l,t])\n\t\tlet f_rt = this.grid.pixt([r,t])\n\t\tlet f_lb = this.grid.pixt([l,b])\n\t\tlet f_rb = this.grid.pixt([r,b])\n\n\t\t// Average these weighted by their distance to the current pixel.\n\t\tlet f_x_b = f_lb * (1-h) + f_rb * h \n\t\tlet f_x_t = f_lt * (1-h) + f_rt * h\n\n\t\treturn f_x_t*(1-v) + f_x_b * v\n\t}\n\t\n\t/** This method takes as input a coordinate on the bigger grid, and 'adds' additional\n\tvalue to it by adding the proper amount to the corresponding positions on the low\n\tresolution grid.\n\t@param {ArrayCoordinate} p array coordinates on the high resolution grid.\n\t@param {number} value - value that should be added to this position.\n\t*/\n\taddValue( p, value ){\n\t\t\n\t\t// 2D bilinear interpolation, the other way around.\n\t\t// Find the 4 positions on the original, low res grid that are closest to the\n\t\t// requested position p\n\t\t\n\t\tlet positions = this.positions(p) \n\t\tlet t = positions[0], r = positions[1], b = positions[2], l = positions[3],\n\t\t\th = positions[4], v = positions[5]\n\t\t\t\n\t\t\n\t\tlet v_lt = value * (1-h) * (1-v)\n\t\tlet v_lb = value * (1-h) * v\n\t\tlet v_rt = value * h * (1-v)\n\t\tlet v_rb = value * h * v\n\t\t\n\t\t\n\t\tthis.grid.setpix( [l,t], this.grid.pixt([l,t]) + v_lt )\n\t\tthis.grid.setpix( [l,b], this.grid.pixt([l,b]) + v_lb )\n\t\tthis.grid.setpix( [r,t], this.grid.pixt([r,t]) + v_rt )\n\t\tthis.grid.setpix( [r,b], this.grid.pixt([r,b]) + v_rb )\n\t\t\n\t}\n\t/** @private \n\t@ignore */\n\tpositions( p ){\n\t\t// Find the 4 positions on the original, low resolution grid\n\t\t// that are closest to the requested position p: x-coordinate l,r (left/right) \n\t\t// and y-coordinate t,b (top/bottom)\n\t\tlet l = ~~(p[0] / this.upscale) // ~~ is a fast alternative for Math.floor\n\t\tlet r = l+1\n\t\t\n\t\tlet t = ~~(p[1] / this.upscale)\n\t\tlet b = t+1\n\t\t\n\t\t// Find the horizontal/vertical distances of these positions to p\n\t\tlet h = (p[0]%this.upscale)/this.upscale\n\t\tlet v = (p[1]%this.upscale)/this.upscale\n\t\t\n\t\t// Correct grid boundaries depending on torus\n\t\tif( r > this.grid.extents[0] ){\n\t\t\tif( this.grid.torus[0] ){\n\t\t\t\tr = 0\n\t\t\t} else {\n\t\t\t\tr = this.grid.extents[0]\n\t\t\t\th = 0.5\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( b > this.grid.extents[1] ){\n\t\t\tif( this.grid.torus[1] ){\n\t\t\t\tb = 0\n\t\t\t} else {\n\t\t\t\tb = this.grid.extents[1]\n\t\t\t\tv = 0.5\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\treturn [t,r,b,l,h,v]\n\t}\n\n\t/*gradient( p ){\n\t\tlet ps = new Array( p.length )\n\t\tfor( let i = 0 ; i < p.length ; i ++ ){\n\t\t\tps[i] = ~~(p[i]/this.upscale)\n\t\t}\n\t\treturn this.grid.gradient( ps )\n\t}*/\n}\n\nexport default CoarseGrid\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/grid/CoarseGrid.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 303,
    "kind": "class",
    "name": "CoarseGrid",
    "memberof": "src/grid/CoarseGrid.js",
    "static": true,
    "longname": "src/grid/CoarseGrid.js~CoarseGrid",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/grid/CoarseGrid.js",
    "importStyle": "CoarseGrid",
    "description": "This class encapsulates a lower-resolution grid and makes it\nvisible as a higher-resolution grid. Only exact subsampling by\na constant factor per dimension is supported. \n\nThis class is useful when combining information of grids of\ndifferent sizes. This is often the case for chemotaxis, where\nwe let diffusion occur on a lower resolution grid to speed things up.\nThis class then allows you to obtain chemokine information from the \nlow resolution chemokine grid using coordinates from the linked,\nhigher resolution model grid.",
    "examples": [
      "<caption>Linear interpolation on a low resolution chemokine grid</caption>\nlet CPM = require( \"path/to/build\" )\n\n// Define a grid with float values for chemokine values, and set the middle pixel\nlet chemogrid = new CPM.Grid2D( [50,50], [true,true], \"Float32\" )\nchemogrid.setpix( [99,99], 100 )\n\n// Make a coarse grid at 5x as high resolution, which is then 500x500 pixels.\nlet coarsegrid = new CPM.CoarseGrid( chemogrid, 5 )\n\n// Use interpolation. Pixels close to the midpoint won't have the exact same\n// value of either 100 or 0, but something inbetween.\nlet p1 = [250,250], p2 = [250,251]\nconsole.log( \"p1 : \" + coarsegrid.pixt(p1) + \", p2 : \" + coarsegrid.pixt(p2) )\n// p1 : 100, p2 : 80 \n\n// Or draw it to see this. Compare these two:\nlet Cim1 = new CPM.Canvas( coarsegrid )\nCim1.drawField()\nlet Cim2 = new CPM.Canvas( chemogrid, {zoom:5} )\nCim2.drawField()"
    ],
    "lineNumber": 36,
    "interface": false,
    "extends": [
      "src/grid/Grid2D.js~Grid2D"
    ]
  },
  {
    "__docId__": 304,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/grid/CoarseGrid.js~CoarseGrid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/CoarseGrid.js~CoarseGrid#constructor",
    "access": "public",
    "description": "The constructor of class CoarseGrid takes a low resolution grid as input\nand a factor 'upscale', which is how much bigger the dimensions of the high\nresolution grid are (must be a constant factor). ",
    "lineNumber": 42,
    "params": [
      {
        "nullable": null,
        "types": [
          "Grid2D"
        ],
        "spread": false,
        "optional": false,
        "name": "grid",
        "description": "the grid to scale up; currently only supports the {@link Grid2D} class."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "upscale",
        "description": "The (integer) factor to magnify the original grid with."
      }
    ]
  },
  {
    "__docId__": 305,
    "kind": "member",
    "name": "extents",
    "memberof": "src/grid/CoarseGrid.js~CoarseGrid",
    "static": false,
    "longname": "src/grid/CoarseGrid.js~CoarseGrid#extents",
    "access": "public",
    "description": "Size of the new grid in all dimensions.",
    "lineNumber": 52,
    "type": {
      "nullable": null,
      "types": [
        "GridSize"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 306,
    "kind": "member",
    "name": "grid",
    "memberof": "src/grid/CoarseGrid.js~CoarseGrid",
    "static": false,
    "longname": "src/grid/CoarseGrid.js~CoarseGrid#grid",
    "access": "public",
    "description": "The original, low-resolution grid. ",
    "lineNumber": 55,
    "type": {
      "nullable": null,
      "types": [
        "Grid2D"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 307,
    "kind": "member",
    "name": "upscale",
    "memberof": "src/grid/CoarseGrid.js~CoarseGrid",
    "static": false,
    "longname": "src/grid/CoarseGrid.js~CoarseGrid#upscale",
    "access": "private",
    "description": "The upscale factor (a positive integer number).",
    "lineNumber": 60,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 308,
    "kind": "method",
    "name": "pixt",
    "memberof": "src/grid/CoarseGrid.js~CoarseGrid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/CoarseGrid.js~CoarseGrid#pixt",
    "access": "public",
    "description": "The pixt method takes as input a coordinate on the bigger grid, and maps it\nto the corresponding value on the resized small grid via bilinear interpolation.\nThis prevents artefacts from the lower resolution of the second grid: the \n[upscale x upscale] pixels that map to the same pixel in the low resolution grid\ndo not get the same value.",
    "lineNumber": 70,
    "params": [
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "p",
        "description": "array coordinates on the high resolution grid."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "interpolated value from the low resolution grid at this position."
    }
  },
  {
    "__docId__": 309,
    "kind": "method",
    "name": "addValue",
    "memberof": "src/grid/CoarseGrid.js~CoarseGrid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/CoarseGrid.js~CoarseGrid#addValue",
    "access": "public",
    "description": "This method takes as input a coordinate on the bigger grid, and 'adds' additional\nvalue to it by adding the proper amount to the corresponding positions on the low\nresolution grid.",
    "lineNumber": 99,
    "params": [
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "p",
        "description": "array coordinates on the high resolution grid."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "value that should be added to this position."
      }
    ],
    "return": null
  },
  {
    "__docId__": 310,
    "kind": "method",
    "name": "positions",
    "memberof": "src/grid/CoarseGrid.js~CoarseGrid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/CoarseGrid.js~CoarseGrid#positions",
    "access": "private",
    "description": null,
    "lineNumber": 124,
    "ignore": true,
    "params": [
      {
        "name": "p",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 311,
    "kind": "file",
    "name": "src/grid/Grid.js",
    "content": "/** This base class defines a general grid and provides grid methods that do\n * not depend on the coordinate system used. This class is never used on its\n * own, as it does not yet contain methods for neighborhood computation etc\n * (which depend on the coordinate system).\n * Coordinate system-dependent methods are implemented in extensions of the\n * Grid class, for example Grid2D and Grid3D. */\nclass Grid {\n\n\t/** The grid constructor.\n\t * @param {GridSize} field_size array of field size in each dimension.\n\t * E.g. [100,200] for a grid that is 100 pixels wide and 200 pixels high.\n\t * Entries must be positive integer numbers.\n\t * @param {boolean[]} [torus=[true,true,...]] - should the borders of the\n\t * grid be linked, so that a cell moving out on the left reappears on the\n\t * right? Should be an array specifying whether the torus holds in each\n\t * dimension; eg [true,false] for a torus in x but not y dimension.\n\t * Warning: setting the torus to false can give artifacts if not done\n\t * properly, see {@link Grid#torus}.*/\n\tconstructor( field_size, torus ){\n\t\n\t\ttorus = torus || []\n\t\n\t\t/** field_size array of field size in each dimension. E.g. [100,200]\n\t\t * for a grid that is 100 pixels wide and 200 pixels high. Entries must\n\t\t * be positive integer numbers.\n\t\t * @type {GridSize}*/\n\t\tthis.extents = field_size\n\t\t\n\t\t/** Number of dimensions of the grid.\n\t\t * @type {number}*/\n\t\tthis.ndim = this.extents.length\n\t\t\n\t\t\n\t\tif( torus.length === 0 ){\n\t\t\tfor( let d = 0; d < this.ndim; d++ ){\n\t\t\t\ttorus.push( true )\n\t\t\t}\n\t\t} else if ( torus.length !== this.ndim ){\n\t\t\tthrow( \"Torus should be specified for each dimension, or not \" +\n\t\t\t\t\"at all!\" )\n\t\t}\n\t\t/** Should the borders of the grid be linked, so that a cell moving\n\t\t * out on the left reappears on the right? Warning: setting to false\n\t\t * can give artifacts if done incorrectly. If torus is set to false,\n\t\t * artifacts arise because\n\t\t * cells at the border have fewer neighbors. Cells will then stick to\n\t\t * the grid borders where they have fewer neighbors to get adhesion and/or\n\t\t * perimeter penalties from. You will need to specify how to handle the\n\t\t * borders explicitly; see the examples/ folder for details on how to\n\t\t * do this.\n\t\t * Torus can be specified for\n\t\t * each dimension separately.\n\t\t * @type {boolean[]}*/\n\t\tthis.torus = torus\n\n\t\t/** Array with values for each pixel stored at the position of its\n\t\t * \t{@link IndexCoordinate}. E.g. the value of pixel with coordinate\n\t\t * \ti is stored as this._pixels[i]. This should be implemented in\n\t\t * \tthe grid subclass; see e.g. {@link Grid2D#_pixelArray}.\n\t\t * \tNote that this array is accessed indirectly via the\n\t\t * {@link _pixels} set- and get methods.\n\t\t * \t@private\n\t\t * \t*/\n\t\tthis._pixelArray = undefined\n\t\tthis.datatype = undefined\n\t\t\n\t\t/* These are used for rapid conversion between array and index\n\t\tcoordinates, but not documented as they should not be used from outside.\n\t\t*/\n\t\t/** @ignore */\n\t\tthis.X_BITS = 1+Math.floor( Math.log2( this.extents[0] - 1 ) )\n\t\t/** @ignore */\n\t\tthis.Y_BITS = 1+Math.floor( Math.log2( this.extents[1] - 1 ) )\n\t\t/** @ignore */\n\t\tthis.Y_MASK = (1 << this.Y_BITS)-1\n\t\t\n\t\t/** Array coordinates to the middle pixel on the grid.\n\t\t * @type {ArrayCoordinate}\n\t\t * */\n\t\tthis.midpoint = this.extents.map( i => Math.round((i-1)/2) )\n\t}\n\n\t/**\n\t * Return the array this._pixelArray, which should be set in the grid\n\t * subclass.\n\t * @returns {Uint16Array|Float32Array}\n\t * @private\n\t */\n\tget _pixels(){\n\t\tif ( this._pixelArray !== undefined ){\n\t\t\treturn this._pixelArray\n\t\t}\n\t\tthrow(\"A private array this._pixelArray needs to be generated in every \" +\n\t\t\t\" Grid subclass! See its documentation for details.\")\n\t}\n\n\t/**\n\t * Set or update the private this._pixelArray.\n\t * @param {Uint16Array|Float32Array} pixels - array of pixels to set.\n\t * @private\n\t */\n\tset _pixels( pixels ){\n\t\t//noinspection JSValidateTypes\n\t\tthis._pixelArray = pixels\n\t}\n\n\t/** Method to check if a given {@link ArrayCoordinate} falls within the\n\t * bounds of this grid. Returns an error if this is not the case.\n\t * @param {ArrayCoordinate} p - the coordinate to check.\n\t */\n\tcheckOnGrid( p ){\n\t\tfor( let d = 0; d < p.length; d++ ){\n\t\t\tif( p[d] < 0 || p[d] >= this.extents[d] ){\n\t\t\t\tthrow(\"You are trying to access a coordinate that does not seem\" +\n\t\t\t\t\t\"to lie on the grid! I am expecting values between 0 and \" +\n\t\t\t\t\t\"the grid dimension specified in field_size. (If this is your\" +\n\t\t\t\t\t\"own grid implementation and this assumption is not valid,\" +\n\t\t\t\t\t\"please overwrite the liesOnGrid() function in your own\" +\n\t\t\t\t\t\"grid class).\")\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t/** Method to correct an {@link ArrayCoordinate} outside the grid dimensions when\n\t * the grid is wrapped (torus = true). If the coordinate falls inside the grid,\n\t * it is returned unchanged. If it falls outside the grid and the grid is periodic\n\t * in that dimension, a corrected coordinate is returned. If the pixel falls outside\n\t * the grid which is not periodic in that dimension, the function returns\n\t * 'undefined'.\n\t * @param {ArrayCoordinate} p - the coordinate of the pixel to correct\n\t * @return {ArrayCoordinate} the corrected coordinate.\n\t */\n\tcorrectPosition( p ){\n\t\n\t\tlet pnew = []\n\t\tlet ignore = false // ignore pixels that fall off the grid when non-periodic grid\n\t\n\t\t// Loop over the x, y, (z) dimensions\n\t\tfor( let d = 0; d < this.ndim; d++ ){\n\t\n\t\t\t// If position is outside the grid dimensions, action depends on whether\n\t\t\t// grid is periodic or not (torus)\n\t\t\tif( p[d] < 0 ){\n\t\t\t\t// If there is a torus in this dimension, correct the position and return.\n\t\t\t\t// otherwise just ignore it.\n\t\t\t\tif( this.torus[d] ){\n\t\t\t\t\tpnew.push( p[d] + this.extents[d] )\n\t\t\t\t} else {\n\t\t\t\t\tignore = true\n\t\t\t\t}\n\t\t\t} else if ( p[d] >= this.extents[d] ){\n\t\t\t\tif( this.torus[d] ){\n\t\t\t\t\tpnew.push( p[d] - this.extents[d] )\n\t\t\t\t} else {\n\t\t\t\t\tignore = true\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpnew.push( p[d] )\n\t\t\t}\n\t\t}\n\t\n\t\tif( !ignore ){ \n\t\t\treturn pnew\n\t\t} else {\n\t\t\treturn undefined\n\t\t}\n\t\n\t}\n\n\t/** Method for conversion from an {@link ArrayCoordinate} to an\n\t * {@link IndexCoordinate}.\n\t * This method should be implemented in the subclass, see\n\t * {@link Grid2D#p2i} for an example.\n\t * @abstract\n\t * @param {ArrayCoordinate} p - the coordinate of the pixel to convert\n\t * @return {IndexCoordinate} the converted coordinate.\n\t */\n\t//eslint-disable-next-line no-unused-vars\n\tp2i ( p ){\n\t\tthrow( \"A p2i method should be implemented in every Grid subclass!\")\n\t}\n\n\t/** Method for conversion from an {@link IndexCoordinate} to an\n\t * {@link ArrayCoordinate}.\n\t * This method should be implemented in the subclass, see\n\t * {@link Grid2D#i2p} for an example.\n\t * @abstract\n\t * @param {IndexCoordinate} i - the coordinate of the pixel to convert\n\t * @return {ArrayCoordinate} the converted coordinate.\n\t */\n\t//eslint-disable-next-line no-unused-vars\n\ti2p ( i ){\n\t\tthrow( \"An i2p method should be implemented in every Grid subclass!\")\n\t}\n\n\t/** Method returning the (Moore) neighborhood of a pixel based on its\n\t * {@link IndexCoordinate}.\n\t * This method should be implemented in the subclass, see\n\t * {@link Grid2D#neighi} for an example.\n\t * @abstract\n\t * @param {IndexCoordinate} i - the coordinate of the pixel to get neighbors\n\t * for.\n\t * @param {boolean[]} torus are borders of the grid linked so that a cell\n\t * leaving on the right re-enters the grid on the left?\n\t * @return {IndexCoordinate[]} an array of neighbors.\n\t */\n\t//eslint-disable-next-line no-unused-vars\n\tneighi ( i, torus = this.torus ){\n\t\tthrow( \"A neighi method should be implemented in every Grid subclass!\")\n\t}\n\n\t/** The neigh method returns the neighborhood of a pixel p. This function\n\t * uses array coordinates as input and output arguments, but internally\n\t * calls a method 'neighi' which computes neighborhoods using index-\n\t * coordinates. Since neighborhoods depend on the coordinate system, the\n\t * 'neighi' method is defined in the extension class for that specific\n\t * coordinate system.\n\t * @param {ArrayCoordinate} p array coordinates of a specific pixel\n\t * @param {boolean[]} torus are borders of the grid linked so that a cell\n\t * leaving on the right re-enters the grid on the left?\n\t * @return {ArrayCoordinate[]} an array of neighbors of pixel p, where each\n\t * element contains the array coordinates of the neighbor in question.\n\t * */\n\tneigh(p, torus = this.torus){\n\t\tlet g = this\n\t\treturn g.neighi( this.p2i(p), torus ).map( function(i){\n\t\t\treturn g.i2p(i)\n\t\t} )\n\t}\n\n\t/** Check if a value is valid on this type of grid.\n\t * This function forbids trying to set forbidden (negative/float) values\n\t * on an integer grid, which could cause bugs if the setpix(i) methods try\n\t * to set such a value unnoticed.\n\t * @private\n\t * @param {number} t - the value that would be stored on the grid.\n\t * @param {number} [tol=1e-6] - numeric tolerance for comparing a number\n\t * with its rounded version, to check if it is integer (e.g. setting\n\t * a value 1.5 on an integer grid would throw an error, but setting\n\t * 1.000000000001 would not if the tolerance is 1e-6.\n\t * @return {void} - return without problem or throw an error when an\n\t * incorrect value is set.\n\t * */\n\t_isValidValue ( t, tol = 1e-6 ) {\n\t\tif( this.datatype === \"Uint16\" ){\n\t\t\tif( t < 0 || Math.abs( t - Math.round(t) ) > tol  ){\n\t\t\t\tthrow( \"You cannot set a negative or floating point number to a Uint16 grid!\" )\n\t\t\t}\n\t\t}\n\t}\n\n\t/** The setpix method changes the value of a pixel p on the grid to t.\n\t * @param {ArrayCoordinate} p array coordinates of the pixel to change the\n\t * value of\n\t * @param {number} t the value to assign to this pixel. This can\n\t * be integers or floating point numbers, depending on the grid subclass\n\t * used (see eg Grid2D). */\n\tsetpix( p, t ){\n\t\tthis._isValidValue(t)\n\t\tthis._pixels[this.p2i(p)] = t\n\t}\n\n\t/** The setpixi method changes the value of a pixel i on the grid to t.\n\t * @param {IndexCoordinate} i index coordinates of the pixel to change the\n\t * value of\n\t * @param {number} t the value to assign to this pixel. This can be integers\n\t * or floating point numbers, depending on the grid subclass used\n\t * (see eg Grid2D).\n\t * */\n\tsetpixi( i, t ){\n\t\tthis._isValidValue(t)\n\t\tthis._pixels[i] = t\n\t}\n\n\t/** The pixt method finds the current value of a pixel p on the grid.\n\t * @param {ArrayCoordinate} p array coordinates of the pixel to find the\n\t * value of\n\t * @return {number} t the value of p on the grid. This can be integers or\n\t * floating point numbers, depending on the grid subclass used (see eg\n\t * Grid2D).\n\t */\n\tpixt( p ){\n\t\treturn this._pixels[this.p2i(p)]\n\t}\n\n\t/** The pixti method finds the current value of a pixel i on the grid.\n\t * @param {IndexCoordinate} i index coordinates of the pixel to find the\n\t * value of\n\t * @return {number} t the value of i on the grid. This can be integers or\n\t * floating point numbers, depending on the grid subclass used (see eg\n\t * Grid2D).\n\t*/\n\tpixti( i ){\n\t\treturn this._pixels[i]\n\t}\n\n\t/** A pixel on the grid.\n\t * @typedef {Object[]} Pixel\n\t * @property {ArrayCoordinate} Pixel[0] - pixel coordinate\n\t * @property {number} Pixel[1] - pixel value\n\t * */\n\t\n\t/* /** A pixel on the grid.\n\t * @typedef {Object[]} iPixel\n\t * @property {IndexCoordinate} Pixel[0] - pixel coordinate\n\t * @property {number} Pixel[1] - pixel value\n\t * */\n\n\t/** This iterator returns locations and values of all non-zero pixels.\n\t * This method isn't actually called because the subclasses implement\n\t * it themselves due to efficiency reasons. It serves as a template to\n\t * document the functionality.\n\t * @abstract\n\t * @return {Pixel} for each pixel, return an array [p,v] where p are\n\t * the pixel's array coordinates on the grid, and v its value.*/\n\t//eslint-disable-next-line require-yield\n\t* pixels() {\n\t\t//noinspection JSValidateTypes\n\t\tthrow(\"Iterator 'pixels' not implemented!\")\n\n\t\t/*\n\t\t// example code:\n\t\tfor( let i of this.pixelsi() ){\n\t\t\tif( this._pixels[i] > 0 ){\n\t\t\t\tyield [this.i2p(i),this._pixels[i]]\n\t\t\t}\n\t\t}*/\n\t}\n\n\t/** This iterator returns locations all pixels including background.\n\t * This method isn't actually called because the subclasses implement\n\t * it themselves due to efficiency reasons. It serves as a template to\n\t * document the functionality.\n\t * @abstract\n\t * @return {IndexCoordinate} for each pixel, because this method should be\n\t * implemented in a grid subclass.\n\t * */\n\t//eslint-disable-next-line require-yield\n\t* pixelsi() {\n\t\tthrow(\"Iterator 'pixelsi' not implemented!\")\n\t\t//yield undefined\n\t}\n\n\t/** This method pre-allocates an array of the correct datatype to make\n\t * a copy of the current pixel values. Values are not actually copied yet.\n\t * @return {Uint16Array|Float32Array} an array with an element for each\n\t * pixel. The datatype is determined by the datatype of this._pixels\n\t * (implemented in the subclass), which can be either Uint16Array or\n\t * Float32Array. */\n\tpixelsBuffer() {\n\n\t\t/** For storing a copy of all pixel values; eg for synchronous updating\n\t\t * of some sort.\n\t\t * @type {Uint16Array|Float32Array}*/\n\t\tthis._pixelsbuffer = new Uint16Array(this._pixels.length)\n\t\n\t\tif( this._pixels instanceof Uint16Array ){\n\t\t\tthis._pixelsbuffer = new Uint16Array(this._pixels.length)\n\t\t} else if( this._pixels instanceof Float32Array ){\n\t\t\tthis._pixelsbuffer = new Float32Array(this._pixels.length)\n\t\t} else {\n\t\t\tthrow(\"unsupported datatype: \" + (typeof this._pixels))\n\t\t}\n\t}\n\n\t/** Template method to compute the gradient at location i on the grid\n\t * (location given in index coordinates).\n\t * This method throws an error, which is overwritten when a subclass\n\t * implements a gradienti method.\n\t * @param {IndexCoordinate} i index coordinate of a pixel to compute the\n\t * gradient at.\n\t * @return {number[]} the gradient\n\t * @see https://en.wikipedia.org/wiki/Gradient*/\n\t//eslint-disable-next-line no-unused-vars\n\tgradienti( i ){\n\t\tthrow(\"method 'gradienti' not implemented! \")\n\t}\n\n\t/** Method to compute the gradient at location p on the grid (location\n\t * given in array coordinates). It internally calls the gradienti\n\t * method using index coordinates, which should be implemented in the grid\n\t * subclass.\n\t * @param {ArrayCoordinate} p array coordinates of a pixel p to compute\n\t * the gradient at\n\t * @return {number} the gradient at position p.\n\t * @see https://en.wikipedia.org/wiki/Gradient*/\n\tgradient( p ){\n\t\t//noinspection JSValidateTypes\n\t\treturn this.gradienti( this.p2i( p ) )\n\t}\n\n\t/** Method to compute the laplacian at location p on the grid\n\t * (location given in array coordinates). It internally calls the laplaciani\n\t * method that does the same but uses index coordinates.\n\t * @param {ArrayCoordinate} p array coordinates of a pixel p to compute the\n\t * laplacian at\n\t * @return {number} the laplacian at position p.\n\t * @see https://en.wikipedia.org/wiki/Laplace_operator#Coordinate_expressions */\n\tlaplacian( p ){\n\t\treturn this.laplaciani( this.p2i( p ) )\n\t}\n\n\t/**\n\t * A method to compute the Neumann neighborhood should be implemented in the\n\t * Grid subclass if the laplacian (see below) is used.\n\t * This mock function ensures that an error is thrown when there is no\n\t * method called neighNeumanni in the grid subclass.\n\t * @abstract\n\t * @see https://en.wikipedia.org/wiki/Von_Neumann_neighborhood\n\t * @param {IndexCoordinate} i - location of the pixel to get neighbors of.\n\t * @param {boolean[]} [torus=[true,true]] - does the grid have linked\n\t * borders? Defaults to the setting on this grid, see {@link torus}\n\t * @return {IndexCoordinate[]} - an array of coordinates for all the neighbors of i.\n\t */\n\t//eslint-disable-next-line no-unused-vars,require-yield\n\t* neighNeumanni ( i, torus = this.torus ){\n\t\tthrow( \"Trying to call the method neighNeumanni, but you haven't \" +\n\t\t\t\"implemented this method in the Grid subclass you are using!\")\n\t}\n\n\t/** Method to compute the laplacian at location i on the grid (location\n\t * given in index coordinates). It internally uses the neighNeumanni method\n\t * to compute a Neumann neighborhood, which should be implemented in the\n\t * grid subclass. It then uses the finite difference method (see link) with\n\t * h = 1.\n\t * @param {IndexCoordinate} i index coordinates of a pixel to compute the\n\t * laplacian at\n\t * @return {number} the laplacian at position p.\n\t * @see https://en.wikipedia.org/wiki/Laplace_operator#Coordinate_expressions\n\t * @see https://en.wikipedia.org/wiki/Discrete_Laplace_operator#Finite_differences\n\t * */\n\tlaplaciani( i ){\n\t\tlet L = 0, n = 0\n\n\t\t// For now: forbid computing a laplacian on an integer grid as it makes\n\t\t// no sense and could happen by accident if you forget to specify the\n\t\t// datatype.\n\t\t// If this is too strict, we can set an option to overrule this error.\n\t\t// This way you still get to see it if you try this by accident.\n\t\tif( this.datatype === \"Uint16\" ){\n\t\t\tthrow(\"Diffusion/laplacian methods do not work on a Uint16 grid! \" +\n\t\t\t\t\"Consider setting datatype='Float32'.\")\n\t\t}\n\n\t\t//noinspection JSUnresolvedFunction\n\t\tfor( let x of this.neighNeumanni(i) ){\n\t\t\tL += this.pixti( x ); n ++\n\t\t} \n\t\treturn L - n * this.pixti( i )\n\t}\n\n\t/** Perform a diffusion step on the grid, updating the values of all pixels\n\t * according to Fick's second law of diffusion.\n\t * @param {number} D diffusion coefficient\n\t * @see https://en.wikipedia.org/wiki/Diffusion#Fick's_law_and_equations\n\t * @see https://en.wikipedia.org/wiki/Discrete_Laplace_operator#Mesh_Laplacians\n\t * */\n\tdiffusion( D ){\n\t\t// For synchronous updating of the grid: compute updated values in a copy\n\t\t// of the current pixels\n\t\tif( ! this._pixelsbuffer ) this.pixelsBuffer()\n\t\tfor( let i of this.pixelsi() ){\n\t\t\t// Diffusion: new value is current value + change.\n\t\t\t// the change is given by the diffusion coefficient D times the laplacian.\n\t\t\tthis._pixelsbuffer[i] = this.pixti( i ) + D * this.laplaciani( i )\n\t\t}\n\t\t// swap the copy and the original\n\t\t[this._pixelsbuffer, this._pixels] = [this._pixels, this._pixelsbuffer]\n\t}\n\n\t\n\t/** Function that updates a gridpoint depending on its current value and\n\t * that of its neighbors.\n\t * @typedef {function} updatePixelFunction\n\t * @param {ArrayCoordinate} p - pixel to update\n\t * @param {ArrayCoordinate[]} neighbors - coordinates of neighbors of p\n\t * @return {number} value - the updated value, based on the current value\n\t * of p and its neighbors.\n\t */\n\n\t/** Apply a function to all pixel values on the grid. It acts on\n\t * this._pixels, which is implemented in the grid subclass.\n\t * @param {updatePixelFunction} f - the function to apply to each pixel. */\n\tapplyLocally( f ){\n\t\tif( ! this._pixelsbuffer ) this.pixelsBuffer()\n\t\tfor( let i of this.pixelsi() ){\n\t\t\tlet p = this.i2p(i)\n\t\t\tthis._pixelsbuffer[i] = f( p, this.neigh(p) ) \n\t\t}\n\t\t[this._pixelsbuffer, this._pixels] = [this._pixels, this._pixelsbuffer]\n\t}\n\t\n\t/** Multiply all pixel values on the grid with a constant factor r.\n\t * This method acts on this._pixels, which is implemented in the grid\n\t * subclass.\n\t * @param {number} r the multiplication factor. */\n\tmultiplyBy( r ){\n\t\tfor( let i of this.pixelsi() ){\n\t\t\tthis._pixels[i] *= r\n\t\t}\n\t}\n\n}\n\nexport default Grid\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/grid/Grid.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 312,
    "kind": "class",
    "name": "Grid",
    "memberof": "src/grid/Grid.js",
    "static": true,
    "longname": "src/grid/Grid.js~Grid",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/grid/Grid.js",
    "importStyle": "Grid",
    "description": "This base class defines a general grid and provides grid methods that do\nnot depend on the coordinate system used. This class is never used on its\nown, as it does not yet contain methods for neighborhood computation etc\n(which depend on the coordinate system).\nCoordinate system-dependent methods are implemented in extensions of the\nGrid class, for example Grid2D and Grid3D.",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 313,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/grid/Grid.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid.js~Grid#constructor",
    "access": "public",
    "description": "The grid constructor.",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "GridSize"
        ],
        "spread": false,
        "optional": false,
        "name": "field_size",
        "description": "array of field size in each dimension.\nE.g. [100,200] for a grid that is 100 pixels wide and 200 pixels high.\nEntries must be positive integer numbers."
      },
      {
        "nullable": null,
        "types": [
          "boolean[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[true,true,...]",
        "defaultRaw": "[true,true,...]",
        "name": "torus",
        "description": "should the borders of the\ngrid be linked, so that a cell moving out on the left reappears on the\nright? Should be an array specifying whether the torus holds in each\ndimension; eg [true,false] for a torus in x but not y dimension.\nWarning: setting the torus to false can give artifacts if not done\nproperly, see {@link Grid#torus}."
      }
    ]
  },
  {
    "__docId__": 314,
    "kind": "member",
    "name": "extents",
    "memberof": "src/grid/Grid.js~Grid",
    "static": false,
    "longname": "src/grid/Grid.js~Grid#extents",
    "access": "public",
    "description": "field_size array of field size in each dimension. E.g. [100,200]\nfor a grid that is 100 pixels wide and 200 pixels high. Entries must\nbe positive integer numbers.",
    "lineNumber": 27,
    "type": {
      "nullable": null,
      "types": [
        "GridSize"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 315,
    "kind": "member",
    "name": "ndim",
    "memberof": "src/grid/Grid.js~Grid",
    "static": false,
    "longname": "src/grid/Grid.js~Grid#ndim",
    "access": "public",
    "description": "Number of dimensions of the grid.",
    "lineNumber": 31,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 316,
    "kind": "member",
    "name": "torus",
    "memberof": "src/grid/Grid.js~Grid",
    "static": false,
    "longname": "src/grid/Grid.js~Grid#torus",
    "access": "public",
    "description": "Should the borders of the grid be linked, so that a cell moving\nout on the left reappears on the right? Warning: setting to false\ncan give artifacts if done incorrectly. If torus is set to false,\nartifacts arise because\ncells at the border have fewer neighbors. Cells will then stick to\nthe grid borders where they have fewer neighbors to get adhesion and/or\nperimeter penalties from. You will need to specify how to handle the\nborders explicitly; see the examples/ folder for details on how to\ndo this.\nTorus can be specified for\neach dimension separately.",
    "lineNumber": 54,
    "type": {
      "nullable": null,
      "types": [
        "boolean[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 317,
    "kind": "member",
    "name": "_pixelArray",
    "memberof": "src/grid/Grid.js~Grid",
    "static": false,
    "longname": "src/grid/Grid.js~Grid#_pixelArray",
    "access": "private",
    "description": "Array with values for each pixel stored at the position of its\n\t{@link IndexCoordinate}. E.g. the value of pixel with coordinate\n\ti is stored as this._pixels[i]. This should be implemented in\n\tthe grid subclass; see e.g. {@link Grid2D#_pixelArray}.\n\tNote that this array is accessed indirectly via the\n{@link _pixels} set- and get methods.",
    "lineNumber": 64,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 318,
    "kind": "member",
    "name": "datatype",
    "memberof": "src/grid/Grid.js~Grid",
    "static": false,
    "longname": "src/grid/Grid.js~Grid#datatype",
    "access": "public",
    "description": null,
    "lineNumber": 65,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 319,
    "kind": "member",
    "name": "X_BITS",
    "memberof": "src/grid/Grid.js~Grid",
    "static": false,
    "longname": "src/grid/Grid.js~Grid#X_BITS",
    "access": "public",
    "description": null,
    "lineNumber": 71,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 320,
    "kind": "member",
    "name": "Y_BITS",
    "memberof": "src/grid/Grid.js~Grid",
    "static": false,
    "longname": "src/grid/Grid.js~Grid#Y_BITS",
    "access": "public",
    "description": null,
    "lineNumber": 73,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 321,
    "kind": "member",
    "name": "Y_MASK",
    "memberof": "src/grid/Grid.js~Grid",
    "static": false,
    "longname": "src/grid/Grid.js~Grid#Y_MASK",
    "access": "public",
    "description": null,
    "lineNumber": 75,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 322,
    "kind": "member",
    "name": "midpoint",
    "memberof": "src/grid/Grid.js~Grid",
    "static": false,
    "longname": "src/grid/Grid.js~Grid#midpoint",
    "access": "public",
    "description": "Array coordinates to the middle pixel on the grid.",
    "lineNumber": 80,
    "type": {
      "nullable": null,
      "types": [
        "ArrayCoordinate"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 323,
    "kind": "get",
    "name": "_pixels",
    "memberof": "src/grid/Grid.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid.js~Grid#_pixels",
    "access": "private",
    "description": "Return the array this._pixelArray, which should be set in the grid\nsubclass.",
    "lineNumber": 89,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Uint16Array|Float32Array}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Uint16Array",
        "Float32Array"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 324,
    "kind": "set",
    "name": "_pixels",
    "memberof": "src/grid/Grid.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid.js~Grid#_pixels",
    "access": "private",
    "description": "Set or update the private this._pixelArray.",
    "lineNumber": 102,
    "params": [
      {
        "nullable": null,
        "types": [
          "Uint16Array",
          "Float32Array"
        ],
        "spread": false,
        "optional": false,
        "name": "pixels",
        "description": "array of pixels to set."
      }
    ]
  },
  {
    "__docId__": 326,
    "kind": "method",
    "name": "checkOnGrid",
    "memberof": "src/grid/Grid.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid.js~Grid#checkOnGrid",
    "access": "public",
    "description": "Method to check if a given {@link ArrayCoordinate} falls within the\nbounds of this grid. Returns an error if this is not the case.",
    "lineNumber": 111,
    "params": [
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "p",
        "description": "the coordinate to check."
      }
    ],
    "return": null
  },
  {
    "__docId__": 327,
    "kind": "method",
    "name": "correctPosition",
    "memberof": "src/grid/Grid.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid.js~Grid#correctPosition",
    "access": "public",
    "description": "Method to correct an {@link ArrayCoordinate} outside the grid dimensions when\nthe grid is wrapped (torus = true). If the coordinate falls inside the grid,\nit is returned unchanged. If it falls outside the grid and the grid is periodic\nin that dimension, a corrected coordinate is returned. If the pixel falls outside\nthe grid which is not periodic in that dimension, the function returns\n'undefined'.",
    "lineNumber": 134,
    "params": [
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "p",
        "description": "the coordinate of the pixel to correct"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ArrayCoordinate"
      ],
      "spread": false,
      "description": "the corrected coordinate."
    }
  },
  {
    "__docId__": 328,
    "kind": "method",
    "name": "p2i",
    "memberof": "src/grid/Grid.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid.js~Grid#p2i",
    "access": "public",
    "description": "Method for conversion from an {@link ArrayCoordinate} to an\n{@link IndexCoordinate}.\nThis method should be implemented in the subclass, see\n{@link Grid2D#p2i} for an example.",
    "lineNumber": 180,
    "params": [
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "p",
        "description": "the coordinate of the pixel to convert"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IndexCoordinate"
      ],
      "spread": false,
      "description": "the converted coordinate."
    },
    "abstract": true
  },
  {
    "__docId__": 329,
    "kind": "method",
    "name": "i2p",
    "memberof": "src/grid/Grid.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid.js~Grid#i2p",
    "access": "public",
    "description": "Method for conversion from an {@link IndexCoordinate} to an\n{@link ArrayCoordinate}.\nThis method should be implemented in the subclass, see\n{@link Grid2D#i2p} for an example.",
    "lineNumber": 193,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "the coordinate of the pixel to convert"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ArrayCoordinate"
      ],
      "spread": false,
      "description": "the converted coordinate."
    },
    "abstract": true
  },
  {
    "__docId__": 330,
    "kind": "method",
    "name": "neighi",
    "memberof": "src/grid/Grid.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid.js~Grid#neighi",
    "access": "public",
    "description": "Method returning the (Moore) neighborhood of a pixel based on its\n{@link IndexCoordinate}.\nThis method should be implemented in the subclass, see\n{@link Grid2D#neighi} for an example.",
    "lineNumber": 209,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "the coordinate of the pixel to get neighbors\nfor."
      },
      {
        "nullable": null,
        "types": [
          "boolean[]"
        ],
        "spread": false,
        "optional": false,
        "name": "torus",
        "description": "are borders of the grid linked so that a cell\nleaving on the right re-enters the grid on the left?"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IndexCoordinate[]"
      ],
      "spread": false,
      "description": "an array of neighbors."
    },
    "abstract": true
  },
  {
    "__docId__": 331,
    "kind": "method",
    "name": "neigh",
    "memberof": "src/grid/Grid.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid.js~Grid#neigh",
    "access": "public",
    "description": "The neigh method returns the neighborhood of a pixel p. This function\nuses array coordinates as input and output arguments, but internally\ncalls a method 'neighi' which computes neighborhoods using index-\ncoordinates. Since neighborhoods depend on the coordinate system, the\n'neighi' method is defined in the extension class for that specific\ncoordinate system.",
    "lineNumber": 225,
    "params": [
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "p",
        "description": "array coordinates of a specific pixel"
      },
      {
        "nullable": null,
        "types": [
          "boolean[]"
        ],
        "spread": false,
        "optional": false,
        "name": "torus",
        "description": "are borders of the grid linked so that a cell\nleaving on the right re-enters the grid on the left?"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ArrayCoordinate[]"
      ],
      "spread": false,
      "description": "an array of neighbors of pixel p, where each\nelement contains the array coordinates of the neighbor in question."
    }
  },
  {
    "__docId__": 332,
    "kind": "method",
    "name": "_isValidValue",
    "memberof": "src/grid/Grid.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid.js~Grid#_isValidValue",
    "access": "private",
    "description": "Check if a value is valid on this type of grid.\nThis function forbids trying to set forbidden (negative/float) values\non an integer grid, which could cause bugs if the setpix(i) methods try\nto set such a value unnoticed.",
    "lineNumber": 245,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "t",
        "description": "the value that would be stored on the grid."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1e-6",
        "defaultRaw": 0.000001,
        "name": "tol",
        "description": "numeric tolerance for comparing a number\nwith its rounded version, to check if it is integer (e.g. setting\na value 1.5 on an integer grid would throw an error, but setting\n1.000000000001 would not if the tolerance is 1e-6."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "void"
      ],
      "spread": false,
      "description": "return without problem or throw an error when an\nincorrect value is set."
    }
  },
  {
    "__docId__": 333,
    "kind": "method",
    "name": "setpix",
    "memberof": "src/grid/Grid.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid.js~Grid#setpix",
    "access": "public",
    "description": "The setpix method changes the value of a pixel p on the grid to t.",
    "lineNumber": 259,
    "params": [
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "p",
        "description": "array coordinates of the pixel to change the\nvalue of"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "t",
        "description": "the value to assign to this pixel. This can\nbe integers or floating point numbers, depending on the grid subclass\nused (see eg Grid2D)."
      }
    ],
    "return": null
  },
  {
    "__docId__": 334,
    "kind": "method",
    "name": "setpixi",
    "memberof": "src/grid/Grid.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid.js~Grid#setpixi",
    "access": "public",
    "description": "The setpixi method changes the value of a pixel i on the grid to t.",
    "lineNumber": 271,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "index coordinates of the pixel to change the\nvalue of"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "t",
        "description": "the value to assign to this pixel. This can be integers\nor floating point numbers, depending on the grid subclass used\n(see eg Grid2D)."
      }
    ],
    "return": null
  },
  {
    "__docId__": 335,
    "kind": "method",
    "name": "pixt",
    "memberof": "src/grid/Grid.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid.js~Grid#pixt",
    "access": "public",
    "description": "The pixt method finds the current value of a pixel p on the grid.",
    "lineNumber": 283,
    "params": [
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "p",
        "description": "array coordinates of the pixel to find the\nvalue of"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "t the value of p on the grid. This can be integers or\nfloating point numbers, depending on the grid subclass used (see eg\nGrid2D)."
    }
  },
  {
    "__docId__": 336,
    "kind": "method",
    "name": "pixti",
    "memberof": "src/grid/Grid.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid.js~Grid#pixti",
    "access": "public",
    "description": "The pixti method finds the current value of a pixel i on the grid.",
    "lineNumber": 294,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "index coordinates of the pixel to find the\nvalue of"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "t the value of i on the grid. This can be integers or\nfloating point numbers, depending on the grid subclass used (see eg\nGrid2D)."
    }
  },
  {
    "__docId__": 337,
    "kind": "typedef",
    "name": "Pixel",
    "memberof": "src/grid/Grid.js~Grid",
    "static": true,
    "longname": "src/grid/Grid.js~Grid.Pixel",
    "access": "public",
    "description": "A pixel on the grid.",
    "properties": [
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "Pixel[0]",
        "description": "pixel coordinate"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "Pixel[1]",
        "description": "pixel value"
      }
    ],
    "type": {
      "types": [
        "Object[]"
      ],
      "optional": false,
      "name": "Pixel"
    }
  },
  {
    "__docId__": 338,
    "kind": "method",
    "name": "pixels",
    "memberof": "src/grid/Grid.js~Grid",
    "generator": true,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid.js~Grid#pixels",
    "access": "public",
    "description": "This iterator returns locations and values of all non-zero pixels.\nThis method isn't actually called because the subclasses implement\nit themselves due to efficiency reasons. It serves as a template to\ndocument the functionality.",
    "lineNumber": 318,
    "return": {
      "nullable": null,
      "types": [
        "Pixel"
      ],
      "spread": false,
      "description": "for each pixel, return an array [p,v] where p are\nthe pixel's array coordinates on the grid, and v its value."
    },
    "abstract": true,
    "params": []
  },
  {
    "__docId__": 339,
    "kind": "method",
    "name": "pixelsi",
    "memberof": "src/grid/Grid.js~Grid",
    "generator": true,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid.js~Grid#pixelsi",
    "access": "public",
    "description": "This iterator returns locations all pixels including background.\nThis method isn't actually called because the subclasses implement\nit themselves due to efficiency reasons. It serves as a template to\ndocument the functionality.",
    "lineNumber": 340,
    "return": {
      "nullable": null,
      "types": [
        "IndexCoordinate"
      ],
      "spread": false,
      "description": "for each pixel, because this method should be\nimplemented in a grid subclass."
    },
    "abstract": true,
    "params": []
  },
  {
    "__docId__": 340,
    "kind": "method",
    "name": "pixelsBuffer",
    "memberof": "src/grid/Grid.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid.js~Grid#pixelsBuffer",
    "access": "public",
    "description": "This method pre-allocates an array of the correct datatype to make\na copy of the current pixel values. Values are not actually copied yet.",
    "lineNumber": 351,
    "return": {
      "nullable": null,
      "types": [
        "Uint16Array",
        "Float32Array"
      ],
      "spread": false,
      "description": "an array with an element for each\npixel. The datatype is determined by the datatype of this._pixels\n(implemented in the subclass), which can be either Uint16Array or\nFloat32Array."
    },
    "params": []
  },
  {
    "__docId__": 341,
    "kind": "member",
    "name": "_pixelsbuffer",
    "memberof": "src/grid/Grid.js~Grid",
    "static": false,
    "longname": "src/grid/Grid.js~Grid#_pixelsbuffer",
    "access": "private",
    "description": "For storing a copy of all pixel values; eg for synchronous updating\nof some sort.",
    "lineNumber": 356,
    "type": {
      "nullable": null,
      "types": [
        "Uint16Array",
        "Float32Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 344,
    "kind": "method",
    "name": "gradienti",
    "memberof": "src/grid/Grid.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid.js~Grid#gradienti",
    "access": "public",
    "description": "Template method to compute the gradient at location i on the grid\n(location given in index coordinates).\nThis method throws an error, which is overwritten when a subclass\nimplements a gradienti method.",
    "see": [
      "https://en.wikipedia.org/wiki/Gradient"
    ],
    "lineNumber": 376,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "index coordinate of a pixel to compute the\ngradient at."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "the gradient"
    }
  },
  {
    "__docId__": 345,
    "kind": "method",
    "name": "gradient",
    "memberof": "src/grid/Grid.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid.js~Grid#gradient",
    "access": "public",
    "description": "Method to compute the gradient at location p on the grid (location\ngiven in array coordinates). It internally calls the gradienti\nmethod using index coordinates, which should be implemented in the grid\nsubclass.",
    "see": [
      "https://en.wikipedia.org/wiki/Gradient"
    ],
    "lineNumber": 388,
    "params": [
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "p",
        "description": "array coordinates of a pixel p to compute\nthe gradient at"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the gradient at position p."
    }
  },
  {
    "__docId__": 346,
    "kind": "method",
    "name": "laplacian",
    "memberof": "src/grid/Grid.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid.js~Grid#laplacian",
    "access": "public",
    "description": "Method to compute the laplacian at location p on the grid\n(location given in array coordinates). It internally calls the laplaciani\nmethod that does the same but uses index coordinates.",
    "see": [
      "https://en.wikipedia.org/wiki/Laplace_operator#Coordinate_expressions"
    ],
    "lineNumber": 400,
    "params": [
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "p",
        "description": "array coordinates of a pixel p to compute the\nlaplacian at"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the laplacian at position p."
    }
  },
  {
    "__docId__": 347,
    "kind": "method",
    "name": "neighNeumanni",
    "memberof": "src/grid/Grid.js~Grid",
    "generator": true,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid.js~Grid#neighNeumanni",
    "access": "public",
    "description": "A method to compute the Neumann neighborhood should be implemented in the\nGrid subclass if the laplacian (see below) is used.\nThis mock function ensures that an error is thrown when there is no\nmethod called neighNeumanni in the grid subclass.",
    "see": [
      "https://en.wikipedia.org/wiki/Von_Neumann_neighborhood"
    ],
    "lineNumber": 417,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "location of the pixel to get neighbors of."
      },
      {
        "nullable": null,
        "types": [
          "boolean[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[true,true]",
        "defaultRaw": [
          true,
          true
        ],
        "name": "torus",
        "description": "does the grid have linked\nborders? Defaults to the setting on this grid, see {@link torus}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IndexCoordinate[]"
      ],
      "spread": false,
      "description": "an array of coordinates for all the neighbors of i."
    },
    "abstract": true
  },
  {
    "__docId__": 348,
    "kind": "method",
    "name": "laplaciani",
    "memberof": "src/grid/Grid.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid.js~Grid#laplaciani",
    "access": "public",
    "description": "Method to compute the laplacian at location i on the grid (location\ngiven in index coordinates). It internally uses the neighNeumanni method\nto compute a Neumann neighborhood, which should be implemented in the\ngrid subclass. It then uses the finite difference method (see link) with\nh = 1.",
    "see": [
      "https://en.wikipedia.org/wiki/Laplace_operator#Coordinate_expressions",
      "https://en.wikipedia.org/wiki/Discrete_Laplace_operator#Finite_differences"
    ],
    "lineNumber": 433,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "index coordinates of a pixel to compute the\nlaplacian at"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the laplacian at position p."
    }
  },
  {
    "__docId__": 349,
    "kind": "method",
    "name": "diffusion",
    "memberof": "src/grid/Grid.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid.js~Grid#diffusion",
    "access": "public",
    "description": "Perform a diffusion step on the grid, updating the values of all pixels\naccording to Fick's second law of diffusion.",
    "see": [
      "https://en.wikipedia.org/wiki/Diffusion#Fick's_law_and_equations",
      "https://en.wikipedia.org/wiki/Discrete_Laplace_operator#Mesh_Laplacians"
    ],
    "lineNumber": 459,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "D",
        "description": "diffusion coefficient"
      }
    ],
    "return": null
  },
  {
    "__docId__": 350,
    "kind": "typedef",
    "name": "updatePixelFunction",
    "memberof": "src/grid/Grid.js~Grid",
    "static": true,
    "longname": "src/grid/Grid.js~Grid.updatePixelFunction",
    "access": "public",
    "description": "Function that updates a gridpoint depending on its current value and\nthat of its neighbors.",
    "params": [
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "p",
        "description": "pixel to update"
      },
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate[]"
        ],
        "spread": false,
        "optional": false,
        "name": "neighbors",
        "description": "coordinates of neighbors of p"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "value - the updated value, based on the current value\nof p and its neighbors."
    },
    "type": {
      "types": [
        "function"
      ],
      "optional": false,
      "name": "updatePixelFunction"
    }
  },
  {
    "__docId__": 351,
    "kind": "method",
    "name": "applyLocally",
    "memberof": "src/grid/Grid.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid.js~Grid#applyLocally",
    "access": "public",
    "description": "Apply a function to all pixel values on the grid. It acts on\nthis._pixels, which is implemented in the grid subclass.",
    "lineNumber": 485,
    "params": [
      {
        "nullable": null,
        "types": [
          "updatePixelFunction"
        ],
        "spread": false,
        "optional": false,
        "name": "f",
        "description": "the function to apply to each pixel."
      }
    ],
    "return": null
  },
  {
    "__docId__": 352,
    "kind": "method",
    "name": "multiplyBy",
    "memberof": "src/grid/Grid.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid.js~Grid#multiplyBy",
    "access": "public",
    "description": "Multiply all pixel values on the grid with a constant factor r.\nThis method acts on this._pixels, which is implemented in the grid\nsubclass.",
    "lineNumber": 498,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "r",
        "description": "the multiplication factor."
      }
    ],
    "return": null
  },
  {
    "__docId__": 353,
    "kind": "file",
    "name": "src/grid/Grid2D.js",
    "content": "import Grid from \"./Grid.js\"\n\n/** A class containing (mostly static) utility functions for dealing with 2D\n *  grids. Extends the Grid class but implements functions specific to the 2D\n *  grid (such as neighborhoods).\n *\n *  @example <caption>Diffusion on a 2D chemokine grid</caption>\n *  let CPM = require(\"path/to/build\")\n *\n *  // Make a grid with a chemokine, add some chemokine at the middle pixel\n * let chemoGrid = new CPM.Grid2D( [100,100], [true,true], \"Float32\" )\n * chemoGrid.setpix( [50,50], 100 )\n *\n * // Measure chemokine at different spots before and after diffusion\n * let p1 = [50,50], p2 = [50,51]\n * console.log( \"p1: \" + chemoGrid.pixt( p1 ) + \", p2: \" + chemoGrid.pixt(p2) )\n * chemoGrid.diffusion( 0.001 )\n * console.log( \"p1: \" + chemoGrid.pixt( p1 ) + \", p2: \" + chemoGrid.pixt(p2) )\n * chemoGrid.multiplyBy( 0.9 )\t // decay of the chemokine\n * console.log( \"p1: \" + chemoGrid.pixt( p1 ) + \", p2: \" + chemoGrid.pixt(p2) )\n *\n * @example <caption>Neighborhoods on a 2D grid</caption>\n *\n * let CPM = require(\"path/to/build\")\n *\n * // Make a grid with a torus, and find the neighborhood of the upper left pixel [0,0]\n * let grid = new CPM.Grid2D( [100,100], [true,true] )\n * console.log( grid.neigh( [0,0] ) ) // returns coordinates of 8 neighbors\n *\n * // Now try a grid without torus; the corner now has fewer neighbors.\n * let grid2 = new CPM.Grid2D( [100,100], [false,false] )\n * console.log( grid2.neigh( [0,0] ) ) // returns only 3 neighbors\n *\n * // Or try a Neumann neighborhood using the iterator\n * for( let i of grid.neighNeumanni( 0 ) ){\n * \tconsole.log( grid.i2p(i).join(\" \") )\n * }\n */\n\nclass Grid2D extends Grid {\n\n\t/** Constructor of the Grid2D object.\n\t * @param {GridSize} extents - the size of the grid in each dimension\n\t * @param {boolean[]} [torus=[true,true]] - should the borders of the grid\n\t * be linked, so that a cell moving out on the left reappears on the right?\n\t * Should be an array specifying whether the torus holds in each dimension;\n\t * eg [true,false] for a torus in x but not y dimension.\n\t * Warning: setting the torus to false can give artifacts if not done\n\t * properly, see {@link Grid#torus}.\n\t * @param {string} [datatype=\"Uint16\"] - What datatype are the values\n\t * associated with each pixel on the grid? Choose from \"Uint16\" or\n\t * \"Float32\". */\n\tconstructor( extents, torus=[true,true], datatype=\"Uint16\" ){\n\t\tsuper( extents, torus )\n\t\t\n\t\t/** @ignore */\n\t\tthis.X_STEP = 1 << this.Y_BITS // for neighborhoods based on pixel index\n\t\t/** @ignore */\n\t\tthis.Y_MASK = this.X_STEP-1\n\t\t// Check that the grid size is not too big to store pixel ID in 32-bit\n\t\t// number, and allow fast conversion of coordinates to unique\n\t\t// ID numbers.\n\t\tif( this.X_BITS + this.Y_BITS > 32 ){\n\t\t\tthrow(\"Field size too large -- field cannot be represented as 32-bit number\")\n\t\t}\n\n\t\tthis.datatype = datatype\n\n\t\t// Attributes per pixel: CellId of the current pixel.\n\t\tif( datatype === \"Uint16\" ){\n\t\t\t/** Array with values for each pixel stored at the position of its\n\t\t\t * {@link IndexCoordinate}. E.g. the value of pixel with coordinate\n\t\t\t * i is stored as this._pixelArray[i].\n\t\t\t * \tNote that this array is accessed indirectly via the\n\t\t\t * {@link _pixels} set- and get methods.\n\t\t\t * @private\n\t\t\t * @type {Uint16Array|Float32Array} */\n\t\t\tthis._pixelArray = new Uint16Array(this.p2i(this.extents))\n\t\t} else if( datatype === \"Float32\" ){\n\t\t\tthis._pixelArray = new Float32Array(this.p2i(this.extents))\n\t\t} else {\n\t\t\tthrow(\"unsupported datatype: \" + datatype)\n\t\t}\n\t}\n\n\t/** This iterator returns locations and values of all pixels.\n\t * Whereas the {@link pixels} generator yields only non-background pixels\n\t * and specifies both their {@link ArrayCoordinate} and value, this\n\t * generator yields all pixels by {@link IndexCoordinate} and does not\n\t * report value.\n\t *\n\t * @return {IndexCoordinate} for each pixel on the grid (including\n\t * background pixels).\n\t *\n\t * @example\n\t * let CPM = require( \"path/to/build\" )\n\t * // make a grid and set some values\n\t * let grid = new CPM.Grid2D( [100,100], [true,true] )\n\t * grid.setpixi( 0, 1 )\n\t * grid.setpixi( 1, 5 )\n\t *\n\t * // iterator\n\t * for( let i of grid.pixelsi() ){\n\t * \tconsole.log( i )\n\t * }\n\t */\n\t* pixelsi() {\n\t\tlet ii = 0, c = 0\n\t\tfor( let i = 0 ; i < this.extents[0] ; i ++ ){\n\t\t\tfor( let j = 0 ; j < this.extents[1] ; j ++ ){\n\t\t\t\tyield ii\n\t\t\t\tii ++\n\t\t\t}\n\t\t\tc += this.X_STEP\n\t\t\tii = c\n\t\t}\n\t}\n\t\n\t/** This iterator returns locations and values of all non-zero pixels.\n\t * @return {Pixel} for each pixel, return an array [p,v] where p are\n\t * the pixel's array coordinates on the grid, and v its value.\n\t *\n\t * @example\n\t * let CPM = require( \"path/to/build\" )\n\t * // make a grid and set some values\n\t * let grid = new CPM.Grid2D( [100,100], [true,true] )\n\t * grid.setpix( [0,0], 1 )\n\t * grid.setpix( [0,1], 5 )\n\t *\n\t * // iterator\n\t * for( let p of grid.pixels() ){\n\t * \tconsole.log( p )\n\t * }\n\t */\n\t* pixels() {\n\t\tlet ii = 0, c = 0\n\t\t// Loop over coordinates [i,j] on the grid\n\t\t// For each pixel with cellId != 0 (so non-background pixels),\n\t\t// return an array with in the first element the pixel \n\t\t// coordinates p = [i,j], and in the second element the cellId of this pixel.\n\t\tfor( let i = 0 ; i < this.extents[0] ; i ++ ){\n\t\t\tfor( let j = 0 ; j < this.extents[1] ; j ++ ){\n\n\t\t\t\t//noinspection JSUnresolvedVariable\n\t\t\t\tlet pixels = this._pixels\n\t\t\t\tif( pixels[ii] > 0 ){ //check non-background\n\t\t\t\t\tyield [[i,j], pixels[ii]]\n\t\t\t\t}\n\t\t\t\tii ++\n\t\t\t}\n\t\t\tc += this.X_STEP\n\t\t\tii = c\n\t\t}\n\t}\n\n\t/**\tSimple method for neighborhood computation. This method is not\n\t * actually used in the framework, except to test the less intuitive\n\t * (but faster) neighi method that works directly on index coordinates\n\t * rather than first converting to array positions (which is expensive\n\t * as  neighborhoods are computed very often in the CPM).\n\t * @ignore\n\t * @param {IndexCoordinate} i - location of the pixel to get neighbors of.\n\t * @return {IndexCoordinate[]} - an array of coordinates for all the\n\t * neighbors of i.\n\t*/\n\tneighiSimple( i ){\n\t\tlet p = this.i2p(i)\n\t\tlet xx = []\n\t\tfor( let d = 0 ; d <= 1 ; d ++ ){\n\t\t\tif( p[d] === 0 ){\n\t\t\t\tif( this.torus[d] ){\n\t\t\t\t\txx[d] = [p[d],this.extents[d]-1,p[d]+1]\n\t\t\t\t} else {\n\t\t\t\t\txx[d] = [p[d],p[d]+1]\n\t\t\t\t}\n\t\t\t} else if( p[d] === this.extents[d]-1 ){\n\t\t\t\tif( this.torus[d] ){\n\t\t\t\t\txx[d] = [p[d],p[d]-1,0]\n\t\t\t\t} else {\n\t\t\t\t\txx[d] = [p[d],p[d]-1]\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\txx[d] = [p[d],p[d]-1,p[d]+1]\n\t\t\t}\n\t\t}\n\n\t\tlet r = [], first=true\n\t\tfor( let x of xx[0] ){\n\t\t\tfor( let y of xx[1] ){\n\t\t\t\tif( first ){\n\t\t\t\t\tfirst = false \n\t\t\t\t} else {\n\t\t\t\t\tr.push( this.p2i( [x,y] ) )\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn r\n\t}\n\t\n\t/**\tReturn array of {@link IndexCoordinate} of von Neumann-4 neighbor\n\t * pixels of the pixel at coordinate i. This function takes the 2D\n\t * Neumann-4 neighborhood, excluding the pixel itself.\n\t * @see https://en.wikipedia.org/wiki/Von_Neumann_neighborhood\n\t * @param {IndexCoordinate} i - location of the pixel to get neighbors of.\n\t * @param {boolean[]} [torus=[true,true]] - does the grid have linked\n\t * borders? Defaults to the setting on this grid, see {@link torus}\n\t * @return {IndexCoordinate[]} - an array of coordinates for all the\n\t * neighbors of i.\n\t*/\n\t* neighNeumanni( i, torus = this.torus ){\n\t\t// normal computation of neighbor indices (top left-middle-right, \n\t\t// left, right, bottom left-middle-right)\n\t\tlet t = i-1, l = i-this.X_STEP, r = i+this.X_STEP, b = i+1\n\t\t\n\t\t// if pixel is part of one of the borders, adjust the \n\t\t// indices accordingly\n\t\t// if torus is false, return NaN for all neighbors that cross\n\t\t// the border.\n\n\t\t// left border\n\t\tif( i < this.extents[1] ){\n\t\t\tif( torus[0] ){\n\t\t\t\tl += this.extents[0] * this.X_STEP\n\t\t\t\tyield l\n\t\t\t} \n\t\t} else {\n\t\t\tyield l\n\t\t}\n\t\t// right border\n\t\tif( i >= this.X_STEP*( this.extents[0] - 1 ) ){\n\t\t\tif( torus[0] ){\n\t\t\t\tr -= this.extents[0] * this.X_STEP\n\t\t\t\tyield r\n\t\t\t}\n\t\t} else {\n\t\t\tyield r\n\t\t}\n\t\t// top border\n\t\tif( i % this.X_STEP === 0 ){\n\t\t\tif( torus[1] ){\n\t\t\t\tt += this.extents[1]\n\t\t\t\tyield t\n\t\t\t} \n\t\t} else {\n\t\t\tyield t\n\t\t}\n\t\t// bottom border\n\t\tif( (i+1-this.extents[1]) % this.X_STEP === 0 ){\n\t\t\tif( torus[1] ){\n\t\t\t\tb -= this.extents[1]\n\t\t\t\tyield b\n\t\t\t} \n\t\t} else {\n\t\t\tyield b\n\t\t}\n\t}\n\t/**\tReturn array of {@link IndexCoordinate} of Moore-8 neighbor pixels of\n\t * the pixel at coordinate i. This function takes the 2D Moore-8\n\t * neighborhood, excluding the pixel itself.\n\t * @see https://en.wikipedia.org/wiki/Moore_neighborhood\n\t * @param {IndexCoordinate} i - location of the pixel to get neighbors of.\n\t * @param {boolean[]} [torus] - does the grid have linked borders? Defaults\n\t * to the setting on this grid, see {@link torus}\n\t * @return {IndexCoordinate[]} - an array of coordinates for all the\n\t * neighbors of i.\n\t*/\n\tneighi( i, torus = this.torus ){\t\n\t\t// normal computation of neighbor indices (top left-middle-right, \n\t\t// left, right, bottom left-middle-right)\n\t\tlet tl, tm, tr, l, r, bl, bm, br\n\t\t\n\t\ttl = i-1-this.X_STEP; tm = i-1; tr = i-1+this.X_STEP\n\t\tl = i-this.X_STEP; r = i+this.X_STEP\n\t\tbl = i+1-this.X_STEP; bm = i+1; br = i+1+this.X_STEP\n\t\t\n\t\t// if pixel is part of one of the borders, adjust the \n\t\t// indices accordingly\n\t\tlet add = NaN // if torus is false, return NaN for all neighbors that cross\n\t\t// the border.\n\t\t// \n\t\t// left border\n\t\tif( i < this.extents[1] ){\n\t\t\tif( torus[0] ){\n\t\t\t\tadd = this.extents[0] * this.X_STEP\n\t\t\t}\n\t\t\ttl += add; l += add; bl += add \t\n\t\t}\n\t\t\n\t\t// right border\n\t\tif( i >= this.X_STEP*( this.extents[0] - 1 ) ){\n\t\t\tif( torus[0] ){\n\t\t\t\tadd = -this.extents[0] * this.X_STEP\n\t\t\t}\n\t\t\ttr += add; r += add; br += add\n\t\t}\n\n\t\tadd = NaN\n\t\t// top border\n\t\tif( i % this.X_STEP === 0 ){\n\t\t\tif( torus[1] ){\n\t\t\t\tadd = this.extents[1]\n\t\t\t}\n\t\t\ttl += add; tm += add; tr += add\t\n\t\t}\n\t\t\n\t\t// bottom border\n\t\tif( (i+1-this.extents[1]) % this.X_STEP === 0 ){\n\t\t\tif( torus[1] ){\n\t\t\t\tadd = -this.extents[1]\n\t\t\t}\n\t\t\tbl += add; bm += add; br += add\n\t\t}\n\t\tif( !(torus[0]&&torus[1]) ){\n\t\t\treturn [ tl, l, bl, tm, bm, tr, r, br ].filter( isFinite )\n\t\t} else {\n\t\t\treturn [ tl, l, bl, tm, bm, tr, r, br ]\n\t\t}\n\t}\n\t\n\t/** Method for conversion from an {@link ArrayCoordinate} to an\n\t * {@link IndexCoordinate}.\n\t *\n\t * See also {@link Grid2D#i2p} for the backward conversion.\n\t *\n\t * @param {ArrayCoordinate} p - the coordinate of the pixel to convert\n\t * @return {IndexCoordinate} the converted coordinate.\n\t *\n\t * @example\n\t * let grid = new CPM.Grid2D( [100,100], [true,true] )\n\t * let p = grid.i2p( 5 )\n\t * console.log( p )\n\t * console.log( grid.p2i( p ))\n\t */\n\tp2i ( p ){\n\t\t// using bitwise operators for speed.\n\t\treturn ( p[0] << this.Y_BITS ) + p[1]\n\t}\n\n\t/** Method for conversion from an {@link IndexCoordinate} to an\n\t * {@link ArrayCoordinate}.\n\t * See also {@link Grid2D#p2i} for the backward conversion.\n\t *\n\t * @param {IndexCoordinate} i - the coordinate of the pixel to convert\n\t * @return {ArrayCoordinate} the converted coordinate.\n\t *\n\t * @example\n\t * let grid = new CPM.Grid2D( [100,100], [true,true] )\n\t * let p = grid.i2p( 5 )\n\t * console.log( p )\n\t * console.log( grid.p2i( p ))\n\t */\n\ti2p ( i ){\n\t\t// using bitwise operators for speed.\n\t\treturn [i >> this.Y_BITS, i & this.Y_MASK]\n\t}\n\t\n\t/** Method to compute the gradient at location i on the grid (location\n\t * given as an {@link IndexCoordinate}).\n\t * @param {IndexCoordinate} i - index coordinate of a pixel to compute the\n\t * gradient at\n\t * @return {number[]} the gradient at position i.\n\t * @see https://en.wikipedia.org/wiki/Gradient */\n\tgradienti( i ){\n\t\tlet t = i-1, b = i+1, l = i-this.X_STEP, r = i+this.X_STEP,\n\t\t\ttorus = this.torus\n\t\t//noinspection JSUnresolvedVariable\n\t\tconst pixels = this._pixels\n\t\t\n\t\tlet dx\n\t\tif( i < this.extents[1] ){ // left border\n\t\t\tif( torus[0] ){\n\t\t\t\tl += this.extents[0] * this.X_STEP\n\t\t\t\tdx = ((pixels[r]-pixels[i])+\n\t\t\t\t\t(pixels[i]-pixels[l]))/2\n\t\t\t} else {\n\t\t\t\tdx = pixels[r]-pixels[i]\n\t\t\t}\n\t\t} else { \n\t\t\tif( i >= this.X_STEP*( this.extents[0] - 1 ) ){ // right border\n\t\t\t\tif( torus[0] ){\n\t\t\t\t\tr -= this.extents[0] * this.X_STEP\n\t\t\t\t\tdx = ((pixels[r]-pixels[i])+\n\t\t\t\t\t\t(pixels[i]-pixels[l]))/2\n\t\t\t\t} else {\n\t\t\t\t\tdx = pixels[i]-pixels[l]\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdx = ((pixels[r]-pixels[i])+\n\t\t\t\t\t(pixels[i]-pixels[l]))/2\n\t\t\t}\n\t\t}\n\n\t\tlet dy\n\t\tif( i % this.X_STEP === 0 ){ // top border\n\t\t\tif( torus[1] ){\n\t\t\t\tt += this.extents[1]\n\t\t\t\tdy = ((pixels[b]-pixels[i])+\n\t\t\t\t\t(pixels[i]-pixels[t]))/2\n\t\t\t}\telse {\n\t\t\t\tdy = pixels[b]-pixels[i]\n\t\t\t}\n\t\t} else { \n\t\t\tif( (i+1-this.extents[1]) % this.X_STEP === 0 ){ // bottom border\n\t\t\t\tif( torus[1] ){\n\t\t\t\t\tb -= this.extents[1]\n\t\t\t\t\tdy = ((pixels[b]-pixels[i])+\n\t\t\t\t\t\t(pixels[i]-pixels[t]))/2\n\t\t\t\t} else {\n\t\t\t\t\tdy = pixels[i]-pixels[t]\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdy = ((pixels[b]-pixels[i])+\n\t\t\t\t\t(pixels[i]-pixels[t]))/2\n\t\t\t}\n\t\t}\n\t\treturn [dx, dy]\n\t}\n}\n\n\n\nexport default Grid2D \n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/grid/Grid2D.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 354,
    "kind": "class",
    "name": "Grid2D",
    "memberof": "src/grid/Grid2D.js",
    "static": true,
    "longname": "src/grid/Grid2D.js~Grid2D",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/grid/Grid2D.js",
    "importStyle": "Grid2D",
    "description": "A class containing (mostly static) utility functions for dealing with 2D\n grids. Extends the Grid class but implements functions specific to the 2D\n grid (such as neighborhoods).",
    "examples": [
      "<caption>Diffusion on a 2D chemokine grid</caption>\n let CPM = require(\"path/to/build\")\n\n // Make a grid with a chemokine, add some chemokine at the middle pixel\nlet chemoGrid = new CPM.Grid2D( [100,100], [true,true], \"Float32\" )\nchemoGrid.setpix( [50,50], 100 )\n\n// Measure chemokine at different spots before and after diffusion\nlet p1 = [50,50], p2 = [50,51]\nconsole.log( \"p1: \" + chemoGrid.pixt( p1 ) + \", p2: \" + chemoGrid.pixt(p2) )\nchemoGrid.diffusion( 0.001 )\nconsole.log( \"p1: \" + chemoGrid.pixt( p1 ) + \", p2: \" + chemoGrid.pixt(p2) )\nchemoGrid.multiplyBy( 0.9 )\t // decay of the chemokine\nconsole.log( \"p1: \" + chemoGrid.pixt( p1 ) + \", p2: \" + chemoGrid.pixt(p2) )",
      "<caption>Neighborhoods on a 2D grid</caption>\n\nlet CPM = require(\"path/to/build\")\n\n// Make a grid with a torus, and find the neighborhood of the upper left pixel [0,0]\nlet grid = new CPM.Grid2D( [100,100], [true,true] )\nconsole.log( grid.neigh( [0,0] ) ) // returns coordinates of 8 neighbors\n\n// Now try a grid without torus; the corner now has fewer neighbors.\nlet grid2 = new CPM.Grid2D( [100,100], [false,false] )\nconsole.log( grid2.neigh( [0,0] ) ) // returns only 3 neighbors\n\n// Or try a Neumann neighborhood using the iterator\nfor( let i of grid.neighNeumanni( 0 ) ){\n\tconsole.log( grid.i2p(i).join(\" \") )\n}"
    ],
    "lineNumber": 40,
    "interface": false,
    "extends": [
      "src/grid/Grid.js~Grid"
    ]
  },
  {
    "__docId__": 355,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/grid/Grid2D.js~Grid2D",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid2D.js~Grid2D#constructor",
    "access": "public",
    "description": "Constructor of the Grid2D object.",
    "lineNumber": 53,
    "params": [
      {
        "nullable": null,
        "types": [
          "GridSize"
        ],
        "spread": false,
        "optional": false,
        "name": "extents",
        "description": "the size of the grid in each dimension"
      },
      {
        "nullable": null,
        "types": [
          "boolean[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[true,true]",
        "defaultRaw": [
          true,
          true
        ],
        "name": "torus",
        "description": "should the borders of the grid\nbe linked, so that a cell moving out on the left reappears on the right?\nShould be an array specifying whether the torus holds in each dimension;\neg [true,false] for a torus in x but not y dimension.\nWarning: setting the torus to false can give artifacts if not done\nproperly, see {@link Grid#torus}."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "\"Uint16\"",
        "defaultRaw": "Uint16",
        "name": "datatype",
        "description": "What datatype are the values\nassociated with each pixel on the grid? Choose from \"Uint16\" or\n\"Float32\"."
      }
    ]
  },
  {
    "__docId__": 356,
    "kind": "member",
    "name": "X_STEP",
    "memberof": "src/grid/Grid2D.js~Grid2D",
    "static": false,
    "longname": "src/grid/Grid2D.js~Grid2D#X_STEP",
    "access": "public",
    "description": null,
    "lineNumber": 57,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 357,
    "kind": "member",
    "name": "Y_MASK",
    "memberof": "src/grid/Grid2D.js~Grid2D",
    "static": false,
    "longname": "src/grid/Grid2D.js~Grid2D#Y_MASK",
    "access": "public",
    "description": null,
    "lineNumber": 59,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 358,
    "kind": "member",
    "name": "datatype",
    "memberof": "src/grid/Grid2D.js~Grid2D",
    "static": false,
    "longname": "src/grid/Grid2D.js~Grid2D#datatype",
    "access": "public",
    "description": null,
    "lineNumber": 67,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 359,
    "kind": "member",
    "name": "_pixelArray",
    "memberof": "src/grid/Grid2D.js~Grid2D",
    "static": false,
    "longname": "src/grid/Grid2D.js~Grid2D#_pixelArray",
    "access": "private",
    "description": "Array with values for each pixel stored at the position of its\n{@link IndexCoordinate}. E.g. the value of pixel with coordinate\ni is stored as this._pixelArray[i].\n\tNote that this array is accessed indirectly via the\n{@link _pixels} set- and get methods.",
    "lineNumber": 78,
    "type": {
      "nullable": null,
      "types": [
        "Uint16Array",
        "Float32Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 361,
    "kind": "method",
    "name": "pixelsi",
    "memberof": "src/grid/Grid2D.js~Grid2D",
    "generator": true,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid2D.js~Grid2D#pixelsi",
    "access": "public",
    "description": "This iterator returns locations and values of all pixels.\nWhereas the {@link pixels} generator yields only non-background pixels\nand specifies both their {@link ArrayCoordinate} and value, this\ngenerator yields all pixels by {@link IndexCoordinate} and does not\nreport value.",
    "examples": [
      "let CPM = require( \"path/to/build\" )\n// make a grid and set some values\nlet grid = new CPM.Grid2D( [100,100], [true,true] )\ngrid.setpixi( 0, 1 )\ngrid.setpixi( 1, 5 )\n\n// iterator\nfor( let i of grid.pixelsi() ){\n\tconsole.log( i )\n}"
    ],
    "lineNumber": 107,
    "return": {
      "nullable": null,
      "types": [
        "IndexCoordinate"
      ],
      "spread": false,
      "description": "for each pixel on the grid (including\nbackground pixels)."
    },
    "params": []
  },
  {
    "__docId__": 362,
    "kind": "method",
    "name": "pixels",
    "memberof": "src/grid/Grid2D.js~Grid2D",
    "generator": true,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid2D.js~Grid2D#pixels",
    "access": "public",
    "description": "This iterator returns locations and values of all non-zero pixels.",
    "examples": [
      "let CPM = require( \"path/to/build\" )\n// make a grid and set some values\nlet grid = new CPM.Grid2D( [100,100], [true,true] )\ngrid.setpix( [0,0], 1 )\ngrid.setpix( [0,1], 5 )\n\n// iterator\nfor( let p of grid.pixels() ){\n\tconsole.log( p )\n}"
    ],
    "lineNumber": 135,
    "return": {
      "nullable": null,
      "types": [
        "Pixel"
      ],
      "spread": false,
      "description": "for each pixel, return an array [p,v] where p are\nthe pixel's array coordinates on the grid, and v its value."
    },
    "params": []
  },
  {
    "__docId__": 363,
    "kind": "method",
    "name": "neighiSimple",
    "memberof": "src/grid/Grid2D.js~Grid2D",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid2D.js~Grid2D#neighiSimple",
    "access": "public",
    "description": "Simple method for neighborhood computation. This method is not\nactually used in the framework, except to test the less intuitive\n(but faster) neighi method that works directly on index coordinates\nrather than first converting to array positions (which is expensive\nas  neighborhoods are computed very often in the CPM).",
    "lineNumber": 166,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "location of the pixel to get neighbors of."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IndexCoordinate[]"
      ],
      "spread": false,
      "description": "an array of coordinates for all the\nneighbors of i."
    }
  },
  {
    "__docId__": 364,
    "kind": "method",
    "name": "neighNeumanni",
    "memberof": "src/grid/Grid2D.js~Grid2D",
    "generator": true,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid2D.js~Grid2D#neighNeumanni",
    "access": "public",
    "description": "Return array of {@link IndexCoordinate} of von Neumann-4 neighbor\npixels of the pixel at coordinate i. This function takes the 2D\nNeumann-4 neighborhood, excluding the pixel itself.",
    "see": [
      "https://en.wikipedia.org/wiki/Von_Neumann_neighborhood"
    ],
    "lineNumber": 210,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "location of the pixel to get neighbors of."
      },
      {
        "nullable": null,
        "types": [
          "boolean[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[true,true]",
        "defaultRaw": [
          true,
          true
        ],
        "name": "torus",
        "description": "does the grid have linked\nborders? Defaults to the setting on this grid, see {@link torus}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IndexCoordinate[]"
      ],
      "spread": false,
      "description": "an array of coordinates for all the\nneighbors of i."
    }
  },
  {
    "__docId__": 365,
    "kind": "method",
    "name": "neighi",
    "memberof": "src/grid/Grid2D.js~Grid2D",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid2D.js~Grid2D#neighi",
    "access": "public",
    "description": "Return array of {@link IndexCoordinate} of Moore-8 neighbor pixels of\nthe pixel at coordinate i. This function takes the 2D Moore-8\nneighborhood, excluding the pixel itself.",
    "see": [
      "https://en.wikipedia.org/wiki/Moore_neighborhood"
    ],
    "lineNumber": 267,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "location of the pixel to get neighbors of."
      },
      {
        "nullable": null,
        "types": [
          "boolean[]"
        ],
        "spread": false,
        "optional": true,
        "name": "torus",
        "description": "does the grid have linked borders? Defaults\nto the setting on this grid, see {@link torus}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IndexCoordinate[]"
      ],
      "spread": false,
      "description": "an array of coordinates for all the\nneighbors of i."
    }
  },
  {
    "__docId__": 366,
    "kind": "method",
    "name": "p2i",
    "memberof": "src/grid/Grid2D.js~Grid2D",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid2D.js~Grid2D#p2i",
    "access": "public",
    "description": "Method for conversion from an {@link ArrayCoordinate} to an\n{@link IndexCoordinate}.\n\nSee also {@link Grid2D#i2p} for the backward conversion.",
    "examples": [
      "let grid = new CPM.Grid2D( [100,100], [true,true] )\nlet p = grid.i2p( 5 )\nconsole.log( p )\nconsole.log( grid.p2i( p ))"
    ],
    "lineNumber": 334,
    "params": [
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "p",
        "description": "the coordinate of the pixel to convert"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IndexCoordinate"
      ],
      "spread": false,
      "description": "the converted coordinate."
    }
  },
  {
    "__docId__": 367,
    "kind": "method",
    "name": "i2p",
    "memberof": "src/grid/Grid2D.js~Grid2D",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid2D.js~Grid2D#i2p",
    "access": "public",
    "description": "Method for conversion from an {@link IndexCoordinate} to an\n{@link ArrayCoordinate}.\nSee also {@link Grid2D#p2i} for the backward conversion.",
    "examples": [
      "let grid = new CPM.Grid2D( [100,100], [true,true] )\nlet p = grid.i2p( 5 )\nconsole.log( p )\nconsole.log( grid.p2i( p ))"
    ],
    "lineNumber": 352,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "the coordinate of the pixel to convert"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ArrayCoordinate"
      ],
      "spread": false,
      "description": "the converted coordinate."
    }
  },
  {
    "__docId__": 368,
    "kind": "method",
    "name": "gradienti",
    "memberof": "src/grid/Grid2D.js~Grid2D",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid2D.js~Grid2D#gradienti",
    "access": "public",
    "description": "Method to compute the gradient at location i on the grid (location\ngiven as an {@link IndexCoordinate}).",
    "see": [
      "https://en.wikipedia.org/wiki/Gradient"
    ],
    "lineNumber": 363,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "index coordinate of a pixel to compute the\ngradient at"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "the gradient at position i."
    }
  },
  {
    "__docId__": 369,
    "kind": "file",
    "name": "src/grid/Grid3D.js",
    "content": "import Grid from \"./Grid.js\"\n\n/** A class containing (mostly static) utility functions for dealing with 3D\n * \tgrids. Extends the Grid class but implements functions specific to the 3D\n * \tgrid (such as neighborhoods).\n *\n * @example <caption>Neighborhoods on a 3D grid</caption>\n *\n * let CPM = require(\"path/to/build\")\n *\n * // Make a grid with a torus, and find the neighborhood of the upper left pixel [0,0,0]\n * let grid = new CPM.Grid3D( [100,100,100], [true,true,true] )\n * console.log( grid.neigh( [0,0,0] ) ) // returns coordinates of 26 neighbors (9+8+9)\n *\n * // Now try a grid without torus; the corner now has fewer neighbors.\n * let grid2 = new CPM.Grid3D( [100,100,100], [false,false,false] )\n * console.log( grid2.neigh( [0,0,0] ) ) // returns only 7 neighbors\n *\n * // Or try a torus in one dimension\n * let grid2 = new CPM.Grid3D( [100,100,100], [true,false,false] )\n * console.log( grid2.neigh( [0,0,0] ) )\n */\nclass Grid3D extends Grid {\n\n\t/** Constructor of the Grid3D object.\n\t * @param {GridSize} extents - the size of the grid in each dimension\n\t * @param {boolean[]} [torus = [true,true,true]] - should the borders of\n\t * the grid be linked, so that a cell moving out on the left reappears on\n\t * the right?\n\t * Warning: setting the torus to false can give artifacts if not done\n\t * properly, see {@link Grid#torus}.*/\n\tconstructor( extents, torus = [true,true,true] ){\n\t\tsuper( extents, torus )\n\t\t// Check that the grid size is not too big to store pixel ID in 32-bit number,\n\t\t// and allow fast conversion of coordinates to unique ID numbers.\n\t\t/** @ignore */\n\t\tthis.Z_BITS = 1+Math.floor( Math.log2( this.extents[2] - 1 ) )\n\t\tif( this.X_BITS + this.Y_BITS + this.Z_BITS > 32 ){\n\t\t\tthrow(\"Field size too large -- field cannot be represented as 32-bit number\")\n\t\t}\n\t\t/** @ignore */\n\t\tthis.Z_MASK = (1 << this.Z_BITS)-1\n\t\t/** @ignore */\n\t\tthis.Z_STEP = 1\n\t\t/** @ignore */\n\t\tthis.Y_STEP = 1 << (this.Z_BITS)\n\t\t/** @ignore */\n\t\tthis.X_STEP = 1 << (this.Z_BITS +this.Y_BITS)\n\t\t/** Array with values for each pixel stored at the position of its\n\t\t * {@link IndexCoordinate}. E.g. the value of pixel with coordinate i\n\t\t * is stored as this._pixelArray[i].\n\t\t * \tNote that this array is accessed indirectly via the\n\t\t * {@link _pixels} set- and get methods.\n\t\t * @private\n\t\t * @type {Uint16Array} */\n\t\tthis._pixelArray = new Uint16Array(this.p2i(extents))\n\t\tthis.datatype = \"Uint16\"\n\t}\n\t/** Method for conversion from an {@link ArrayCoordinate} to an\n\t * {@link IndexCoordinate}.\n\t *\n\t * See also {@link Grid3D#i2p} for the backward conversion.\n\t *\n\t * @param {ArrayCoordinate} p - the coordinate of the pixel to convert\n\t * @return {IndexCoordinate} the converted coordinate.\n\t *\n\t * @example\n\t * let grid = new CPM.Grid3D( [100,100,100], [true,true,true] )\n\t * let p = grid.i2p( 5 )\n\t * console.log( p )\n\t * console.log( grid.p2i( p ))\n\t */\n\tp2i( p ){\n\t\treturn ( p[0] << ( this.Z_BITS + this.Y_BITS ) ) + \n\t\t\t( p[1] << this.Z_BITS ) + \n\t\t\tp[2]\n\t}\n\t/** Method for conversion from an {@link IndexCoordinate} to an\n\t * {@link ArrayCoordinate}.\n\t *\n\t * See also {@link Grid3D#p2i} for the backward conversion.\n\t *\n\t * @param {IndexCoordinate} i - the coordinate of the pixel to convert\n\t * @return {ArrayCoordinate} the converted coordinate.\n\t *\n\t * @example\n\t * let grid = new CPM.Grid3D( [100,100,100], [true,true,true] )\n\t * let p = grid.i2p( 5 )\n\t * console.log( p )\n\t * console.log( grid.p2i( p ))\n\t */\n\ti2p( i ){\n\t\treturn [i >> (this.Y_BITS + this.Z_BITS), \n\t\t\t( i >> this.Z_BITS ) & this.Y_MASK, i & this.Z_MASK ]\n\t}\n\t\n\t/** This iterator returns locations and values of all non-zero pixels.\n\t * Whereas the {@link pixels} generator yields only non-background pixels\n\t * and specifies both their {@link ArrayCoordinate} and value, this\n\t * generator yields all pixels by {@link IndexCoordinate} and does not\n\t * report value.\n\t *\n\t * @return {IndexCoordinate} for each pixel, return its\n\t * {@link IndexCoordinate}.\n\t *\n\t *\n\t * @example\n\t * let CPM = require( \"path/to/build\" )\n\t * // make a grid and set some values\n\t * let grid = new CPM.Grid3D( [100,100,100], [true,true,true] )\n\t * grid.setpixi( 0, 1 )\n\t * grid.setpixi( 1, 5 )\n\t *\n\t * // iterator\n\t * for( let i of grid.pixelsi() ){\n\t * \tconsole.log( i )\n\t * }\n\t */\n\t* pixelsi() {\n\t\tlet ii = 0, c = 0\n\t\tfor( let i = 0 ; i < this.extents[0] ; i ++ ){\n\t\t\tlet d = 0\n\t\t\tfor( let j = 0 ; j < this.extents[1] ; j ++ ){\n\t\t\t\tfor( let k = 0 ; k < this.extents[2] ; k ++ ){\n\t\t\t\t\tyield ii\n\t\t\t\t\tii++\n\t\t\t\t}\n\t\t\t\td += this.Y_STEP\n\t\t\t\tii = c + d\n\t\t\t}\n\t\t\tc += this.X_STEP\n\t\t\tii = c\n\t\t}\n\t}\n\n\t/** This iterator returns locations and values of all non-zero pixels.\n\t * @return {Pixel} for each pixel, return an array [p,v] where p are\n\t * the pixel's array coordinates on the grid, and v its value.\n\t *\n\t * @example\n\t * let CPM = require( \"path/to/build\" )\n\t * // make a grid and set some values\n\t * let grid = new CPM.Grid3D( [100,100,100], [true,true,true] )\n\t * grid.setpix( [0,0,0], 1 )\n\t * grid.setpix( [0,0,1], 5 )\n\t *\n\t * // iterator\n\t * for( let p of grid.pixels() ){\n\t * \tconsole.log( p )\n\t * }\n\t */\n\t* pixels() {\n\t\tlet ii = 0, c = 0\n\t\tfor( let i = 0 ; i < this.extents[0] ; i ++ ){\n\t\t\tlet d = 0\n\t\t\tfor( let j = 0 ; j < this.extents[1] ; j ++ ){\n\t\t\t\tfor( let k = 0 ; k < this.extents[2] ; k ++ ){\n\t\t\t\t\t//noinspection JSUnresolvedVariable\n\t\t\t\t\tlet pixels = this._pixels\n\t\t\t\t\tif( pixels[ii] > 0 ){\n\t\t\t\t\t\tyield [[i,j,k], pixels[ii]]\n\t\t\t\t\t}\n\t\t\t\t\tii++\n\t\t\t\t}\n\t\t\t\td += this.Y_STEP\n\t\t\t\tii = c + d\n\t\t\t}\n\t\t\tc += this.X_STEP\n\t\t\tii = c\n\t\t}\n\t}\n\n\t/**\tReturn array of {@link IndexCoordinate} of the Moore neighbor pixels\n\t * of the pixel at coordinate i. This function takes the 3D equivalent of\n\t * the 2D Moore-8 neighborhood, excluding the pixel itself.\n\t * @see https://en.wikipedia.org/wiki/Moore_neighborhood\n\t * @param {IndexCoordinate} i - location of the pixel to get neighbors of.\n\t * @param {boolean[]} [torus=[true,true,true]] - does the grid have linked\n\t * borders? Defaults to the setting on this grid, see {@link torus}\n\t * @return {IndexCoordinate[]} - an array of coordinates for all the\n\t * neighbors of i.\n\t*/\n\tneighi( i, torus = this.torus ){\n\t\tlet p = this.i2p(i)\n\n\t\tlet xx = []\n\t\tfor( let d = 0 ; d <= 2 ; d ++ ){\n\t\t\tif( p[d] === 0 ){\n\t\t\t\tif( torus[d] ){\n\t\t\t\t\txx[d] = [p[d],this.extents[d]-1,p[d]+1]\n\t\t\t\t} else {\n\t\t\t\t\txx[d] = [p[d],p[d]+1]\n\t\t\t\t}\n\t\t\t} else if( p[d] === this.extents[d]-1 ){\n\t\t\t\tif( torus[d] ){\n\t\t\t\t\txx[d] = [p[d],p[d]-1,0]\n\t\t\t\t} else {\n\t\t\t\t\txx[d] = [p[d],p[d]-1]\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\txx[d] = [p[d],p[d]-1,p[d]+1]\n\t\t\t}\n\t\t}\n\t\tlet r = [], first=true\n\t\tfor( let x of xx[0] ){\n\t\t\tfor( let y of xx[1] ){\n\t\t\t\tfor( let z of xx[2] ){\n\t\t\t\t\tif( first ){\n\t\t\t\t\t\tfirst = false \n\t\t\t\t\t} else {\n\t\t\t\t\t\tr.push( this.p2i( [x,y,z] ) )\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn r\n\t}\n}\n\nexport default Grid3D \n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/grid/Grid3D.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 370,
    "kind": "class",
    "name": "Grid3D",
    "memberof": "src/grid/Grid3D.js",
    "static": true,
    "longname": "src/grid/Grid3D.js~Grid3D",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/grid/Grid3D.js",
    "importStyle": "Grid3D",
    "description": "A class containing (mostly static) utility functions for dealing with 3D\n\tgrids. Extends the Grid class but implements functions specific to the 3D\n\tgrid (such as neighborhoods).",
    "examples": [
      "<caption>Neighborhoods on a 3D grid</caption>\n\nlet CPM = require(\"path/to/build\")\n\n// Make a grid with a torus, and find the neighborhood of the upper left pixel [0,0,0]\nlet grid = new CPM.Grid3D( [100,100,100], [true,true,true] )\nconsole.log( grid.neigh( [0,0,0] ) ) // returns coordinates of 26 neighbors (9+8+9)\n\n// Now try a grid without torus; the corner now has fewer neighbors.\nlet grid2 = new CPM.Grid3D( [100,100,100], [false,false,false] )\nconsole.log( grid2.neigh( [0,0,0] ) ) // returns only 7 neighbors\n\n// Or try a torus in one dimension\nlet grid2 = new CPM.Grid3D( [100,100,100], [true,false,false] )\nconsole.log( grid2.neigh( [0,0,0] ) )"
    ],
    "lineNumber": 23,
    "interface": false,
    "extends": [
      "src/grid/Grid.js~Grid"
    ]
  },
  {
    "__docId__": 371,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/grid/Grid3D.js~Grid3D",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid3D.js~Grid3D#constructor",
    "access": "public",
    "description": "Constructor of the Grid3D object.",
    "lineNumber": 32,
    "params": [
      {
        "nullable": null,
        "types": [
          "GridSize"
        ],
        "spread": false,
        "optional": false,
        "name": "extents",
        "description": "the size of the grid in each dimension"
      },
      {
        "nullable": null,
        "types": [
          "boolean[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " [true,true,true]",
        "defaultRaw": [
          true,
          true,
          true
        ],
        "name": "torus",
        "description": "should the borders of\nthe grid be linked, so that a cell moving out on the left reappears on\nthe right?\nWarning: setting the torus to false can give artifacts if not done\nproperly, see {@link Grid#torus}."
      }
    ]
  },
  {
    "__docId__": 372,
    "kind": "member",
    "name": "Z_BITS",
    "memberof": "src/grid/Grid3D.js~Grid3D",
    "static": false,
    "longname": "src/grid/Grid3D.js~Grid3D#Z_BITS",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 373,
    "kind": "member",
    "name": "Z_MASK",
    "memberof": "src/grid/Grid3D.js~Grid3D",
    "static": false,
    "longname": "src/grid/Grid3D.js~Grid3D#Z_MASK",
    "access": "public",
    "description": null,
    "lineNumber": 42,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 374,
    "kind": "member",
    "name": "Z_STEP",
    "memberof": "src/grid/Grid3D.js~Grid3D",
    "static": false,
    "longname": "src/grid/Grid3D.js~Grid3D#Z_STEP",
    "access": "public",
    "description": null,
    "lineNumber": 44,
    "ignore": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 375,
    "kind": "member",
    "name": "Y_STEP",
    "memberof": "src/grid/Grid3D.js~Grid3D",
    "static": false,
    "longname": "src/grid/Grid3D.js~Grid3D#Y_STEP",
    "access": "public",
    "description": null,
    "lineNumber": 46,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 376,
    "kind": "member",
    "name": "X_STEP",
    "memberof": "src/grid/Grid3D.js~Grid3D",
    "static": false,
    "longname": "src/grid/Grid3D.js~Grid3D#X_STEP",
    "access": "public",
    "description": null,
    "lineNumber": 48,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 377,
    "kind": "member",
    "name": "_pixelArray",
    "memberof": "src/grid/Grid3D.js~Grid3D",
    "static": false,
    "longname": "src/grid/Grid3D.js~Grid3D#_pixelArray",
    "access": "private",
    "description": "Array with values for each pixel stored at the position of its\n{@link IndexCoordinate}. E.g. the value of pixel with coordinate i\nis stored as this._pixelArray[i].\n\tNote that this array is accessed indirectly via the\n{@link _pixels} set- and get methods.",
    "lineNumber": 56,
    "type": {
      "nullable": null,
      "types": [
        "Uint16Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 378,
    "kind": "member",
    "name": "datatype",
    "memberof": "src/grid/Grid3D.js~Grid3D",
    "static": false,
    "longname": "src/grid/Grid3D.js~Grid3D#datatype",
    "access": "public",
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 379,
    "kind": "method",
    "name": "p2i",
    "memberof": "src/grid/Grid3D.js~Grid3D",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid3D.js~Grid3D#p2i",
    "access": "public",
    "description": "Method for conversion from an {@link ArrayCoordinate} to an\n{@link IndexCoordinate}.\n\nSee also {@link Grid3D#i2p} for the backward conversion.",
    "examples": [
      "let grid = new CPM.Grid3D( [100,100,100], [true,true,true] )\nlet p = grid.i2p( 5 )\nconsole.log( p )\nconsole.log( grid.p2i( p ))"
    ],
    "lineNumber": 73,
    "params": [
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "p",
        "description": "the coordinate of the pixel to convert"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IndexCoordinate"
      ],
      "spread": false,
      "description": "the converted coordinate."
    }
  },
  {
    "__docId__": 380,
    "kind": "method",
    "name": "i2p",
    "memberof": "src/grid/Grid3D.js~Grid3D",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid3D.js~Grid3D#i2p",
    "access": "public",
    "description": "Method for conversion from an {@link IndexCoordinate} to an\n{@link ArrayCoordinate}.\n\nSee also {@link Grid3D#p2i} for the backward conversion.",
    "examples": [
      "let grid = new CPM.Grid3D( [100,100,100], [true,true,true] )\nlet p = grid.i2p( 5 )\nconsole.log( p )\nconsole.log( grid.p2i( p ))"
    ],
    "lineNumber": 92,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "the coordinate of the pixel to convert"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ArrayCoordinate"
      ],
      "spread": false,
      "description": "the converted coordinate."
    }
  },
  {
    "__docId__": 381,
    "kind": "method",
    "name": "pixelsi",
    "memberof": "src/grid/Grid3D.js~Grid3D",
    "generator": true,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid3D.js~Grid3D#pixelsi",
    "access": "public",
    "description": "This iterator returns locations and values of all non-zero pixels.\nWhereas the {@link pixels} generator yields only non-background pixels\nand specifies both their {@link ArrayCoordinate} and value, this\ngenerator yields all pixels by {@link IndexCoordinate} and does not\nreport value.",
    "examples": [
      "let CPM = require( \"path/to/build\" )\n// make a grid and set some values\nlet grid = new CPM.Grid3D( [100,100,100], [true,true,true] )\ngrid.setpixi( 0, 1 )\ngrid.setpixi( 1, 5 )\n\n// iterator\nfor( let i of grid.pixelsi() ){\n\tconsole.log( i )\n}"
    ],
    "lineNumber": 119,
    "return": {
      "nullable": null,
      "types": [
        "IndexCoordinate"
      ],
      "spread": false,
      "description": "for each pixel, return its\n{@link IndexCoordinate}."
    },
    "params": []
  },
  {
    "__docId__": 382,
    "kind": "method",
    "name": "pixels",
    "memberof": "src/grid/Grid3D.js~Grid3D",
    "generator": true,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid3D.js~Grid3D#pixels",
    "access": "public",
    "description": "This iterator returns locations and values of all non-zero pixels.",
    "examples": [
      "let CPM = require( \"path/to/build\" )\n// make a grid and set some values\nlet grid = new CPM.Grid3D( [100,100,100], [true,true,true] )\ngrid.setpix( [0,0,0], 1 )\ngrid.setpix( [0,0,1], 5 )\n\n// iterator\nfor( let p of grid.pixels() ){\n\tconsole.log( p )\n}"
    ],
    "lineNumber": 152,
    "return": {
      "nullable": null,
      "types": [
        "Pixel"
      ],
      "spread": false,
      "description": "for each pixel, return an array [p,v] where p are\nthe pixel's array coordinates on the grid, and v its value."
    },
    "params": []
  },
  {
    "__docId__": 383,
    "kind": "method",
    "name": "neighi",
    "memberof": "src/grid/Grid3D.js~Grid3D",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/Grid3D.js~Grid3D#neighi",
    "access": "public",
    "description": "Return array of {@link IndexCoordinate} of the Moore neighbor pixels\nof the pixel at coordinate i. This function takes the 3D equivalent of\nthe 2D Moore-8 neighborhood, excluding the pixel itself.",
    "see": [
      "https://en.wikipedia.org/wiki/Moore_neighborhood"
    ],
    "lineNumber": 183,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "location of the pixel to get neighbors of."
      },
      {
        "nullable": null,
        "types": [
          "boolean[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[true,true,true]",
        "defaultRaw": [
          true,
          true,
          true
        ],
        "name": "torus",
        "description": "does the grid have linked\nborders? Defaults to the setting on this grid, see {@link torus}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IndexCoordinate[]"
      ],
      "spread": false,
      "description": "an array of coordinates for all the\nneighbors of i."
    }
  },
  {
    "__docId__": 384,
    "kind": "file",
    "name": "src/grid/GridManipulator.js",
    "content": "\n\nimport PixelsByCell from \"../stats/PixelsByCell.js\"\nimport CentroidsWithTorusCorrection from \"../stats/CentroidsWithTorusCorrection.js\"\nimport Centroids from \"../stats/Centroids.js\"\nimport Grid2D from \"./Grid2D.js\"\nimport Grid3D from \"./Grid3D.js\"\n\n\n/** This class contains methods that should be executed once per\n * Monte Carlo Step. Examples are cell division, cell death etc.\n *\n * It also contains methods to seed new cells in certain shapes and\n * configurations. Methods are written for CPMs, but some of the methods\n * may also apply to other models of class ({@link GridBasedModel}, e.g.\n * the cell seeding methods) or even a general grid ({@link Grid}, e.g.\n * the {@link makeLine} and {@link assignCellPixels} methods).\n *\n * @example\n * // Build CPM and attach a gridmanipulator\n * let C = new CPM.CPM( [100,100], {T:20, J:[[0,20],[20,10]]} )\n * let gm = new CPM.GridManipulator( C )\n */\nclass GridManipulator {\n\t/** Constructor of class GridManipulator.\n\t *\n\t * @param {CPM|GridBasedModel|Grid} C - the model whose grid\n\t * you wish to manipulate.\n\t * Methods are written for CPMs, but some of the methods may also\n\t * apply to other models of class ({@link GridBasedModel}, e.g.\n\t * the cell seeding methods) or even a general grid ({@link Grid}, e.g.\n\t * the {@link makeLine} and {@link assignCellPixels} methods).\n\t*/\n\tconstructor( C ){\n\t\t/** The model whose grid we are manipulating.\n\t\t * @type {CPM|GridBasedModel|Grid}*/\n\t\tthis.C = C\n\t}\n\t\n\t/** @experimental\n\t */\n\tkillCell( cellID ){\n\n\t\tfor( let [p,i] of this.C.pixels() ){\n\t\t\tif( i == cellID ){\n\t\t\t\tthis.C.setpix( p, 0 )\n\t\t\t}\n\t\t}\n\n\t\t// update stats\n\t\tif (\"PixelsByCell\" in this.C.stat_values) {\n\t\t\tdelete this.C.stat_values[\"PixelsByCell\"][cellID]\n\t\t}\n\t}\n\t\n\n\t\n\t/** Seed a new cell at a random position. Return 0 if failed, ID of new\n\t * cell otherwise.\n\t * Try a specified number of times, then give up if grid is too full. \n\t * The first cell will always be seeded at the midpoint of the grid.\n\t *\n\t * See also {@link seedCellAt} to seed a cell on a predefined position.\n\t *\n\t * @param {CellKind} kind - what kind of cell should be seeded? This\n\t * determines the CPM parameters that will be used for that cell.\n\t * @param {number} [max_attempts = 10000] - number of tries allowed. The\n\t * method will attempt to seed a cell at a random position, but this will\n\t * fail if the position is already occupied. After max_attempts fails,\n\t * it will not try again. This can happen if the grid is very full.\n\t * @return {CellId} - the {@link CellId} of the newly seeded cell, or 0\n\t * if the seeding has failed.\n\t *\n\t * @example\n\t * // Build CPM and attach a gridmanipulator\n\t * let C = new CPM.CPM( [100,100], {T:20, J:[[0,20],[20,10]]} )\n\t * let gm = new CPM.GridManipulator( C )\n\t *\n\t * // Seed some cells\n\t * gm.seedCell( 1 )\n\t * gm.seedCell( 1 )\n\t *\n\t * // Check which pixels are nonzero. One is always the grid midpoint.\n\t * for( let p of C.pixels() ){\n\t * \tconsole.log( p )\n\t * }\n\t */\n\tseedCell( kind, max_attempts = 10000 ){\n\t\tlet p = this.C.midpoint\n\t\twhile( this.C.pixt( p ) !== 0 && max_attempts-- > 0 ){\n\t\t\tfor( let i = 0 ; i < p.length ; i ++ ){\n\t\t\t\tp[i] = this.C.ran(0,this.C.extents[i]-1)\n\t\t\t}\n\t\t}\n\t\tif( this.C.pixt(p)  !== 0 ){\n\t\t\treturn 0 // failed\n\t\t}\n\t\tconst newID = this.C.makeNewCellID( kind )\n\t\tthis.C.setpix( p, newID )\n\t\treturn newID\n\t}\n\t/**  Seed a new cell of celltype \"kind\" onto position \"p\".\n\t * This succeeds regardless of whether there is already a cell there.\n\t * See also {@link seedCell} to seed a cell on a random position.\n\t *\n\t * @param {CellKind} kind - what kind of cell should be seeded?\n\t * This determines the CPM parameters that will be used for that cell.\n\t * @param {ArrayCoordinate} p - position to seed the cell at.\n\t * @return {CellId} - the {@link CellId} of the newly seeded cell, or 0\n\t * if the seeding has failed.\n\t *\n\t * @example\n\t * // Build CPM and attach a gridmanipulator\n\t * let C = new CPM.CPM( [100,100], {T:20, J:[[0,20],[20,10]]} )\n\t * let gm = new CPM.GridManipulator( C )\n\t *\n\t * // Seed some cells\n\t * gm.seedCellAt( 1, [2,4] )\n\t * gm.seedCellAt( 1, [9,3] )\n\t *\n\t * // Check which pixels are nonzero. These should be the positions defined above.\n\t * for( let p of C.pixels() ){\n\t * \tconsole.log( p )\n\t * }\n\t */\n\tseedCellAt( kind, p ){\n\t\n\t\tconst newid = this.C.makeNewCellID( kind )\n\t\tthis.C.grid.checkOnGrid(p)\n\t\tthis.C.setpix( p, newid )\n\t\treturn newid\n\n\t}\n\t\n\t/**  Seed \"n\" cells of celltype \"kind\" at random points lying within a\n\t * circle surrounding \"center\" with radius \"radius\".\n\t *\n\t * See also {@link seedCell} to seed a cell on a random position in\n\t * the entire grid, and {@link seedCellAt} to seed a cell at a specific\n\t * position.\n\t * @param {CellKind} kind - what kind of cell should be seeded? This\n\t * determines the CPM parameters that will be used for that cell.\n\t * @param {number} n - the number of cells to seed (must be integer).\n\t * @param {ArrayCoordinate} center - position on the grid where the center\n\t * of the circle should be.\n\t * @param {number} radius - the radius of the circle to seed cells in.\n\t * @param {number} max_attempts - the maximum number of attempts to seed a\n\t * cell. Seeding can fail if the randomly chosen position is outside the\n\t * circle, or if there is already a cell there. After max_attempts the\n\t * method will stop trying and throw an error.\n\t *\n\t * @example\n\t * // Build CPM and attach a gridmanipulator\n\t * let C = new CPM.CPM( [100,100], {T:20, J:[[0,20],[20,10]]} )\n\t * let gm = new CPM.GridManipulator( C )\n\t *\n\t * // Seed cells within a circle\n\t * gm.seedCellsInCircle( 1, 10, [50,30], 20 )\n\t *\n\t * // Check which pixels are nonzero. These should be within the circle.\n\t * for( let p of C.pixels() ){\n\t * \tconsole.log( p )\n\t * }\n\t */\n\tseedCellsInCircle( kind, n, center, radius, max_attempts = 10000 ){\n\t\tif( !max_attempts ){\n\t\t\tmax_attempts = 10*n\n\t\t}\n\t\tlet C = this.C\n\t\twhile( n > 0 ){\n\t\t\tif( --max_attempts === 0 ){\n\t\t\t\tthrow(\"too many attempts to seed cells!\")\n\t\t\t}\n\t\t\tlet p = center.map( function(i){ return C.ran(Math.ceil(i-radius),Math.floor(i+radius)) } )\n\t\t\tlet d = 0\n\t\t\tfor( let i = 0 ; i < p.length ; i ++ ){\n\t\t\t\td += (p[i]-center[i])*(p[i]-center[i])\n\t\t\t}\n\t\t\tif( d < radius*radius && this.C.pixt(p) == 0 ){\n\t\t\t\tthis.seedCellAt( kind, p )\n\t\t\t\tn--\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Helper method to return an entire plane or line of pixels; can be used\n\t * in conjunction with {@link assignCellPixels} to assign all these pixels\n\t * to a given CellId at once. (See also {@link makeBox} and\n\t * {@link makeCircle}).\n\t * The method takes an existing array of coordinates (which can be\n\t * empty) and adds the pixels of the specified plane to it.\n\t * See {@link assignCellPixels} for a method that sets such a pixel set to a\n\t * new value.\n\t *\n\t * The plane is specified by fixing one coordinate (x,y,or z) to a\n\t * fixed value, and letting the others range from their min value 0 to\n\t * their max value. In 3D, this returns a plane.\n\t *\n\t * @param {number} dimension - the dimension to fix the coordinate of:\n\t * 0 = x, 1 = y, 2 = z. (E.g. for a straight vertical line, we fix the\n\t * x-coordinate).\n\t * @param {number} coordinateValue - the value of the coordinate in the\n\t * fixed dimension; location of the plane. (E.g. for our straight vertical\n\t * line, the x-value where the line should be placed).\n\t * @param {ArrayCoordinate[]} [pixels] - (Optional) existing array of pixels;\n\t * if given, the line will be added to this set.\n\t * @return {ArrayCoordinate[]} the updated array of pixels.\n\t *\n\t * @example\n\t * let C = new CPM.CPM( [10,10], {T:20, J:[[0,20],[20,10]]} )\n\t * let gm = new CPM.GridManipulator( C )\n\t * let myLine = gm.makeLine( 0, 2 )\n\t * gm.assignCellPixels( myLine, 1 )\n\t */\n\tmakeLine ( dimension, coordinateValue, pixels ) {\n\n\t\tpixels = pixels || []\n\n\t\tlet x,y,z\n\t\tlet minC = [0,0,0]\n\t\tlet maxC = [0,0,0]\n\t\tfor( let dim = 0; dim < this.C.ndim; dim++ ){\n\t\t\tmaxC[dim] = this.C.extents[dim]-1\n\t\t}\n\t\tminC[dimension] = coordinateValue\n\t\tmaxC[dimension] = coordinateValue\n\n\t\t// For every coordinate x,y,z, loop over all possible values from min to max.\n\t\t// one of these loops will have only one iteration because min = max = coordvalue.\n\t\tfor( x = minC[0]; x <= maxC[0]; x++ ){\n\t\t\tfor( y = minC[1]; y<=maxC[1]; y++ ){\n\t\t\t\tfor( z = minC[2]; z<=maxC[2]; z++ ){\n\t\t\t\t\tif( this.C.ndim === 3 ){\n\t\t\t\t\t\tpixels.push( [x,y,z] )\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//console.log(x,y)\n\t\t\t\t\t\tpixels.push( [x,y] )\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn pixels\n\t}\n\n\t/** Deprecated method, please use {@link makeLine} instead. Old method\n\t * just links to the new method for backwards-compatibility.\n\t *\n\t * @param {number} dim - the dimension to fix the coordinate of:\n\t * 0 = x, 1 = y, 2 = z. (E.g. for a straight vertical line, we fix the\n\t * x-coordinate).\n\t * @param {number} coordinateValue - the value of the coordinate in the\n\t * fixed dimension; location of the plane. (E.g. for our straight vertical\n\t * line, the x-value where the line should be placed).\n\t * @param {ArrayCoordinate[]} [pixels] - (Optional) existing array of pixels;\n\t * if given, the line will be added to this set.\n\t * @return {ArrayCoordinate[]} the updated array of pixels.\n \t */\n\tmakePlane( pixels, dim, coordinateValue ){\n\t\treturn this.makeLine( dim, coordinateValue, pixels )\n\t}\n\n\t/** Helper method to return a rectangle (or in 3D: box) of pixels; can be used\n\t * in conjunction with {@link assignCellPixels} to assign all these pixels\n\t * to a given CellId at once. (See also {@link makeLine} and\n\t * {@link makeCircle}).\n\t * The method takes an existing array of coordinates (which can be\n\t * empty) and adds the pixels of the specified rectangle/box to it.\n\t * See {@link assignCellPixels} for a method that sets such a pixel set to a\n\t * new value.\n\t *\n\t * The box/rectangle is specified by its bottom left corner (x,y,z)\n\t * and size (dx, dy, dz).\n\t *\n\t * @param {ArrayCoordinate[]} bottomLeft - the coordinate of the bottom\n\t * left corner of the rectangle/box.\n\t * @param {number[]} boxSize - the size of the rectangle in each dimension:\n\t * [dx,dy,dz].\n\t * @param {ArrayCoordinate[]} [pixels] - (Optional) existing array of pixels;\n\t * if given, the line will be added to this set.\n\t * @return {ArrayCoordinate[]} the updated array of pixels.\n\t *\n\t * @example\n\t * let C = new CPM.CPM( [10,10], {T:20, J:[[0,20],[20,10]]} )\n\t * let gm = new CPM.GridManipulator( C )\n\t * let rect = gm.makeBox( [50,50], [10,10] )\n\t * gm.assignCellPixels( rect, 1 )\n\t */\n\tmakeBox( bottomLeft, boxSize, pixels ){\n\n\t\t// this array will contain all positions in the circle (/sphere)\n\t\t// for radius = 1, just return the array with a single element:\n\t\t// the center pixel\n\t\tpixels = pixels || []\n\n\t\t// check that box dimensions do not exceed dimensions of the grid\n\t\tfor( let d = 0; d < this.C.grid.ndim; d++ ){\n\t\t\tif( boxSize[d] > this.C.grid.extents[d] ){\n\t\t\t\tthrow( \"GridManipulator.makeBox: You are trying to make a \" +\n\t\t\t\t\t\"box that exceeds grid dimensions!\" )\n\t\t\t}\n\t\t}\n\n\t\t// find pixels inside the box, and correct them for torus if required\n\t\tconst p = bottomLeft\n\t\tfor( let xx = 0; xx < boxSize[0]; xx++ ){\n\t\t\tfor( let yy = 0; yy < boxSize[1]; yy++ ){\n\n\t\t\t\tlet pNew = [p[0]+xx,p[1]+yy]\n\t\t\t\tif( this.C.grid.ndim === 3 ){\n\n\t\t\t\t\tfor( let zz = 0; zz <= boxSize[2]; zz++ ){\n\t\t\t\t\t\tpNew.push(p[2]+zz)\n\t\t\t\t\t\t// correct for torus\n\t\t\t\t\t\tconst pCorr = this.C.grid.correctPosition( pNew )\n\t\t\t\t\t\tif( typeof pCorr !== \"undefined\" ){ pixels.push( pCorr ) }\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tconst pCorr = this.C.grid.correctPosition( pNew )\n\t\t\t\t\tif( typeof pCorr !== \"undefined\"  ){ pixels.push( pCorr ) }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn pixels\n\n\t}\n\n\t/** Helper method to return a circle (in 3D: sphere) of pixels; can be used\n\t * in conjunction with {@link assignCellPixels} to assign all these pixels\n\t * to a given CellId at once. (See also {@link makeLine} and\n\t * {@link makeBox}).\n\t * The method takes an existing array of coordinates (which can be\n\t * empty) and adds the pixels of the specified circle/sphere to it.\n\t * See {@link assignCellPixels} for a method that sets such a pixel set to a\n\t * new value.\n\t *\n\t * The circle/sphere is specified by its center (x,y,z)\n\t * and radius.\n\t *\n\t * @param {ArrayCoordinate[]} center - the coordinate of the center\n\t * of the circle/sphere.\n\t * @param {number} radius - the radius of the circle/sphere.\n\t * @param {ArrayCoordinate[]} [pixels] - (Optional) existing array of pixels;\n\t * if given, the circle/sphere pixels will be added to this set.\n\t * @return {ArrayCoordinate[]} the updated array of pixels.\n\t *\n\t * @example\n\t * let C = new CPM.CPM( [10,10], {T:20, J:[[0,20],[20,10]]} )\n\t * let gm = new CPM.GridManipulator( C )\n\t * let circ = gm.makeCircle( [50,50], 10 )\n\t * gm.assignCellPixels( circ, 1 )\n\t */\n\tmakeCircle( center, radius, pixels = [] ){\n\n\n\t\t// the positions to return depends on the Grid geometry. currently support only\n\t\t// square 2D/3D lattices.\n\t\tif( !( this.C.grid instanceof Grid2D ) && !( this.C.grid instanceof Grid3D ) ){\n\t\t\tthrow( \"In makeCircle: radius > 1 only supported for grids of \" +\n\t\t\t\t\"class Grid2D or Grid3D. Please set radius=1 to continue.\" )\n\t\t}\n\n\t\t// find the pixels\tinside the radius\n\t\tconst p = center\n\t\tfor( let xx = -radius; xx <= radius; xx++ ){\n\t\t\tfor( let yy = -radius; yy <= radius; yy++ ){\n\n\t\t\t\tlet pNew = [p[0]+xx,p[1]+yy]\n\t\t\t\tif( this.C.grid.ndim === 3 ){\n\n\t\t\t\t\tfor( let zz = - radius; zz <= radius; zz++ ){\n\t\t\t\t\t\tpNew.push(p[2]+zz)\n\t\t\t\t\t\tif( Math.sqrt( xx*xx + yy*yy + zz*zz ) <= radius ){\n\t\t\t\t\t\t\tconst pCorr = this.C.grid.correctPosition( pNew )\n\t\t\t\t\t\t\tif(  typeof pCorr !== \"undefined\"  ){ pixels.push( pCorr ) }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tif( Math.sqrt( xx*xx + yy*yy ) <= radius ){\n\t\t\t\t\t\tconst pCorr = this.C.grid.correctPosition( pNew )\n\t\t\t\t\t\tif(  typeof pCorr !== \"undefined\"  ){ pixels.push( pCorr ) }\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\treturn pixels\n\n\t}\n\n\n\t/** Helper method that assigns all pixels in a given array to a\n\t * cell of a given cellkind: changes the pixels defined by voxels\n\t * (array of coordinates p) into the given cellKind and a corresponding\n\t * cellID.\n\t *\n\t * @param {ArrayCoordinate[]} voxels - Array of pixels to change.\n\t * @param {CellKind} cellkind - cellkind to change these pixels into.\n\t * @param {CellId} [newID] - (Optional) id of the cell to assign the\n\t * \tpixels to; if this is unspecified, a new cellID is generated for this\n\t * \tpurpose.\n\t * \t@example\n\t * \tlet C = new CPM.CPM( [10,10], {T:20, J:[[0,20],[20,10]]} )\n\t * \tlet gm = new CPM.GridManipulator( C )\n\t * \tlet myLine = gm.makeLine( 0, 2 )\n\t * \tgm.assignCellPixels( myLine, 1 )\n\t **/\n\tassignCellPixels ( voxels, cellkind, newID ){\n\n\t\tnewID = newID || this.C.makeNewCellID( cellkind )\n\t\tfor( let p of voxels ){\n\t\t\tthis.C.setpix( p, newID )\n\t\t}\n\t\t\n\t}\n\n\t/** Abrogated; this is now {@link assignCellPixels}. **/\n\tchangeKind( voxels, cellkind, newid ){\n\t\tthis.assignCellPixels( voxels, cellkind, newid )\n\t}\n\n\t/** Let cell \"id\" divide by splitting it along a line perpendicular to\n\t * its major axis. \n\t \n\t @param {CellId} id - the id of the cell that needs to divide.\n\t @return {CellId} the id of the newly generated daughter cell.\n\t   \n\t\t@example\n\t\t* let C = new CPM.CPM( [10,10], {\n\t\t* \tT:20, \n\t\t*\tJ:[[0,20],[20,10]], \n\t\t*\tV:[0,200], \n\t\t*\tLAMBDA_V:[0,2] \n\t\t* })\n\t\t* let gm = new CPM.GridManipulator( C )\n\t\t*\n\t\t* // Seed a single cell\n\t\t* gm.seedCell( 1 )\n\t\t* \n\t\t* // Perform some Monte Carlo Steps before dividing the cell\n\t\t* for( let t = 0; t < 100; t++ ){\n\t\t* \tC.timeStep()\n\t\t* }\n\t\t* gm.divideCell( 1 )\n\t\t* \n\t\t* // Check which pixels belong to which cell. Should be roughly half half.\n\t\t* C.getStat( PixelsByCell )\n\t */\n\tdivideCell( id ){\n\t\tlet C = this.C\n\t\tlet torus = C.conf.torus.indexOf(true) >= 0\n\t\tif( C.ndim != 2 || torus ){\n\t\t\tthrow(\"The divideCell methods is only implemented for 2D non-torus lattices yet!\")\n\t\t}\n\t\tlet cp = C.getStat( PixelsByCell )[id], com = C.getStat( Centroids )[id]\n\t\tlet bxx = 0, bxy = 0, byy=0, cx, cy, x2, y2, side, T, D, x0, y0, x1, y1, L2\n\n\t\t// Loop over the pixels belonging to this cell\n\t\tfor( let j = 0 ; j < cp.length ; j ++ ){\n\t\t\tcx = cp[j][0] - com[0] // x position rel to centroid\n\t\t\tcy = cp[j][1] - com[1] // y position rel to centroid\n\n\t\t\t// sum of squared distances:\n\t\t\tbxx += cx*cx\n\t\t\tbxy += cx*cy\n\t\t\tbyy += cy*cy\n\t\t}\n\n\t\t// This code computes a \"dividing line\", which is perpendicular to the longest\n\t\t// axis of the cell.\n\t\tif( bxy == 0 ){\n\t\t\tx0 = 0\n\t\t\ty0 = 0\n\t\t\tx1 = 1\n\t\t\ty1 = 0\n\t\t} else {\n\t\t\tT = bxx + byy\n\t\t\tD = bxx*byy - bxy*bxy\n\t\t\t//L1 = T/2 + Math.sqrt(T*T/4 - D)\n\t\t\tL2 = T/2 - Math.sqrt(T*T/4 - D)\n\t\t\tx0 = 0\n\t\t\ty0 = 0\n\t\t\tx1 = L2 - byy\n\t\t\ty1 = bxy\n\t\t}\n\t\t// console.log( id )\n\t\t// create a new ID for the second cell\n\t\t\n\t\tlet nid = C.makeNewCellID( C.cellKind( id ))\n\t\tif (C.hasOwnProperty(\"cells\")){\n\t\t\tC.birth( nid, id )\n\t\t}\n\t\t\n\t\t// Loop over the pixels belonging to this cell\n\t\t//let sidea = 0, sideb = 0\n\t\t//let pix_id = []\n\t\t//let pix_nid = []\n\t\t//let sidea = 0, sideb=0\n\n\t\tfor( let j = 0 ; j < cp.length ; j ++ ){\n\t\t\t// coordinates of current cell relative to center of mass\n\t\t\tx2 = cp[j][0]-com[0]\n\t\t\ty2 = cp[j][1]-com[1]\n\n\t\t\t// Depending on which side of the dividing line this pixel is,\n\t\t\t// set it to the new type\n\t\t\tside = (x1 - x0)*(y2 - y0) - (x2 - x0)*(y1 - y0)\n\t\t\tif( side > 0 ){\n\t\t\t\t//sidea++\n\t\t\t\tC.setpix( cp[j], nid ) \n\t\t\t\t// console.log( cp[j] + \" \" + C.cellKind( id ) )\n\t\t\t\t//pix_nid.push( cp[j] )\n\t\t\t} else {\n\t\t\t\t//pix_id.push( cp[j] )\n\t\t\t\t//sideb++\n\n\t\t\t}\n\t\t}\n\t\t//console.log( \"3 \" + C.cellKind( id ) )\n\t\t//cp[id] = pix_id\n\t\t//cp[nid] = pix_nid\n\t\tC.stat_values = {} // remove cached stats or this will crash!!!\n\t\treturn nid\n\t}\n\n\t/** @experimental \n\t * Let cell \"id\" divide by splitting it along a line perpendicular to\n\t * its major axis, with Torus enabled. Watch out that this can give\n\t * rise to weird artefacts when cells span more than half the grid in\n\t * a wrapped direction.\n\t \n\t @param {CellId} id - the id of the cell that needs to divide.\n\t @return {CellId} the id of the newly generated daughter cell.\n\t   \n\t\t@example\n\t\t* let C = new CPM.CPM( [10,10], {\n\t\t* \tT:20, \n\t\t*\tJ:[[0,20],[20,10]], \n\t\t*\tV:[0,200], \n\t\t*\tLAMBDA_V:[0,2] \n\t\t* })\n\t\t* let gm = new CPM.GridManipulator( C )\n\t\t*\n\t\t* // Seed a single cell\n\t\t* gm.seedCell( 1 )\n\t\t* \n\t\t* // Perform some Monte Carlo Steps before dividing the cell\n\t\t* for( let t = 0; t < 100; t++ ){\n\t\t* \tC.timeStep()\n\t\t* }\n\t\t* gm.divideCell( 1 )\n\t\t* \n\t\t* // Check which pixels belong to which cell. Should be roughly half half.\n\t\t* C.getStat( PixelsByCell )\n\t */\n\tdivideCellTorus( id ){\n\t\tlet C = this.C\n\t\tif( C.ndim != 2 ){\n\t\t\tthrow(\"The divideCell method is only implemented for 2D lattices yet!\")\n\t\t}\n\t\tlet cp = C.getStat( PixelsByCell )[id], com = C.getStat( CentroidsWithTorusCorrection )[id]\n\t\tlet bxx = 0, bxy = 0, byy=0, T, D, x1, y1, L2\n\n\t\t// Loop over the pixels belonging to this cell\n\t\tlet si = this.C.extents, pixdist = {}, c = new Array(2)\n\t\tfor( let j = 0 ; j < cp.length ; j ++ ){\n\t\t\tfor ( let dim = 0 ; dim < 2 ; dim ++ ){\n\t\t\t\tc[dim] = cp[j][dim] - com[dim]\n\t\t\t\tif( C.conf.torus[dim] && j > 0 ){\n\t\t\t\t\t// If distance is greater than half the grid size, correct the\n\t\t\t\t\t// coordinate.\n\t\t\t\t\tif( c[dim] > si[dim]/2 ){\n\t\t\t\t\t\tc[dim] -= si[dim]\n\t\t\t\t\t} else if( c[dim] < -si[dim]/2 ){\n\t\t\t\t\t\tc[dim] += si[dim]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpixdist[j] = [...c]\n\t\t\tbxx += c[0]*c[0]\n\t\t\tbxy += c[0]*c[1]\n\t\t\tbyy += c[1]*c[1]\n\t\t}\n\n\t\t// This code computes a \"dividing line\", which is perpendicular to the longest\n\t\t// axis of the cell.\n\t\tif( bxy == 0 ){\n\t\t\tx1 = 1\n\t\t\ty1 = 0\n\t\t} else {\n\t\t\tT = bxx + byy\n\t\t\tD = bxx*byy - bxy*bxy\n\t\t\t//L1 = T/2 + Math.sqrt(T*T/4 - D)\n\t\t\tL2 = T/2 - Math.sqrt(T*T/4 - D)\n\t\t\tx1 = L2 - byy\n\t\t\ty1 = bxy\n\t\t}\n\t\t// console.log( id )\n\t\t// create a new ID for the second cell\n\t\tlet nid = C.makeNewCellID( C.cellKind( id ) )\n\t\t\n\t\tfor( let j = 0 ; j < cp.length ; j ++ ){\n\t\t\t//  x0 and y0 can be omitted as the div line is relative to the centroid (0, 0)\n\t\t\tif( x1*pixdist[j][1]-pixdist[j][0]*y1 > 0 ){\n\t\t\t\tC.setpix( cp[j], nid ) \n\t\t\t}\n\t\t}\n\t\t\n\t\tif (C.hasOwnProperty(\"cells\")){\n\t\t\tC.birth(nid, id)\n\t\t}\n\t\t// console.log()\n\t\t\n\t\t\n\t\tC.stat_values = {} // remove cached stats or this will crash!!!\n\t\treturn nid\n\t}\n}\n\n\n\n\nexport default GridManipulator \n\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/grid/GridManipulator.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 385,
    "kind": "class",
    "name": "GridManipulator",
    "memberof": "src/grid/GridManipulator.js",
    "static": true,
    "longname": "src/grid/GridManipulator.js~GridManipulator",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/grid/GridManipulator.js",
    "importStyle": "GridManipulator",
    "description": "This class contains methods that should be executed once per\nMonte Carlo Step. Examples are cell division, cell death etc.\n\nIt also contains methods to seed new cells in certain shapes and\nconfigurations. Methods are written for CPMs, but some of the methods\nmay also apply to other models of class ({@link GridBasedModel}, e.g.\nthe cell seeding methods) or even a general grid ({@link Grid}, e.g.\nthe {@link makeLine} and {@link assignCellPixels} methods).",
    "examples": [
      "// Build CPM and attach a gridmanipulator\nlet C = new CPM.CPM( [100,100], {T:20, J:[[0,20],[20,10]]} )\nlet gm = new CPM.GridManipulator( C )"
    ],
    "lineNumber": 24,
    "interface": false
  },
  {
    "__docId__": 386,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/grid/GridManipulator.js~GridManipulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/GridManipulator.js~GridManipulator#constructor",
    "access": "public",
    "description": "Constructor of class GridManipulator.",
    "lineNumber": 34,
    "params": [
      {
        "nullable": null,
        "types": [
          "CPM",
          "GridBasedModel",
          "Grid"
        ],
        "spread": false,
        "optional": false,
        "name": "C",
        "description": "the model whose grid\nyou wish to manipulate.\nMethods are written for CPMs, but some of the methods may also\napply to other models of class ({@link GridBasedModel}, e.g.\nthe cell seeding methods) or even a general grid ({@link Grid}, e.g.\nthe {@link makeLine} and {@link assignCellPixels} methods)."
      }
    ]
  },
  {
    "__docId__": 387,
    "kind": "member",
    "name": "C",
    "memberof": "src/grid/GridManipulator.js~GridManipulator",
    "static": false,
    "longname": "src/grid/GridManipulator.js~GridManipulator#C",
    "access": "public",
    "description": "The model whose grid we are manipulating.",
    "lineNumber": 37,
    "type": {
      "nullable": null,
      "types": [
        "CPM",
        "GridBasedModel",
        "Grid"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 388,
    "kind": "method",
    "name": "killCell",
    "memberof": "src/grid/GridManipulator.js~GridManipulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/GridManipulator.js~GridManipulator#killCell",
    "access": "public",
    "description": null,
    "lineNumber": 42,
    "experimental": true,
    "params": [
      {
        "name": "cellID",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 389,
    "kind": "method",
    "name": "seedCell",
    "memberof": "src/grid/GridManipulator.js~GridManipulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/GridManipulator.js~GridManipulator#seedCell",
    "access": "public",
    "description": "Seed a new cell at a random position. Return 0 if failed, ID of new\ncell otherwise.\nTry a specified number of times, then give up if grid is too full. \nThe first cell will always be seeded at the midpoint of the grid.\n\nSee also {@link seedCellAt} to seed a cell on a predefined position.",
    "examples": [
      "// Build CPM and attach a gridmanipulator\nlet C = new CPM.CPM( [100,100], {T:20, J:[[0,20],[20,10]]} )\nlet gm = new CPM.GridManipulator( C )\n\n// Seed some cells\ngm.seedCell( 1 )\ngm.seedCell( 1 )\n\n// Check which pixels are nonzero. One is always the grid midpoint.\nfor( let p of C.pixels() ){\n\tconsole.log( p )\n}"
    ],
    "lineNumber": 88,
    "params": [
      {
        "nullable": null,
        "types": [
          "CellKind"
        ],
        "spread": false,
        "optional": false,
        "name": "kind",
        "description": "what kind of cell should be seeded? This\ndetermines the CPM parameters that will be used for that cell."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " 10000",
        "defaultRaw": 10000,
        "name": "max_attempts",
        "description": "number of tries allowed. The\nmethod will attempt to seed a cell at a random position, but this will\nfail if the position is already occupied. After max_attempts fails,\nit will not try again. This can happen if the grid is very full."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CellId"
      ],
      "spread": false,
      "description": "the {@link CellId} of the newly seeded cell, or 0\nif the seeding has failed."
    }
  },
  {
    "__docId__": 390,
    "kind": "method",
    "name": "seedCellAt",
    "memberof": "src/grid/GridManipulator.js~GridManipulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/GridManipulator.js~GridManipulator#seedCellAt",
    "access": "public",
    "description": " Seed a new cell of celltype \"kind\" onto position \"p\".\nThis succeeds regardless of whether there is already a cell there.\nSee also {@link seedCell} to seed a cell on a random position.",
    "examples": [
      "// Build CPM and attach a gridmanipulator\nlet C = new CPM.CPM( [100,100], {T:20, J:[[0,20],[20,10]]} )\nlet gm = new CPM.GridManipulator( C )\n\n// Seed some cells\ngm.seedCellAt( 1, [2,4] )\ngm.seedCellAt( 1, [9,3] )\n\n// Check which pixels are nonzero. These should be the positions defined above.\nfor( let p of C.pixels() ){\n\tconsole.log( p )\n}"
    ],
    "lineNumber": 126,
    "params": [
      {
        "nullable": null,
        "types": [
          "CellKind"
        ],
        "spread": false,
        "optional": false,
        "name": "kind",
        "description": "what kind of cell should be seeded?\nThis determines the CPM parameters that will be used for that cell."
      },
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "p",
        "description": "position to seed the cell at."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CellId"
      ],
      "spread": false,
      "description": "the {@link CellId} of the newly seeded cell, or 0\nif the seeding has failed."
    }
  },
  {
    "__docId__": 391,
    "kind": "method",
    "name": "seedCellsInCircle",
    "memberof": "src/grid/GridManipulator.js~GridManipulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/GridManipulator.js~GridManipulator#seedCellsInCircle",
    "access": "public",
    "description": " Seed \"n\" cells of celltype \"kind\" at random points lying within a\ncircle surrounding \"center\" with radius \"radius\".\n\nSee also {@link seedCell} to seed a cell on a random position in\nthe entire grid, and {@link seedCellAt} to seed a cell at a specific\nposition.",
    "examples": [
      "// Build CPM and attach a gridmanipulator\nlet C = new CPM.CPM( [100,100], {T:20, J:[[0,20],[20,10]]} )\nlet gm = new CPM.GridManipulator( C )\n\n// Seed cells within a circle\ngm.seedCellsInCircle( 1, 10, [50,30], 20 )\n\n// Check which pixels are nonzero. These should be within the circle.\nfor( let p of C.pixels() ){\n\tconsole.log( p )\n}"
    ],
    "lineNumber": 165,
    "params": [
      {
        "nullable": null,
        "types": [
          "CellKind"
        ],
        "spread": false,
        "optional": false,
        "name": "kind",
        "description": "what kind of cell should be seeded? This\ndetermines the CPM parameters that will be used for that cell."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "n",
        "description": "the number of cells to seed (must be integer)."
      },
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "center",
        "description": "position on the grid where the center\nof the circle should be."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "radius",
        "description": "the radius of the circle to seed cells in."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "max_attempts",
        "description": "the maximum number of attempts to seed a\ncell. Seeding can fail if the randomly chosen position is outside the\ncircle, or if there is already a cell there. After max_attempts the\nmethod will stop trying and throw an error."
      }
    ],
    "return": null
  },
  {
    "__docId__": 392,
    "kind": "method",
    "name": "makeLine",
    "memberof": "src/grid/GridManipulator.js~GridManipulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/GridManipulator.js~GridManipulator#makeLine",
    "access": "public",
    "description": "Helper method to return an entire plane or line of pixels; can be used\nin conjunction with {@link assignCellPixels} to assign all these pixels\nto a given CellId at once. (See also {@link makeBox} and\n{@link makeCircle}).\nThe method takes an existing array of coordinates (which can be\nempty) and adds the pixels of the specified plane to it.\nSee {@link assignCellPixels} for a method that sets such a pixel set to a\nnew value.\n\nThe plane is specified by fixing one coordinate (x,y,or z) to a\nfixed value, and letting the others range from their min value 0 to\ntheir max value. In 3D, this returns a plane.",
    "examples": [
      "let C = new CPM.CPM( [10,10], {T:20, J:[[0,20],[20,10]]} )\nlet gm = new CPM.GridManipulator( C )\nlet myLine = gm.makeLine( 0, 2 )\ngm.assignCellPixels( myLine, 1 )"
    ],
    "lineNumber": 215,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dimension",
        "description": "the dimension to fix the coordinate of:\n0 = x, 1 = y, 2 = z. (E.g. for a straight vertical line, we fix the\nx-coordinate)."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "coordinateValue",
        "description": "the value of the coordinate in the\nfixed dimension; location of the plane. (E.g. for our straight vertical\nline, the x-value where the line should be placed)."
      },
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate[]"
        ],
        "spread": false,
        "optional": true,
        "name": "pixels",
        "description": "(Optional) existing array of pixels;\nif given, the line will be added to this set."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ArrayCoordinate[]"
      ],
      "spread": false,
      "description": "the updated array of pixels."
    }
  },
  {
    "__docId__": 393,
    "kind": "method",
    "name": "makePlane",
    "memberof": "src/grid/GridManipulator.js~GridManipulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/GridManipulator.js~GridManipulator#makePlane",
    "access": "public",
    "description": "Deprecated method, please use {@link makeLine} instead. Old method\njust links to the new method for backwards-compatibility.",
    "lineNumber": 259,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dim",
        "description": "the dimension to fix the coordinate of:\n0 = x, 1 = y, 2 = z. (E.g. for a straight vertical line, we fix the\nx-coordinate)."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "coordinateValue",
        "description": "the value of the coordinate in the\nfixed dimension; location of the plane. (E.g. for our straight vertical\nline, the x-value where the line should be placed)."
      },
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate[]"
        ],
        "spread": false,
        "optional": true,
        "name": "pixels",
        "description": "(Optional) existing array of pixels;\nif given, the line will be added to this set."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ArrayCoordinate[]"
      ],
      "spread": false,
      "description": "the updated array of pixels."
    }
  },
  {
    "__docId__": 394,
    "kind": "method",
    "name": "makeBox",
    "memberof": "src/grid/GridManipulator.js~GridManipulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/GridManipulator.js~GridManipulator#makeBox",
    "access": "public",
    "description": "Helper method to return a rectangle (or in 3D: box) of pixels; can be used\nin conjunction with {@link assignCellPixels} to assign all these pixels\nto a given CellId at once. (See also {@link makeLine} and\n{@link makeCircle}).\nThe method takes an existing array of coordinates (which can be\nempty) and adds the pixels of the specified rectangle/box to it.\nSee {@link assignCellPixels} for a method that sets such a pixel set to a\nnew value.\n\nThe box/rectangle is specified by its bottom left corner (x,y,z)\nand size (dx, dy, dz).",
    "examples": [
      "let C = new CPM.CPM( [10,10], {T:20, J:[[0,20],[20,10]]} )\nlet gm = new CPM.GridManipulator( C )\nlet rect = gm.makeBox( [50,50], [10,10] )\ngm.assignCellPixels( rect, 1 )"
    ],
    "lineNumber": 289,
    "params": [
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate[]"
        ],
        "spread": false,
        "optional": false,
        "name": "bottomLeft",
        "description": "the coordinate of the bottom\nleft corner of the rectangle/box."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "boxSize",
        "description": "the size of the rectangle in each dimension:\n[dx,dy,dz]."
      },
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate[]"
        ],
        "spread": false,
        "optional": true,
        "name": "pixels",
        "description": "(Optional) existing array of pixels;\nif given, the line will be added to this set."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ArrayCoordinate[]"
      ],
      "spread": false,
      "description": "the updated array of pixels."
    }
  },
  {
    "__docId__": 395,
    "kind": "method",
    "name": "makeCircle",
    "memberof": "src/grid/GridManipulator.js~GridManipulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/GridManipulator.js~GridManipulator#makeCircle",
    "access": "public",
    "description": "Helper method to return a circle (in 3D: sphere) of pixels; can be used\nin conjunction with {@link assignCellPixels} to assign all these pixels\nto a given CellId at once. (See also {@link makeLine} and\n{@link makeBox}).\nThe method takes an existing array of coordinates (which can be\nempty) and adds the pixels of the specified circle/sphere to it.\nSee {@link assignCellPixels} for a method that sets such a pixel set to a\nnew value.\n\nThe circle/sphere is specified by its center (x,y,z)\nand radius.",
    "examples": [
      "let C = new CPM.CPM( [10,10], {T:20, J:[[0,20],[20,10]]} )\nlet gm = new CPM.GridManipulator( C )\nlet circ = gm.makeCircle( [50,50], 10 )\ngm.assignCellPixels( circ, 1 )"
    ],
    "lineNumber": 355,
    "params": [
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate[]"
        ],
        "spread": false,
        "optional": false,
        "name": "center",
        "description": "the coordinate of the center\nof the circle/sphere."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "radius",
        "description": "the radius of the circle/sphere."
      },
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate[]"
        ],
        "spread": false,
        "optional": true,
        "name": "pixels",
        "description": "(Optional) existing array of pixels;\nif given, the circle/sphere pixels will be added to this set."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ArrayCoordinate[]"
      ],
      "spread": false,
      "description": "the updated array of pixels."
    }
  },
  {
    "__docId__": 396,
    "kind": "method",
    "name": "assignCellPixels",
    "memberof": "src/grid/GridManipulator.js~GridManipulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/GridManipulator.js~GridManipulator#assignCellPixels",
    "access": "public",
    "description": "Helper method that assigns all pixels in a given array to a\ncell of a given cellkind: changes the pixels defined by voxels\n(array of coordinates p) into the given cellKind and a corresponding\ncellID.",
    "examples": [
      "\tlet C = new CPM.CPM( [10,10], {T:20, J:[[0,20],[20,10]]} )\n\tlet gm = new CPM.GridManipulator( C )\n\tlet myLine = gm.makeLine( 0, 2 )\n\tgm.assignCellPixels( myLine, 1 )"
    ],
    "lineNumber": 413,
    "params": [
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate[]"
        ],
        "spread": false,
        "optional": false,
        "name": "voxels",
        "description": "Array of pixels to change."
      },
      {
        "nullable": null,
        "types": [
          "CellKind"
        ],
        "spread": false,
        "optional": false,
        "name": "cellkind",
        "description": "cellkind to change these pixels into."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": true,
        "name": "newID",
        "description": "(Optional) id of the cell to assign the\n\tpixels to; if this is unspecified, a new cellID is generated for this\n\tpurpose."
      }
    ],
    "return": null
  },
  {
    "__docId__": 397,
    "kind": "method",
    "name": "changeKind",
    "memberof": "src/grid/GridManipulator.js~GridManipulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/GridManipulator.js~GridManipulator#changeKind",
    "access": "public",
    "description": "Abrogated; this is now {@link assignCellPixels}. *",
    "lineNumber": 423,
    "params": [
      {
        "name": "voxels",
        "types": [
          "*"
        ]
      },
      {
        "name": "cellkind",
        "types": [
          "*"
        ]
      },
      {
        "name": "newid",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 398,
    "kind": "method",
    "name": "divideCell",
    "memberof": "src/grid/GridManipulator.js~GridManipulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/GridManipulator.js~GridManipulator#divideCell",
    "access": "public",
    "description": "Let cell \"id\" divide by splitting it along a line perpendicular to\nits major axis. ",
    "examples": [
      "let C = new CPM.CPM( [10,10], {\n\tT:20, \nJ:[[0,20],[20,10]], \nV:[0,200], \nLAMBDA_V:[0,2] \n})\nlet gm = new CPM.GridManipulator( C )\n\n// Seed a single cell\ngm.seedCell( 1 )\n\n// Perform some Monte Carlo Steps before dividing the cell\nfor( let t = 0; t < 100; t++ ){\n\tC.timeStep()\n}\ngm.divideCell( 1 )\n\n// Check which pixels belong to which cell. Should be roughly half half.\nC.getStat( PixelsByCell )"
    ],
    "lineNumber": 454,
    "params": [
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "the id of the cell that needs to divide."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CellId"
      ],
      "spread": false,
      "description": "the id of the newly generated daughter cell."
    }
  },
  {
    "__docId__": 399,
    "kind": "method",
    "name": "divideCellTorus",
    "memberof": "src/grid/GridManipulator.js~GridManipulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/GridManipulator.js~GridManipulator#divideCellTorus",
    "access": "public",
    "description": null,
    "examples": [
      "let C = new CPM.CPM( [10,10], {\n\tT:20, \nJ:[[0,20],[20,10]], \nV:[0,200], \nLAMBDA_V:[0,2] \n})\nlet gm = new CPM.GridManipulator( C )\n\n// Seed a single cell\ngm.seedCell( 1 )\n\n// Perform some Monte Carlo Steps before dividing the cell\nfor( let t = 0; t < 100; t++ ){\n\tC.timeStep()\n}\ngm.divideCell( 1 )\n\n// Check which pixels belong to which cell. Should be roughly half half.\nC.getStat( PixelsByCell )"
    ],
    "lineNumber": 561,
    "experimental": "Let cell \"id\" divide by splitting it along a line perpendicular to\nits major axis, with Torus enabled. Watch out that this can give\nrise to weird artefacts when cells span more than half the grid in\na wrapped direction.",
    "params": [
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "the id of the cell that needs to divide."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CellId"
      ],
      "spread": false,
      "description": "the id of the newly generated daughter cell."
    }
  },
  {
    "__docId__": 400,
    "kind": "file",
    "name": "src/grid/grid-typedef.js",
    "content": "/** An array with the grid size in pixels for each dimension.\nEach element must be a positive integer.\nFor example, for GridSize array g, g[0] is the size in x-dimension, g[1] in y, etc.\n\n@typedef {number[]} GridSize\n*/\n\n/** Array coordinates to a pixel on the grid.\n\nWe generally use two types of coordinates. An ArrayCoordinate contains the 'regular'\n[x,y] or [x,y,z] pointer to a position on the grid, which is intuitive to use.\n\nHowever, for speed, models of class {@link GridBasedModel} often use a different type\nof coordinates called {@link IndexCoordinate}. See methods {@link p2i} and {@link i2p}\nof the appropriate grid subclass for conversions between the two.\n\n@typedef {number[]} ArrayCoordinate\n*/\n\n/** Index coordinate to a pixel on the grid.\n\nWe generally use two types of coordinates. An {@link ArrayCoordinate} contains the 'regular'\n[x,y] or [x,y,z] pointer to a position on the grid, which is intuitive to use.\n\nHowever, for speed, models of class {@link GridBasedModel} often use a different type\nof coordinates called IndexCoordinate, which is a non-negative integer number. \nSee methods {@link p2i} and {@link i2p} of the appropriate grid subclass for \nconversions between the two.\n\n@typedef {number} IndexCoordinate\n*/",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/grid/grid-typedef.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 401,
    "kind": "typedef",
    "name": "GridSize",
    "memberof": "src/grid/grid-typedef.js",
    "static": true,
    "longname": "src/grid/grid-typedef.js~GridSize",
    "access": "public",
    "description": "An array with the grid size in pixels for each dimension.\nEach element must be a positive integer.\nFor example, for GridSize array g, g[0] is the size in x-dimension, g[1] in y, etc.",
    "type": {
      "types": [
        "number[]"
      ],
      "optional": false,
      "name": "GridSize"
    }
  },
  {
    "__docId__": 402,
    "kind": "typedef",
    "name": "ArrayCoordinate",
    "memberof": "src/grid/grid-typedef.js",
    "static": true,
    "longname": "src/grid/grid-typedef.js~ArrayCoordinate",
    "access": "public",
    "description": "Array coordinates to a pixel on the grid.\n\nWe generally use two types of coordinates. An ArrayCoordinate contains the 'regular'\n[x,y] or [x,y,z] pointer to a position on the grid, which is intuitive to use.\n\nHowever, for speed, models of class {@link GridBasedModel} often use a different type\nof coordinates called {@link IndexCoordinate}. See methods {@link p2i} and {@link i2p}\nof the appropriate grid subclass for conversions between the two.",
    "type": {
      "types": [
        "number[]"
      ],
      "optional": false,
      "name": "ArrayCoordinate"
    }
  },
  {
    "__docId__": 403,
    "kind": "typedef",
    "name": "IndexCoordinate",
    "memberof": "src/grid/grid-typedef.js",
    "static": true,
    "longname": "src/grid/grid-typedef.js~IndexCoordinate",
    "access": "public",
    "description": "Index coordinate to a pixel on the grid.\n\nWe generally use two types of coordinates. An {@link ArrayCoordinate} contains the 'regular'\n[x,y] or [x,y,z] pointer to a position on the grid, which is intuitive to use.\n\nHowever, for speed, models of class {@link GridBasedModel} often use a different type\nof coordinates called IndexCoordinate, which is a non-negative integer number. \nSee methods {@link p2i} and {@link i2p} of the appropriate grid subclass for \nconversions between the two.",
    "type": {
      "types": [
        "number"
      ],
      "optional": false,
      "name": "IndexCoordinate"
    }
  },
  {
    "__docId__": 404,
    "kind": "file",
    "name": "src/hamiltonian/ActivityConstraint.js",
    "content": "import SoftConstraint from \"./SoftConstraint.js\"\nimport ParameterChecker from \"./ParameterChecker.js\"\n\n/** This class implements the activity constraint of Potts models published in:\n *\n *\tNiculescu I, Textor J, de Boer RJ (2015) \n *\tCrawling and Gliding: A Computational Model for Shape-Driven Cell Migration. \n *\tPLoS Comput Biol 11(10): e1004280. \n * \n * Pixels recently added to a cell get an \"activity\", which then declines with every MCS.\n * Copy attempts from more active into less active pixels have a higher success rate,\n * which puts a positive feedback on protrusive activity and leads to cell migration.\n * \n * This constraint is generally used together with {@link Adhesion}, {@link VolumeConstraint},\n * and {@link PerimeterConstraint}.\n * \n * @see https://doi.org/10.1371/journal.pcbi.1004280\n *\n * @example\n * // Build a CPM and add the constraint\n * let CPM = require( \"path/to/build\" )\n * let C = new CPM.CPM( [200,200], {\n * \tT : 20,\n * \tJ : [[0,20],[20,10]],\n * \tV : [0,500],\n * \tLAMBDA_V : [0,5],\n * \tP : [0,260],\n * \tLAMBDA_P : [0,2] \t\n * })\n * C.add( new CPM.ActivityConstraint( {\n * \tLAMBDA_ACT : [0,500],\n * \tMAX_ACT : [0,30],\n * \tACT_MEAN : \"geometric\"\n * } ) )\n * \n * // Or add automatically by entering the parameters in the CPM\n * let C2 = new CPM.CPM( [200,200], {\n * \tT : 20,\n * \tJ : [[0,20],[20,10]],\n * \tV : [0,500],\n * \tLAMBDA_V : [0,5],\n * \tP : [0,260],\n * \tLAMBDA_P : [0,2],\n * \tLAMBDA_ACT : [0,500],\n * \tMAX_ACT : [0,30],\n * \tACT_MEAN : \"geometric\"\t\n * })\n */\nclass ActivityConstraint extends SoftConstraint {\n\n\t/** The constructor of the ActivityConstraint requires a conf object with parameters.\n\t@param {object} conf - parameter object for this constraint\n\t@param {string} [conf.ACT_MEAN=\"geometric\"] - should local mean activity be measured with an\n\t\"arithmetic\" or a \"geometric\" mean?\n\t@param {PerKindNonNegative} conf.LAMBDA_ACT - strength of the activityconstraint per cellkind.\n\t@param {PerKindNonNegative} conf.MAX_ACT - how long do pixels remember their activity? Given per cellkind.\n\t*/\n\tconstructor( conf ){\n\t\tsuper( conf )\n\n\t\t/** Activity of all cellpixels with a non-zero activity is stored in this object,\n\t\twith the {@link IndexCoordinate} of each pixel as key and its current activity as\n\t\tvalue. When the activity reaches 0, the pixel is removed from the object until it\n\t\tis added again. \n\t\t@type {object}*/\n\t\tthis.cellpixelsact = {}\n\t\t\n\t\t/** Wrapper: select function to compute activities based on ACT_MEAN in conf.\n\t\tDefault is to use the {@link activityAtGeom} for a geometric mean.\n\t\t@type {function}*/\n\t\tthis.activityAt = this.activityAtGeom\n\t\tif( this.conf.ACT_MEAN == \"arithmetic\" ){\n\t\t\tthis.activityAt = this.activityAtArith\n\t\t} \n\t\t\n\t}\n\t\n\t/** This method checks that all required parameters are present in the object supplied to\n\tthe constructor, and that they are of the right format. It throws an error when this\n\tis not the case.*/\n\tconfChecker(){\n\t\tlet checker = new ParameterChecker( this.conf, this.C )\n\t\tchecker.confCheckParameter( \"ACT_MEAN\", \"SingleValue\", \"String\", [ \"geometric\", \"arithmetic\" ] )\n\t\tchecker.confCheckParameter( \"LAMBDA_ACT\", \"KindArray\", \"NonNegative\" )\n\t\tchecker.confCheckParameter( \"MAX_ACT\", \"KindArray\", \"NonNegative\" )\n\t}\n\t\n\t/* ======= ACT MODEL ======= */\n\n\t/* Act model : compute local activity values within cell around pixel i.\n\t * Depending on settings in conf, this is an arithmetic (activityAtArith)\n\t * or geometric (activityAtGeom) mean of the activities of the neighbors\n\t * of pixel i.\n\t */\n\t/** Method to compute the Hamiltonian for this constraint. \n\t @param {IndexCoordinate} sourcei - coordinate of the source pixel that tries to copy.\n\t @param {IndexCoordinate} targeti - coordinate of the target pixel the source is trying\n\t to copy into.\n\t @param {CellId} src_type - cellid of the source pixel.\n\t @param {CellId} tgt_type - cellid of the target pixel. \n\t @return {number} the change in Hamiltonian for this copy attempt and this constraint.*/ \n\tdeltaH ( sourcei, targeti, src_type, tgt_type ){\n\n\t\tlet deltaH = 0, maxact, lambdaact\n\n\t\t// use parameters for the source cell, unless that is the background.\n\t\t// In that case, use parameters of the target cell.\n\t\tif( src_type != 0 ){\n\t\t\tmaxact = this.cellParameter(\"MAX_ACT\", src_type)\n\t\t\tlambdaact = this.cellParameter(\"LAMBDA_ACT\", src_type)\n\t\t} else {\n\t\t\t// special case: punishment for a copy attempt from background into\n\t\t\t// an active cell. This effectively means that the active cell retracts,\n\t\t\t// which is different from one cell pushing into another (active) cell.\n\t\t\tmaxact = this.cellParameter(\"MAX_ACT\", tgt_type)\n\t\t\tlambdaact = this.cellParameter(\"LAMBDA_ACT\", tgt_type)\n\t\t}\n\t\tif( !maxact || !lambdaact ){\n\t\t\treturn 0\n\t\t}\n\n\t\t// compute the Hamiltonian. The activityAt method is a wrapper for either activityAtArith\n\t\t// or activityAtGeom, depending on conf (see constructor).\t\n\t\tdeltaH += lambdaact*(this.activityAt( targeti ) - this.activityAt( sourcei ))/maxact\n\t\treturn deltaH\n\t}\n\n\t/** Activity mean computation methods for arithmetic mean. It computes the mean activity\n\t\tof a pixel and all its neighbors belonging to the same cell.\n\t\t\n\t\tThis method is generally called indirectly via {@link activityAt}, which is set\n\t\tbased on the value of ACT_MEAN in the configuration object given to the constructor.\n\t\t\n\t\t@param {IndexCoordinate} i - pixel to evaluate local activity at.\n\t\t@return {number} the arithmetic mean of activities in this part of the cell.\n\t\t@private\n\t*/\n\tactivityAtArith( i ){\n\t\tconst t = this.C.pixti( i )\n\t\t\n\t\t// no activity for background/stroma\n\t\tif( t <= 0 ){ return 0 }\n\t\t\n\t\t// neighborhood pixels\n\t\tconst N = this.C.neighi(i)\n\t\t\n\t\t// r activity summed, nN number of neighbors\n\t\t// we start with the current pixel. \n\t\tlet r = this.pxact(i), nN = 1\n\t\t\n\t\t// loop over neighbor pixels\n\t\tfor( let j = 0 ; j < N.length ; j ++ ){ \n\t\t\tconst tn = this.C.pixti( N[j] ) \n\t\t\t\n\t\t\t// a neighbor only contributes if it belongs to the same cell\n\t\t\tif( tn == t ){\n\t\t\t\tr += this.pxact( N[j] )\n\t\t\t\tnN ++ \n\t\t\t}\n\t\t}\n\n\t\t// average is summed r divided by num neighbors.\n\t\treturn r/nN\n\t}\n\t/** Activity mean computation methods for geometric mean. It computes the mean activity\n\t\tof a pixel and all its neighbors belonging to the same cell.\n\t\t\n\t\tThis method is generally called indirectly via {@link activityAt}, which is set\n\t\tbased on the value of ACT_MEAN in the configuration object given to the constructor.\n\t\t\n\t\t@param {IndexCoordinate} i - pixel to evaluate local activity at.\n\t\t@return {number} the geometric mean of activities in this part of the cell.\n\t\t@private\n\t*/\n\tactivityAtGeom ( i ){\n\t\tconst t = this.C.pixti( i )\n\n\t\t// no activity for background/stroma\n\t\tif( t <= 0 ){ return 0 }\n\t\t\n\t\t//neighborhood pixels\n\t\tconst N = this.C.neighi( i )\n\t\t\n\t\t// r activity product, nN number of neighbors.\n\t\t// we start with the current pixel.\n\t\tlet nN = 1, r = this.pxact( i )\n\n\t\t// loop over neighbor pixels\n\t\tfor( let j = 0 ; j < N.length ; j ++ ){ \n\t\t\tconst tn = this.C.pixti( N[j] ) \n\n\t\t\t// a neighbor only contributes if it belongs to the same cell.\n\t\t\t// if it does and has activity 0, the product will also be zero so\n\t\t\t// we can already return.\n\t\t\tif( tn == t ){\n\t\t\t\tif( this.pxact( N[j] ) == 0 ) return 0\n\t\t\t\tr *= this.pxact( N[j] )\n\t\t\t\tnN ++ \n\t\t\t}\n\t\t}\n\t\t\n\t\t// Geometric mean computation. \n\t\treturn Math.pow(r,1/nN)\n\t}\n\n\n\t/** Current activity (under the Act model) of the pixel at position i. \n\t@param {IndexCoordinate} i the position of the pixel to evaluate the activity of.\n\t@return {number} the current activity of this pixel, which is >= 0.*/\n\tpxact ( i ){\n\t\t// If the pixel is not in the cellpixelsact object, it has activity 0.\n\t\t// Otherwise, its activity is stored in the object.\n\t\treturn this.cellpixelsact[i] || 0\n\t}\n\t\n\t/** The postSetpixListener of the ActivityConstraint ensures that pixels are \n\tgiven their maximal activity when they are freshly added to a CPM.\n\t@listens {CPM#setpixi} because when a new pixel is set (which is determined in the CPM),\n\tits activity must change so that this class knows about the update.\n\t@param {IndexCoordinate} i - the coordinate of the pixel that is changed.\n\t@param {CellId} t_old - the cellid of this pixel before the copy\n\t@param {CellId} t - the cellid of this pixel after the copy.\n\t*/\n\t/* eslint-disable no-unused-vars*/\n\tpostSetpixListener( i, t_old, t ){\n\t\t// After setting a pixel, it gets the MAX_ACT value of its cellkind.\n\t\tthis.cellpixelsact[i] = this.cellParameter(\"MAX_ACT\", t)\n\t}\n\t\n\t/** The postMCSListener of the ActivityConstraint ensures that pixel activities\n\tdecline with one after every MCS.\n\t@listens {CPM#timeStep} because when the CPM has finished an MCS, the activities must go down.\n\t*/\n\tpostMCSListener(){\n\t\t// iterate over cellpixelsage and decrease all activities by one.\n\t\tfor( let key in this.cellpixelsact ){\n\t\t\t// activities that reach zero no longer need to be stored.\n\t\t\tif( --this.cellpixelsact[ key ] <= 0 ){\n\t\t\t\tdelete this.cellpixelsact[ key ]\n\t\t\t}\n\t\t}\n\t}\n\n\n}\n\nexport default ActivityConstraint\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/hamiltonian/ActivityConstraint.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 405,
    "kind": "class",
    "name": "ActivityConstraint",
    "memberof": "src/hamiltonian/ActivityConstraint.js",
    "static": true,
    "longname": "src/hamiltonian/ActivityConstraint.js~ActivityConstraint",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/hamiltonian/ActivityConstraint.js",
    "importStyle": "ActivityConstraint",
    "description": "This class implements the activity constraint of Potts models published in:\n\nNiculescu I, Textor J, de Boer RJ (2015) \nCrawling and Gliding: A Computational Model for Shape-Driven Cell Migration. \nPLoS Comput Biol 11(10): e1004280. \n\nPixels recently added to a cell get an \"activity\", which then declines with every MCS.\nCopy attempts from more active into less active pixels have a higher success rate,\nwhich puts a positive feedback on protrusive activity and leads to cell migration.\n\nThis constraint is generally used together with {@link Adhesion}, {@link VolumeConstraint},\nand {@link PerimeterConstraint}.",
    "examples": [
      "// Build a CPM and add the constraint\nlet CPM = require( \"path/to/build\" )\nlet C = new CPM.CPM( [200,200], {\n\tT : 20,\n\tJ : [[0,20],[20,10]],\n\tV : [0,500],\n\tLAMBDA_V : [0,5],\n\tP : [0,260],\n\tLAMBDA_P : [0,2] \t\n})\nC.add( new CPM.ActivityConstraint( {\n\tLAMBDA_ACT : [0,500],\n\tMAX_ACT : [0,30],\n\tACT_MEAN : \"geometric\"\n} ) )\n\n// Or add automatically by entering the parameters in the CPM\nlet C2 = new CPM.CPM( [200,200], {\n\tT : 20,\n\tJ : [[0,20],[20,10]],\n\tV : [0,500],\n\tLAMBDA_V : [0,5],\n\tP : [0,260],\n\tLAMBDA_P : [0,2],\n\tLAMBDA_ACT : [0,500],\n\tMAX_ACT : [0,30],\n\tACT_MEAN : \"geometric\"\t\n})"
    ],
    "see": [
      "https://doi.org/10.1371/journal.pcbi.1004280"
    ],
    "lineNumber": 49,
    "interface": false,
    "extends": [
      "src/hamiltonian/SoftConstraint.js~SoftConstraint"
    ]
  },
  {
    "__docId__": 406,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/hamiltonian/ActivityConstraint.js~ActivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ActivityConstraint.js~ActivityConstraint#constructor",
    "access": "public",
    "description": "The constructor of the ActivityConstraint requires a conf object with parameters.",
    "lineNumber": 58,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "conf",
        "description": "parameter object for this constraint"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "\"geometric\"",
        "defaultRaw": "geometric",
        "name": "conf.ACT_MEAN",
        "description": "should local mean activity be measured with an\n\"arithmetic\" or a \"geometric\" mean?"
      },
      {
        "nullable": null,
        "types": [
          "PerKindNonNegative"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.LAMBDA_ACT",
        "description": "strength of the activityconstraint per cellkind."
      },
      {
        "nullable": null,
        "types": [
          "PerKindNonNegative"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.MAX_ACT",
        "description": "how long do pixels remember their activity? Given per cellkind."
      }
    ]
  },
  {
    "__docId__": 407,
    "kind": "member",
    "name": "cellpixelsact",
    "memberof": "src/hamiltonian/ActivityConstraint.js~ActivityConstraint",
    "static": false,
    "longname": "src/hamiltonian/ActivityConstraint.js~ActivityConstraint#cellpixelsact",
    "access": "public",
    "description": "Activity of all cellpixels with a non-zero activity is stored in this object,\nwith the {@link IndexCoordinate} of each pixel as key and its current activity as\nvalue. When the activity reaches 0, the pixel is removed from the object until it\nis added again. ",
    "lineNumber": 66,
    "type": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 408,
    "kind": "member",
    "name": "activityAt",
    "memberof": "src/hamiltonian/ActivityConstraint.js~ActivityConstraint",
    "static": false,
    "longname": "src/hamiltonian/ActivityConstraint.js~ActivityConstraint#activityAt",
    "access": "public",
    "description": "Wrapper: select function to compute activities based on ACT_MEAN in conf.\nDefault is to use the {@link activityAtGeom} for a geometric mean.",
    "lineNumber": 71,
    "type": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 410,
    "kind": "method",
    "name": "confChecker",
    "memberof": "src/hamiltonian/ActivityConstraint.js~ActivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ActivityConstraint.js~ActivityConstraint#confChecker",
    "access": "public",
    "description": "This method checks that all required parameters are present in the object supplied to\nthe constructor, and that they are of the right format. It throws an error when this\nis not the case.",
    "lineNumber": 81,
    "params": [],
    "return": null
  },
  {
    "__docId__": 411,
    "kind": "method",
    "name": "deltaH",
    "memberof": "src/hamiltonian/ActivityConstraint.js~ActivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ActivityConstraint.js~ActivityConstraint#deltaH",
    "access": "public",
    "description": "Method to compute the Hamiltonian for this constraint. ",
    "lineNumber": 102,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "sourcei",
        "description": "coordinate of the source pixel that tries to copy."
      },
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "targeti",
        "description": "coordinate of the target pixel the source is trying\nto copy into."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "src_type",
        "description": "cellid of the source pixel."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_type",
        "description": "cellid of the target pixel."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the change in Hamiltonian for this copy attempt and this constraint."
    }
  },
  {
    "__docId__": 412,
    "kind": "method",
    "name": "activityAtArith",
    "memberof": "src/hamiltonian/ActivityConstraint.js~ActivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ActivityConstraint.js~ActivityConstraint#activityAtArith",
    "access": "private",
    "description": "Activity mean computation methods for arithmetic mean. It computes the mean activity\nof a pixel and all its neighbors belonging to the same cell.\n\nThis method is generally called indirectly via {@link activityAt}, which is set\nbased on the value of ACT_MEAN in the configuration object given to the constructor.",
    "lineNumber": 138,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "pixel to evaluate local activity at."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the arithmetic mean of activities in this part of the cell."
    }
  },
  {
    "__docId__": 413,
    "kind": "method",
    "name": "activityAtGeom",
    "memberof": "src/hamiltonian/ActivityConstraint.js~ActivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ActivityConstraint.js~ActivityConstraint#activityAtGeom",
    "access": "private",
    "description": "Activity mean computation methods for geometric mean. It computes the mean activity\nof a pixel and all its neighbors belonging to the same cell.\n\nThis method is generally called indirectly via {@link activityAt}, which is set\nbased on the value of ACT_MEAN in the configuration object given to the constructor.",
    "lineNumber": 175,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "pixel to evaluate local activity at."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the geometric mean of activities in this part of the cell."
    }
  },
  {
    "__docId__": 414,
    "kind": "method",
    "name": "pxact",
    "memberof": "src/hamiltonian/ActivityConstraint.js~ActivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ActivityConstraint.js~ActivityConstraint#pxact",
    "access": "public",
    "description": "Current activity (under the Act model) of the pixel at position i. ",
    "lineNumber": 210,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "the position of the pixel to evaluate the activity of."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the current activity of this pixel, which is >= 0."
    }
  },
  {
    "__docId__": 415,
    "kind": "method",
    "name": "postSetpixListener",
    "memberof": "src/hamiltonian/ActivityConstraint.js~ActivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ActivityConstraint.js~ActivityConstraint#postSetpixListener",
    "access": "public",
    "description": "The postSetpixListener of the ActivityConstraint ensures that pixels are \ngiven their maximal activity when they are freshly added to a CPM.",
    "lineNumber": 225,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "the coordinate of the pixel that is changed."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "t_old",
        "description": "the cellid of this pixel before the copy"
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "t",
        "description": "the cellid of this pixel after the copy."
      }
    ],
    "listens": [
      {
        "types": [
          "CPM#setpixi"
        ],
        "description": "because when a new pixel is set (which is determined in the CPM),\nits activity must change so that this class knows about the update."
      }
    ],
    "return": null
  },
  {
    "__docId__": 416,
    "kind": "method",
    "name": "postMCSListener",
    "memberof": "src/hamiltonian/ActivityConstraint.js~ActivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ActivityConstraint.js~ActivityConstraint#postMCSListener",
    "access": "public",
    "description": "The postMCSListener of the ActivityConstraint ensures that pixel activities\ndecline with one after every MCS.",
    "lineNumber": 234,
    "listens": [
      {
        "types": [
          "CPM#timeStep"
        ],
        "description": "because when the CPM has finished an MCS, the activities must go down."
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 417,
    "kind": "file",
    "name": "src/hamiltonian/ActivityMultiBackground.js",
    "content": "\n\nimport ActivityConstraint from \"./ActivityConstraint.js\"\nimport ParameterChecker from \"./ParameterChecker.js\"\n/**\n * The ActivityMultiBackground constraint implements the activity constraint of Potts models,\n but allows users to specify locations on the grid where LAMBDA_ACT is different. \n See {@link ActivityConstraint} for the normal version of this constraint.\n See {@link ActivityMultiBackground#constructor} for an explanation of the parameters.\n */\nclass ActivityMultiBackground extends ActivityConstraint {\n\n\t/** Creates an instance of the ActivityMultiBackground constraint \n\t* @param {object} conf - Configuration object with the parameters.\n\t* ACT_MEAN is a single string determining whether the activity mean should be computed\n\t* using a \"geometric\" or \"arithmetic\" mean. \n\t*/\n\t/** The constructor of the ActivityConstraint requires a conf object with parameters.\n\t@param {object} conf - parameter object for this constraint\n\t@param {string} [conf.ACT_MEAN=\"geometric\"] - should local mean activity be measured with an\n\t\"arithmetic\" or a \"geometric\" mean?\n\t@param {PerKindArray} conf.LAMBDA_ACT_MBG - strength of the activityconstraint per cellkind and per background.\n\t@param {PerKindNonNegative} conf.MAX_ACT - how long do pixels remember their activity? Given per cellkind.\n\t@param {Array} conf.BACKGROUND_VOXELS - an array where each element represents a different background type.\n\tThis is again an array of {@ArrayCoordinate}s of the pixels belonging to that backgroundtype. These pixels\n\twill have the LAMBDA_ACT_MBG value of that backgroundtype, instead of the standard value.\n\t*/\n\tconstructor( conf ){\n\t\tsuper( conf )\n\n\t\t/** Activity of all cellpixels with a non-zero activity is stored in this object,\n\t\twith the {@link IndexCoordinate} of each pixel as key and its current activity as\n\t\tvalue. When the activity reaches 0, the pixel is removed from the object until it\n\t\tis added again. \n\t\t@type {object}*/\n\t\tthis.cellpixelsact = {} // activity of cellpixels with a non-zero activity\n\t\t\n\t\t/** Wrapper: select function to compute activities based on ACT_MEAN in conf.\n\t\tDefault is to use the {@link activityAtGeom} for a geometric mean.\n\t\t@type {function}*/\n\t\tthis.activityAt = this.activityAtGeom\n\t\tif( this.conf.ACT_MEAN == \"arithmetic\" ){\n\t\t\tthis.activityAt = this.activityAtArith\n\t\t} \n\t\t\n\t\t/** Store which pixels belong to which background type \n\t\t@type {Array}*/\n\t\tthis.bgvoxels = []\n\t\t\n\t\t/** Track if this.bgvoxels has been set.\n\t\t@type {boolean}*/\n\t\tthis.setup = false\n\t}\n\t\n\t/** This method checks that all required parameters are present in the object supplied to\n\tthe constructor, and that they are of the right format. It throws an error when this\n\tis not the case.*/\n\tconfChecker(){\n\t\tlet checker = new ParameterChecker( this.conf, this.C )\n\t\tchecker.confCheckParameter( \"ACT_MEAN\", \"SingleValue\", \"String\", [ \"geometric\", \"arithmetic\" ] )\n\t\tchecker.confCheckPresenceOf( \"LAMBDA_ACT_MBG\" )\n\t\tchecker.confCheckParameter( \"MAX_ACT\", \"KindArray\", \"NonNegative\" )\n\t\t\n\t\t// Custom checks\n\t\tchecker.confCheckStructureKindArray( this.conf[\"LAMBDA_ACT_MBG\"], \"LAMBDA_ACT_MBG\" )\n\t\tfor( let e of this.conf[\"LAMBDA_ACT_MBG\"] ){\n\t\t\tfor( let i of e ){\n\t\t\t\tif( !checker.isNonNegative(i) ){\n\t\t\t\t\tthrow(\"Elements of LAMBDA_ACT_MBG must be non-negative numbers!\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tchecker.confCheckPresenceOf( \"BACKGROUND_VOXELS\" )\n\t\tlet bgvox = this.conf[\"BACKGROUND_VOXELS\"]\n\t\t// Background voxels must be an array of arrays\n\t\tif( !(bgvox instanceof Array) ){\n\t\t\tthrow( \"Parameter BACKGROUND_VOXELS should be an array of at least two arrays!\" )\n\t\t} else if ( bgvox.length < 2 ){\n\t\t\tthrow( \"Parameter BACKGROUND_VOXELS should be an array of at least two arrays!\" )\n\t\t}\n\t\t// Elements of the initial array must be arrays.\n\t\tfor( let e of bgvox ){\n\t\t\tif( !(e instanceof Array) ){\n\t\t\t\tthrow( \"Parameter BACKGROUND_VOXELS should be an array of at least two arrays!\" )\n\t\t\t}\n\t\t\t\n\t\t\t// Entries of this array must be pixel coordinates, which are arrays of length C.extents.length\n\t\t\tfor( let ee of e ){\n\t\t\t\tlet isCoordinate = true\n\t\t\t\tif( !(ee instanceof Array) ){\n\t\t\t\t\tisCoordinate = false\n\t\t\t\t} else if ( ee.length != this.C.extents.length ){\n\t\t\t\t\tisCoordinate = false\n\t\t\t\t}\n\t\t\t\tif( !isCoordinate ){\n\t\t\t\t\tthrow( \"Parameter BACKGROUND_VOXELS: subarray elements should be ArrayCoordinates; arrays of length \" + this.C.extents.length + \"!\" )\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/** Get the background voxels from input argument or the conf object and store them in a correct format\n\tin this.bgvoxels. This only has to be done once, but can be called from outside to\n\tchange the background voxels during a simulation (eg in a HTML page).\n\t */\t\n\tsetBackgroundVoxels( voxels ){\n\t\n\t\tvoxels = voxels || this.conf[\"BACKGROUND_VOXELS\"]\n\t\n\t\t// reset if any exist already\n\t\tthis.bgvoxels = []\n\t\tfor( let bgkind = 0; bgkind < voxels.length; bgkind++ ){\n\t\t\tthis.bgvoxels.push({})\n\t\t\tfor( let v of voxels[bgkind] ){\n\t\t\t\tthis.bgvoxels[bgkind][ this.C.grid.p2i(v) ] = true\n\t\t\t}\n\t\t}\n\t\tthis.setup = true\n\n\t}\n\t\n\t/* ======= ACT MODEL ======= */\n\n\t/* Act model : compute local activity values within cell around pixel i.\n\t * Depending on settings in conf, this is an arithmetic (activityAtArith)\n\t * or geometric (activityAtGeom) mean of the activities of the neighbors\n\t * of pixel i.\n\t */\n\t/** Method to compute the Hamiltonian for this constraint. \n\t @param {IndexCoordinate} sourcei - coordinate of the source pixel that tries to copy.\n\t @param {IndexCoordinate} targeti - coordinate of the target pixel the source is trying\n\t to copy into.\n\t @param {CellId} src_type - cellid of the source pixel.\n\t @param {CellId} tgt_type - cellid of the target pixel. \n\t @return {number} the change in Hamiltonian for this copy attempt and this constraint.*/ \n\tdeltaH ( sourcei, targeti, src_type, tgt_type ){\n\t\n\t\tif( ! this.setup ){\n\t\t\tthis.setBackgroundVoxels()\n\t\t}\n\n\t\tlet deltaH = 0, maxact, lambdaact\n\t\tlet bgindex1 = 0, bgindex2 = 0\n\t\t\n\t\tfor( let bgkind = 0; bgkind < this.bgvoxels.length; bgkind++ ){\n\t\t\tif( sourcei in this.bgvoxels[bgkind] ){\n\t\t\t\tbgindex1 = bgkind\n\t\t\t}\n\t\t\tif( targeti in this.bgvoxels[bgkind] ){\n\t\t\t\tbgindex2 = bgkind\n\t\t\t}\n\t\t}\n\t\t\n\n\t\t// use parameters for the source cell, unless that is the background.\n\t\t// In that case, use parameters of the target cell.\n\t\tif( src_type != 0 ){\n\t\t\tmaxact = this.cellParameter(\"MAX_ACT\", src_type)\n\t\t\tlambdaact = this.cellParameter(\"LAMBDA_ACT_MBG\", src_type)[bgindex1]\n\t\t} else {\n\t\t\t// special case: punishment for a copy attempt from background into\n\t\t\t// an active cell. This effectively means that the active cell retracts,\n\t\t\t// which is different from one cell pushing into another (active) cell.\n\t\t\tmaxact = this.cellParameter(\"MAX_ACT\", tgt_type)\n\t\t\tlambdaact = this.cellParameter(\"LAMBDA_ACT_MBG\", tgt_type)[bgindex2]\n\t\t}\n\t\tif( !maxact || !lambdaact ){\n\t\t\treturn 0\n\t\t}\n\n\t\t// compute the Hamiltonian. The activityAt method is a wrapper for either activityAtArith\n\t\t// or activityAtGeom, depending on conf (see constructor).\t\n\t\tdeltaH += lambdaact*(this.activityAt( targeti ) - this.activityAt( sourcei ))/maxact\n\t\treturn deltaH\n\t}\n\n\n\n}\n\nexport default ActivityMultiBackground\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/hamiltonian/ActivityMultiBackground.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 418,
    "kind": "class",
    "name": "ActivityMultiBackground",
    "memberof": "src/hamiltonian/ActivityMultiBackground.js",
    "static": true,
    "longname": "src/hamiltonian/ActivityMultiBackground.js~ActivityMultiBackground",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/hamiltonian/ActivityMultiBackground.js",
    "importStyle": "ActivityMultiBackground",
    "description": "The ActivityMultiBackground constraint implements the activity constraint of Potts models,\nbut allows users to specify locations on the grid where LAMBDA_ACT is different. \nSee {@link ActivityConstraint} for the normal version of this constraint.\nSee {@link ActivityMultiBackground#constructor} for an explanation of the parameters.",
    "lineNumber": 11,
    "interface": false,
    "extends": [
      "src/hamiltonian/ActivityConstraint.js~ActivityConstraint"
    ]
  },
  {
    "__docId__": 419,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/hamiltonian/ActivityMultiBackground.js~ActivityMultiBackground",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ActivityMultiBackground.js~ActivityMultiBackground#constructor",
    "access": "public",
    "description": "The constructor of the ActivityConstraint requires a conf object with parameters.",
    "lineNumber": 28,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "conf",
        "description": "parameter object for this constraint"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "\"geometric\"",
        "defaultRaw": "geometric",
        "name": "conf.ACT_MEAN",
        "description": "should local mean activity be measured with an\n\"arithmetic\" or a \"geometric\" mean?"
      },
      {
        "nullable": null,
        "types": [
          "PerKindArray"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.LAMBDA_ACT_MBG",
        "description": "strength of the activityconstraint per cellkind and per background."
      },
      {
        "nullable": null,
        "types": [
          "PerKindNonNegative"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.MAX_ACT",
        "description": "how long do pixels remember their activity? Given per cellkind."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.BACKGROUND_VOXELS",
        "description": "an array where each element represents a different background type.\nThis is again an array of {@ArrayCoordinate}s of the pixels belonging to that backgroundtype. These pixels\nwill have the LAMBDA_ACT_MBG value of that backgroundtype, instead of the standard value."
      }
    ]
  },
  {
    "__docId__": 420,
    "kind": "member",
    "name": "cellpixelsact",
    "memberof": "src/hamiltonian/ActivityMultiBackground.js~ActivityMultiBackground",
    "static": false,
    "longname": "src/hamiltonian/ActivityMultiBackground.js~ActivityMultiBackground#cellpixelsact",
    "access": "public",
    "description": "Activity of all cellpixels with a non-zero activity is stored in this object,\nwith the {@link IndexCoordinate} of each pixel as key and its current activity as\nvalue. When the activity reaches 0, the pixel is removed from the object until it\nis added again. ",
    "lineNumber": 36,
    "type": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 421,
    "kind": "member",
    "name": "activityAt",
    "memberof": "src/hamiltonian/ActivityMultiBackground.js~ActivityMultiBackground",
    "static": false,
    "longname": "src/hamiltonian/ActivityMultiBackground.js~ActivityMultiBackground#activityAt",
    "access": "public",
    "description": "Wrapper: select function to compute activities based on ACT_MEAN in conf.\nDefault is to use the {@link activityAtGeom} for a geometric mean.",
    "lineNumber": 41,
    "type": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 423,
    "kind": "member",
    "name": "bgvoxels",
    "memberof": "src/hamiltonian/ActivityMultiBackground.js~ActivityMultiBackground",
    "static": false,
    "longname": "src/hamiltonian/ActivityMultiBackground.js~ActivityMultiBackground#bgvoxels",
    "access": "public",
    "description": "Store which pixels belong to which background type ",
    "lineNumber": 48,
    "type": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 424,
    "kind": "member",
    "name": "setup",
    "memberof": "src/hamiltonian/ActivityMultiBackground.js~ActivityMultiBackground",
    "static": false,
    "longname": "src/hamiltonian/ActivityMultiBackground.js~ActivityMultiBackground#setup",
    "access": "public",
    "description": "Track if this.bgvoxels has been set.",
    "lineNumber": 52,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 425,
    "kind": "method",
    "name": "confChecker",
    "memberof": "src/hamiltonian/ActivityMultiBackground.js~ActivityMultiBackground",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ActivityMultiBackground.js~ActivityMultiBackground#confChecker",
    "access": "public",
    "description": "This method checks that all required parameters are present in the object supplied to\nthe constructor, and that they are of the right format. It throws an error when this\nis not the case.",
    "lineNumber": 58,
    "params": [],
    "return": null
  },
  {
    "__docId__": 426,
    "kind": "method",
    "name": "setBackgroundVoxels",
    "memberof": "src/hamiltonian/ActivityMultiBackground.js~ActivityMultiBackground",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ActivityMultiBackground.js~ActivityMultiBackground#setBackgroundVoxels",
    "access": "public",
    "description": "Get the background voxels from input argument or the conf object and store them in a correct format\nin this.bgvoxels. This only has to be done once, but can be called from outside to\nchange the background voxels during a simulation (eg in a HTML page).",
    "lineNumber": 106,
    "params": [
      {
        "name": "voxels",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 429,
    "kind": "method",
    "name": "deltaH",
    "memberof": "src/hamiltonian/ActivityMultiBackground.js~ActivityMultiBackground",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ActivityMultiBackground.js~ActivityMultiBackground#deltaH",
    "access": "public",
    "description": "Method to compute the Hamiltonian for this constraint. ",
    "lineNumber": 136,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "sourcei",
        "description": "coordinate of the source pixel that tries to copy."
      },
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "targeti",
        "description": "coordinate of the target pixel the source is trying\nto copy into."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "src_type",
        "description": "cellid of the source pixel."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_type",
        "description": "cellid of the target pixel."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the change in Hamiltonian for this copy attempt and this constraint."
    }
  },
  {
    "__docId__": 430,
    "kind": "file",
    "name": "src/hamiltonian/Adhesion.js",
    "content": "import SoftConstraint from \"./SoftConstraint.js\"\nimport ParameterChecker from \"./ParameterChecker.js\"\n\n/** \n * Implements the adhesion constraint of Potts models. \n * Each pair of neighboring pixels [n,m] gets a positive energy penalty deltaH if n and m\n * do not belong to the same {@link CellId}.\n *\n * @example\n * // Build a CPM and add the constraint\n * let CPM = require( \"path/to/build\" )\n * let C = new CPM.CPM( [200,200], { T : 20 } )\n * C.add( new CPM.Adhesion( { J : [[0,20],[20,10]] } ) )\n * \n * // Or add automatically by entering the parameters in the CPM\n * let C2 = new CPM.CPM( [200,200], {\n * \tT : 20,\n * \tJ : [[0,20],[20,10]]\n * })\n */\nclass Adhesion extends SoftConstraint {\n\n\t/** The constructor of Adhesion requires a conf object with a single parameter J.\n\t@param {object} conf - parameter object for this constraint\n\t@param {CellKindInteractionMatrix} conf.J - J[n][m] gives the adhesion energy between a pixel of\n\t{@link CellKind} n and a pixel of {@link CellKind} m. J[n][n] is only non-zero\n\twhen the pixels in question are of the same {@link CellKind}, but a different \n\t{@link CellId}. Energies are given as non-negative numbers.\n\t*/\n\tconstructor( conf ){\n\t\tsuper( conf )\t\t\n\t}\n\n\t/** This method checks that all required parameters are present in the object supplied to\n\tthe constructor, and that they are of the right format. It throws an error when this\n\tis not the case.*/\n\tconfChecker(){\n\t\tlet checker = new ParameterChecker( this.conf, this.C )\n\t\tchecker.confCheckParameter( \"J\", \"KindMatrix\", \"Number\" )\n\t}\n\n\t/**  Get adhesion between two cells t1,t2 from \"conf\". \n\t@param {CellId} t1 - cellid of the first cell.\n\t@param {CellId} t2 - cellid of the second cell.\n\t@return {number} adhesion between a pixel of t1 and one of t2.\n\t@private\n\t*/\n\tJ( t1, t2 ) {\n\t\treturn this.cellParameter(\"J\", t1)[this.C.cellKind(t2)]\n\t}\n\t/**  Returns the Hamiltonian around a pixel i with cellid tp by checking all its\n\tneighbors that belong to a different cellid.\n\t@param {IndexCoordinate} i - coordinate of the pixel to evaluate hamiltonian at.\n\t@param {CellId} tp - cellid of this pixel.\n\t@return {number} sum over all neighbors of adhesion energies (only non-zero for \n\tneighbors belonging to a different cellid).\t\n\t@private\n\t */\n\tH( i, tp ){\n\t\tlet r = 0, tn\n\t\t/* eslint-disable */\n\t\tconst N = this.C.grid.neighi( i )\n\t\tfor( let j = 0 ; j < N.length ; j ++ ){\n\t\t\ttn = this.C.pixti( N[j] )\n\t\t\tif( tn != tp ) r += this.J( tn, tp )\n\t\t}\n\t\treturn r\n\t}\n\t/** Method to compute the Hamiltonian for this constraint. \n\t @param {IndexCoordinate} sourcei - coordinate of the source pixel that tries to copy.\n\t @param {IndexCoordinate} targeti - coordinate of the target pixel the source is trying\n\t to copy into.\n\t @param {CellId} src_type - cellid of the source pixel.\n\t @param {CellId} tgt_type - cellid of the target pixel. \n\t @return {number} the change in Hamiltonian for this copy attempt and this constraint.*/ \n\tdeltaH( sourcei, targeti, src_type, tgt_type ){\n\t\treturn this.H( targeti, src_type ) - this.H( targeti, tgt_type )\n\t}\n}\n\nexport default Adhesion\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/hamiltonian/Adhesion.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 431,
    "kind": "class",
    "name": "Adhesion",
    "memberof": "src/hamiltonian/Adhesion.js",
    "static": true,
    "longname": "src/hamiltonian/Adhesion.js~Adhesion",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/hamiltonian/Adhesion.js",
    "importStyle": "Adhesion",
    "description": "Implements the adhesion constraint of Potts models. \nEach pair of neighboring pixels [n,m] gets a positive energy penalty deltaH if n and m\ndo not belong to the same {@link CellId}.",
    "examples": [
      "// Build a CPM and add the constraint\nlet CPM = require( \"path/to/build\" )\nlet C = new CPM.CPM( [200,200], { T : 20 } )\nC.add( new CPM.Adhesion( { J : [[0,20],[20,10]] } ) )\n\n// Or add automatically by entering the parameters in the CPM\nlet C2 = new CPM.CPM( [200,200], {\n\tT : 20,\n\tJ : [[0,20],[20,10]]\n})"
    ],
    "lineNumber": 21,
    "interface": false,
    "extends": [
      "src/hamiltonian/SoftConstraint.js~SoftConstraint"
    ]
  },
  {
    "__docId__": 432,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/hamiltonian/Adhesion.js~Adhesion",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/Adhesion.js~Adhesion#constructor",
    "access": "public",
    "description": "The constructor of Adhesion requires a conf object with a single parameter J.",
    "lineNumber": 30,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "conf",
        "description": "parameter object for this constraint"
      },
      {
        "nullable": null,
        "types": [
          "CellKindInteractionMatrix"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.J",
        "description": "J[n][m] gives the adhesion energy between a pixel of\n{@link CellKind} n and a pixel of {@link CellKind} m. J[n][n] is only non-zero\nwhen the pixels in question are of the same {@link CellKind}, but a different \n{@link CellId}. Energies are given as non-negative numbers."
      }
    ]
  },
  {
    "__docId__": 433,
    "kind": "method",
    "name": "confChecker",
    "memberof": "src/hamiltonian/Adhesion.js~Adhesion",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/Adhesion.js~Adhesion#confChecker",
    "access": "public",
    "description": "This method checks that all required parameters are present in the object supplied to\nthe constructor, and that they are of the right format. It throws an error when this\nis not the case.",
    "lineNumber": 37,
    "params": [],
    "return": null
  },
  {
    "__docId__": 434,
    "kind": "method",
    "name": "J",
    "memberof": "src/hamiltonian/Adhesion.js~Adhesion",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/Adhesion.js~Adhesion#J",
    "access": "private",
    "description": " Get adhesion between two cells t1,t2 from \"conf\". ",
    "lineNumber": 48,
    "params": [
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "t1",
        "description": "cellid of the first cell."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "t2",
        "description": "cellid of the second cell."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "adhesion between a pixel of t1 and one of t2."
    }
  },
  {
    "__docId__": 435,
    "kind": "method",
    "name": "H",
    "memberof": "src/hamiltonian/Adhesion.js~Adhesion",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/Adhesion.js~Adhesion#H",
    "access": "private",
    "description": " Returns the Hamiltonian around a pixel i with cellid tp by checking all its\nneighbors that belong to a different cellid.",
    "lineNumber": 59,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "coordinate of the pixel to evaluate hamiltonian at."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "tp",
        "description": "cellid of this pixel."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "sum over all neighbors of adhesion energies (only non-zero for \nneighbors belonging to a different cellid)."
    }
  },
  {
    "__docId__": 436,
    "kind": "method",
    "name": "deltaH",
    "memberof": "src/hamiltonian/Adhesion.js~Adhesion",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/Adhesion.js~Adhesion#deltaH",
    "access": "public",
    "description": "Method to compute the Hamiltonian for this constraint. ",
    "lineNumber": 76,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "sourcei",
        "description": "coordinate of the source pixel that tries to copy."
      },
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "targeti",
        "description": "coordinate of the target pixel the source is trying\nto copy into."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "src_type",
        "description": "cellid of the source pixel."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_type",
        "description": "cellid of the target pixel."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the change in Hamiltonian for this copy attempt and this constraint."
    }
  },
  {
    "__docId__": 437,
    "kind": "file",
    "name": "src/hamiltonian/AttractionPointConstraint.js",
    "content": "import SoftConstraint from \"./SoftConstraint.js\"\nimport ParameterChecker from \"./ParameterChecker.js\"\n\n\n/**Implements bias of motion in the direction of a supplied \"attraction point\".\n * This constraint computes the cosine of the angle alpha between the direction\n * of the copy attempt (from source to target pixel), and the direction from the\n * source to the attraction point. This cosine is 1 if these directions are\n * aligned, 0 if they are perpendicular, and 1 if they are opposite.\n * We take the negative (so that deltaH is negative for a copy attempt in the\n * right direction), and modify the strength of this bias using the lambda\n * parameter. The constraint only acts on copy attempts *from* the cell that\n * is responding to the field; it does not take into account the target pixel\n * (except for its location to determine the direction of the copy attempt).\n *\n * The current implementation works for torus grids as long as the grid size in\n * each dimension is larger than a few pixels.\n *\n * Automatic adding of this constraint via the conf object is currently not\n * supported, so you will have to add this constraint using the\n * {@link CPM#add} method.\n *\n * @example\n * // Build a CPM and add the constraint\n * let CPM = require( \"path/to/build\" )\n * let C = new CPM.CPM( [200,200], { T : 20 } )\n * C.add( new CPM.AttractionPointConstraint( {\n * \tLAMBDA_ATTRACTIONPOINT : [0,100],\n * \tATTRACTIONPOINT: [[0,0],[100,100]],\n * } ) )\n *\n * // We can even add a second one at a different location\n * C.add( new CPM.AttractionPointConstraint( {\n * \tLAMBDA_ATTRACTIONPOINT : [0,100],\n * \tATTRACTIONPOINT: [50,50],\n * } ) )\n */\nclass AttractionPointConstraint extends SoftConstraint {\n\n\t/** The constructor of an AttractionPointConstraint requires a conf object\n\t * with two parameters.\n\t * @param {object} conf - parameter object for this constraint\n\t * @param {PerKindNonNegative} conf.LAMBDA_ATTRACTIONPOINT - strength of\n\t * the constraint per cellkind.\n\t * @param {ArrayCoordinate} conf.ATTRACTIONPOINT coordinate of the\n\t * attraction point.\n\t*/\n\tconstructor( conf ){\n\t\tsuper( conf )\t\t\n\t}\n\t\n\t/** This method checks that all required parameters are present in the\n\t * bject supplied to the constructor, and that they are of the right format.\n\t * It throws an error when this is not the case.*/\n\tconfChecker(){\n\t\tlet checker = new ParameterChecker( this.conf, this.C )\n\t\tchecker.confCheckParameter( \"LAMBDA_ATTRACTIONPOINT\",\n\t\t\t\"KindArray\", \"NonNegative\" )\n\t\t\n\t\t// Custom check for the attractionpoint\n\t\tchecker.confCheckPresenceOf( \"ATTRACTIONPOINT\" )\n\t\tlet pt = this.conf[\"ATTRACTIONPOINT\"]\n\t\tif( !checker.isCoordinate(pt) ){\n\t\t\tthrow( \"ATTRACTIONPOINT must be a coordinate array with the same \" +\n\t\t\t\t\"dimensions as the grid!\" )\n\t\t}\n\t}\n\n\t/** Method to compute the Hamiltonian for this constraint.\n\t * @param {IndexCoordinate} src_i - coordinate of the source pixel that\n\t * tries to copy.\n\t * @param {IndexCoordinate} tgt_i - coordinate of the target pixel the\n\t * source is trying to copy into.\n\t * @param {CellId} src_type - cellid of the source pixel.\n\t * @param {CellId} tgt_type - cellid of the target pixel. This argument is\n\t * not actually used but is given for consistency with other soft\n\t * constraints; the CPM always calls this method with four arguments.\n\t * @return {number} the change in Hamiltonian for this copy attempt and\n\t * this constraint. */\n\t/* eslint-disable no-unused-vars*/\n\tdeltaH( src_i, tgt_i, src_type, tgt_type ){\n\n\t\t// deltaH is only non-zero when the source pixel belongs to a cell with\n\t\t// an attraction point, so it does not act on copy attempts where the\n\t\t// background would invade the cell.\n\t\tlet l = this.cellParameter(\"LAMBDA_ATTRACTIONPOINT\", src_type )\n\t\tif( !l ){\n\t\t\treturn 0\n\t\t}\n\n\t\t// To assess whether the copy attempt lies in the direction of the\n\t\t// attraction point, we must take into account whether the grid has\n\t\t// wrapped boundaries (torus; see below).\n\t\tlet torus = this.C.conf.torus\n\n\t\t// tgt is the attraction point; p1 is the source location and p2 is\n\t\t// the location of the target pixel.\n\t\tlet tgt = this.cellParameter(\"ATTRACTIONPOINT\", src_type )\n\t\tlet p1 = this.C.grid.i2p( src_i ), p2 = this.C.grid.i2p( tgt_i )\n\n\t\t// To bias a copy attempt p1 -> p2 in the direction of vector 'dir'.\n\t\t// r will contain the dot product of the copy attempt vector and the\n\t\t// vector pointing from the source pixel to the attraction point.\n\t\t// The copy attempt vector always has length one, but the vector to the\n\t\t// attraction point has a variable length that will be stored in ldir\n\t\t// (actually, we store the squared length).\n\t\tlet r = 0., ldir = 0.\n\n\t\t// loops over the coordinates x,y,(z)\n\t\tfor( let i = 0; i < p1.length ; i++ ){\n\n\t\t\t// compute the distance between the target and the current position\n\t\t\t// in this dimension, and add it in squared form to the total.\n\t\t\tlet dir_i = tgt[i] - p1[i]\n\t\t\tldir += dir_i * dir_i\n\n\t\t\t// similarly, the distance between the source and target pixel in this\n\t\t\t// dimension (direction of the copy attempt is from p1 to p2)\n\t\t\tlet dx = p2[i] - p1[i]\n\n\t\t\t// we may have to correct for torus if a copy attempt crosses the\n\t\t\t// boundary.\n\t\t\tlet si = this.C.extents[i]\n\t\t\tif( torus[i] ){\n\t\t\t\t// If distance is greater than half the grid size, correct the\n\t\t\t\t// coordinate.\n\t\t\t\tif( dx > si/2 ){\n\t\t\t\t\tdx -= si\n\t\t\t\t} else if( dx < -si/2 ){\n\t\t\t\t\tdx += si\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// direction of the gradient; add contribution of the current\n\t\t\t// dimension to the dot product.\n\t\t\tr += dx * dir_i \n\t\t}\n\n\t\t// divide dot product by squared length of directional vector to obtain\n\t\t// cosine of the angle between the copy attempt direction and the\n\t\t// direction to the attraction point. This cosine is 1 if they are\n\t\t// perfectly aligned, 0 if they are perpendicular, and negative\n\t\t// if the directions are opposite. Since we want to reward copy attempts\n\t\t// in the right direction, deltaH is the negative of this (and\n\t\t// multiplied by the lambda weight factor).\n\t\treturn - r * l / Math.sqrt( ldir )\n\t}\n}\n\nexport default AttractionPointConstraint\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/hamiltonian/AttractionPointConstraint.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 438,
    "kind": "class",
    "name": "AttractionPointConstraint",
    "memberof": "src/hamiltonian/AttractionPointConstraint.js",
    "static": true,
    "longname": "src/hamiltonian/AttractionPointConstraint.js~AttractionPointConstraint",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/hamiltonian/AttractionPointConstraint.js",
    "importStyle": "AttractionPointConstraint",
    "description": "Implements bias of motion in the direction of a supplied \"attraction point\".\nThis constraint computes the cosine of the angle alpha between the direction\nof the copy attempt (from source to target pixel), and the direction from the\nsource to the attraction point. This cosine is 1 if these directions are\naligned, 0 if they are perpendicular, and 1 if they are opposite.\nWe take the negative (so that deltaH is negative for a copy attempt in the\nright direction), and modify the strength of this bias using the lambda\nparameter. The constraint only acts on copy attempts *from* the cell that\nis responding to the field; it does not take into account the target pixel\n(except for its location to determine the direction of the copy attempt).\n\nThe current implementation works for torus grids as long as the grid size in\neach dimension is larger than a few pixels.\n\nAutomatic adding of this constraint via the conf object is currently not\nsupported, so you will have to add this constraint using the\n{@link CPM#add} method.",
    "examples": [
      "// Build a CPM and add the constraint\nlet CPM = require( \"path/to/build\" )\nlet C = new CPM.CPM( [200,200], { T : 20 } )\nC.add( new CPM.AttractionPointConstraint( {\n\tLAMBDA_ATTRACTIONPOINT : [0,100],\n\tATTRACTIONPOINT: [[0,0],[100,100]],\n} ) )\n\n// We can even add a second one at a different location\nC.add( new CPM.AttractionPointConstraint( {\n\tLAMBDA_ATTRACTIONPOINT : [0,100],\n\tATTRACTIONPOINT: [50,50],\n} ) )"
    ],
    "lineNumber": 38,
    "interface": false,
    "extends": [
      "src/hamiltonian/SoftConstraint.js~SoftConstraint"
    ]
  },
  {
    "__docId__": 439,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/hamiltonian/AttractionPointConstraint.js~AttractionPointConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/AttractionPointConstraint.js~AttractionPointConstraint#constructor",
    "access": "public",
    "description": "The constructor of an AttractionPointConstraint requires a conf object\nwith two parameters.",
    "lineNumber": 48,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "conf",
        "description": "parameter object for this constraint"
      },
      {
        "nullable": null,
        "types": [
          "PerKindNonNegative"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.LAMBDA_ATTRACTIONPOINT",
        "description": "strength of\nthe constraint per cellkind."
      },
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.ATTRACTIONPOINT",
        "description": "coordinate of the\nattraction point."
      }
    ]
  },
  {
    "__docId__": 440,
    "kind": "method",
    "name": "confChecker",
    "memberof": "src/hamiltonian/AttractionPointConstraint.js~AttractionPointConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/AttractionPointConstraint.js~AttractionPointConstraint#confChecker",
    "access": "public",
    "description": "This method checks that all required parameters are present in the\nbject supplied to the constructor, and that they are of the right format.\nIt throws an error when this is not the case.",
    "lineNumber": 55,
    "params": [],
    "return": null
  },
  {
    "__docId__": 441,
    "kind": "method",
    "name": "deltaH",
    "memberof": "src/hamiltonian/AttractionPointConstraint.js~AttractionPointConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/AttractionPointConstraint.js~AttractionPointConstraint#deltaH",
    "access": "public",
    "description": "Method to compute the Hamiltonian for this constraint.",
    "lineNumber": 81,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "src_i",
        "description": "coordinate of the source pixel that\ntries to copy."
      },
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_i",
        "description": "coordinate of the target pixel the\nsource is trying to copy into."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "src_type",
        "description": "cellid of the source pixel."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_type",
        "description": "cellid of the target pixel. This argument is\nnot actually used but is given for consistency with other soft\nconstraints; the CPM always calls this method with four arguments."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the change in Hamiltonian for this copy attempt and\nthis constraint."
    }
  },
  {
    "__docId__": 442,
    "kind": "file",
    "name": "src/hamiltonian/AutoAdderConfig.js",
    "content": "\n\nimport Adhesion from \"./Adhesion.js\"\nimport VolumeConstraint from \"./VolumeConstraint.js\"\nimport ActivityConstraint from \"./ActivityConstraint.js\"\nimport PerimeterConstraint from \"./PerimeterConstraint.js\"\nimport BarrierConstraint from \"./BarrierConstraint.js\"\n\n/** This class enables automatic addition of Hamiltonian terms to a CPM\n * through their parameter names.\n *\n * For each parameter name, we specify one Hamiltonian term. If the parameter\n * is present, then a new instance of this term is initialized with the CPM's\n * configuration as parameter and added to the CPM. \n@type {object}\n@property {Constraint} J - An {@link Adhesion} constraint is added when there is a parameter J.\n@property {Constraint} LAMBDA_V - A {@link VolumeConstraint} is added when there is a parameter LAMBDA_V.\n@property {Constraint} LAMBDA_P - A {@link PerimeterConstraint} is added when there is a parameter LAMBDA_P.\n@property {Constraint} LAMBDA_ACT - An {@link ActivityConstraint} is added when there is a parameter LAMBDA_ACT.\n@property {Constraint} IS_BARRIER - A {@link BarrierConstraint} is added when there is a parameter IS_BARRIER.\n*/\nlet AutoAdderConfig = {\n\tJ : Adhesion,\n\tLAMBDA_V : VolumeConstraint,\n\tLAMBDA_ACT : ActivityConstraint,\n\tLAMBDA_P : PerimeterConstraint,\n\tIS_BARRIER : BarrierConstraint\n}\n\nexport default AutoAdderConfig\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/hamiltonian/AutoAdderConfig.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 443,
    "kind": "variable",
    "name": "AutoAdderConfig",
    "memberof": "src/hamiltonian/AutoAdderConfig.js",
    "static": true,
    "longname": "src/hamiltonian/AutoAdderConfig.js~AutoAdderConfig",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/hamiltonian/AutoAdderConfig.js",
    "importStyle": "AutoAdderConfig",
    "description": "This class enables automatic addition of Hamiltonian terms to a CPM\nthrough their parameter names.\n\nFor each parameter name, we specify one Hamiltonian term. If the parameter\nis present, then a new instance of this term is initialized with the CPM's\nconfiguration as parameter and added to the CPM. ",
    "lineNumber": 22,
    "properties": [
      {
        "nullable": null,
        "types": [
          "Constraint"
        ],
        "spread": false,
        "optional": false,
        "name": "J",
        "description": "An {@link Adhesion} constraint is added when there is a parameter J."
      },
      {
        "nullable": null,
        "types": [
          "Constraint"
        ],
        "spread": false,
        "optional": false,
        "name": "LAMBDA_V",
        "description": "A {@link VolumeConstraint} is added when there is a parameter LAMBDA_V."
      },
      {
        "nullable": null,
        "types": [
          "Constraint"
        ],
        "spread": false,
        "optional": false,
        "name": "LAMBDA_P",
        "description": "A {@link PerimeterConstraint} is added when there is a parameter LAMBDA_P."
      },
      {
        "nullable": null,
        "types": [
          "Constraint"
        ],
        "spread": false,
        "optional": false,
        "name": "LAMBDA_ACT",
        "description": "An {@link ActivityConstraint} is added when there is a parameter LAMBDA_ACT."
      },
      {
        "nullable": null,
        "types": [
          "Constraint"
        ],
        "spread": false,
        "optional": false,
        "name": "IS_BARRIER",
        "description": "A {@link BarrierConstraint} is added when there is a parameter IS_BARRIER."
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 444,
    "kind": "file",
    "name": "src/hamiltonian/BarrierConstraint.js",
    "content": "import HardConstraint from \"./HardConstraint.js\"\nimport ParameterChecker from \"./ParameterChecker.js\"\n\n/** \n * This constraint allows a \"barrier\" celltype from and into which copy attempts are forbidden.\n * @example\n * // Build a CPM and add the constraint\n * let CPM = require( \"path/to/build\" )\n * let C = new CPM.CPM( [200,200], {\n * \tT : 20,\n * \tJ : [[0,0,20],[0,0,5],[20,5,10]],\n * \tV : [0,0,500],\n * \tLAMBDA_V : [0,0,5],\n * })\n * C.add( new CPM.BarrierConstraint( {\n * \tIS_BARRIER : [false,true,false]\n * } ) )\n * \n * // OR: add automatically by entering the parameters in the CPM\n * C = new CPM.CPM( [200,200], {\n * \tT : 20,\n * \tJ : [[0,0,20],[0,0,5],[20,5,10]],\n * \tV : [0,0,500],\n * \tLAMBDA_V : [0,0,5],\n * \tIS_BARRIER : [false,true,false]\n * })\n * \n * // Make a horizontal line barrier (cellkind 1 )\n * let cid = C.makeNewCellID( 1 )\n * for( let x = 0; x < 200; x++ ){\n * \tC.setpix( [x,95], cid )\n * }\n * // Seed a cell (cellkind2)\n * let gm = new CPM.GridManipulator( C )\n * gm.seedCell(2)\n */\nclass BarrierConstraint extends HardConstraint {\n\n\t/** The constructor of the BarrierConstraint requires a conf object with a single parameter.\n\t@param {object} conf - parameter object for this constraint.\n\t@param {PerKindBoolean} conf.IS_BARRIER - specify for each cellkind if it should be \n \tconsidered as a barrier. If so, all copy attempts into and from it are forbidden.\n\t*/\n\tconstructor( conf ){\n\t\tsuper(conf)\n\t}\n\n\t/** This method checks that all required parameters are present in the object supplied to\n\tthe constructor, and that they are of the right format. It throws an error when this\n\tis not the case.*/\n\tconfChecker(){\n\t\tlet checker = new ParameterChecker( this.conf, this.C )\n\t\tchecker.confCheckParameter( \"IS_BARRIER\", \"KindArray\", \"Boolean\" )\n\t}\n\n\t/** Method for hard constraints to compute whether the copy attempt fulfills the rule.\n\t @param {IndexCoordinate} src_i - coordinate of the source pixel that tries to copy.\n\t @param {IndexCoordinate} tgt_i - coordinate of the target pixel the source is trying\n\t to copy into.\n\t @param {CellId} src_type - cellid of the source pixel.\n\t @param {CellId} tgt_type - cellid of the target pixel. \n\t @return {boolean} whether the copy attempt satisfies the constraint.*/ \n\tfulfilled( src_i, tgt_i, src_type, tgt_type ){\n\t\n\t\t// Fulfilled = false when either src or tgt pixel is of the barrier cellkind\t\n\t\tif( this.cellParameter(\"IS_BARRIER\", src_type ) ){\n\t\t\treturn false\n\t\t}\n\n\t\tif( this.cellParameter(\"IS_BARRIER\", tgt_type ) ){\n\t\t\treturn false\n\t\t}\n\n\t\treturn true\n\t}\n}\n\nexport default BarrierConstraint\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/hamiltonian/BarrierConstraint.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 445,
    "kind": "class",
    "name": "BarrierConstraint",
    "memberof": "src/hamiltonian/BarrierConstraint.js",
    "static": true,
    "longname": "src/hamiltonian/BarrierConstraint.js~BarrierConstraint",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/hamiltonian/BarrierConstraint.js",
    "importStyle": "BarrierConstraint",
    "description": "This constraint allows a \"barrier\" celltype from and into which copy attempts are forbidden.",
    "examples": [
      "// Build a CPM and add the constraint\nlet CPM = require( \"path/to/build\" )\nlet C = new CPM.CPM( [200,200], {\n\tT : 20,\n\tJ : [[0,0,20],[0,0,5],[20,5,10]],\n\tV : [0,0,500],\n\tLAMBDA_V : [0,0,5],\n})\nC.add( new CPM.BarrierConstraint( {\n\tIS_BARRIER : [false,true,false]\n} ) )\n\n// OR: add automatically by entering the parameters in the CPM\nC = new CPM.CPM( [200,200], {\n\tT : 20,\n\tJ : [[0,0,20],[0,0,5],[20,5,10]],\n\tV : [0,0,500],\n\tLAMBDA_V : [0,0,5],\n\tIS_BARRIER : [false,true,false]\n})\n\n// Make a horizontal line barrier (cellkind 1 )\nlet cid = C.makeNewCellID( 1 )\nfor( let x = 0; x < 200; x++ ){\n\tC.setpix( [x,95], cid )\n}\n// Seed a cell (cellkind2)\nlet gm = new CPM.GridManipulator( C )\ngm.seedCell(2)"
    ],
    "lineNumber": 37,
    "interface": false,
    "extends": [
      "src/hamiltonian/HardConstraint.js~HardConstraint"
    ]
  },
  {
    "__docId__": 446,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/hamiltonian/BarrierConstraint.js~BarrierConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/BarrierConstraint.js~BarrierConstraint#constructor",
    "access": "public",
    "description": "The constructor of the BarrierConstraint requires a conf object with a single parameter.",
    "lineNumber": 44,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "conf",
        "description": "parameter object for this constraint."
      },
      {
        "nullable": null,
        "types": [
          "PerKindBoolean"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.IS_BARRIER",
        "description": "specify for each cellkind if it should be \nconsidered as a barrier. If so, all copy attempts into and from it are forbidden."
      }
    ]
  },
  {
    "__docId__": 447,
    "kind": "method",
    "name": "confChecker",
    "memberof": "src/hamiltonian/BarrierConstraint.js~BarrierConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/BarrierConstraint.js~BarrierConstraint#confChecker",
    "access": "public",
    "description": "This method checks that all required parameters are present in the object supplied to\nthe constructor, and that they are of the right format. It throws an error when this\nis not the case.",
    "lineNumber": 51,
    "params": [],
    "return": null
  },
  {
    "__docId__": 448,
    "kind": "method",
    "name": "fulfilled",
    "memberof": "src/hamiltonian/BarrierConstraint.js~BarrierConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/BarrierConstraint.js~BarrierConstraint#fulfilled",
    "access": "public",
    "description": "Method for hard constraints to compute whether the copy attempt fulfills the rule.",
    "lineNumber": 63,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "src_i",
        "description": "coordinate of the source pixel that tries to copy."
      },
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_i",
        "description": "coordinate of the target pixel the source is trying\nto copy into."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "src_type",
        "description": "cellid of the source pixel."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_type",
        "description": "cellid of the target pixel."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "whether the copy attempt satisfies the constraint."
    }
  },
  {
    "__docId__": 449,
    "kind": "file",
    "name": "src/hamiltonian/BorderConstraint.js",
    "content": "\nimport HardConstraint from \"./HardConstraint.js\"\nimport ParameterChecker from \"./ParameterChecker.js\"\n/** \n * This constraint allows a set of \"barrier\" background pixels, into \n * which copy attempts are forbidden.\n * @example\n * // Build a CPM and add the constraint\n * let CPM = require( \"path/to/build\" )\n * let C = new CPM.CPM( [200,200], {\n * \tT : 20,\n * \tJ : [[0,20],[20,10]],\n * \tV : [0,500],\n * \tLAMBDA_V : [0,5],\n * })\n * \n * // Build a barrier and add the border constraint\n * let border = []\n * let channelwidth = 10\n * for( let x = 0; x < C.extents[0]; x++ ){\n * \tlet ymin = Math.floor( C.extents[1]/2 )\n *  let ymax = ymin + channelwidth\n *  border.push( [x,ymin] )\n *  border.push( [x,ymax] )\n * }\n * \n * C.add( new CPM.BorderConstraint( {\n * \tBARRIER_VOXELS : border\n * } ) )\n * \n * // Seed a cell\n * let gm = new CPM.GridManipulator( C )\n * gm.seedCell(1)\n */\nclass BorderConstraint extends HardConstraint {\n\n\t/** Creates an instance of the ActivityMultiBackground constraint \n\t* @param {object} conf - Configuration object with the parameters.\n\t* ACT_MEAN is a single string determining whether the activity mean should be computed\n\t* using a \"geometric\" or \"arithmetic\" mean. \n\t*/\n\t/** The constructor of the ActivityConstraint requires a conf object with parameters.\n\t@param {object} conf - parameter object for this constraint\n\t@param {string} [conf.ACT_MEAN=\"geometric\"] - should local mean activity be measured with an\n\t\"arithmetic\" or a \"geometric\" mean?\n\t@param {PerKindArray} conf.LAMBDA_ACT_MBG - strength of the activityconstraint per cellkind and per background.\n\t@param {PerKindNonNegative} conf.MAX_ACT - how long do pixels remember their activity? Given per cellkind.\n\t@param {Array} conf.BACKGROUND_VOXELS - an array where each element represents a different background type.\n\tThis is again an array of {@ArrayCoordinate}s of the pixels belonging to that backgroundtype. These pixels\n\twill have the LAMBDA_ACT_MBG value of that backgroundtype, instead of the standard value.\n\t*/\n\tconstructor( conf ){\n\t\tsuper( conf )\n\t\n\t\t/** Store which pixels are barrier pixels. Each entry has key the {@IndexCoordinate} of\n\t\tthe pixel, and value equal to true.\n\t\t@type {object}*/\n\t\tthis.barriervoxels = {}\n\t\t\n\t\t/** Track if this.barriervoxels has been set.\n\t\t@type {boolean}*/\n\t\tthis.setup = false\n\t}\n\t\n\t\n\t\n\t/** This method checks that all required parameters are present in the object supplied to\n\tthe constructor, and that they are of the right format. It throws an error when this\n\tis not the case.*/\n\tconfChecker(){\n\t\tlet checker = new ParameterChecker( this.conf, this.C )\n\n\t\tchecker.confCheckPresenceOf( \"BARRIER_VOXELS\" )\n\t\tlet barriervox = this.conf[\"BARRIER_VOXELS\"]\n\t\t// Barrier voxels must be an array of arrays\n\t\tif( !(barriervox instanceof Array) ){\n\t\t\tthrow( \"Parameter BARRIER_VOXELS should be an array!\" )\n\t\t} \n\t\t// Elements of the initial array must be arrays.\n\t\tfor( let e of barriervox ){\n\t\t\t\n\t\t\tlet isCoordinate = true\n\t\t\tif( !(e instanceof Array)){\n\t\t\t\tisCoordinate = false\n\t\t\t} else if( e.length != this.C.extents.length ){\n\t\t\t\tisCoordinate = false\n\t\t\t}\n\t\t\tif( !isCoordinate ){\n\t\t\t\tthrow( \"Parameter BARRIER_VOXELS: elements should be ArrayCoordinates; arrays of length \" + this.C.extents.length + \"!\" )\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\t/** Get the background voxels from input argument or the conf object and store them in a correct format\n\tin this.barriervoxels. This only has to be done once, but can be called from outside to\n\tchange the background voxels during a simulation (eg in a HTML page).\n\t@param {ArrayCoordinate[]} voxels - the pixels that should act as barrier.\n\t */\t\n\tsetBarrierVoxels( voxels ){\n\t\n\t\tvoxels = voxels || this.conf[\"BARRIER_VOXELS\"]\n\t\n\t\t// reset if any exist already\n\t\tthis.barriervoxels = {}\n\t\tfor( let v of voxels ){\n\t\t\tthis.barriervoxels[ this.C.grid.p2i(v) ] = true\n\t\t}\n\t\tthis.setup = true\n\n\t}\n\t\n\t/** Method for hard constraints to compute whether the copy attempt fulfills the rule.\n\t @param {IndexCoordinate} src_i - coordinate of the source pixel that tries to copy.\n\t @param {IndexCoordinate} tgt_i - coordinate of the target pixel the source is trying\n\t to copy into.\n\t @param {CellId} src_type - cellid of the source pixel.\n\t @param {CellId} tgt_type - cellid of the target pixel. \n\t @return {boolean} whether the copy attempt satisfies the constraint.*/ \n\t// eslint-disable-next-line no-unused-vars\n\tfulfilled( src_i, tgt_i, src_type, tgt_type ){\n\t\n\t\tif( !this.setup ){\n\t\t\tthis.setBarrierVoxels()\n\t\t}\n\t\n\t\t// If the target pixel is a barrier pixel, forbid the copy attempt.\n\t\tif( tgt_i in this.barriervoxels ){\n\t\t\treturn false\n\t\t}\n\t\t\n\t\t// Otherwise accept it.\n\t\treturn true\n\t}\n\n\n\n}\n\nexport default BorderConstraint\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/hamiltonian/BorderConstraint.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 450,
    "kind": "class",
    "name": "BorderConstraint",
    "memberof": "src/hamiltonian/BorderConstraint.js",
    "static": true,
    "longname": "src/hamiltonian/BorderConstraint.js~BorderConstraint",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/hamiltonian/BorderConstraint.js",
    "importStyle": "BorderConstraint",
    "description": "This constraint allows a set of \"barrier\" background pixels, into \nwhich copy attempts are forbidden.",
    "examples": [
      "// Build a CPM and add the constraint\nlet CPM = require( \"path/to/build\" )\nlet C = new CPM.CPM( [200,200], {\n\tT : 20,\n\tJ : [[0,20],[20,10]],\n\tV : [0,500],\n\tLAMBDA_V : [0,5],\n})\n\n// Build a barrier and add the border constraint\nlet border = []\nlet channelwidth = 10\nfor( let x = 0; x < C.extents[0]; x++ ){\n\tlet ymin = Math.floor( C.extents[1]/2 )\n let ymax = ymin + channelwidth\n border.push( [x,ymin] )\n border.push( [x,ymax] )\n}\n\nC.add( new CPM.BorderConstraint( {\n\tBARRIER_VOXELS : border\n} ) )\n\n// Seed a cell\nlet gm = new CPM.GridManipulator( C )\ngm.seedCell(1)"
    ],
    "lineNumber": 35,
    "interface": false,
    "extends": [
      "src/hamiltonian/HardConstraint.js~HardConstraint"
    ]
  },
  {
    "__docId__": 451,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/hamiltonian/BorderConstraint.js~BorderConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/BorderConstraint.js~BorderConstraint#constructor",
    "access": "public",
    "description": "The constructor of the ActivityConstraint requires a conf object with parameters.",
    "lineNumber": 52,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "conf",
        "description": "parameter object for this constraint"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "\"geometric\"",
        "defaultRaw": "geometric",
        "name": "conf.ACT_MEAN",
        "description": "should local mean activity be measured with an\n\"arithmetic\" or a \"geometric\" mean?"
      },
      {
        "nullable": null,
        "types": [
          "PerKindArray"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.LAMBDA_ACT_MBG",
        "description": "strength of the activityconstraint per cellkind and per background."
      },
      {
        "nullable": null,
        "types": [
          "PerKindNonNegative"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.MAX_ACT",
        "description": "how long do pixels remember their activity? Given per cellkind."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.BACKGROUND_VOXELS",
        "description": "an array where each element represents a different background type.\nThis is again an array of {@ArrayCoordinate}s of the pixels belonging to that backgroundtype. These pixels\nwill have the LAMBDA_ACT_MBG value of that backgroundtype, instead of the standard value."
      }
    ]
  },
  {
    "__docId__": 452,
    "kind": "member",
    "name": "barriervoxels",
    "memberof": "src/hamiltonian/BorderConstraint.js~BorderConstraint",
    "static": false,
    "longname": "src/hamiltonian/BorderConstraint.js~BorderConstraint#barriervoxels",
    "access": "public",
    "description": "Store which pixels are barrier pixels. Each entry has key the {@IndexCoordinate} of\nthe pixel, and value equal to true.",
    "lineNumber": 58,
    "type": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 453,
    "kind": "member",
    "name": "setup",
    "memberof": "src/hamiltonian/BorderConstraint.js~BorderConstraint",
    "static": false,
    "longname": "src/hamiltonian/BorderConstraint.js~BorderConstraint#setup",
    "access": "public",
    "description": "Track if this.barriervoxels has been set.",
    "lineNumber": 62,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 454,
    "kind": "method",
    "name": "confChecker",
    "memberof": "src/hamiltonian/BorderConstraint.js~BorderConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/BorderConstraint.js~BorderConstraint#confChecker",
    "access": "public",
    "description": "This method checks that all required parameters are present in the object supplied to\nthe constructor, and that they are of the right format. It throws an error when this\nis not the case.",
    "lineNumber": 70,
    "params": [],
    "return": null
  },
  {
    "__docId__": 455,
    "kind": "method",
    "name": "setBarrierVoxels",
    "memberof": "src/hamiltonian/BorderConstraint.js~BorderConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/BorderConstraint.js~BorderConstraint#setBarrierVoxels",
    "access": "public",
    "description": "Get the background voxels from input argument or the conf object and store them in a correct format\nin this.barriervoxels. This only has to be done once, but can be called from outside to\nchange the background voxels during a simulation (eg in a HTML page).",
    "lineNumber": 101,
    "params": [
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate[]"
        ],
        "spread": false,
        "optional": false,
        "name": "voxels",
        "description": "the pixels that should act as barrier."
      }
    ],
    "return": null
  },
  {
    "__docId__": 458,
    "kind": "method",
    "name": "fulfilled",
    "memberof": "src/hamiltonian/BorderConstraint.js~BorderConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/BorderConstraint.js~BorderConstraint#fulfilled",
    "access": "public",
    "description": "Method for hard constraints to compute whether the copy attempt fulfills the rule.",
    "lineNumber": 122,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "src_i",
        "description": "coordinate of the source pixel that tries to copy."
      },
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_i",
        "description": "coordinate of the target pixel the source is trying\nto copy into."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "src_type",
        "description": "cellid of the source pixel."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_type",
        "description": "cellid of the target pixel."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "whether the copy attempt satisfies the constraint."
    }
  },
  {
    "__docId__": 459,
    "kind": "file",
    "name": "src/hamiltonian/ChemotaxisConstraint.js",
    "content": "import SoftConstraint from \"./SoftConstraint.js\"\nimport CoarseGrid from \"../grid/CoarseGrid.js\"\nimport Grid2D from \"../grid/Grid2D.js\"\nimport ParameterChecker from \"./ParameterChecker.js\"\n\n\n/** \n * This class implements a constraint for cells moving up a chemotactic gradient.\n * It checks the chemokine gradient in the direction of the attempted copy, and \n * rewards copy attempts that go up the gradient. This effect is stronger when the\n * gradient is steep. Copy attempts going to a lower chemokine value are punished.\n * \n * The grid with the chemokine must be supplied, see the {@link constructor}.\n *\n * @example\n * // Build a chemotaxis field\n * let CPM = require( \"path/to/build\" )\n * let chemogrid = new CPM.Grid2D( [200,200], [true,true], \"Float32\" )\n * chemogrid.setpix( [100,100], 100 )\n * \n * // Build a CPM with the constraint\n * let C = new CPM.CPM( [200,200], {\n * \tT : 20,\n * \tJ : [[0,20],[20,10]],\n * \tV : [0,500],\n * \tLAMBDA_V : [0,5]\t\n * })\n * C.add( new CPM.ChemotaxisConstraint( {\n * \tLAMBDA_CH : [0,5000],\n * \tCH_FIELD : chemogrid\n * } ) )\n */\nclass ChemotaxisConstraint extends SoftConstraint {\n\n\t/** Set the CPM attached to this constraint.\n\t@param {CPM} C - the CPM to attach.*/\n\tset CPM(C){\n\t\tsuper.CPM = C\n\t\t\n\t\tthis.checkField()\n\t}\n\t\n\t/** @todo add checks for dimensions, better check for type.*/\n\tcheckField(){\n\t\tif( !( this.field instanceof CoarseGrid || this.field instanceof Grid2D ) ){\n\t\t\tthrow( \"CH_FIELD must be a CoarseGrid or a Grid2D!\" )\n\t\t}\n\t}\n\t\n\t/** This method checks that all required parameters are present in the object supplied to\n\tthe constructor, and that they are of the right format. It throws an error when this\n\tis not the case.*/\n\tconfChecker(){\n\t\tlet checker = new ParameterChecker( this.conf, this.C )\n\t\tchecker.confCheckParameter( \"LAMBDA_CH\", \"KindArray\", \"NonNegative\" )\n\n\t\t// Custom check for the chemotactic field\n\t\tchecker.confCheckPresenceOf( \"CH_FIELD\" )\n\t}\n\n\t/** The constructor of the ChemotaxisConstraint requires a conf object with a parameter\n\tand a chemotactic field.\n\t@todo what kinds of grids are allowed for the chemotactic field? Do we need to check\n\tsomewhere that its properties \"match\" that of the CPM? (That is, the same resolution and\n\ttorus properties)?\n\t@param {object} conf - parameter object for this constraint\n\t@param {PerKindNonNegative} conf.LAMBDA_CH - chemotactic sensitivity per cellkind.\n\t@param {CoarseGrid|Grid2D} conf.CH_FIELD - the chemotactic field where the chemokine lives.\n\t*/\n\tconstructor( conf ){\n\t\tsuper( conf )\n\t\t\n\t\t/** @todo is this ever used? */\n\t\tthis.conf = conf\n\t\t/** The field where the chemokine lives.\n\t\t@type {CoarseGrid|Grid2D}*/\n\t\tthis.field = conf.CH_FIELD\n\t\tif( this.field instanceof CoarseGrid ){\n\t\t\tthis.deltaH = this.deltaHCoarse\n\t\t}\n\t}\n\n\t/** Method to compute the Hamiltonian if the chemotactic field is a {@link CoarseGrid}.\n\t\tThis method is used instead of the regular {@link deltaH} whenever this is true.\n\t @param {IndexCoordinate} sourcei - coordinate of the source pixel that tries to copy.\n\t @param {IndexCoordinate} targeti - coordinate of the target pixel the source is trying\n\t to copy into.\n\t @param {CellId} src_type - cellid of the source pixel.\n\t @param {CellId} tgt_type - cellid of the target pixel. This argument is not actually\n\t used by this method, but is supplied for compatibility; the CPM will always call the\n\t deltaH method with all 4 arguments.\n\t @return {number} the change in Hamiltonian for this copy attempt and this constraint.\n\t @private */\n\t/* eslint-disable no-unused-vars*/\n\tdeltaHCoarse( sourcei, targeti, src_type, tgt_type ){\n\t\tlet sp = this.C.grid.i2p( sourcei ), tp = this.C.grid.i2p( targeti )\n\t\tlet delta = this.field.pixt( tp ) - this.field.pixt( sp )\n\t\tlet lambdachem = this.cellParameter(\"LAMBDA_CH\", src_type)\n\t\treturn -delta*lambdachem\n\t}\n\n\t/** Method to compute the Hamiltonian for this constraint. \n\t @param {IndexCoordinate} sourcei - coordinate of the source pixel that tries to copy.\n\t @param {IndexCoordinate} targeti - coordinate of the target pixel the source is trying\n\t to copy into.\n\t @param {CellId} src_type - cellid of the source pixel.\n\t @param {CellId} tgt_type - cellid of the target pixel. This argument is not actually\n\t used by this method, but is supplied for compatibility; the CPM will always call the\n\t deltaH method with all 4 arguments.\n\t @return {number} the change in Hamiltonian for this copy attempt and this constraint.*/\n\t/* eslint-disable no-unused-vars*/\n\tdeltaH( sourcei, targeti, src_type, tgt_type  ){\n\t\tlet delta = this.field.pixt( targeti ) - this.field.pixt( sourcei )\n\t\tlet lambdachem = this.cellParameter(\"LAMBDA_CH\",src_type)\n\t\treturn -delta*lambdachem\n\t}\n}\n\nexport default ChemotaxisConstraint\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/hamiltonian/ChemotaxisConstraint.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 460,
    "kind": "class",
    "name": "ChemotaxisConstraint",
    "memberof": "src/hamiltonian/ChemotaxisConstraint.js",
    "static": true,
    "longname": "src/hamiltonian/ChemotaxisConstraint.js~ChemotaxisConstraint",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/hamiltonian/ChemotaxisConstraint.js",
    "importStyle": "ChemotaxisConstraint",
    "description": "This class implements a constraint for cells moving up a chemotactic gradient.\nIt checks the chemokine gradient in the direction of the attempted copy, and \nrewards copy attempts that go up the gradient. This effect is stronger when the\ngradient is steep. Copy attempts going to a lower chemokine value are punished.\n\nThe grid with the chemokine must be supplied, see the {@link constructor}.",
    "examples": [
      "// Build a chemotaxis field\nlet CPM = require( \"path/to/build\" )\nlet chemogrid = new CPM.Grid2D( [200,200], [true,true], \"Float32\" )\nchemogrid.setpix( [100,100], 100 )\n\n// Build a CPM with the constraint\nlet C = new CPM.CPM( [200,200], {\n\tT : 20,\n\tJ : [[0,20],[20,10]],\n\tV : [0,500],\n\tLAMBDA_V : [0,5]\t\n})\nC.add( new CPM.ChemotaxisConstraint( {\n\tLAMBDA_CH : [0,5000],\n\tCH_FIELD : chemogrid\n} ) )"
    ],
    "lineNumber": 33,
    "interface": false,
    "extends": [
      "src/hamiltonian/SoftConstraint.js~SoftConstraint"
    ]
  },
  {
    "__docId__": 461,
    "kind": "set",
    "name": "CPM",
    "memberof": "src/hamiltonian/ChemotaxisConstraint.js~ChemotaxisConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ChemotaxisConstraint.js~ChemotaxisConstraint#CPM",
    "access": "public",
    "description": "Set the CPM attached to this constraint.",
    "lineNumber": 37,
    "params": [
      {
        "nullable": null,
        "types": [
          "CPM"
        ],
        "spread": false,
        "optional": false,
        "name": "C",
        "description": "the CPM to attach."
      }
    ]
  },
  {
    "__docId__": 462,
    "kind": "method",
    "name": "checkField",
    "memberof": "src/hamiltonian/ChemotaxisConstraint.js~ChemotaxisConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ChemotaxisConstraint.js~ChemotaxisConstraint#checkField",
    "access": "public",
    "description": null,
    "lineNumber": 44,
    "todo": [
      "add checks for dimensions, better check for type."
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 463,
    "kind": "method",
    "name": "confChecker",
    "memberof": "src/hamiltonian/ChemotaxisConstraint.js~ChemotaxisConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ChemotaxisConstraint.js~ChemotaxisConstraint#confChecker",
    "access": "public",
    "description": "This method checks that all required parameters are present in the object supplied to\nthe constructor, and that they are of the right format. It throws an error when this\nis not the case.",
    "lineNumber": 53,
    "params": [],
    "return": null
  },
  {
    "__docId__": 464,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/hamiltonian/ChemotaxisConstraint.js~ChemotaxisConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ChemotaxisConstraint.js~ChemotaxisConstraint#constructor",
    "access": "public",
    "description": "The constructor of the ChemotaxisConstraint requires a conf object with a parameter\nand a chemotactic field.",
    "lineNumber": 70,
    "todo": [
      "what kinds of grids are allowed for the chemotactic field? Do we need to check\nsomewhere that its properties \"match\" that of the CPM? (That is, the same resolution and\ntorus properties)?"
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "conf",
        "description": "parameter object for this constraint"
      },
      {
        "nullable": null,
        "types": [
          "PerKindNonNegative"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.LAMBDA_CH",
        "description": "chemotactic sensitivity per cellkind."
      },
      {
        "nullable": null,
        "types": [
          "CoarseGrid",
          "Grid2D"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.CH_FIELD",
        "description": "the chemotactic field where the chemokine lives."
      }
    ]
  },
  {
    "__docId__": 465,
    "kind": "member",
    "name": "conf",
    "memberof": "src/hamiltonian/ChemotaxisConstraint.js~ChemotaxisConstraint",
    "static": false,
    "longname": "src/hamiltonian/ChemotaxisConstraint.js~ChemotaxisConstraint#conf",
    "access": "public",
    "description": null,
    "lineNumber": 74,
    "todo": [
      "is this ever used?"
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 466,
    "kind": "member",
    "name": "field",
    "memberof": "src/hamiltonian/ChemotaxisConstraint.js~ChemotaxisConstraint",
    "static": false,
    "longname": "src/hamiltonian/ChemotaxisConstraint.js~ChemotaxisConstraint#field",
    "access": "public",
    "description": "The field where the chemokine lives.",
    "lineNumber": 77,
    "type": {
      "nullable": null,
      "types": [
        "CoarseGrid",
        "Grid2D"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 468,
    "kind": "method",
    "name": "deltaHCoarse",
    "memberof": "src/hamiltonian/ChemotaxisConstraint.js~ChemotaxisConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ChemotaxisConstraint.js~ChemotaxisConstraint#deltaHCoarse",
    "access": "private",
    "description": "Method to compute the Hamiltonian if the chemotactic field is a {@link CoarseGrid}.\nThis method is used instead of the regular {@link deltaH} whenever this is true.",
    "lineNumber": 95,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "sourcei",
        "description": "coordinate of the source pixel that tries to copy."
      },
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "targeti",
        "description": "coordinate of the target pixel the source is trying\nto copy into."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "src_type",
        "description": "cellid of the source pixel."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_type",
        "description": "cellid of the target pixel. This argument is not actually\nused by this method, but is supplied for compatibility; the CPM will always call the\ndeltaH method with all 4 arguments."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the change in Hamiltonian for this copy attempt and this constraint."
    }
  },
  {
    "__docId__": 469,
    "kind": "method",
    "name": "deltaH",
    "memberof": "src/hamiltonian/ChemotaxisConstraint.js~ChemotaxisConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ChemotaxisConstraint.js~ChemotaxisConstraint#deltaH",
    "access": "public",
    "description": "Method to compute the Hamiltonian for this constraint. ",
    "lineNumber": 112,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "sourcei",
        "description": "coordinate of the source pixel that tries to copy."
      },
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "targeti",
        "description": "coordinate of the target pixel the source is trying\nto copy into."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "src_type",
        "description": "cellid of the source pixel."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_type",
        "description": "cellid of the target pixel. This argument is not actually\nused by this method, but is supplied for compatibility; the CPM will always call the\ndeltaH method with all 4 arguments."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the change in Hamiltonian for this copy attempt and this constraint."
    }
  },
  {
    "__docId__": 470,
    "kind": "file",
    "name": "src/hamiltonian/ConnectivityConstraint.js",
    "content": "\n\nimport HardConstraint from \"./HardConstraint.js\"\nimport ParameterChecker from \"./ParameterChecker.js\"\n\n/** This constraint enforces that cells stay 'connected' throughout any copy attempts.\nCopy attempts that break the cell into two parts are therefore forbidden. To speed things\nup, this constraint only checks if the borderpixels of the cells stay connected.\n@experimental\n*/\nclass ConnectivityConstraint extends HardConstraint {\n\n\t/** The constructor of the ConnectivityConstraint requires a conf object with one parameter.\n\t@param {object} conf - parameter object for this constraint.\n\t@param {PerKindBoolean} conf.CONNECTED - should the cellkind be connected or not?\n\t*/\n\tconstructor( conf ){\n\t\tsuper(conf)\n\t\t\n\t\t/** Object tracking the borderpixels of each cell. This is kept up to date after\n\t\tevery copy attempt.\n\t\t@type {CellObject}*/\n\t\tthis.borderpixelsbycell = {}\n\t}\n\t\n\t/** The set CPM method attaches the CPM to the constraint. */\n\tset CPM(C){\n\t\tsuper.CPM = C\n\t\t\n\t\t/** Private property used by {@link updateBorderPixels} to track borders. \n\t\t@private\n\t\t@type {Uint16Array} */\n\t\tthis._neighbours = new Uint16Array(this.C.grid.p2i(this.C.extents))\n\t}\n\t\n\t/** This method checks that all required parameters are present in the object supplied to\n\tthe constructor, and that they are of the right format. It throws an error when this\n\tis not the case.*/\n\tconfChecker(){\n\t\tlet checker = new ParameterChecker( this.conf, this.C )\n\t\tchecker.confCheckParameter( \"CONNECTED\", \"KindArray\", \"Boolean\" )\n\t}\n\t\n\t/** Update the borderpixels when pixel i changes from t_old into t_new.\n\t@param {IndexCoordinate} i - the pixel to change\n\t@param {CellId} t_old - the cell the pixel belonged to previously\n\t@param {CellId} t_new - the cell the pixel belongs to now. */\n\tupdateBorderPixels( i, t_old, t_new  ){\n\t\tif( t_old == t_new ) return\n\t\tif( !(t_new in this.borderpixelsbycell) ){\n\t\t\tthis.borderpixelsbycell[t_new] = {}\n\t\t}\n\t\tconst Ni = this.C.grid.neighi( i )\n\t\tconst wasborder = this._neighbours[i] > 0\n\t\t// current neighbors of pixel i, set counter to zero and loop over nbh.\n\t\tthis._neighbours[i] = 0\n\t\tfor( let ni of Ni  ){\n\t\t\t// type of the neighbor.\n\t\t\tconst nt = this.C.grid.pixti(ni)\n\t\t\t\n\t\t\t// If type is not the t_new of pixel i, nbi++ because the neighbor belongs\n\t\t\t// to a different cell. \n\t\t\tif( nt != t_new ){\n\t\t\t\tthis._neighbours[i] ++ \n\t\t\t}\n\t\t\t\n\t\t\t// If neighbor type is t_old, the border of t_old may have to be adjusted. \n\t\t\t// It gets an extra neighbor because the current pixel becomes t_new.\n\t\t\tif( nt == t_old ){\n\t\t\t\t// If this wasn't a borderpixel of t_old, it now becomes one because\n\t\t\t\t// it has a neighbor belonging to t_new\n\t\t\t\tif( this._neighbours[ni] ++ == 0 ){\n\t\t\t\t\tif( !(t_old in this.borderpixelsbycell) ){\n\t\t\t\t\t\tthis.borderpixelsbycell[t_old] = {}\n\t\t\t\t\t}\n\t\t\t\t\tthis.borderpixelsbycell[t_old][ni] = true\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// If type is t_new, the neighbor may no longer be a borderpixel\n\t\t\tif( nt == t_new ){\n\t\t\t\tif( --this._neighbours[ni] == 0 && ( ni in this.borderpixelsbycell[t_new] ) ){\n\t\t\t\t\tdelete this.borderpixelsbycell[t_new][ni]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Case 1: \n\t\t// If current pixel is a borderpixel, add it to those of the current cell.\n\t\tif( this._neighbours[i] > 0 ){\n\t\t\tthis.borderpixelsbycell[t_new][i]=true\n\t\t}\n\t\t\n\t\t// Case 2:\n\t\t// Current pixel was a borderpixel. Remove from the old cell. \n\t\tif( wasborder ){\n\t\t\t// It was a borderpixel from the old cell, but no longer belongs to that cell.\n\t\t\tif( i in this.borderpixelsbycell[t_old] ){ \n\t\t\t\tdelete this.borderpixelsbycell[t_old][i]\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\t/** Get the connected components of the borderpixels of the current cell.\n\t@param {CellId} cellid - cell to check the connected components of.\n\t@return {object} an array with an element for every connected component, which is in\n\tturn an array of the {@link ArrayCoordinate}s of the pixels belonging to that component.  */\n\tconnectedComponentsOfCellBorder( cellid ){\n\t\n\t\t/* Note that to get number of connected components, we only need to look at cellborderpixels. */\n\t\tif( !( cellid in this.borderpixelsbycell ) ){\n\t\t\treturn []\n\t\t}\n\t\t\n\t\t//let cbpi = Object.keys( this.borderpixelsbycell[cellid] ), cbpobject = this.borderpixelsbycell[cellid]\n\t\treturn this.connectedComponentsOf( this.borderpixelsbycell[cellid] )\n\t\t\t\n\t\t\n\t}\n\t\n\t\n\t/** Get the connected components of a set of pixels.\n\t@param {object} pixelobject - an object with as keys the {@link IndexCoordinate}s of the pixels to check.\n\t@return {object} an array with an element for every connected component, which is in\n\tturn an array of the {@link ArrayCoordinate}s of the pixels belonging to that component.  */\n\tconnectedComponentsOf( pixelobject ){\n\t\n\t\tlet cbpi = Object.keys( pixelobject )\n\t\t\n\t\tlet visited = {}, k=0, pixels = [], C = this.C\n\t\tlet labelComponent = function(seed, k){\n\t\t\tlet q = [seed]\n\t\t\tlet cellid = C.pixti(q)\n\t\t\tvisited[q[0]] = 1\n\t\t\tpixels[k] = []\n\t\t\twhile( q.length > 0 ){\n\t\t\t\tlet e = q.pop()\n\t\t\t\tpixels[k].push(C.grid.i2p(e) )\n\t\t\t\tlet ne = C.grid.neighi( e )\n\t\t\t\tfor( let i = 0 ; i < ne.length ; i ++ ){\n\t\t\t\t\tif( C.pixti( ne[i] ) == cellid &&\n\t\t\t\t\t\t!(ne[i] in visited) && (ne[i] in pixelobject) ){\n\t\t\t\t\t\tq.push(ne[i])\n\t\t\t\t\t\tvisited[ne[i]]=1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor( let i = 0 ; i < cbpi.length ; i ++ ){\n\t\t\tlet pi = cbpi[i]\n\t\t\tif( !(pi in visited) ){\n\t\t\t\tlabelComponent( pi, k )\n\t\t\t\tk++\n\t\t\t}\n\t\t}\n\t\treturn pixels\n\t}\n\n\t/** The postSetpixListener of the ConnectivityConstraint updates the internally\n\ttracked borderpixels after every copy.\n\t@param {IndexCoordinate} i - the pixel to change\n\t@param {CellId} t_old - the cell the pixel belonged to previously\n\t@param {CellId} t - the cell the pixel belongs to now.\t\n\t*/\n\tpostSetpixListener(  i, t_old, t ){\n\t\tthis.updateBorderPixels( i, t_old, t )\n\t}\t\n\t\n\t/** To speed things up: first check if a pixel change disrupts the local connectivity\n\tin its direct neighborhood. If local connectivity is not disrupted, we don't have to\n\tcheck global connectivity at all. This currently only works in 2D, so it returns \n\tfalse for 3D (ensuring that connectivity is checked globally).\n\t@param {IndexCoordinate} tgt_i - the pixel to change\n\t@param {CellId} tgt_type - the cell the pixel belonged to before the copy attempt.\n\t@return {boolean} does the local neighborhood remain connected if this pixel changes?\n\t*/\n\tlocalConnected( tgt_i, tgt_type ){\n\t\n\t\tif( this.C.extents.length != 2 ){\n\t\t\treturn false\n\t\t}\n\t\n\t\tlet neighbors = 0\n\t\tfor( let i of this.C.grid.neighNeumanni(tgt_i) ){\n\t\t\tif( this.C.pixti(i) != tgt_type ){\n\t\t\t\tneighbors++\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( neighbors >= 2 ){\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t\t\n\t}\n\t\n\t/** This method checks if the connectivity still holds after pixel tgt_i is changed from\n\ttgt_type to src_type. \n\t@param {IndexCoordinate} tgt_i - the pixel to change\n\t@param {CellId} src_type - the new cell for this pixel.\n\t@param {CellId} tgt_type - the cell the pixel belonged to previously. \t\n\t*/\n\tcheckConnected( tgt_i, src_type, tgt_type ){\n\t\n\t\t// If local connectivity is preserved, global connectivity holds too.\n\t\tif( this.localConnected( tgt_i, tgt_type ) ){\n\t\t\treturn true\n\t\t}\n\t\n\t\t// Otherwise, check connected components of the cell border. Before the copy attempt:\n\t\tlet comp1 = this.connectedComponentsOfCellBorder( tgt_type )\n\t\tlet length_before = comp1.length\n\t\n\t\t// Update the borderpixels as if the change occurs\n\t\tthis.updateBorderPixels( tgt_i, tgt_type, src_type )\n\t\tlet comp = this.connectedComponentsOfCellBorder( tgt_type )\n\t\tlet length_after = comp.length\n\t\t\n\t\t// The src pixels copies its type, so the cell src_type gains a pixel. This\n\t\t// pixel is by definition connected because the copy happens from a neighbor.\n\t\t// So we only have to check if tgt_type remains connected\n\t\tlet connected = true\n\t\tif( length_after > length_before ){\n\t\t\tconnected = false\n\t\t}\n\t\t\n\t\t// Change borderpixels back because the copy attempt hasn't actually gone through yet.\n\t\tthis.updateBorderPixels( tgt_i, src_type, tgt_type )\n\t\t\n\t\treturn connected\n\t\t\n\t}\n\n\t/** Method for hard constraints to compute whether the copy attempt fulfills the rule.\n\t @param {IndexCoordinate} src_i - coordinate of the source pixel that tries to copy.\n\t @param {IndexCoordinate} tgt_i - coordinate of the target pixel the source is trying\n\t to copy into.\n\t @param {CellId} src_type - cellid of the source pixel.\n\t @param {CellId} tgt_type - cellid of the target pixel. \n\t @return {boolean} whether the copy attempt satisfies the constraint.*/ \n\tfulfilled( src_i, tgt_i, src_type, tgt_type ){\n\t\t// connectedness of src cell cannot change if it was connected in the first place.\n\t\t\n\t\t// connectedness of tgt cell\n\t\tif( tgt_type != 0 && this.cellParameter(\"CONNECTED\",tgt_type) ){\n\t\t\treturn this.checkConnected( tgt_i, src_type, tgt_type )\n\t\t}\n\t\t\n\t\treturn true\n\t}\n}\n\nexport default ConnectivityConstraint\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/hamiltonian/ConnectivityConstraint.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 471,
    "kind": "class",
    "name": "ConnectivityConstraint",
    "memberof": "src/hamiltonian/ConnectivityConstraint.js",
    "static": true,
    "longname": "src/hamiltonian/ConnectivityConstraint.js~ConnectivityConstraint",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/hamiltonian/ConnectivityConstraint.js",
    "importStyle": "ConnectivityConstraint",
    "description": "This constraint enforces that cells stay 'connected' throughout any copy attempts.\nCopy attempts that break the cell into two parts are therefore forbidden. To speed things\nup, this constraint only checks if the borderpixels of the cells stay connected.",
    "lineNumber": 11,
    "experimental": true,
    "interface": false,
    "extends": [
      "src/hamiltonian/HardConstraint.js~HardConstraint"
    ]
  },
  {
    "__docId__": 472,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/hamiltonian/ConnectivityConstraint.js~ConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ConnectivityConstraint.js~ConnectivityConstraint#constructor",
    "access": "public",
    "description": "The constructor of the ConnectivityConstraint requires a conf object with one parameter.",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "conf",
        "description": "parameter object for this constraint."
      },
      {
        "nullable": null,
        "types": [
          "PerKindBoolean"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.CONNECTED",
        "description": "should the cellkind be connected or not?"
      }
    ]
  },
  {
    "__docId__": 473,
    "kind": "member",
    "name": "borderpixelsbycell",
    "memberof": "src/hamiltonian/ConnectivityConstraint.js~ConnectivityConstraint",
    "static": false,
    "longname": "src/hamiltonian/ConnectivityConstraint.js~ConnectivityConstraint#borderpixelsbycell",
    "access": "public",
    "description": "Object tracking the borderpixels of each cell. This is kept up to date after\nevery copy attempt.",
    "lineNumber": 23,
    "type": {
      "nullable": null,
      "types": [
        "CellObject"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 474,
    "kind": "set",
    "name": "CPM",
    "memberof": "src/hamiltonian/ConnectivityConstraint.js~ConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ConnectivityConstraint.js~ConnectivityConstraint#CPM",
    "access": "public",
    "description": "The set CPM method attaches the CPM to the constraint.",
    "lineNumber": 27
  },
  {
    "__docId__": 475,
    "kind": "member",
    "name": "_neighbours",
    "memberof": "src/hamiltonian/ConnectivityConstraint.js~ConnectivityConstraint",
    "static": false,
    "longname": "src/hamiltonian/ConnectivityConstraint.js~ConnectivityConstraint#_neighbours",
    "access": "private",
    "description": "Private property used by {@link updateBorderPixels} to track borders. ",
    "lineNumber": 33,
    "type": {
      "nullable": null,
      "types": [
        "Uint16Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 476,
    "kind": "method",
    "name": "confChecker",
    "memberof": "src/hamiltonian/ConnectivityConstraint.js~ConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ConnectivityConstraint.js~ConnectivityConstraint#confChecker",
    "access": "public",
    "description": "This method checks that all required parameters are present in the object supplied to\nthe constructor, and that they are of the right format. It throws an error when this\nis not the case.",
    "lineNumber": 39,
    "params": [],
    "return": null
  },
  {
    "__docId__": 477,
    "kind": "method",
    "name": "updateBorderPixels",
    "memberof": "src/hamiltonian/ConnectivityConstraint.js~ConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ConnectivityConstraint.js~ConnectivityConstraint#updateBorderPixels",
    "access": "public",
    "description": "Update the borderpixels when pixel i changes from t_old into t_new.",
    "lineNumber": 48,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "the pixel to change"
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "t_old",
        "description": "the cell the pixel belonged to previously"
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "t_new",
        "description": "the cell the pixel belongs to now."
      }
    ],
    "return": null
  },
  {
    "__docId__": 478,
    "kind": "method",
    "name": "connectedComponentsOfCellBorder",
    "memberof": "src/hamiltonian/ConnectivityConstraint.js~ConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ConnectivityConstraint.js~ConnectivityConstraint#connectedComponentsOfCellBorder",
    "access": "public",
    "description": "Get the connected components of the borderpixels of the current cell.",
    "lineNumber": 108,
    "params": [
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "cellid",
        "description": "cell to check the connected components of."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "an array with an element for every connected component, which is in\nturn an array of the {@link ArrayCoordinate}s of the pixels belonging to that component."
    }
  },
  {
    "__docId__": 479,
    "kind": "method",
    "name": "connectedComponentsOf",
    "memberof": "src/hamiltonian/ConnectivityConstraint.js~ConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ConnectivityConstraint.js~ConnectivityConstraint#connectedComponentsOf",
    "access": "public",
    "description": "Get the connected components of a set of pixels.",
    "lineNumber": 126,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "pixelobject",
        "description": "an object with as keys the {@link IndexCoordinate}s of the pixels to check."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "an array with an element for every connected component, which is in\nturn an array of the {@link ArrayCoordinate}s of the pixels belonging to that component."
    }
  },
  {
    "__docId__": 480,
    "kind": "method",
    "name": "postSetpixListener",
    "memberof": "src/hamiltonian/ConnectivityConstraint.js~ConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ConnectivityConstraint.js~ConnectivityConstraint#postSetpixListener",
    "access": "public",
    "description": "The postSetpixListener of the ConnectivityConstraint updates the internally\ntracked borderpixels after every copy.",
    "lineNumber": 165,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "the pixel to change"
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "t_old",
        "description": "the cell the pixel belonged to previously"
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "t",
        "description": "the cell the pixel belongs to now."
      }
    ],
    "return": null
  },
  {
    "__docId__": 481,
    "kind": "method",
    "name": "localConnected",
    "memberof": "src/hamiltonian/ConnectivityConstraint.js~ConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ConnectivityConstraint.js~ConnectivityConstraint#localConnected",
    "access": "public",
    "description": "To speed things up: first check if a pixel change disrupts the local connectivity\nin its direct neighborhood. If local connectivity is not disrupted, we don't have to\ncheck global connectivity at all. This currently only works in 2D, so it returns \nfalse for 3D (ensuring that connectivity is checked globally).",
    "lineNumber": 177,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_i",
        "description": "the pixel to change"
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_type",
        "description": "the cell the pixel belonged to before the copy attempt."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "does the local neighborhood remain connected if this pixel changes?"
    }
  },
  {
    "__docId__": 482,
    "kind": "method",
    "name": "checkConnected",
    "memberof": "src/hamiltonian/ConnectivityConstraint.js~ConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ConnectivityConstraint.js~ConnectivityConstraint#checkConnected",
    "access": "public",
    "description": "This method checks if the connectivity still holds after pixel tgt_i is changed from\ntgt_type to src_type. ",
    "lineNumber": 203,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_i",
        "description": "the pixel to change"
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "src_type",
        "description": "the new cell for this pixel."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_type",
        "description": "the cell the pixel belonged to previously."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 483,
    "kind": "method",
    "name": "fulfilled",
    "memberof": "src/hamiltonian/ConnectivityConstraint.js~ConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ConnectivityConstraint.js~ConnectivityConstraint#fulfilled",
    "access": "public",
    "description": "Method for hard constraints to compute whether the copy attempt fulfills the rule.",
    "lineNumber": 241,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "src_i",
        "description": "coordinate of the source pixel that tries to copy."
      },
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_i",
        "description": "coordinate of the target pixel the source is trying\nto copy into."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "src_type",
        "description": "cellid of the source pixel."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_type",
        "description": "cellid of the target pixel."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "whether the copy attempt satisfies the constraint."
    }
  },
  {
    "__docId__": 484,
    "kind": "file",
    "name": "src/hamiltonian/Constraint.js",
    "content": "/** This base class defines a general CPM constraint and provides methods that do not \ndepend on the specific constraint used. This class is never used on its own, \nas it does not yet contain the actual definition of a constraint (such as a deltaH method).\n\nIn general, we distinguish between two types of constraint:\n\n- a {@link HardConstraint} is a hard rule that *must* be fulfilled in order for a copy\nattempt to succeed;\n- a {@link SoftConstraint} is an energy term in the Hamiltonian that can make a copy \nattempt either more or less energetically favourable, but does not by itself determine\nwhether a copy attempt will succeed. An unfavourable outcome may be outbalanced by \nfavourable energies from other terms, and even a copy attempt net unfavourable \nenergy (deltaH > 0) may succeed with a success chance P = exp(-DeltaH/T). \n\nSee the subclasses {@link SoftConstraint} and {@link HardConstraint} for details. Each\nimplemented constraint is in turn a subclass of one of these two.\n*/\nclass Constraint {\n\n\t/** This method is actually implemented in the subclass.\n\t@abstract\n\t*/\n\tget CONSTRAINT_TYPE() {\n\t\tthrow(\"You need to implement the 'CONSTRAINT_TYPE' getter for this constraint!\")\n\t}\n\t\n\t/** Get the parameters of this constraint from the conf object. \n\t@return {object} conf - configuration settings for this constraint, containing the\n\trelevant parameters.\n\t*/\n\tget parameters(){\n\t\treturn this.conf\n\t}\n\n\t/** Get a cellid or cellkind-specific parameter for a constraint. \n\t * This function is here to document its functionality, but it is \n\t * always overwritten by the constructor (via \"set CPM\") to point\n\t * to another function. This is normally  @function  paramOfKind,\n\t * which retrieves the parameter from the conf object for the current {@link cellKind}.\n\t * If CPMEvol is used this is instead redirected to @function  paramOfCell,\n\t * which looks whether the parameter is overwritten in an @object Cell\n\t * and otherwise returns @function paramOfKind\n\t * @abstract\n\t * \n\t * @param {string} param - name of parameter in conf object\n\t * @param {CellId} cid - Cell Id of cell in question, if id-specific parameter is not present, cellkind of cid is used\n\t@return {any} parameter - the requested parameter\n\t*/\n\t/* eslint-disable no-unused-vars */\n\tcellParameter(param, cid){\n\t\tthrow( \"this is a template function that should never actually be called as it is overwritten to point to paramOfCell() or paramOfKind().\")\n\t}\n\n\t/**\n\t * Get a cellId specific parameter, only used if CPMEvol is used: \n\t * looks whether the requested parameter is overwritten in an @object Cell\n\t * and otherwise returns @function paramOfKind\n\t * \n\t * @param {string} param - name of parameter in conf object\n\t * @param {CellId} cid - Cell Id of cell in question, if id-specific parameter is not present, cellkind of cid is used\n\t@return {any} parameter - the requested parameter\n\t*/\n\tparamOfCell(param, cid){\n\t\tif (this.C.cells[cid][param] !== undefined){\n\t\t\treturn this.C.cells[cid][param]\n\t\t}\n\t\treturn this.paramOfKind(param,cid)\n\t}\n\n\t/** Returns a cellKind specfic variable: \n\t * Assumes that the parameter is indexable by cellkind.\n\t *\n\t * @param {string} param - name of parameter in conf object\n\t * @param {CellId} cid - Cell Id of cell in question, if id-specific parameter is not present, cellkind of cid is used\n\t@return {any} parameter - the requested parameter\n\t*/\n\tparamOfKind(param, cid){\n\t\treturn this.conf[param][this.C.cellKind(cid)]\n\t}\n\t\n\t/** The constructor of a constraint takes a configuration object.\n\tThis method is usually overwritten by the actual constraint so that the entries\n\tof this object can be documented.\n\t@param {object} conf - configuration settings for this constraint, containing the\n\trelevant parameters.\n\t@abstract*/\n\tconstructor( conf ){\n\t\t/** Configuration object for this constraint.\n\t\t@type {object}*/\n\t\tthis.conf = conf\n\t}\n\t/** This function attaches the relevant CPM to this constraint, so that information\n\tabout this cpm can be requested from the constraint. If the cpm is of type CPMEvol,\n\tthe cellParameter call is redirected to check for CellId-specific parameters.\n\t@todo Check why some constraints overwrite this? Because that disables the automatic\n\tusage of a confChecker() when it is implemented. \n\t@param {CPM} C - the CPM to attach to this constraint.*/\n\t/*eslint-disable*/\n\tset CPM(C){\n\t\t/** CPM on which this constraint acts.\n\t\t@type {CPM}*/\n\t\tthis.C = C\n\t\tthis.cellParameter = this.paramOfKind\n\t\tif (C.constructor.name === \"CPMEvol\"){\n\t\t\tthis.cellParameter = this.paramOfCell\n\t\t}\n\t\tif( typeof this.confChecker === \"function\" ){\n\t\t\tthis.confChecker()\n\t\t}\n\t}\n\t/** The optional confChecker method should verify that all the required conf parameters\n\tare actually present in the conf object and have the right format. It is implemented in\n\tthe subclass that specifies the actual constraint.\n\t@abstract */\n\tconfChecker( ){\n\t}\n\n}\n\nexport default Constraint\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/hamiltonian/Constraint.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 485,
    "kind": "class",
    "name": "Constraint",
    "memberof": "src/hamiltonian/Constraint.js",
    "static": true,
    "longname": "src/hamiltonian/Constraint.js~Constraint",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/hamiltonian/Constraint.js",
    "importStyle": "Constraint",
    "description": "This base class defines a general CPM constraint and provides methods that do not \ndepend on the specific constraint used. This class is never used on its own, \nas it does not yet contain the actual definition of a constraint (such as a deltaH method).\n\nIn general, we distinguish between two types of constraint:\n\n- a {@link HardConstraint} is a hard rule that *must* be fulfilled in order for a copy\nattempt to succeed;\n- a {@link SoftConstraint} is an energy term in the Hamiltonian that can make a copy \nattempt either more or less energetically favourable, but does not by itself determine\nwhether a copy attempt will succeed. An unfavourable outcome may be outbalanced by \nfavourable energies from other terms, and even a copy attempt net unfavourable \nenergy (deltaH > 0) may succeed with a success chance P = exp(-DeltaH/T). \n\nSee the subclasses {@link SoftConstraint} and {@link HardConstraint} for details. Each\nimplemented constraint is in turn a subclass of one of these two.",
    "lineNumber": 18,
    "interface": false
  },
  {
    "__docId__": 486,
    "kind": "get",
    "name": "CONSTRAINT_TYPE",
    "memberof": "src/hamiltonian/Constraint.js~Constraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/Constraint.js~Constraint#CONSTRAINT_TYPE",
    "access": "public",
    "description": "This method is actually implemented in the subclass.",
    "lineNumber": 23,
    "abstract": true,
    "type": null
  },
  {
    "__docId__": 487,
    "kind": "get",
    "name": "parameters",
    "memberof": "src/hamiltonian/Constraint.js~Constraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/Constraint.js~Constraint#parameters",
    "access": "public",
    "description": "Get the parameters of this constraint from the conf object. ",
    "lineNumber": 31,
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "conf - configuration settings for this constraint, containing the\nrelevant parameters."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 488,
    "kind": "method",
    "name": "cellParameter",
    "memberof": "src/hamiltonian/Constraint.js~Constraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/Constraint.js~Constraint#cellParameter",
    "access": "public",
    "description": "Get a cellid or cellkind-specific parameter for a constraint. \nThis function is here to document its functionality, but it is \nalways overwritten by the constructor (via \"set CPM\") to point\nto another function. This is normally  @function  paramOfKind,\nwhich retrieves the parameter from the conf object for the current {@link cellKind}.\nIf CPMEvol is used this is instead redirected to @function  paramOfCell,\nwhich looks whether the parameter is overwritten in an @object Cell\nand otherwise returns @function paramOfKind",
    "lineNumber": 50,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "param",
        "description": "name of parameter in conf object"
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "cid",
        "description": "Cell Id of cell in question, if id-specific parameter is not present, cellkind of cid is used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "any"
      ],
      "spread": false,
      "description": "parameter - the requested parameter"
    },
    "abstract": true
  },
  {
    "__docId__": 489,
    "kind": "method",
    "name": "paramOfCell",
    "memberof": "src/hamiltonian/Constraint.js~Constraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/Constraint.js~Constraint#paramOfCell",
    "access": "public",
    "description": "Get a cellId specific parameter, only used if CPMEvol is used: \nlooks whether the requested parameter is overwritten in an @object Cell\nand otherwise returns @function paramOfKind",
    "lineNumber": 63,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "param",
        "description": "name of parameter in conf object"
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "cid",
        "description": "Cell Id of cell in question, if id-specific parameter is not present, cellkind of cid is used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "any"
      ],
      "spread": false,
      "description": "parameter - the requested parameter"
    }
  },
  {
    "__docId__": 490,
    "kind": "method",
    "name": "paramOfKind",
    "memberof": "src/hamiltonian/Constraint.js~Constraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/Constraint.js~Constraint#paramOfKind",
    "access": "public",
    "description": "Returns a cellKind specfic variable: \nAssumes that the parameter is indexable by cellkind.",
    "lineNumber": 77,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "param",
        "description": "name of parameter in conf object"
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "cid",
        "description": "Cell Id of cell in question, if id-specific parameter is not present, cellkind of cid is used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "any"
      ],
      "spread": false,
      "description": "parameter - the requested parameter"
    }
  },
  {
    "__docId__": 491,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/hamiltonian/Constraint.js~Constraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/Constraint.js~Constraint#constructor",
    "access": "public",
    "description": "The constructor of a constraint takes a configuration object.\nThis method is usually overwritten by the actual constraint so that the entries\nof this object can be documented.",
    "lineNumber": 87,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "conf",
        "description": "configuration settings for this constraint, containing the\nrelevant parameters."
      }
    ],
    "abstract": true
  },
  {
    "__docId__": 492,
    "kind": "member",
    "name": "conf",
    "memberof": "src/hamiltonian/Constraint.js~Constraint",
    "static": false,
    "longname": "src/hamiltonian/Constraint.js~Constraint#conf",
    "access": "public",
    "description": "Configuration object for this constraint.",
    "lineNumber": 90,
    "type": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 493,
    "kind": "set",
    "name": "CPM",
    "memberof": "src/hamiltonian/Constraint.js~Constraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/Constraint.js~Constraint#CPM",
    "access": "public",
    "description": "This function attaches the relevant CPM to this constraint, so that information\nabout this cpm can be requested from the constraint. If the cpm is of type CPMEvol,\nthe cellParameter call is redirected to check for CellId-specific parameters.",
    "lineNumber": 99,
    "todo": [
      "Check why some constraints overwrite this? Because that disables the automatic\nusage of a confChecker() when it is implemented. "
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "CPM"
        ],
        "spread": false,
        "optional": false,
        "name": "C",
        "description": "the CPM to attach to this constraint."
      }
    ]
  },
  {
    "__docId__": 494,
    "kind": "member",
    "name": "C",
    "memberof": "src/hamiltonian/Constraint.js~Constraint",
    "static": false,
    "longname": "src/hamiltonian/Constraint.js~Constraint#C",
    "access": "public",
    "description": "CPM on which this constraint acts.",
    "lineNumber": 102,
    "type": {
      "nullable": null,
      "types": [
        "CPM"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 497,
    "kind": "method",
    "name": "confChecker",
    "memberof": "src/hamiltonian/Constraint.js~Constraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/Constraint.js~Constraint#confChecker",
    "access": "public",
    "description": "The optional confChecker method should verify that all the required conf parameters\nare actually present in the conf object and have the right format. It is implemented in\nthe subclass that specifies the actual constraint.",
    "lineNumber": 115,
    "abstract": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 498,
    "kind": "file",
    "name": "src/hamiltonian/HardConstraint.js",
    "content": "import Constraint from \"./Constraint.js\"\n\n/** Extension of class {@link Constraint} used for a hard constraint. See description in\n {@link Constraint} for details. This class is not used on its own but serves as a base\n class for a hard constraint. */\nclass HardConstraint extends Constraint {\n\n\t/** Let the CPM know that this is a soft constraint, so return 'soft'.\n\t@return {string} \"hard\"*/\n\tget CONSTRAINT_TYPE() {\n\t\treturn \"hard\"\n\t}\n\t/*constructor( conf ){\n\t\tthis.conf = conf\n\t}*/\n\t/*set CPM(C){\n\t\tthis.C = C\n\t}*/\n\t\n\t/** Hard constraints must have a 'fulfilled' method to compute whether the copy attempt fulfills the rule.\n\tThis method must be implemented in the subclass.\n\t @param {IndexCoordinate} src_i - coordinate of the source pixel that tries to copy.\n\t @param {IndexCoordinate} tgt_i - coordinate of the target pixel the source is trying\n\t to copy into.\n\t @param {CellId} src_type - cellid of the source pixel.\n\t @param {CellId} tgt_type - cellid of the target pixel. \n\t @return {boolean} whether the copy attempt satisfies the constraint.\n\t @abstract\n\t */ \n\t// eslint-disable-next-line no-unused-vars\n\tfulfilled( src_i, tgt_i, src_type, tgt_type ){\n\t\tthrow(\"You need to implement the 'fulfilled' method for this constraint!\")\n\t}\n}\n\nexport default HardConstraint\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/hamiltonian/HardConstraint.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 499,
    "kind": "class",
    "name": "HardConstraint",
    "memberof": "src/hamiltonian/HardConstraint.js",
    "static": true,
    "longname": "src/hamiltonian/HardConstraint.js~HardConstraint",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/hamiltonian/HardConstraint.js",
    "importStyle": "HardConstraint",
    "description": "Extension of class {@link Constraint} used for a hard constraint. See description in\n{@link Constraint} for details. This class is not used on its own but serves as a base\nclass for a hard constraint.",
    "lineNumber": 6,
    "interface": false,
    "extends": [
      "src/hamiltonian/Constraint.js~Constraint"
    ]
  },
  {
    "__docId__": 500,
    "kind": "get",
    "name": "CONSTRAINT_TYPE",
    "memberof": "src/hamiltonian/HardConstraint.js~HardConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/HardConstraint.js~HardConstraint#CONSTRAINT_TYPE",
    "access": "public",
    "description": "Let the CPM know that this is a soft constraint, so return 'soft'.",
    "lineNumber": 10,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "\"hard\""
    },
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 501,
    "kind": "method",
    "name": "fulfilled",
    "memberof": "src/hamiltonian/HardConstraint.js~HardConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/HardConstraint.js~HardConstraint#fulfilled",
    "access": "public",
    "description": "Hard constraints must have a 'fulfilled' method to compute whether the copy attempt fulfills the rule.\nThis method must be implemented in the subclass.",
    "lineNumber": 31,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "src_i",
        "description": "coordinate of the source pixel that tries to copy."
      },
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_i",
        "description": "coordinate of the target pixel the source is trying\nto copy into."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "src_type",
        "description": "cellid of the source pixel."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_type",
        "description": "cellid of the target pixel."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "whether the copy attempt satisfies the constraint."
    },
    "abstract": true
  },
  {
    "__docId__": 502,
    "kind": "file",
    "name": "src/hamiltonian/HardVolumeRangeConstraint.js",
    "content": "\n\nimport HardConstraint from \"./HardConstraint.js\"\nimport ParameterChecker from \"./ParameterChecker.js\"\n\n/** \n * This constraint forbids that cells exceed or fall below a certain size range. \n * @example\n * // Build a CPM and add the constraint\n * let CPM = require( \"path/to/build\" )\n * let C = new CPM.CPM( [200,200], {T : 4})\n * C.add( new CPM.HardVolumeRangeConstraint( {\n * \tLAMBDA_VRANGE_MIN : [0,1],\n * \tLAMBDA_VRANGE_MAX : [0,2]\n * } ) )\n */\nclass HardVolumeRangeConstraint extends HardConstraint {\n\n\t/** The constructor of the HardVolumeRangeConstraint requires a conf object with two parameters.\n\t@param {object} conf - parameter object for this constraint.\n\t@param {PerKindNonNegative} conf.LAMBDA_VRANGE_MIN - minimum volume of each cellkind.\n\t@param {PerKindNonNegative} conf.LAMBDA_VRANGE_MAX - maximum volume of each cellkind.\n\t*/\n\tconstructor( conf ){\n\t\tsuper(conf)\n\t}\n\t\n\t/** This method checks that all required parameters are present in the object supplied to\n\tthe constructor, and that they are of the right format. It throws an error when this\n\tis not the case.*/\n\tconfChecker(){\n\t\tlet checker = new ParameterChecker( this.conf, this.C )\n\t\tchecker.confCheckParameter( \"LAMBDA_VRANGE_MAX\", \"KindArray\", \"NonNegative\" )\n\t\tchecker.confCheckParameter( \"LAMBDA_VRANGE_MIN\", \"KindArray\", \"NonNegative\" )\n\t}\n\n\t/** Method for hard constraints to compute whether the copy attempt fulfills the rule.\n\t @param {IndexCoordinate} src_i - coordinate of the source pixel that tries to copy.\n\t @param {IndexCoordinate} tgt_i - coordinate of the target pixel the source is trying\n\t to copy into.\n\t @param {CellId} src_type - cellid of the source pixel.\n\t @param {CellId} tgt_type - cellid of the target pixel. \n\t @return {boolean} whether the copy attempt satisfies the constraint.*/ \n\tfulfilled( src_i, tgt_i, src_type, tgt_type ){\n\t\t// volume gain of src cell\n\t\tif( src_type != 0 && this.C.getVolume(src_type) + 1 > \n\t\t\tthis.cellParameter(\"LAMBDA_VRANGE_MAX\", src_type) ){\n\t\t\treturn false\n\t\t}\n\t\t// volume loss of tgt cell\n\t\tif( tgt_type != 0 && this.C.getVolume(tgt_type) - 1 < \n\t\t\tthis.cellParameter(\"LAMBDA_VRANGE_MIN\",tgt_type) ){\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n}\n\nexport default HardVolumeRangeConstraint\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/hamiltonian/HardVolumeRangeConstraint.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 503,
    "kind": "class",
    "name": "HardVolumeRangeConstraint",
    "memberof": "src/hamiltonian/HardVolumeRangeConstraint.js",
    "static": true,
    "longname": "src/hamiltonian/HardVolumeRangeConstraint.js~HardVolumeRangeConstraint",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/hamiltonian/HardVolumeRangeConstraint.js",
    "importStyle": "HardVolumeRangeConstraint",
    "description": "This constraint forbids that cells exceed or fall below a certain size range. ",
    "examples": [
      "// Build a CPM and add the constraint\nlet CPM = require( \"path/to/build\" )\nlet C = new CPM.CPM( [200,200], {T : 4})\nC.add( new CPM.HardVolumeRangeConstraint( {\n\tLAMBDA_VRANGE_MIN : [0,1],\n\tLAMBDA_VRANGE_MAX : [0,2]\n} ) )"
    ],
    "lineNumber": 17,
    "interface": false,
    "extends": [
      "src/hamiltonian/HardConstraint.js~HardConstraint"
    ]
  },
  {
    "__docId__": 504,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/hamiltonian/HardVolumeRangeConstraint.js~HardVolumeRangeConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/HardVolumeRangeConstraint.js~HardVolumeRangeConstraint#constructor",
    "access": "public",
    "description": "The constructor of the HardVolumeRangeConstraint requires a conf object with two parameters.",
    "lineNumber": 24,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "conf",
        "description": "parameter object for this constraint."
      },
      {
        "nullable": null,
        "types": [
          "PerKindNonNegative"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.LAMBDA_VRANGE_MIN",
        "description": "minimum volume of each cellkind."
      },
      {
        "nullable": null,
        "types": [
          "PerKindNonNegative"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.LAMBDA_VRANGE_MAX",
        "description": "maximum volume of each cellkind."
      }
    ]
  },
  {
    "__docId__": 505,
    "kind": "method",
    "name": "confChecker",
    "memberof": "src/hamiltonian/HardVolumeRangeConstraint.js~HardVolumeRangeConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/HardVolumeRangeConstraint.js~HardVolumeRangeConstraint#confChecker",
    "access": "public",
    "description": "This method checks that all required parameters are present in the object supplied to\nthe constructor, and that they are of the right format. It throws an error when this\nis not the case.",
    "lineNumber": 31,
    "params": [],
    "return": null
  },
  {
    "__docId__": 506,
    "kind": "method",
    "name": "fulfilled",
    "memberof": "src/hamiltonian/HardVolumeRangeConstraint.js~HardVolumeRangeConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/HardVolumeRangeConstraint.js~HardVolumeRangeConstraint#fulfilled",
    "access": "public",
    "description": "Method for hard constraints to compute whether the copy attempt fulfills the rule.",
    "lineNumber": 44,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "src_i",
        "description": "coordinate of the source pixel that tries to copy."
      },
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_i",
        "description": "coordinate of the target pixel the source is trying\nto copy into."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "src_type",
        "description": "cellid of the source pixel."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_type",
        "description": "cellid of the target pixel."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "whether the copy attempt satisfies the constraint."
    }
  },
  {
    "__docId__": 507,
    "kind": "file",
    "name": "src/hamiltonian/LocalConnectivityConstraint.js",
    "content": "\n\nimport HardConstraint from \"./HardConstraint.js\"\nimport ParameterChecker from \"./ParameterChecker.js\"\n\n/** Version of the {@link ConnectivityConstraint} which only checks local\n * connectivity.\n * @experimental\n * */\nclass LocalConnectivityConstraint extends HardConstraint {\n\n\t/** The constructor of the LocalConnectivityConstraint requires a conf\n\t * object with one parameter.\n\t * @param {object} conf - parameter object for this constraint.\n\t * @param {PerKindBoolean} conf.CONNECTED - should the cellkind be connected\n\t * or not?\n\t * */\n\tconstructor( conf ){\n\t\tsuper(conf)\n\t}\n\t\n\n\t/** This method checks that all required parameters are present in the\n\t * object supplied to the constructor, and that they are of the right\n\t * format. It throws an error when this is not the case.\n\t * */\n\tconfChecker(){\n\t\tlet checker = new ParameterChecker( this.conf, this.C )\n\t\tchecker.confCheckParameter( \"CONNECTED\", \"KindArray\", \"Boolean\" )\n\t}\n\t\n\t/** Get the connected components of a set of pixels.\n\t * @param {object} pixelObject - an object with as keys the\n\t * {@link IndexCoordinate}s of the pixels to check.\n\t * @return {object} an array with an element for every connected component,\n\t * which is in turn an array of the {@link ArrayCoordinate}s of the pixels\n\t * belonging to that component.\n\t * */\n\tconnectedComponentsOf( pixelObject ){\n\t\n\t\tlet cbpi = Object.keys( pixelObject )\n\t\t\n\t\tlet visited = {}, k=0, pixels = [], C = this.C\n\t\tlet labelComponent = function(seed, k){\n\t\t\tlet q = [seed]\n\t\t\tlet cellId = C.grid.pixti(q)\n\t\t\tvisited[q[0]] = 1\n\t\t\tpixels[k] = []\n\t\t\twhile( q.length > 0 ){\n\t\t\t\tlet e = q.pop()\n\t\t\t\tpixels[k].push(C.grid.i2p(e) )\n\t\t\t\tlet ne = C.grid.neighi( e )\n\t\t\t\tfor( let i = 0 ; i < ne.length ; i ++ ){\n\t\t\t\t\tif( C.grid.pixti( ne[i] ) === cellId &&\n\t\t\t\t\t\t!(ne[i] in visited) && (ne[i] in pixelObject) ){\n\t\t\t\t\t\tq.push(ne[i])\n\t\t\t\t\t\tvisited[ne[i]]=1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor( let i = 0 ; i < cbpi.length ; i ++ ){\n\t\t\tlet pi = parseInt( cbpi[i] )\n\t\t\tif( !(pi in visited) ){\n\t\t\t\tlabelComponent( pi, k )\n\t\t\t\tk++\n\t\t\t}\n\t\t}\n\t\treturn pixels\n\t}\n\n\t\n\t/** This method checks if the connectivity still holds after pixel tgt_i is\n\t * changed from tgt_type to src_type.\n\t * @param {IndexCoordinate} tgt_i - the pixel to change.\n\t * @param {CellId} src_type - the new cell for this pixel.\n\t * @param {CellId} tgt_type - the cell the pixel belonged to previously.\n\t * */\n\tcheckConnected( tgt_i, src_type, tgt_type ){\n\t\n\t\t// Get neighbors of the target pixel\n\t\tlet nbh = this.C.grid.neighi( tgt_i )\n\t\t\n\t\t// object storing the neighbors of tgt_type\n\t\tlet nbhObj = {}\n\t\t\n\t\tfor( let n of nbh ){\n\t\t\n\t\t\t// add it and its neighbors to the neighborhood object\n\t\t\tif( this.C.grid.pixti(n) === tgt_type ){\n\t\t\t\tnbhObj[n] = true\n\t\t\t}\n\t\t\t\n\t\t\t/*for( let i of this.C.grid.neighi(n) ){\n\t\t\t\n\t\t\t\tif( ( this.C.grid.pixti(i) == tgt_type ) && !( i == tgt_i ) ){\n\t\t\t\t\tnbhObj[i] = true\n\t\t\t\t}\n\t\t\t}*/\n\t\t}\n\t\t\n\t\t// Get connected components.\n\t\tlet conn = this.connectedComponentsOf( nbhObj )\n\t\t\n\t\treturn ( conn.length === 1 )\n\t\t\n\t}\n\n\t/** Method for hard constraints to compute whether the copy attempt fulfills\n\t * the rule.\n\t * @param {IndexCoordinate} src_i - coordinate of the source pixel that\n\t * tries to copy.\n\t * @param {IndexCoordinate} tgt_i - coordinate of the target pixel the\n\t * source is trying to copy into.\n\t * @param {CellId} src_type - cellId of the source pixel.\n\t * @param {CellId} tgt_type - cellId of the target pixel.\n\t * @return {boolean} whether the copy attempt satisfies the constraint.\n\t * */\n\tfulfilled( src_i, tgt_i, src_type, tgt_type ){\n\t\t// connectedness of src cell cannot change if it was connected in the first place.\n\t\t\n\t\t// connectedness of tgt cell\n\t\tif( tgt_type !== 0 && this.cellParameter(\"CONNECTED\",tgt_type) ){\n\t\t\treturn this.checkConnected( tgt_i, src_type, tgt_type )\n\t\t}\n\t\t\n\t\treturn true\n\t}\n}\n\nexport default LocalConnectivityConstraint\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/hamiltonian/LocalConnectivityConstraint.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 508,
    "kind": "class",
    "name": "LocalConnectivityConstraint",
    "memberof": "src/hamiltonian/LocalConnectivityConstraint.js",
    "static": true,
    "longname": "src/hamiltonian/LocalConnectivityConstraint.js~LocalConnectivityConstraint",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/hamiltonian/LocalConnectivityConstraint.js",
    "importStyle": "LocalConnectivityConstraint",
    "description": "Version of the {@link ConnectivityConstraint} which only checks local\nconnectivity.",
    "lineNumber": 10,
    "experimental": true,
    "interface": false,
    "extends": [
      "src/hamiltonian/HardConstraint.js~HardConstraint"
    ]
  },
  {
    "__docId__": 509,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/hamiltonian/LocalConnectivityConstraint.js~LocalConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/LocalConnectivityConstraint.js~LocalConnectivityConstraint#constructor",
    "access": "public",
    "description": "The constructor of the LocalConnectivityConstraint requires a conf\nobject with one parameter.",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "conf",
        "description": "parameter object for this constraint."
      },
      {
        "nullable": null,
        "types": [
          "PerKindBoolean"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.CONNECTED",
        "description": "should the cellkind be connected\nor not?"
      }
    ]
  },
  {
    "__docId__": 510,
    "kind": "method",
    "name": "confChecker",
    "memberof": "src/hamiltonian/LocalConnectivityConstraint.js~LocalConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/LocalConnectivityConstraint.js~LocalConnectivityConstraint#confChecker",
    "access": "public",
    "description": "This method checks that all required parameters are present in the\nobject supplied to the constructor, and that they are of the right\nformat. It throws an error when this is not the case.",
    "lineNumber": 27,
    "params": [],
    "return": null
  },
  {
    "__docId__": 511,
    "kind": "method",
    "name": "connectedComponentsOf",
    "memberof": "src/hamiltonian/LocalConnectivityConstraint.js~LocalConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/LocalConnectivityConstraint.js~LocalConnectivityConstraint#connectedComponentsOf",
    "access": "public",
    "description": "Get the connected components of a set of pixels.",
    "lineNumber": 39,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "pixelObject",
        "description": "an object with as keys the\n{@link IndexCoordinate}s of the pixels to check."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "an array with an element for every connected component,\nwhich is in turn an array of the {@link ArrayCoordinate}s of the pixels\nbelonging to that component."
    }
  },
  {
    "__docId__": 512,
    "kind": "method",
    "name": "checkConnected",
    "memberof": "src/hamiltonian/LocalConnectivityConstraint.js~LocalConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/LocalConnectivityConstraint.js~LocalConnectivityConstraint#checkConnected",
    "access": "public",
    "description": "This method checks if the connectivity still holds after pixel tgt_i is\nchanged from tgt_type to src_type.",
    "lineNumber": 79,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_i",
        "description": "the pixel to change."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "src_type",
        "description": "the new cell for this pixel."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_type",
        "description": "the cell the pixel belonged to previously."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 513,
    "kind": "method",
    "name": "fulfilled",
    "memberof": "src/hamiltonian/LocalConnectivityConstraint.js~LocalConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/LocalConnectivityConstraint.js~LocalConnectivityConstraint#fulfilled",
    "access": "public",
    "description": "Method for hard constraints to compute whether the copy attempt fulfills\nthe rule.",
    "lineNumber": 119,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "src_i",
        "description": "coordinate of the source pixel that\ntries to copy."
      },
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_i",
        "description": "coordinate of the target pixel the\nsource is trying to copy into."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "src_type",
        "description": "cellId of the source pixel."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_type",
        "description": "cellId of the target pixel."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "whether the copy attempt satisfies the constraint."
    }
  },
  {
    "__docId__": 514,
    "kind": "file",
    "name": "src/hamiltonian/ParameterChecker.js",
    "content": "/** Class for checking if parameters are present in a conf object and are of the expected\nstructure and type. This is not meant for usage from outside the package, but you can\nuse it when you are building your own constraints and want to specify the required parameters.\n\n@example\n* // Add this above your constraint class\n* import ParameterChecker from \"./ParameterChecker.js\"\n* \n* // from inside the confChecker() function of your constraint:\n* let checker = new ParameterChecker( this.conf, this.C )\n* \n* // Most parameters have a standard structure and value type;\n* // you can check them like this:\n* checker.confCheckParameter( \"MY_PARAMETER\", \"KindMatrix\", \"Number\" ) // see Adhesion\n* checker.confCheckParameter( \"MY_PARAMETER_2\", \"KindArray\", \"NonNegative\" )\n* \n* // Or you can just check their presence and do a custom check:\n* checker.confCheckPresenceOf( \"MY_WEIRD_PARAMETER\" )\n* if( !myCondition ){\n* \tthrow( \"Some error because MY_WEIRD_PARAMETER does not fulfill myCondition!\" )\n* }\n*/\nclass ParameterChecker {\n\n\t/** The constructor of the ParameterChecker takes a configuration object.\n\t@param {object} conf - configuration settings as supplied to a constraint, containing the\n\trelevant parameters.\n\t@param {CPM} C - the attached CPM.\n\t*/\n\tconstructor( conf, C ){\n\t\n\t\t/** The configuration object to check parameters in \n\t\t@type {object}*/\n\t\tthis.conf = conf\n\t\t\n\t\t/** The attached CPM. This is used to check if parameter array lengths match\n\t\tthe number of cellkinds\n\t\t@type {CPM}*/\n\t\tthis.C = C\n\t}\n\t\n\t/* ========= CHECKING PARAMETER PRESENCE ======== */\n\n\t/** Method to check if a parameter of a given name is present in the conf object \n\tsupplied to the constraint, and if it is defined. Throws an error if this is not the case.\n\t@param {string} name - the name of the parameter, which should be present as a key\n\tin the object.\n\t\n\t@example\n\t* let conf = { MY_PARAMETER : \"something\" }\n\t* // This works, because  MY_PARAMETER is present in conf\n\t* let checker = new ParameterChecker( conf, myCPM )\n\t* checker.confCheckPresenceOf( \"MY_PARAMETER\" )\n\t* \n\t* // There will be an error if MY_PARAMETER is absent/undefined:\n\t* conf = {}\n\t* checker = new ParameterChecker( conf, myCPM )\n\t* checker.confCheckPresenceOf( \"MY_PARAMETER\" )\n\t* conf = { MY_PARAMETER : \"undefined\" }\n\t* checker = new ParameterChecker( conf, myCPM )\n\t* checker.confCheckPresenceOf( \"MY_PARAMETER\" )\n\t*/\n\tconfCheckPresenceOf( name ){\n\t\tif( !this.conf.hasOwnProperty( name ) ){\n\t\t\tthrow( \"Cannot find parameter \" + name + \" in the conf object!\" )\n\t\t}\n\t\tif( this.conf[name] == \"undefined\" ){\n\t\t\tthrow( \"Parameter \" + name + \" is undefined!\" )\n\t\t}\n\t}\n\t\n\t/* ========= CHECKING PARAMETER STRUCTURE ======== */\n\t\n\t/** Helper function. Some parameters need to be specified for each {@link CellKind}, \n\tso to check those we first need to know the number of cellkinds on the CPM.\n\tThis number is retrieved from the CPM or added to it if it isn't there yet.\n\t@param {number} n_default - a number of cellkinds (including background), which is used\n\tto set the number of cellkinds in the CPM if it isn't there yet.\n\t@return {number} the number of non-background cellkinds as cached in the CPM.\n\t@private\n\t*/\n\tconfCheckCellKinds( n_default ){\n\t\tif( !this.C ){\n\t\t\tthrow(\"confCheck method called before addition to CPM!\")\n\t\t}\n\t\tif( !(\"n_cell_kinds\" in this.C) ){\n\t\t\tthis.C.n_cell_kinds = n_default - 1\n\t\t}\n\t\treturn this.C.n_cell_kinds\n\t}\n\t\n\t/** Parameter structure for parameters that should come as a single value.\n\tThis value can be of type string, boolean, or number.\n\t@example\n\t* let ACT_MEAN = \"arithmetic\" // Is a SingleValue parameter\n\t@typedef {number|string|boolean} SingleValue\n\t*/\n\t\n\t/** Check if a parameter consists of a single value (rather than an object or array),\n\twhich can be a string, number, or boolean. \n\t@param {SingleValue} p - the parameter to check, which must be a single\n\tstring/number/boolean value.\n\t@param {string} name - the name of this parameter in the conf object, used for the\n\terror message if p is not a single value.\n\t\n\t@example\n\t* let checker = new ParameterChecker( conf, C )\n\t* let p1 = true, p2 = 1, p3 = \"hi\", p4 = [1,2]\n\t* // Nothing happens for parameters of type SingleValue:\n\t* checker.confCheckStructureSingle( p1, \"MY_PARAMETER\" )\n\t* checker.confCheckStructureSingle( p2, \"MY_PARAMETER\" )\n\t* checker.confCheckStructureSingle( p3, \"MY_PARAMETER\" )\n\t*\n\t* // This will throw an error because p4 is an array.\n\t* checker.confCheckStructureSingle( p4, \"MY_PARAMETER\" )\n\t*/\n\tconfCheckStructureSingle( p, name ){\n\t\n\t\t// single values are of type string, number, or boolean. If that is the case,\n\t\t// just return.\n\t\tlet type = typeof p\n\t\tif( type == \"string\" || type == \"number\" || type == \"boolean\" ){\n\t\t\treturn\n\t\t} else {\n\t\t\tthrow( \"Parameter \" + name + \" should be a single value!\" )\n\t\t}\n\n\t}\n\t\n\t/** Parameter structure for parameters that should come in an array with an element\n\tfor each {@link CellKind} including background.\n\t@example\n\t* let V = [0,5] // Is a KindArray parameter\n\t@typedef {Array} KindArray\n\t*/\n\t\n\t/** Check if a parameter has a {@link KindArray} structure.\n\t@param {KindArray} p - the parameter to check\n\t@param {string} name - the name of this parameter in the conf object, used for the\n\terror message if p is not a {@link KindArray}.\n\t\n\t@example\n\t* // C is a CPM which has 2 cellkinds including background:\n\t* let checker = new ParameterChecker( conf, C )\n\t* let p1 = [1,1], p2 = [\"hi\",\"hi\"], p3 = \"hi\", p4 = [1,2,3]\n\t* // Nothing happens when parameters are indeed arrays of length 2\n\t* // (regardless of what type of array)\n\t* checker.confCheckStructureKindArray( p1, \"MY_PARAMETER\" )\n\t* checker.confCheckStructureKindArray( p2, \"MY_PARAMETER\" )\n\t*\n\t* // You'll get an error when p is no array, or when \n\t* // its length doesn't match the number of cellkinds:\n\t* checker.confCheckStructureSingle( p3, \"MY_PARAMETER\" )\n\t* checker.confCheckStructureSingle( p4, \"MY_PARAMETER\" )\n\t*/\n\tconfCheckStructureKindArray( p, name ){\n\t\tif( !(p instanceof Array) ){\n\t\t\tthrow( \"Parameter \" + name + \" should be an array!\" )\n\t\t}\t\n\t\t\n\t\t// Check if the array has an element for each cellkind incl. background\n\t\tlet n_cell_kinds = this.confCheckCellKinds( p.length )\n\t\tif( this.conf[name].length != n_cell_kinds + 1 ){\n\t\t\tthrow( \"Parameter \" + name + \n\t\t\t\" should be an array with an element for each cellkind including background!\" )\n\t\t}\n\t}\n\t\n\t/** Parameter structure for parameters that specify interactions between two cells \n\twith each a {@link CellKind}. Should be an array of arrays (\"matrix\") \n\twhere each array has an element for each cellkind including background. \n\tThus, M[n][m] specifies the parameter for an interaction between a cell of \n\tcellkind n and a cell of cellkind m.\n\t@example\n\t* let J = [[0,20],[20,10]] // is a KindMatrix parameter.\n\t@typedef {Array} KindMatrix\n\t*/\n\t\n\t/** Checker if a parameter has a {@link KindMatrix} structure.\n\tIf this is not the case, the method throws an error.\n\t@param {KindMatrix} p - the parameter to check\n\t@param {string} name - the name of this parameter in the conf object, used for the\n\terror message if p is not a {@link KindMatrix}.\n\t\n\t@example\n\t* // C is a CPM which has 2 cellkinds including background:\n\t* let checker = new ParameterChecker( conf, C )\n\t* let p1 = [[1,1],[1,1]], p2 = [[\"a\",\"a\"],[\"a\",\"a\"]] \n\t* // Nothing happens when parameters are indeed arrays of length 2\n\t* // with sub-arrays of length 2 (regardless of what is in the elements)\n\t* checker.confCheckStructureKindArray( p1, \"MY_PARAMETER\" ) //OK\n\t* checker.confCheckStructureKindArray( p2, \"MY_PARAMETER\" ) //OK\n\t*\n\t* // You'll get an error when p is no array, or when \n\t* // its length doesn't match the number of cellkinds:\n\t* let p3 = 1, p4 = [1,2,3], p5 = [[1,2],[1,2],[1,2]]\n\t* checker.confCheckStructureSingle( p3, \"MY_PARAMETER\" ) //error\n\t* checker.confCheckStructureSingle( p4, \"MY_PARAMETER\" ) //error\n\t* checker.confCheckStructureSingle( p5, \"MY_PARAMETER\" ) //error\n\t*/\n\tconfCheckStructureKindMatrix( p, name ){\n\n\t\tlet err1 = false, err2 = false\n\t\tlet n_cell_kinds\n\n\t\t// err1: Check if the main array is an array and has the right size\n\t\tif( !(p instanceof Array) ){\n\t\t\terr1 = true\n\t\t} else {\n\t\t\tn_cell_kinds = this.confCheckCellKinds( p.length )\n\t\t\tif( !( p.length == n_cell_kinds + 1 ) ){\n\t\t\t\terr1 = true\n\t\t\t}\t\t\n\t\t}\n\t\tif( err1 ){\n\t\t\tthrow( \"Parameter \" + name + \n\t\t\t\" must be an array with a sub-array for each cellkind including background!\" )\n\t\t}\n\t\t\n\t\t// Check if subarrays have the right size\n\t\tfor( let e of p ){\n\t\t\tif( !(e instanceof Array) ){\n\t\t\t\terr2 = true\n\t\t\t} else {\n\t\t\t\tif( !( e.length == n_cell_kinds + 1 ) ){\n\t\t\t\t\terr2 = true\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t\tif( err2 ){\n\t\t\t\tthrow( \"Sub-arrays of \" + name + \n\t\t\t\t\" must have an element for each cellkind including background!\" )\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/** Method for checking if the parameter has the right structure. Throws an error\n\tmessage if the parameter does not have this structure.\n\t\n\tIt internally uses one of the following functions, depending on the structure argument:\n\t{@link confCheckStructureSingle}, {@link confCheckStructureKindArray}, or\n\t{@link confCheckStructureKindMatrix}.\n\t\n\t@param {SingleValue|KindArray|KindMatrix} p - the parameter to check the structure of\n\t@param {string} name - the name of this parameter in the conf object, used for the\n\terror message.\n\t@param {string} structure - parameter structure, which must be one of \n\t\"{@link SingleValue}\", \"{@link KindArray}\", or \"{@link KindMatrix}\".\n\t\n\t@example\n\t* // My own configuration object\n\t* let conf = {\n\t*\tP1 : true,\n\t* \tP2 : [0,2],\n\t* \tP3 : [-1,2,4],\n\t* \tP4 : [[1,2],[1,2]]\n\t* }\n\t* // C is a CPM which has 2 cellkinds including background:\n\t* let checker = new ParameterChecker( conf, C )\n\t* // These checks work out fine:\n\t* checker.confCheckStructure( conf[\"P1\"],\"P1\",\"SingleValue\")\n\t* checker.confCheckStructure( conf[\"P2\"],\"P2\",\"KindArray\")\n\t* checker.confCheckStructure( conf[\"P4\"],\"P4\",\"KindMatrix\")\n\t* \n\t* // These checks throw an error:\n\t* checker.confCheckStructure( conf[\"P1\"],\"P1\",\"KindArray\") // not an array\n\t* checker.confCheckStructure( conf[\"P2\"],\"P3\",\"KindArray\") // too long\n\t*/\n\tconfCheckStructure( p, name, structure ){\n\t\tif( structure == \"SingleValue\" ){\n\t\t\tthis.confCheckStructureSingle( p, name )\n\t\t} else if ( structure == \"KindArray\" ){\n\t\t\tthis.confCheckStructureKindArray( p, name )\n\t\t} else if ( structure == \"KindMatrix\" ){\n\t\t\tthis.confCheckStructureKindMatrix( p, name )\n\t\t} else {\n\t\t\tthrow(\"Unknown structure \" + structure + \", please choose 'SingleValue', 'KindArray', or 'KindMatrix'.\")\n\t\t}\n\t}\n\t\n\t/* ========= CHECKING VALUE TYPE ======== */\n\t\n\t/** Check if a value is of type 'number'.\n\t@param {number} v - value to check.\n\t@return {boolean} is v a number?\n\t@example\n\tthis.isNumber( -1 ) // true\n\tthis.isNumber( 0.5 ) // true\n\tthis.isNumber( true ) // false\n\tthis.isNumber( [1,2 ] ) // false\n\tthis.isNumber( \"hello world\" ) // false\n\t@private\n\t*/\n\tisNumber( v ){\n\t\treturn ( typeof v === \"number\" )\n\t}\n\t/** Check if a value is of type 'number' and non-negative.\n\t@param {number} v - value to check.\n\t@return {boolean} is v a non-negative number?\n\t@example\n\tthis.isNonNegative( -1 ) // false\n\tthis.isNonNegative( 0.5 ) // true\n\tthis.isNumber( true ) // false\n\tthis.isNumber( [1,2 ] ) // false\n\tthis.isNumber( \"hello world\" ) // false\n\t@private\n\t*/\n\tisNonNegative( v ){\n\t\tif( !( typeof v === \"number\" ) || v < 0 ){\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n\t/** Check if a value is of type 'number' and between 0 and 1.\n\t@param {number} v - value to check.\n\t@return {boolean} is v a number between 0 and 1?\n\t@example\n\tthis.isProbability( -1 ) // false\n\tthis.isProbability( 0.5 ) // true\n\tthis.isProbability( true ) // false\n\tthis.isProbability( [1,2 ] ) // false\n\tthis.isProbability( \"hello world\" ) // false\n\t@private\n\t*/\n\tisProbability( v ){\n\t\tif( !( typeof v === \"number\" ) || v < 0 || v > 1 ){\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n\t/** Check if a value is of type 'string' and has one of a set of\n\tpredefined values.\n\t@param {number} v - value to check.\n\t@param {string[]} [values=[]] - possible values. If left empty,\n\tany string is considered OK.\n\t@return {boolean} is v a string and does it match one of the predefined values?\n\t@example\n\tthis.isString( true ) // false\n\tthis.isString( [\"a\",\"b\"] ) // false\n\tthis.isString( \"hello world\" ) // true\n\t@private\n\t*/\n\tisString( v, values = [] ){\n\t\tif( !( typeof v === \"string\" ) ){\n\t\t\treturn false\n\t\t}\n\t\tlet found = false\n\t\tfor( let val of values ){\n\t\t\tif( val == v ){\n\t\t\t\tfound = true\n\t\t\t}\n\t\t}\n\t\treturn found\n\t}\n\t/** Check if a value is of type 'boolean'.\n\t@param {number} v - value to check.\n\t@return {boolean} is v a boolean?\n\t@example\n\tthis.isBoolean( true ) // true\n\tthis.isBoolean( [true,false] ) // false\n\tthis.isBoolean( \"hello world\" ) // true\n\t@private\n\t*/\n\tisBoolean( v ){\n\t\treturn( typeof v === \"boolean\" )\n\t}\n\t\n\t/** Check if a value is a coordinate in the dimensions of the current grid.\n\t@param {number} v - value to check.\n\t@return {boolean} is v a coordinate of the right dimensions?\n\t@public\n\t*/\n\tisCoordinate( v ){\n\t\tif( !( v instanceof Array ) ){\n\t\t\treturn false\n\t\t}\n\t\tif( !v.length == this.C.extents.length ){\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n\t\n\t/** Check if the elements of a given parameter are of the right type.\n\tIt throws an error if this is not the case.\n\t@param {anything} p - parameter to check.\n\t@param {string} name - parameter name used for any error messages.\n\t@param {string} structure - parameter structure, which must be one of \n\t\"{@link SingleValue}\", \"{@link KindArray}\", or \"{@link KindMatrix}\".\n\t@param {string} valuetype - type of value, which must be one of \n\t\"Number\", \"NonNegative\", \"Probability\", \"String\", or \"Boolean\". \n\t@param {string[]} values - predefined specific options for the value. \n\tIf left empty, this is ignored.\n\t@private\n\t*/\n\tconfCheckValueType( p, name, structure, valuetype, values = [] ){\n\t\n\t\t// Determine which checkfunction will be used.\n\t\tlet valuechecker\n\t\tif( valuetype == \"Number\" ){\n\t\t\tvaluechecker = this.isNumber\n\t\t} else if ( valuetype == \"NonNegative\" ){\n\t\t\tvaluechecker = this.isNonNegative\n\t\t} else if ( valuetype == \"Probability\" ){\n\t\t\tvaluechecker = this.isProbability\n\t\t} else if ( valuetype == \"String\" ){\n\t\t\tvaluechecker = this.isString\n\t\t} else if ( valuetype == \"Boolean\" ){\n\t\t\tvaluechecker = this.isBoolean\n\t\t} else {\n\t\t\tthrow( \"Unsupported valuetype in check for parameter \" + name +\n\t\t\t\t\", please choose from: 'Number','NonNegative', 'Probability', 'String', 'Boolean'.\")\n\t\t}\n\t\t\n\t\tlet message =  \"Parameter \" + name + \" : incorrect type. Expecting values of type \" + valuetype + \".\" \n\t\t\n\t\t// structure determines how the checker is applied.\n\t\tif( structure == \"SingleValue\" ){\n\t\t\tif( p == \"undefined\" || !valuechecker( p, values ) ){ throw(message) }\n\t\t} else if ( structure == \"KindArray\" ){\n\t\t\tfor( let i of p ){\n\t\t\t\tif( i == \"undefined\" || !valuechecker( i, values ) ){ throw(message) }\n\t\t\t}\n\t\t} else if ( structure == \"KindMatrix\" ){\n\t\t\tfor( let i of p ){\n\t\t\t\tfor( let j of i ){\n\t\t\t\t\tif( j == \"undefined\" || !valuechecker( j, values ) ){ throw(message) }\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow(\"Unknown structure \" + structure + \", please choose 'SingleValue', 'KindArray', or 'KindMatrix'.\")\n\t\t}\n\t}\n\t\n\t/** Check if a parameter exists and is defined, has the right structure, and if all \n\tits elements are of the correct type. Throw an error if any of these do not hold.\n\t@param {string} name - parameter name used for any error messages.\n\t@param {string} structure - parameter structure, which must be one of \n\t\"{@link SingleValue}\", \"{@link KindArray}\", or \"{@link KindMatrix}\".\n\t@param {string} valuetype - type of value, which must be one of \n\t\"Number\", \"NonNegative\", \"Probability\", \"String\", or \"Boolean\". \n\t@param {string[]} [values =[]] - predefined specific options for the value. \n\tIf left empty, this is ignored.\n\t\n\t@example\n\t* // from inside the confChecker() function of your constraint:\n\t* let checker = new ParameterChecker( this.conf, this.C )\n\t* \n\t* checker.confCheckParameter( \"MY_PARAMETER\", \"KindMatrix\", \"Number\" ) // see Adhesion\n\t* checker.confCheckParameter( \"MY_PARAMETER_2\", \"KindArray\", \"NonNegative\" )\n\t*/\n\tconfCheckParameter( name, structure, valuetype, values = [] ){\n\t\tthis.confCheckPresenceOf( name )\n\t\tlet p = this.conf[name]\n\t\tthis.confCheckStructure( p, name, structure )\n\t\tthis.confCheckValueType( p, name, structure, valuetype, values )\n\t}\n\t\n\t\n}\n\nexport default ParameterChecker",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/hamiltonian/ParameterChecker.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 515,
    "kind": "class",
    "name": "ParameterChecker",
    "memberof": "src/hamiltonian/ParameterChecker.js",
    "static": true,
    "longname": "src/hamiltonian/ParameterChecker.js~ParameterChecker",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/hamiltonian/ParameterChecker.js",
    "importStyle": "ParameterChecker",
    "description": "Class for checking if parameters are present in a conf object and are of the expected\nstructure and type. This is not meant for usage from outside the package, but you can\nuse it when you are building your own constraints and want to specify the required parameters.",
    "examples": [
      "// Add this above your constraint class\nimport ParameterChecker from \"./ParameterChecker.js\"\n\n// from inside the confChecker() function of your constraint:\nlet checker = new ParameterChecker( this.conf, this.C )\n\n// Most parameters have a standard structure and value type;\n// you can check them like this:\nchecker.confCheckParameter( \"MY_PARAMETER\", \"KindMatrix\", \"Number\" ) // see Adhesion\nchecker.confCheckParameter( \"MY_PARAMETER_2\", \"KindArray\", \"NonNegative\" )\n\n// Or you can just check their presence and do a custom check:\nchecker.confCheckPresenceOf( \"MY_WEIRD_PARAMETER\" )\nif( !myCondition ){\n\tthrow( \"Some error because MY_WEIRD_PARAMETER does not fulfill myCondition!\" )\n}"
    ],
    "lineNumber": 23,
    "interface": false
  },
  {
    "__docId__": 516,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/hamiltonian/ParameterChecker.js~ParameterChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ParameterChecker.js~ParameterChecker#constructor",
    "access": "public",
    "description": "The constructor of the ParameterChecker takes a configuration object.",
    "lineNumber": 30,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "conf",
        "description": "configuration settings as supplied to a constraint, containing the\nrelevant parameters."
      },
      {
        "nullable": null,
        "types": [
          "CPM"
        ],
        "spread": false,
        "optional": false,
        "name": "C",
        "description": "the attached CPM."
      }
    ]
  },
  {
    "__docId__": 517,
    "kind": "member",
    "name": "conf",
    "memberof": "src/hamiltonian/ParameterChecker.js~ParameterChecker",
    "static": false,
    "longname": "src/hamiltonian/ParameterChecker.js~ParameterChecker#conf",
    "access": "public",
    "description": "The configuration object to check parameters in ",
    "lineNumber": 34,
    "type": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 518,
    "kind": "member",
    "name": "C",
    "memberof": "src/hamiltonian/ParameterChecker.js~ParameterChecker",
    "static": false,
    "longname": "src/hamiltonian/ParameterChecker.js~ParameterChecker#C",
    "access": "public",
    "description": "The attached CPM. This is used to check if parameter array lengths match\nthe number of cellkinds",
    "lineNumber": 39,
    "type": {
      "nullable": null,
      "types": [
        "CPM"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 519,
    "kind": "method",
    "name": "confCheckPresenceOf",
    "memberof": "src/hamiltonian/ParameterChecker.js~ParameterChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ParameterChecker.js~ParameterChecker#confCheckPresenceOf",
    "access": "public",
    "description": "Method to check if a parameter of a given name is present in the conf object \nsupplied to the constraint, and if it is defined. Throws an error if this is not the case.",
    "examples": [
      "let conf = { MY_PARAMETER : \"something\" }\n// This works, because  MY_PARAMETER is present in conf\nlet checker = new ParameterChecker( conf, myCPM )\nchecker.confCheckPresenceOf( \"MY_PARAMETER\" )\n\n// There will be an error if MY_PARAMETER is absent/undefined:\nconf = {}\nchecker = new ParameterChecker( conf, myCPM )\nchecker.confCheckPresenceOf( \"MY_PARAMETER\" )\nconf = { MY_PARAMETER : \"undefined\" }\nchecker = new ParameterChecker( conf, myCPM )\nchecker.confCheckPresenceOf( \"MY_PARAMETER\" )"
    ],
    "lineNumber": 63,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "the name of the parameter, which should be present as a key\nin the object."
      }
    ],
    "return": null
  },
  {
    "__docId__": 520,
    "kind": "method",
    "name": "confCheckCellKinds",
    "memberof": "src/hamiltonian/ParameterChecker.js~ParameterChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ParameterChecker.js~ParameterChecker#confCheckCellKinds",
    "access": "private",
    "description": "Helper function. Some parameters need to be specified for each {@link CellKind}, \nso to check those we first need to know the number of cellkinds on the CPM.\nThis number is retrieved from the CPM or added to it if it isn't there yet.",
    "lineNumber": 82,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "n_default",
        "description": "a number of cellkinds (including background), which is used\nto set the number of cellkinds in the CPM if it isn't there yet."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the number of non-background cellkinds as cached in the CPM."
    }
  },
  {
    "__docId__": 521,
    "kind": "typedef",
    "name": "SingleValue",
    "memberof": "src/hamiltonian/ParameterChecker.js~ParameterChecker",
    "static": true,
    "longname": "src/hamiltonian/ParameterChecker.js~ParameterChecker.SingleValue",
    "access": "public",
    "description": "Parameter structure for parameters that should come as a single value.\nThis value can be of type string, boolean, or number.",
    "examples": [
      "let ACT_MEAN = \"arithmetic\" // Is a SingleValue parameter"
    ],
    "type": {
      "types": [
        "number",
        "string",
        "boolean"
      ],
      "optional": false,
      "name": "SingleValue"
    }
  },
  {
    "__docId__": 522,
    "kind": "method",
    "name": "confCheckStructureSingle",
    "memberof": "src/hamiltonian/ParameterChecker.js~ParameterChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ParameterChecker.js~ParameterChecker#confCheckStructureSingle",
    "access": "public",
    "description": "Check if a parameter consists of a single value (rather than an object or array),\nwhich can be a string, number, or boolean. ",
    "examples": [
      "let checker = new ParameterChecker( conf, C )\nlet p1 = true, p2 = 1, p3 = \"hi\", p4 = [1,2]\n// Nothing happens for parameters of type SingleValue:\nchecker.confCheckStructureSingle( p1, \"MY_PARAMETER\" )\nchecker.confCheckStructureSingle( p2, \"MY_PARAMETER\" )\nchecker.confCheckStructureSingle( p3, \"MY_PARAMETER\" )\n\n// This will throw an error because p4 is an array.\nchecker.confCheckStructureSingle( p4, \"MY_PARAMETER\" )"
    ],
    "lineNumber": 117,
    "params": [
      {
        "nullable": null,
        "types": [
          "SingleValue"
        ],
        "spread": false,
        "optional": false,
        "name": "p",
        "description": "the parameter to check, which must be a single\nstring/number/boolean value."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "the name of this parameter in the conf object, used for the\nerror message if p is not a single value."
      }
    ],
    "return": null
  },
  {
    "__docId__": 523,
    "kind": "typedef",
    "name": "KindArray",
    "memberof": "src/hamiltonian/ParameterChecker.js~ParameterChecker",
    "static": true,
    "longname": "src/hamiltonian/ParameterChecker.js~ParameterChecker.KindArray",
    "access": "public",
    "description": "Parameter structure for parameters that should come in an array with an element\nfor each {@link CellKind} including background.",
    "examples": [
      "let V = [0,5] // Is a KindArray parameter"
    ],
    "type": {
      "types": [
        "Array"
      ],
      "optional": false,
      "name": "KindArray"
    }
  },
  {
    "__docId__": 524,
    "kind": "method",
    "name": "confCheckStructureKindArray",
    "memberof": "src/hamiltonian/ParameterChecker.js~ParameterChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ParameterChecker.js~ParameterChecker#confCheckStructureKindArray",
    "access": "public",
    "description": "Check if a parameter has a {@link KindArray} structure.",
    "examples": [
      "// C is a CPM which has 2 cellkinds including background:\nlet checker = new ParameterChecker( conf, C )\nlet p1 = [1,1], p2 = [\"hi\",\"hi\"], p3 = \"hi\", p4 = [1,2,3]\n// Nothing happens when parameters are indeed arrays of length 2\n// (regardless of what type of array)\nchecker.confCheckStructureKindArray( p1, \"MY_PARAMETER\" )\nchecker.confCheckStructureKindArray( p2, \"MY_PARAMETER\" )\n\n// You'll get an error when p is no array, or when \n// its length doesn't match the number of cellkinds:\nchecker.confCheckStructureSingle( p3, \"MY_PARAMETER\" )\nchecker.confCheckStructureSingle( p4, \"MY_PARAMETER\" )"
    ],
    "lineNumber": 156,
    "params": [
      {
        "nullable": null,
        "types": [
          "KindArray"
        ],
        "spread": false,
        "optional": false,
        "name": "p",
        "description": "the parameter to check"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "the name of this parameter in the conf object, used for the\nerror message if p is not a {@link KindArray}."
      }
    ],
    "return": null
  },
  {
    "__docId__": 525,
    "kind": "typedef",
    "name": "KindMatrix",
    "memberof": "src/hamiltonian/ParameterChecker.js~ParameterChecker",
    "static": true,
    "longname": "src/hamiltonian/ParameterChecker.js~ParameterChecker.KindMatrix",
    "access": "public",
    "description": "Parameter structure for parameters that specify interactions between two cells \nwith each a {@link CellKind}. Should be an array of arrays (\"matrix\") \nwhere each array has an element for each cellkind including background. \nThus, M[n][m] specifies the parameter for an interaction between a cell of \ncellkind n and a cell of cellkind m.",
    "examples": [
      "let J = [[0,20],[20,10]] // is a KindMatrix parameter."
    ],
    "type": {
      "types": [
        "Array"
      ],
      "optional": false,
      "name": "KindMatrix"
    }
  },
  {
    "__docId__": 526,
    "kind": "method",
    "name": "confCheckStructureKindMatrix",
    "memberof": "src/hamiltonian/ParameterChecker.js~ParameterChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ParameterChecker.js~ParameterChecker#confCheckStructureKindMatrix",
    "access": "public",
    "description": "Checker if a parameter has a {@link KindMatrix} structure.\nIf this is not the case, the method throws an error.",
    "examples": [
      "// C is a CPM which has 2 cellkinds including background:\nlet checker = new ParameterChecker( conf, C )\nlet p1 = [[1,1],[1,1]], p2 = [[\"a\",\"a\"],[\"a\",\"a\"]] \n// Nothing happens when parameters are indeed arrays of length 2\n// with sub-arrays of length 2 (regardless of what is in the elements)\nchecker.confCheckStructureKindArray( p1, \"MY_PARAMETER\" ) //OK\nchecker.confCheckStructureKindArray( p2, \"MY_PARAMETER\" ) //OK\n\n// You'll get an error when p is no array, or when \n// its length doesn't match the number of cellkinds:\nlet p3 = 1, p4 = [1,2,3], p5 = [[1,2],[1,2],[1,2]]\nchecker.confCheckStructureSingle( p3, \"MY_PARAMETER\" ) //error\nchecker.confCheckStructureSingle( p4, \"MY_PARAMETER\" ) //error\nchecker.confCheckStructureSingle( p5, \"MY_PARAMETER\" ) //error"
    ],
    "lineNumber": 201,
    "params": [
      {
        "nullable": null,
        "types": [
          "KindMatrix"
        ],
        "spread": false,
        "optional": false,
        "name": "p",
        "description": "the parameter to check"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "the name of this parameter in the conf object, used for the\nerror message if p is not a {@link KindMatrix}."
      }
    ],
    "return": null
  },
  {
    "__docId__": 527,
    "kind": "method",
    "name": "confCheckStructure",
    "memberof": "src/hamiltonian/ParameterChecker.js~ParameterChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ParameterChecker.js~ParameterChecker#confCheckStructure",
    "access": "public",
    "description": "Method for checking if the parameter has the right structure. Throws an error\nmessage if the parameter does not have this structure.\n\nIt internally uses one of the following functions, depending on the structure argument:\n{@link confCheckStructureSingle}, {@link confCheckStructureKindArray}, or\n{@link confCheckStructureKindMatrix}.",
    "examples": [
      "// My own configuration object\nlet conf = {\nP1 : true,\n\tP2 : [0,2],\n\tP3 : [-1,2,4],\n\tP4 : [[1,2],[1,2]]\n}\n// C is a CPM which has 2 cellkinds including background:\nlet checker = new ParameterChecker( conf, C )\n// These checks work out fine:\nchecker.confCheckStructure( conf[\"P1\"],\"P1\",\"SingleValue\")\nchecker.confCheckStructure( conf[\"P2\"],\"P2\",\"KindArray\")\nchecker.confCheckStructure( conf[\"P4\"],\"P4\",\"KindMatrix\")\n\n// These checks throw an error:\nchecker.confCheckStructure( conf[\"P1\"],\"P1\",\"KindArray\") // not an array\nchecker.confCheckStructure( conf[\"P2\"],\"P3\",\"KindArray\") // too long"
    ],
    "lineNumber": 268,
    "params": [
      {
        "nullable": null,
        "types": [
          "SingleValue",
          "KindArray",
          "KindMatrix"
        ],
        "spread": false,
        "optional": false,
        "name": "p",
        "description": "the parameter to check the structure of"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "the name of this parameter in the conf object, used for the\nerror message."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "structure",
        "description": "parameter structure, which must be one of \n\"{@link SingleValue}\", \"{@link KindArray}\", or \"{@link KindMatrix}\"."
      }
    ],
    "return": null
  },
  {
    "__docId__": 528,
    "kind": "method",
    "name": "isNumber",
    "memberof": "src/hamiltonian/ParameterChecker.js~ParameterChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ParameterChecker.js~ParameterChecker#isNumber",
    "access": "private",
    "description": "Check if a value is of type 'number'.",
    "examples": [
      "this.isNumber( -1 ) // true\nthis.isNumber( 0.5 ) // true\nthis.isNumber( true ) // false\nthis.isNumber( [1,2 ] ) // false\nthis.isNumber( \"hello world\" ) // false"
    ],
    "lineNumber": 293,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "v",
        "description": "value to check."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "is v a number?"
    }
  },
  {
    "__docId__": 529,
    "kind": "method",
    "name": "isNonNegative",
    "memberof": "src/hamiltonian/ParameterChecker.js~ParameterChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ParameterChecker.js~ParameterChecker#isNonNegative",
    "access": "private",
    "description": "Check if a value is of type 'number' and non-negative.",
    "examples": [
      "this.isNonNegative( -1 ) // false\nthis.isNonNegative( 0.5 ) // true\nthis.isNumber( true ) // false\nthis.isNumber( [1,2 ] ) // false\nthis.isNumber( \"hello world\" ) // false"
    ],
    "lineNumber": 307,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "v",
        "description": "value to check."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "is v a non-negative number?"
    }
  },
  {
    "__docId__": 530,
    "kind": "method",
    "name": "isProbability",
    "memberof": "src/hamiltonian/ParameterChecker.js~ParameterChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ParameterChecker.js~ParameterChecker#isProbability",
    "access": "private",
    "description": "Check if a value is of type 'number' and between 0 and 1.",
    "examples": [
      "this.isProbability( -1 ) // false\nthis.isProbability( 0.5 ) // true\nthis.isProbability( true ) // false\nthis.isProbability( [1,2 ] ) // false\nthis.isProbability( \"hello world\" ) // false"
    ],
    "lineNumber": 324,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "v",
        "description": "value to check."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "is v a number between 0 and 1?"
    }
  },
  {
    "__docId__": 531,
    "kind": "method",
    "name": "isString",
    "memberof": "src/hamiltonian/ParameterChecker.js~ParameterChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ParameterChecker.js~ParameterChecker#isString",
    "access": "private",
    "description": "Check if a value is of type 'string' and has one of a set of\npredefined values.",
    "examples": [
      "this.isString( true ) // false\nthis.isString( [\"a\",\"b\"] ) // false\nthis.isString( \"hello world\" ) // true"
    ],
    "lineNumber": 342,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "v",
        "description": "value to check."
      },
      {
        "nullable": null,
        "types": [
          "string[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[]",
        "defaultRaw": [],
        "name": "values",
        "description": "possible values. If left empty,\nany string is considered OK."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "is v a string and does it match one of the predefined values?"
    }
  },
  {
    "__docId__": 532,
    "kind": "method",
    "name": "isBoolean",
    "memberof": "src/hamiltonian/ParameterChecker.js~ParameterChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ParameterChecker.js~ParameterChecker#isBoolean",
    "access": "private",
    "description": "Check if a value is of type 'boolean'.",
    "examples": [
      "this.isBoolean( true ) // true\nthis.isBoolean( [true,false] ) // false\nthis.isBoolean( \"hello world\" ) // true"
    ],
    "lineNumber": 363,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "v",
        "description": "value to check."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "is v a boolean?"
    }
  },
  {
    "__docId__": 533,
    "kind": "method",
    "name": "isCoordinate",
    "memberof": "src/hamiltonian/ParameterChecker.js~ParameterChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ParameterChecker.js~ParameterChecker#isCoordinate",
    "access": "public",
    "description": "Check if a value is a coordinate in the dimensions of the current grid.",
    "lineNumber": 372,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "v",
        "description": "value to check."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "is v a coordinate of the right dimensions?"
    }
  },
  {
    "__docId__": 534,
    "kind": "method",
    "name": "confCheckValueType",
    "memberof": "src/hamiltonian/ParameterChecker.js~ParameterChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ParameterChecker.js~ParameterChecker#confCheckValueType",
    "access": "private",
    "description": "Check if the elements of a given parameter are of the right type.\nIt throws an error if this is not the case.",
    "lineNumber": 394,
    "params": [
      {
        "nullable": null,
        "types": [
          "anything"
        ],
        "spread": false,
        "optional": false,
        "name": "p",
        "description": "parameter to check."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "parameter name used for any error messages."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "structure",
        "description": "parameter structure, which must be one of \n\"{@link SingleValue}\", \"{@link KindArray}\", or \"{@link KindMatrix}\"."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "valuetype",
        "description": "type of value, which must be one of \n\"Number\", \"NonNegative\", \"Probability\", \"String\", or \"Boolean\"."
      },
      {
        "nullable": null,
        "types": [
          "string[]"
        ],
        "spread": false,
        "optional": false,
        "name": "values",
        "description": "predefined specific options for the value. \nIf left empty, this is ignored."
      }
    ],
    "return": null
  },
  {
    "__docId__": 535,
    "kind": "method",
    "name": "confCheckParameter",
    "memberof": "src/hamiltonian/ParameterChecker.js~ParameterChecker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/ParameterChecker.js~ParameterChecker#confCheckParameter",
    "access": "public",
    "description": "Check if a parameter exists and is defined, has the right structure, and if all \nits elements are of the correct type. Throw an error if any of these do not hold.",
    "examples": [
      "// from inside the confChecker() function of your constraint:\nlet checker = new ParameterChecker( this.conf, this.C )\n\nchecker.confCheckParameter( \"MY_PARAMETER\", \"KindMatrix\", \"Number\" ) // see Adhesion\nchecker.confCheckParameter( \"MY_PARAMETER_2\", \"KindArray\", \"NonNegative\" )"
    ],
    "lineNumber": 450,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "parameter name used for any error messages."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "structure",
        "description": "parameter structure, which must be one of \n\"{@link SingleValue}\", \"{@link KindArray}\", or \"{@link KindMatrix}\"."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "valuetype",
        "description": "type of value, which must be one of \n\"Number\", \"NonNegative\", \"Probability\", \"String\", or \"Boolean\"."
      },
      {
        "nullable": null,
        "types": [
          "string[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[]",
        "defaultRaw": [],
        "name": "values",
        "description": "predefined specific options for the value. \nIf left empty, this is ignored."
      }
    ],
    "return": null
  },
  {
    "__docId__": 536,
    "kind": "file",
    "name": "src/hamiltonian/PerimeterConstraint.js",
    "content": "\n\nimport SoftConstraint from \"./SoftConstraint.js\"\nimport ParameterChecker from \"./ParameterChecker.js\"\n\n/** \n * Implements the perimeter constraint of Potts models. \n * A cell's \"perimeter\" is the number over all its borderpixels of the number of \n * neighbors that do not belong to the cell itself. \n * \n * This constraint is typically used together with {@link Adhesion} and {@VolumeConstraint}.\n * \n * See {@link PerimeterConstraint#constructor} for the required parameters.\n *\n * @example\n * // Build a CPM and add the constraint\n * let CPM = require( \"path/to/build\" )\n * let C = new CPM.CPM( [200,200], {\n * \tT : 20,\n * \tJ : [[0,20],[20,10]],\n * \tV : [0,500],\n * \tLAMBDA_V : [0,5]\n * })\n * C.add( new CPM.PerimeterConstraint( {\n * \tP : [0,260],\n * \tLAMBDA_P : [0,2] \t\n * } ) )\n * \n * // Or add automatically by entering the parameters in the CPM\n * let C2 = new CPM.CPM( [200,200], {\n * \tT : 20,\n * \tJ : [[0,20],[20,10]],\n * \tV : [0,500],\n * \tLAMBDA_V : [0,5],\n * \tP : [0,260],\n * \tLAMBDA_P : [0,2]\n * })\n */\nclass PerimeterConstraint extends SoftConstraint {\n\n\t/** The constructor of the PerimeterConstraint requires a conf object with\n\t * parameters.\n\t * @param {object} conf - parameter object for this constraint\n\t * @param {PerKindNonNegative} conf.LAMBDA_P - strength of the perimeter\n\t * \tconstraint per cellkind.\n\t * @param {PerKindNonNegative} conf.P - Target perimeter per cellkind.\n\t*/\n\tconstructor( conf ){\n\t\tsuper( conf )\n\t\t\n\t\t/** The perimeter size of each pixel is tracked.\n\t\t@type {CellObject}*/\n\t\tthis.cellperimeters = {}\n\t}\n\n\t/** Set the CPM attached to this constraint.\n\t@param {CPM} C - the CPM to attach.*/\n\tset CPM(C){\n\t\tsuper.CPM = C\n\t\t\n\t\t// if C already has cells, initialize perimeters\n\t\tif( C.cellvolume.length !== 0 ){\n\t\t\tthis.initializePerimeters()\n\t\t}\n\t}\n\t\n\t/** This method checks that all required parameters are present in the\n\t * object supplied to the constructor, and that they are of the right\n\t * format. It throws an error when this is not the case.*/\n\tconfChecker(){\n\t\tlet checker = new ParameterChecker( this.conf, this.C )\n\t\tchecker.confCheckParameter( \"LAMBDA_P\", \"KindArray\", \"NonNegative\" )\n\t\tchecker.confCheckParameter( \"P\", \"KindArray\", \"NonNegative\" )\n\t}\n\n\t/** This method initializes the this.cellperimeters object when the\n\t * constraint is added to a non-empty CPM. */\n\tinitializePerimeters(){\n\n\t\tfor( let bp of this.C.cellBorderPixels() ){\n\t\t\tconst p = bp[0]\n\t\t\tlet cid = this.C.pixt(p)\n\t\t\tif( !(cid in this.cellperimeters) ){\n\t\t\t\tthis.cellperimeters[cid] = 0\n\t\t\t}\n\t\t\tconst i = this.C.grid.p2i( p )\n\t\t\tthis.cellperimeters[cid] += this.C.perimeterNeighbours[i]\n\t\t}\n\n\t}\n\n\t/** The postSetpixListener of the PerimeterConstraint ensures that cell\n\t * perimeters are updated after each copy in the CPM.\n\t * @listens {CPM#setpixi} because when a new pixel is set (which is\n\t * \tdetermined in the CPM),\tsome of the cell perimeters will change.\n\t * @param {IndexCoordinate} i - the coordinate of the pixel that is changed.\n\t * @param {CellId} t_old - the cellid of this pixel before the copy\n\t * @param {CellId} t_new - the cellid of this pixel after the copy.\n\t*/\n\t/* eslint-disable no-unused-vars*/\n\tpostSetpixListener( i, t_old, t_new ){\n\t\tif( t_old === t_new ){ return }\n\t\t\n\t\t// Neighborhood of the pixel that changes\n\t\tconst Ni = this.C.neighi( i )\n\t\t\n\t\t// Keep track of perimeter before and after copy\n\t\tlet n_new = 0, n_old = 0\n\t\t\n\t\t// Loop over the neighborhood. \n\t\tfor( let i = 0 ; i < Ni.length ; i ++  ){\n\t\t\tconst nt = this.C.pixti(Ni[i])\n\t\t\t\n\t\t\t// neighbors are added to the perimeter if they are\n\t\t\t// of a different cellID than the current pixel\n\t\t\tif( nt !== t_new ){\n\t\t\t\tn_new ++ \n\t\t\t}\n\t\t\tif( nt !== t_old ){\n\t\t\t\tn_old ++\n\t\t\t}\n\t\t\t\n\t\t\t// if the neighbor is non-background, the perimeter\n\t\t\t// of the cell it belongs to may also have to be updated.\n\t\t\tif( nt !== 0 ){\n\t\t\t\n\t\t\t\t// if it was of t_old, its perimeter goes up because the\n\t\t\t\t// current pixel will no longer be t_old. This means it will\n\t\t\t\t// have a different type and start counting as perimeter.\n\t\t\t\tif( nt === t_old ){\n\t\t\t\t\tthis.cellperimeters[nt] ++\n\t\t\t\t}\n\t\t\t\t// opposite if it is t_new.\n\t\t\t\tif( nt === t_new ){\n\t\t\t\t\tthis.cellperimeters[nt] --\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// update perimeters of the old and new type if they are non-background\n\t\tif( t_old !== 0 ){\n\t\t\tthis.cellperimeters[t_old] -= n_old\n\t\t}\n\t\tif( t_new !== 0 ){\n\t\t\tif( !(t_new in this.cellperimeters) ){\n\t\t\t\tthis.cellperimeters[t_new] = 0\n\t\t\t}\n\t\t\tthis.cellperimeters[t_new] += n_new\n\t\t}\n\t}\n\t\n\t/** Method to compute the Hamiltonian for this constraint.\n\t * @param {IndexCoordinate} sourcei - coordinate of the source pixel that\n\t * \ttries to copy.\n\t * @param {IndexCoordinate} targeti - coordinate of the target pixel the\n\t * \tsource is trying to copy into.\n\t * @param {CellId} src_type - cellid of the source pixel.\n\t * @param {CellId} tgt_type - cellid of the target pixel.\n\t * @return {number} the change in Hamiltonian for this copy attempt and\n\t * this constraint.*/\n\tdeltaH( sourcei, targeti, src_type, tgt_type ){\n\t\tif( src_type === tgt_type ){\n\t\t\treturn 0\n\t\t}\n\t\tconst ls = this.cellParameter(\"LAMBDA_P\", src_type)\n\t\tconst lt = this.cellParameter(\"LAMBDA_P\", tgt_type)\n\t\tif( !(ls>0) && !(lt>0) ){\n\t\t\treturn 0\n\t\t}\n\t\tconst Ni = this.C.neighi( targeti )\n\t\tlet pchange = {}\n\t\tpchange[src_type] = 0; pchange[tgt_type] = 0\n\t\tfor( let i = 0 ; i < Ni.length ; i ++  ){\n\t\t\tconst nt = this.C.pixti(Ni[i])\n\t\t\tif( nt !== src_type ){\n\t\t\t\tpchange[src_type]++ \n\t\t\t}\n\t\t\tif( nt !== tgt_type ){\n\t\t\t\tpchange[tgt_type]--\n\t\t\t}\n\t\t\tif( nt === tgt_type ){\n\t\t\t\tpchange[nt] ++\n\t\t\t}\n\t\t\tif( nt === src_type ){\n\t\t\t\tpchange[nt] --\n\t\t\t}\n\t\t}\n\t\tlet r = 0.0\n\t\tif( ls > 0 ){\n\t\t\tconst pt = this.cellParameter(\"P\", src_type),\n\t\t\t\tps = this.cellperimeters[src_type]\n\t\t\tconst hnew = (ps+pchange[src_type])-pt,\n\t\t\t\thold = ps-pt\n\t\t\tr += ls*((hnew*hnew)-(hold*hold))\n\t\t}\n\t\tif( lt > 0 ){\n\t\t\tconst pt = this.cellParameter(\"P\", tgt_type),\n\t\t\t\tps = this.cellperimeters[tgt_type]\n\t\t\tconst hnew = (ps+pchange[tgt_type])-pt,\n\t\t\t\thold = ps-pt\n\t\t\tr += lt*((hnew*hnew)-(hold*hold))\n\t\t}\n\t\t// eslint-disable-next-line\n\t\t//console.log( r )\n\t\treturn r\n\t}\n}\n\nexport default PerimeterConstraint\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/hamiltonian/PerimeterConstraint.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 537,
    "kind": "class",
    "name": "PerimeterConstraint",
    "memberof": "src/hamiltonian/PerimeterConstraint.js",
    "static": true,
    "longname": "src/hamiltonian/PerimeterConstraint.js~PerimeterConstraint",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/hamiltonian/PerimeterConstraint.js",
    "importStyle": "PerimeterConstraint",
    "description": "Implements the perimeter constraint of Potts models. \nA cell's \"perimeter\" is the number over all its borderpixels of the number of \nneighbors that do not belong to the cell itself. \n\nThis constraint is typically used together with {@link Adhesion} and {@VolumeConstraint}.\n\nSee {@link PerimeterConstraint#constructor} for the required parameters.",
    "examples": [
      "// Build a CPM and add the constraint\nlet CPM = require( \"path/to/build\" )\nlet C = new CPM.CPM( [200,200], {\n\tT : 20,\n\tJ : [[0,20],[20,10]],\n\tV : [0,500],\n\tLAMBDA_V : [0,5]\n})\nC.add( new CPM.PerimeterConstraint( {\n\tP : [0,260],\n\tLAMBDA_P : [0,2] \t\n} ) )\n\n// Or add automatically by entering the parameters in the CPM\nlet C2 = new CPM.CPM( [200,200], {\n\tT : 20,\n\tJ : [[0,20],[20,10]],\n\tV : [0,500],\n\tLAMBDA_V : [0,5],\n\tP : [0,260],\n\tLAMBDA_P : [0,2]\n})"
    ],
    "lineNumber": 39,
    "interface": false,
    "extends": [
      "src/hamiltonian/SoftConstraint.js~SoftConstraint"
    ]
  },
  {
    "__docId__": 538,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/hamiltonian/PerimeterConstraint.js~PerimeterConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/PerimeterConstraint.js~PerimeterConstraint#constructor",
    "access": "public",
    "description": "The constructor of the PerimeterConstraint requires a conf object with\nparameters.",
    "lineNumber": 48,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "conf",
        "description": "parameter object for this constraint"
      },
      {
        "nullable": null,
        "types": [
          "PerKindNonNegative"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.LAMBDA_P",
        "description": "strength of the perimeter\n\tconstraint per cellkind."
      },
      {
        "nullable": null,
        "types": [
          "PerKindNonNegative"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.P",
        "description": "Target perimeter per cellkind."
      }
    ]
  },
  {
    "__docId__": 539,
    "kind": "member",
    "name": "cellperimeters",
    "memberof": "src/hamiltonian/PerimeterConstraint.js~PerimeterConstraint",
    "static": false,
    "longname": "src/hamiltonian/PerimeterConstraint.js~PerimeterConstraint#cellperimeters",
    "access": "public",
    "description": "The perimeter size of each pixel is tracked.",
    "lineNumber": 53,
    "type": {
      "nullable": null,
      "types": [
        "CellObject"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 540,
    "kind": "set",
    "name": "CPM",
    "memberof": "src/hamiltonian/PerimeterConstraint.js~PerimeterConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/PerimeterConstraint.js~PerimeterConstraint#CPM",
    "access": "public",
    "description": "Set the CPM attached to this constraint.",
    "lineNumber": 58,
    "params": [
      {
        "nullable": null,
        "types": [
          "CPM"
        ],
        "spread": false,
        "optional": false,
        "name": "C",
        "description": "the CPM to attach."
      }
    ]
  },
  {
    "__docId__": 541,
    "kind": "method",
    "name": "confChecker",
    "memberof": "src/hamiltonian/PerimeterConstraint.js~PerimeterConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/PerimeterConstraint.js~PerimeterConstraint#confChecker",
    "access": "public",
    "description": "This method checks that all required parameters are present in the\nobject supplied to the constructor, and that they are of the right\nformat. It throws an error when this is not the case.",
    "lineNumber": 70,
    "params": [],
    "return": null
  },
  {
    "__docId__": 542,
    "kind": "method",
    "name": "initializePerimeters",
    "memberof": "src/hamiltonian/PerimeterConstraint.js~PerimeterConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/PerimeterConstraint.js~PerimeterConstraint#initializePerimeters",
    "access": "public",
    "description": "This method initializes the this.cellperimeters object when the\nconstraint is added to a non-empty CPM.",
    "lineNumber": 78,
    "params": [],
    "return": null
  },
  {
    "__docId__": 543,
    "kind": "method",
    "name": "postSetpixListener",
    "memberof": "src/hamiltonian/PerimeterConstraint.js~PerimeterConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/PerimeterConstraint.js~PerimeterConstraint#postSetpixListener",
    "access": "public",
    "description": "The postSetpixListener of the PerimeterConstraint ensures that cell\nperimeters are updated after each copy in the CPM.",
    "lineNumber": 101,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "the coordinate of the pixel that is changed."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "t_old",
        "description": "the cellid of this pixel before the copy"
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "t_new",
        "description": "the cellid of this pixel after the copy."
      }
    ],
    "listens": [
      {
        "types": [
          "CPM#setpixi"
        ],
        "description": "because when a new pixel is set (which is\n\tdetermined in the CPM),\tsome of the cell perimeters will change."
      }
    ],
    "return": null
  },
  {
    "__docId__": 544,
    "kind": "method",
    "name": "deltaH",
    "memberof": "src/hamiltonian/PerimeterConstraint.js~PerimeterConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/PerimeterConstraint.js~PerimeterConstraint#deltaH",
    "access": "public",
    "description": "Method to compute the Hamiltonian for this constraint.",
    "lineNumber": 161,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "sourcei",
        "description": "coordinate of the source pixel that\n\ttries to copy."
      },
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "targeti",
        "description": "coordinate of the target pixel the\n\tsource is trying to copy into."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "src_type",
        "description": "cellid of the source pixel."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_type",
        "description": "cellid of the target pixel."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the change in Hamiltonian for this copy attempt and\nthis constraint."
    }
  },
  {
    "__docId__": 545,
    "kind": "file",
    "name": "src/hamiltonian/PersistenceConstraint.js",
    "content": "import SoftConstraint from \"./SoftConstraint.js\"\nimport Centroids from \"../stats/Centroids.js\"\nimport CentroidsWithTorusCorrection from \"../stats/CentroidsWithTorusCorrection.js\"\nimport ParameterChecker from \"./ParameterChecker.js\"\n\n/**\n * This is a constraint in which each cell has a preferred direction of migration. \n * This direction is only dependent on the cell, not on the specific pixel of a cell.\n * \n * This constraint works with torus as long as the field size is large enough. \n */\nclass PersistenceConstraint extends SoftConstraint {\n\n\t/** The constructor of the PersistenceConstraint requires a conf object with parameters.\n\t@param {object} conf - parameter object for this constraint\n\t@param {PerKindNonNegative} conf.LAMBDA_DIR - strength of the persistenceconstraint per cellkind.\n\t@param {PerKindNonNegative} [conf.DELTA_T = [10,10,...]] - the number of MCS over which the current direction is \n\tdetermined. Eg if DELTA_T = 10 for a cellkind, then its current direction is given by\n\tthe vector from its centroid 10 MCS ago to its centroid now.\n\t@param {PerKindProb} conf.PERSIST - persistence per cellkind. If this is 1, its new\n\ttarget direction is exactly equal to its current direction. If it is lower than 1, \n\tangular noise is added accordingly. \n\t*/\n\tconstructor( conf ){\n\t\tsuper( conf )\n\t\t\n\t\t/** Cache centroids over the previous conf.DELTA_T MCS to determine directions.\n\t\t@type {CellObject}\n\t\t*/\n\t\tthis.cellcentroidlists = {}\n\t\t/** Target direction of movement of each cell.\n\t\t@type {CellObject}\n\t\t*/\n\t\tthis.celldirections = {}\n\t}\n\t\n\t/** Set the CPM attached to this constraint.\n\t@param {CPM} C - the CPM to attach.*/\n\tset CPM(C){\n\t\t\n\t\t/** @ignore */\n\t\tthis.halfsize = new Array(C.ndim).fill(0)\n\t\t\n\t\tsuper.CPM = C\n\t\t\n\t\tfor( let i = 0 ; i < C.ndim ; i ++ ){\n\t\t\tthis.halfsize[i] = C.extents[i]/2\n\t\t}\n\t\tthis.confChecker()\n\t}\n\t\n\t/** This method checks that all required parameters are present in the object supplied to\n\tthe constructor, and that they are of the right format. It throws an error when this\n\tis not the case.*/\n\tconfChecker(){\n\t\tlet checker = new ParameterChecker( this.conf, this.C )\n\t\tchecker.confCheckParameter( \"LAMBDA_DIR\", \"KindArray\", \"NonNegative\" )\n\t\tchecker.confCheckParameter( \"PERSIST\", \"KindArray\", \"Probability\" )\n\t}\n\t\n\t/** Method to compute the Hamiltonian for this constraint. \n\t @param {IndexCoordinate} sourcei - coordinate of the source pixel that tries to copy.\n\t @param {IndexCoordinate} targeti - coordinate of the target pixel the source is trying\n\t to copy into.\n\t @param {CellId} src_type - cellid of the source pixel.\n\t @param {CellId} tgt_type - cellid of the target pixel. This argument is not used by this\n\t method, but is supplied for consistency with other SoftConstraints. The CPM will always\n\t call this method supplying the tgt_type as fourth argument.\n\t @return {number} the change in Hamiltonian for this copy attempt and this constraint.*/ \n\t/* eslint-disable no-unused-vars*/\n\tdeltaH ( sourcei, targeti, src_type, tgt_type ) {\n\t\tif( src_type == 0 || !(src_type in this.celldirections) ) return 0\n\t\tlet b = this.celldirections[src_type]\n\t\tlet p1 = this.C.grid.i2p(sourcei), p2 = this.C.grid.i2p(targeti)\n\t\tlet a = []\n\t\tfor( let i = 0 ; i < p1.length ; i ++ ){\n\t\t\ta[i] = p2[i]-p1[i]\n\t\t\t// Correct for torus if necessary\n\t\t\tif( this.C.grid.torus[i] ){\n\t\t\t\tif( a[i] > this.halfsize[i] ){\n\t\t\t\t\ta[i] -= this.C.extents[i]\n\t\t\t\t} else if( a[i] < -this.halfsize[i] ){\n\t\t\t\t\ta[i] += this.C.extents[i]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet dp = 0\n\t\tfor( let i = 0 ; i < a.length ; i ++ ){\n\t\t\tdp += a[i]*b[i]\n\t\t}\n\t\treturn - dp\n\t}\n\t\n\t/** Normalize a vector a by its length.\n\t@param {number[]} a - vector to normalize.\n\t@return {number[]} normalized version of this vector.\n\t@private*/\n\tnormalize( a ){\n\t\tlet norm = 0\n\t\tfor( let i = 0 ; i < a.length ; i ++ ){\n\t\t\tnorm += a[i]*a[i]\n\t\t}\n\t\tnorm = Math.sqrt(norm)\n\t\tfor( let i = 0 ; i < a.length ; i ++ ){\n\t\t\ta[i] /= norm\n\t\t}\n\t}\n\t/** this function samples a random number from a normal distribution\n\t@param {number} [mu=0] - mean of the normal distribution.\n\t@param {number} [sigma=1] - SD of the normal distribution.\n\t@return {number} the random number generated.\n\t@private\n\t*/\n\tsampleNorm (mu=0, sigma=1) {\n\t\tlet u1 = this.C.random()\n\t\tlet u2 = this.C.random()\n\t\tlet z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(Math.PI*2 * u2)\n\t\treturn z0 * sigma + mu\n\t}\n\t/** This function samples a random direction vector with length 1\n\t@param {number} [n=3] - number of dimensions of the space to make the vector in.\n\t@return {number[]} - a normalized direction vector.\n\t*/\n\trandDir (n=3) {\n\t\tlet dir = []\n\t\twhile(n-- > 0){\n\t\t\tdir.push(this.sampleNorm())\n\t\t}\n\t\tthis.normalize(dir)\n\t\treturn dir\n\t}\n\t/** Change the target direction of a cell to a given vector.\n\t\t@param {CellId} t - the cellid of the cell to change the direction of.\n\t\t@param {number[]} dx - the new direction this cell should get.\n\t*/\n\tsetDirection( t, dx ){\n\t\tthis.celldirections[t] = dx\n\t}\n\t\n\t/** After each MCS, update the target direction of each cell based on its actual\n\tdirection over the last {conf.DELTA_T[cellkind]} steps, and some angular noise\n\tdepending on {conf.PERSIST[cellkind]}.\n\t@listens {CPM#timeStep} because when the CPM has finished an MCS, cells have new \n\tcentroids and their direction must be updated. \n\t*/\n\tpostMCSListener(){\n\t\tlet centroids\n\t\tif( this.C.conf.torus ){\n\t\t\tcentroids = this.C.getStat( CentroidsWithTorusCorrection )\n\t\t} else {\n\t\t\tcentroids = this.C.getStat( Centroids )\n\t\t}\n\t\tfor( let t of this.C.cellIDs() ){\n\t\t\tlet ld = this.cellParameter(\"LAMBDA_DIR\", t)\n\t\t\tlet dt = this.conf[\"DELTA_T\"] && this.conf[\"DELTA_T\"][this.C.cellKind(t)] ? // cannot convert this call easily to cellParameter\n\t\t\t\tthis.cellParameter(\"DELTA_T\", t) : 10\n\t\t\tif( ld == 0 ){\n\t\t\t\tdelete this.cellcentroidlists[t]\n\t\t\t\tdelete this.celldirections[t]\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif( !(t in this.cellcentroidlists ) ){\n\t\t\t\tthis.cellcentroidlists[t] = []\n\t\t\t\tthis.celldirections[t] = this.randDir(this.C.ndim)\n\t\t\t}\n\n\t\t\tlet ci = centroids[t]\n\t\t\tthis.cellcentroidlists[t].unshift(ci)\n\t\t\tif( this.cellcentroidlists[t].length >= dt ){\n\t\t\t\t// note, dt could change during execution\n\t\t\t\tlet l\n\t\t\t\twhile( this.cellcentroidlists[t].length >= dt ){\n\t\t\t\t\tl = this.cellcentroidlists[t].pop()\n\t\t\t\t}\n\t\t\t\tlet dx = []\n\t\t\t\tfor( let j = 0 ; j < l.length ; j ++ ){\n\t\t\t\t\tdx[j] = ci[j] - l[j]\n\t\t\t\t\t\n\t\t\t\t\t// torus correction; do only if CPM actually has a torus in this dimension.\n\t\t\t\t\tif( this.C.grid.torus[j] ){\n\t\t\t\t\t\tif( dx[j] > this.halfsize[j] ){\n\t\t\t\t\t\t\tdx[j] -= this.C.extents[j]\n\t\t\t\t\t\t} else if( dx[j] < -this.halfsize[j] ){\n\t\t\t\t\t\t\tdx[j] += this.C.extents[j]\n\t\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// apply angular diffusion to target direction if needed\n\t\t\t\tlet per = this.cellParameter(\"PERSIST\", t)\n\t\t\t\tif( per < 1 ){\n\t\t\t\t\tthis.normalize(dx)\n\t\t\t\t\tthis.normalize(this.celldirections[t])\n\t\t\t\t\tfor (let j = 0; j < dx.length; j++) {\n\t\t\t\t\t\tdx[j] = (1 - per) * dx[j] + per * this.celldirections[t][j]\n\t\t\t\t\t}\n\t\t\t\t\tthis.normalize(dx)\n\t\t\t\t\t// this may lead to NaNs if the displacement was zero. If that's the case,\n\t\t\t\t\t// the cell hasn't moved and has lost its persistent \"memory\", so we give it\n\t\t\t\t\t// a new random direction.\n\t\t\t\t\tif( dx.some( d => Number.isNaN(d) ) ){\n\t\t\t\t\t\tthis.celldirections[t] = this.randDir(this.C.ndim)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let j = 0; j < dx.length; j++) {\n\t\t\t\t\t\t\tdx[j] *= ld\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.celldirections[t] = dx\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport default PersistenceConstraint \n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/hamiltonian/PersistenceConstraint.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 546,
    "kind": "class",
    "name": "PersistenceConstraint",
    "memberof": "src/hamiltonian/PersistenceConstraint.js",
    "static": true,
    "longname": "src/hamiltonian/PersistenceConstraint.js~PersistenceConstraint",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/hamiltonian/PersistenceConstraint.js",
    "importStyle": "PersistenceConstraint",
    "description": "This is a constraint in which each cell has a preferred direction of migration. \nThis direction is only dependent on the cell, not on the specific pixel of a cell.\n\nThis constraint works with torus as long as the field size is large enough. ",
    "lineNumber": 12,
    "interface": false,
    "extends": [
      "src/hamiltonian/SoftConstraint.js~SoftConstraint"
    ]
  },
  {
    "__docId__": 547,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/hamiltonian/PersistenceConstraint.js~PersistenceConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/PersistenceConstraint.js~PersistenceConstraint#constructor",
    "access": "public",
    "description": "The constructor of the PersistenceConstraint requires a conf object with parameters.",
    "lineNumber": 24,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "conf",
        "description": "parameter object for this constraint"
      },
      {
        "nullable": null,
        "types": [
          "PerKindNonNegative"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.LAMBDA_DIR",
        "description": "strength of the persistenceconstraint per cellkind."
      },
      {
        "nullable": null,
        "types": [
          "PerKindNonNegative"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " [10,10,...]",
        "defaultRaw": " [10,10,...]",
        "name": "conf.DELTA_T",
        "description": "the number of MCS over which the current direction is \ndetermined. Eg if DELTA_T = 10 for a cellkind, then its current direction is given by\nthe vector from its centroid 10 MCS ago to its centroid now."
      },
      {
        "nullable": null,
        "types": [
          "PerKindProb"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.PERSIST",
        "description": "persistence per cellkind. If this is 1, its new\ntarget direction is exactly equal to its current direction. If it is lower than 1, \nangular noise is added accordingly."
      }
    ]
  },
  {
    "__docId__": 548,
    "kind": "member",
    "name": "cellcentroidlists",
    "memberof": "src/hamiltonian/PersistenceConstraint.js~PersistenceConstraint",
    "static": false,
    "longname": "src/hamiltonian/PersistenceConstraint.js~PersistenceConstraint#cellcentroidlists",
    "access": "public",
    "description": "Cache centroids over the previous conf.DELTA_T MCS to determine directions.",
    "lineNumber": 30,
    "type": {
      "nullable": null,
      "types": [
        "CellObject"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 549,
    "kind": "member",
    "name": "celldirections",
    "memberof": "src/hamiltonian/PersistenceConstraint.js~PersistenceConstraint",
    "static": false,
    "longname": "src/hamiltonian/PersistenceConstraint.js~PersistenceConstraint#celldirections",
    "access": "public",
    "description": "Target direction of movement of each cell.",
    "lineNumber": 34,
    "type": {
      "nullable": null,
      "types": [
        "CellObject"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 550,
    "kind": "set",
    "name": "CPM",
    "memberof": "src/hamiltonian/PersistenceConstraint.js~PersistenceConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/PersistenceConstraint.js~PersistenceConstraint#CPM",
    "access": "public",
    "description": "Set the CPM attached to this constraint.",
    "lineNumber": 39,
    "params": [
      {
        "nullable": null,
        "types": [
          "CPM"
        ],
        "spread": false,
        "optional": false,
        "name": "C",
        "description": "the CPM to attach."
      }
    ]
  },
  {
    "__docId__": 551,
    "kind": "member",
    "name": "halfsize",
    "memberof": "src/hamiltonian/PersistenceConstraint.js~PersistenceConstraint",
    "static": false,
    "longname": "src/hamiltonian/PersistenceConstraint.js~PersistenceConstraint#halfsize",
    "access": "public",
    "description": null,
    "lineNumber": 42,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 552,
    "kind": "method",
    "name": "confChecker",
    "memberof": "src/hamiltonian/PersistenceConstraint.js~PersistenceConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/PersistenceConstraint.js~PersistenceConstraint#confChecker",
    "access": "public",
    "description": "This method checks that all required parameters are present in the object supplied to\nthe constructor, and that they are of the right format. It throws an error when this\nis not the case.",
    "lineNumber": 55,
    "params": [],
    "return": null
  },
  {
    "__docId__": 553,
    "kind": "method",
    "name": "deltaH",
    "memberof": "src/hamiltonian/PersistenceConstraint.js~PersistenceConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/PersistenceConstraint.js~PersistenceConstraint#deltaH",
    "access": "public",
    "description": "Method to compute the Hamiltonian for this constraint. ",
    "lineNumber": 71,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "sourcei",
        "description": "coordinate of the source pixel that tries to copy."
      },
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "targeti",
        "description": "coordinate of the target pixel the source is trying\nto copy into."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "src_type",
        "description": "cellid of the source pixel."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_type",
        "description": "cellid of the target pixel. This argument is not used by this\nmethod, but is supplied for consistency with other SoftConstraints. The CPM will always\ncall this method supplying the tgt_type as fourth argument."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the change in Hamiltonian for this copy attempt and this constraint."
    }
  },
  {
    "__docId__": 554,
    "kind": "method",
    "name": "normalize",
    "memberof": "src/hamiltonian/PersistenceConstraint.js~PersistenceConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/PersistenceConstraint.js~PersistenceConstraint#normalize",
    "access": "private",
    "description": "Normalize a vector a by its length.",
    "lineNumber": 98,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "a",
        "description": "vector to normalize."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "normalized version of this vector."
    }
  },
  {
    "__docId__": 555,
    "kind": "method",
    "name": "sampleNorm",
    "memberof": "src/hamiltonian/PersistenceConstraint.js~PersistenceConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/PersistenceConstraint.js~PersistenceConstraint#sampleNorm",
    "access": "private",
    "description": "this function samples a random number from a normal distribution",
    "lineNumber": 114,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "mu",
        "description": "mean of the normal distribution."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "sigma",
        "description": "SD of the normal distribution."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the random number generated."
    }
  },
  {
    "__docId__": 556,
    "kind": "method",
    "name": "randDir",
    "memberof": "src/hamiltonian/PersistenceConstraint.js~PersistenceConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/PersistenceConstraint.js~PersistenceConstraint#randDir",
    "access": "public",
    "description": "This function samples a random direction vector with length 1",
    "lineNumber": 124,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "3",
        "defaultRaw": 3,
        "name": "n",
        "description": "number of dimensions of the space to make the vector in."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "a normalized direction vector."
    }
  },
  {
    "__docId__": 557,
    "kind": "method",
    "name": "setDirection",
    "memberof": "src/hamiltonian/PersistenceConstraint.js~PersistenceConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/PersistenceConstraint.js~PersistenceConstraint#setDirection",
    "access": "public",
    "description": "Change the target direction of a cell to a given vector.",
    "lineNumber": 136,
    "params": [
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "t",
        "description": "the cellid of the cell to change the direction of."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "dx",
        "description": "the new direction this cell should get."
      }
    ],
    "return": null
  },
  {
    "__docId__": 558,
    "kind": "method",
    "name": "postMCSListener",
    "memberof": "src/hamiltonian/PersistenceConstraint.js~PersistenceConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/PersistenceConstraint.js~PersistenceConstraint#postMCSListener",
    "access": "public",
    "description": "After each MCS, update the target direction of each cell based on its actual\ndirection over the last {conf.DELTA_T[cellkind]} steps, and some angular noise\ndepending on {conf.PERSIST[cellkind]}.",
    "lineNumber": 146,
    "listens": [
      {
        "types": [
          "CPM#timeStep"
        ],
        "description": "because when the CPM has finished an MCS, cells have new \ncentroids and their direction must be updated."
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 559,
    "kind": "file",
    "name": "src/hamiltonian/PreferredDirectionConstraint.js",
    "content": "import SoftConstraint from \"./SoftConstraint.js\"\nimport ParameterChecker from \"./ParameterChecker.js\"\n\n/** Implements a global bias direction of motion.\n\tThis constraint computes the *unnormalized* dot product \n\tbetween copy attempt vector and target direction vector.\n\n\tSupply the target direction vector in normalized form, or \n\tuse the length of the vector to influence the strength \n\tof this bias.\n\n\tWorks for torus grids, if they are \"big enough\".\n\t\n\t * @example\n\t * // Build a CPM and add the constraint\n\t * let CPM = require( \"path/to/build\" )\n\t * let C = new CPM.CPM( [200,200], { T : 20 } )\n\t * C.add( new CPM.PreferredDirectionConstraint( {\n\t * \tLAMBDA_DIR : [0,50], \n\t * \tDIR : [[0,0],[1,1]]\n\t * } ) )\n\t*/\nclass PreferredDirectionConstraint extends SoftConstraint {\n\n\t\n\t/** The constructor of the PreferredDirectionConstraint requires a conf object with parameters.\n\t@param {object} conf - parameter object for this constraint\n\t@param {PerKindNonNegative} conf.LAMBDA_DIR - strength of the constraint per cellkind.\n\t@param {ArrayCoordinate[]} conf.DIR 'vector' with the preferred direction. This is\n\tan array with the {@link ArrayCoordinate}s of the start and endpoints of this vector. \n\t*/\n\tconstructor(conf){\n\t\tsuper(conf)\n\t}\n\t\n\t/** This method checks that all required parameters are present in the object supplied to\n\tthe constructor, and that they are of the right format. It throws an error when this\n\tis not the case.*/\n\tconfChecker(){\n\t\tlet checker = new ParameterChecker( this.conf, this.C )\n\t\tchecker.confCheckParameter( \"LAMBDA_DIR\", \"KindArray\", \"NonNegative\" )\n\t\t\n\t\t// Custom check for the attractionpoint\n\t\tchecker.confCheckPresenceOf( \"DIR\" )\n\t\tlet pt = this.conf[\"DIR\"]\n\t\tif( !( pt instanceof Array ) ){\n\t\t\tthrow( \"DIR must be an array with the start and end coordinate of the preferred direction vector!\" )\n\t\t}\n\t\tfor( let p of pt ){\n\t\t\n\t\t\tif( !checker.isCoordinate(p) ){\n\t\t\t\tthrow(\"DIR elements must be coordinate arrays with the same dimensions as the grid!\")\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/** Method to compute the Hamiltonian for this constraint. \n\t @param {IndexCoordinate} src_i - coordinate of the source pixel that tries to copy.\n\t @param {IndexCoordinate} tgt_i - coordinate of the target pixel the source is trying\n\t to copy into.\n\t @param {CellId} src_type - cellid of the source pixel.\n\t @param {CellId} tgt_type - cellid of the target pixel. This argument is not actually\n\t used but is given for consistency with other soft constraints; the CPM always calls\n\t this method with four arguments.\n\t @return {number} the change in Hamiltonian for this copy attempt and this constraint.*/ \n\t/* eslint-disable no-unused-vars*/\n\tdeltaH( src_i, tgt_i, src_type, tgt_type ){\n\t\tlet l = this.cellParameter(\"LAMBDA_DIR\", src_type)\n\t\tif( !l ){\n\t\t\treturn 0\n\t\t}\n\t\tlet torus = this.C.conf.torus\n\t\tlet dir = this.cellParameter(\"DIR\", src_type)\n\t\tlet p1 = this.C.grid.i2p( src_i ), p2 = this.C.grid.i2p( tgt_i )\n\t\t// To bias a copy attempt p1 -> p2 in the direction of vector 'dir'.\n\t\tlet r = 0.\n\t\t// loops over the coordinates x,y,(z)\n\t\tfor( let i = 0; i < p1.length ; i++ ){\n\t\t\tlet si = this.C.extents[i]\n\t\t\t// direction of the copy attempt on this coordinate is from p1 to p2\n\t\t\tlet dx = p2[i] - p1[i]\n\t\t\tif( torus[i] ){\n\t\t\t\t// If distance is greater than half the grid size, correct the\n\t\t\t\t// coordinate.\n\t\t\t\tif( dx > si/2 ){\n\t\t\t\t\tdx -= si\n\t\t\t\t} else if( dx < -si/2 ){\n\t\t\t\t\tdx += si\n\t\t\t\t}\n\t\t\t}\n\t\t\t// direction of the gradient\n\t\t\tr += dx * dir[i] \n\t\t}\n\t\treturn - r * l\n\t}\n}\n\nexport default PreferredDirectionConstraint\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/hamiltonian/PreferredDirectionConstraint.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 560,
    "kind": "class",
    "name": "PreferredDirectionConstraint",
    "memberof": "src/hamiltonian/PreferredDirectionConstraint.js",
    "static": true,
    "longname": "src/hamiltonian/PreferredDirectionConstraint.js~PreferredDirectionConstraint",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/hamiltonian/PreferredDirectionConstraint.js",
    "importStyle": "PreferredDirectionConstraint",
    "description": "Implements a global bias direction of motion.\nThis constraint computes the *unnormalized* dot product \nbetween copy attempt vector and target direction vector.\n\nSupply the target direction vector in normalized form, or \nuse the length of the vector to influence the strength \nof this bias.\n\nWorks for torus grids, if they are \"big enough\".",
    "examples": [
      "// Build a CPM and add the constraint\nlet CPM = require( \"path/to/build\" )\nlet C = new CPM.CPM( [200,200], { T : 20 } )\nC.add( new CPM.PreferredDirectionConstraint( {\n\tLAMBDA_DIR : [0,50], \n\tDIR : [[0,0],[1,1]]\n} ) )"
    ],
    "lineNumber": 23,
    "interface": false,
    "extends": [
      "src/hamiltonian/SoftConstraint.js~SoftConstraint"
    ]
  },
  {
    "__docId__": 561,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/hamiltonian/PreferredDirectionConstraint.js~PreferredDirectionConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/PreferredDirectionConstraint.js~PreferredDirectionConstraint#constructor",
    "access": "public",
    "description": "The constructor of the PreferredDirectionConstraint requires a conf object with parameters.",
    "lineNumber": 32,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "conf",
        "description": "parameter object for this constraint"
      },
      {
        "nullable": null,
        "types": [
          "PerKindNonNegative"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.LAMBDA_DIR",
        "description": "strength of the constraint per cellkind."
      },
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate[]"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.DIR",
        "description": "'vector' with the preferred direction. This is\nan array with the {@link ArrayCoordinate}s of the start and endpoints of this vector."
      }
    ]
  },
  {
    "__docId__": 562,
    "kind": "method",
    "name": "confChecker",
    "memberof": "src/hamiltonian/PreferredDirectionConstraint.js~PreferredDirectionConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/PreferredDirectionConstraint.js~PreferredDirectionConstraint#confChecker",
    "access": "public",
    "description": "This method checks that all required parameters are present in the object supplied to\nthe constructor, and that they are of the right format. It throws an error when this\nis not the case.",
    "lineNumber": 39,
    "params": [],
    "return": null
  },
  {
    "__docId__": 563,
    "kind": "method",
    "name": "deltaH",
    "memberof": "src/hamiltonian/PreferredDirectionConstraint.js~PreferredDirectionConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/PreferredDirectionConstraint.js~PreferredDirectionConstraint#deltaH",
    "access": "public",
    "description": "Method to compute the Hamiltonian for this constraint. ",
    "lineNumber": 67,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "src_i",
        "description": "coordinate of the source pixel that tries to copy."
      },
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_i",
        "description": "coordinate of the target pixel the source is trying\nto copy into."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "src_type",
        "description": "cellid of the source pixel."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_type",
        "description": "cellid of the target pixel. This argument is not actually\nused but is given for consistency with other soft constraints; the CPM always calls\nthis method with four arguments."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the change in Hamiltonian for this copy attempt and this constraint."
    }
  },
  {
    "__docId__": 564,
    "kind": "file",
    "name": "src/hamiltonian/SoftConnectivityConstraint.js",
    "content": "\n\nimport SoftConstraint from \"./SoftConstraint.js\"\nimport ParameterChecker from \"./ParameterChecker.js\"\n\n/** This constraint encourages that cells stay 'connected' throughout any copy attempts.\nIn contrast to the hard version of the {@link ConnectivityConstraint}, this version does\nnot completely forbid copy attempts that break the cell connectivity, but punishes them\nthrough a positive term in the Hamiltonian. \n@experimental\n*/\nclass SoftConnectivityConstraint extends SoftConstraint {\n\n\t/** The constructor of the ConnectivityConstraint requires a conf object with one parameter.\n\t@param {object} conf - parameter object for this constraint.\n\t@param {PerKindBoolean} conf.LAMBDA_CONNECTIVITY - should the cellkind be connected or not?\n\t*/\n\tconstructor( conf ){\n\t\tsuper(conf)\n\t\t\n\t\t/** Object tracking the borderpixels of each cell. This is kept up to date after\n\t\tevery copy attempt.\n\t\t@type {CellObject}*/\n\t\tthis.borderpixelsbycell = {}\n\t\t\n\t\tthis.components = []\n\t}\n\t\n\t/** The set CPM method attaches the CPM to the constraint. */\n\tset CPM(C){\n\t\tsuper.CPM = C\n\t\t\n\t\t/** Private property used by {@link updateBorderPixels} to track borders. \n\t\t@private\n\t\t@type {Uint16Array} */\n\t\tthis._neighbours = new Uint16Array(this.C.grid.p2i(this.C.extents))\n\t}\n\t\n\t/** This method checks that all required parameters are present in the object supplied to\n\tthe constructor, and that they are of the right format. It throws an error when this\n\tis not the case.*/\n\tconfChecker(){\n\t\tlet checker = new ParameterChecker( this.conf, this.C )\n\t\tchecker.confCheckParameter( \"LAMBDA_CONNECTIVITY\", \"KindArray\", \"NonNegative\" )\n\t}\n\t\n\t/** Update the borderpixels when pixel i changes from t_old into t_new.\n\t@param {IndexCoordinate} i - the pixel to change\n\t@param {CellId} t_old - the cell the pixel belonged to previously\n\t@param {CellId} t_new - the cell the pixel belongs to now. */\n\tupdateBorderPixels( i, t_old, t_new  ){\n\t\tif( t_old == t_new ) return\n\t\tif( !(t_new in this.borderpixelsbycell) ){\n\t\t\tthis.borderpixelsbycell[t_new] = {}\n\t\t}\n\t\tconst Ni = this.C.grid.neighi( i )\n\t\tconst wasborder = this._neighbours[i] > 0\n\t\t// current neighbors of pixel i, set counter to zero and loop over nbh.\n\t\tthis._neighbours[i] = 0\n\t\tfor( let ni of Ni  ){\n\t\t\t// type of the neighbor.\n\t\t\tconst nt = this.C.grid.pixti(ni)\n\t\t\t\n\t\t\t// If type is not the t_new of pixel i, nbi++ because the neighbor belongs\n\t\t\t// to a different cell. \n\t\t\tif( nt != t_new ){\n\t\t\t\tthis._neighbours[i] ++ \n\t\t\t}\n\t\t\t\n\t\t\t// If neighbor type is t_old, the border of t_old may have to be adjusted. \n\t\t\t// It gets an extra neighbor because the current pixel becomes t_new.\n\t\t\tif( nt == t_old ){\n\t\t\t\t// If this wasn't a borderpixel of t_old, it now becomes one because\n\t\t\t\t// it has a neighbor belonging to t_new\n\t\t\t\tif( this._neighbours[ni] ++ == 0 ){\n\t\t\t\t\tif( !(t_old in this.borderpixelsbycell) ){\n\t\t\t\t\t\tthis.borderpixelsbycell[t_old] = {}\n\t\t\t\t\t}\n\t\t\t\t\tthis.borderpixelsbycell[t_old][ni] = true\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// If type is t_new, the neighbor may no longer be a borderpixel\n\t\t\tif( nt == t_new ){\n\t\t\t\tif( --this._neighbours[ni] == 0 && ( ni in this.borderpixelsbycell[t_new] ) ){\n\t\t\t\t\tdelete this.borderpixelsbycell[t_new][ni]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Case 1: \n\t\t// If current pixel is a borderpixel, add it to those of the current cell.\n\t\tif( this._neighbours[i] > 0 ){\n\t\t\tthis.borderpixelsbycell[t_new][i]=true\n\t\t}\n\t\t\n\t\t// Case 2:\n\t\t// Current pixel was a borderpixel. Remove from the old cell. \n\t\tif( wasborder ){\n\t\t\t// It was a borderpixel from the old cell, but no longer belongs to that cell.\n\t\t\tif( i in this.borderpixelsbycell[t_old] ){ \n\t\t\t\tdelete this.borderpixelsbycell[t_old][i]\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\t/** Get the connected components of the borderpixels of the current cell.\n\t@param {CellId} cellid - cell to check the connected components of.\n\t@return {object} an array with an element for every connected component, which is in\n\tturn an array of the {@link ArrayCoordinate}s of the pixels belonging to that component.  */\n\tconnectedComponentsOfCellBorder( cellid ){\n\t\n\t\t/* Note that to get number of connected components, we only need to look at cellborderpixels. */\n\t\tif( !( cellid in this.borderpixelsbycell ) ){\n\t\t\treturn []\n\t\t}\n\t\t\n\t\t//let cbpi = Object.keys( this.borderpixelsbycell[cellid] ), cbpobject = this.borderpixelsbycell[cellid]\n\t\treturn this.connectedComponentsOf( this.borderpixelsbycell[cellid] )\n\t}\n\t\n\t/** Get the connected components of a set of pixels.\n\t@param {object} pixelobject - an object with as keys the {@link IndexCoordinate}s of the pixels to check.\n\t@return {object} an array with an element for every connected component, which is in\n\tturn an array of the {@link ArrayCoordinate}s of the pixels belonging to that component.  */\n\tconnectedComponentsOf( pixelobject ){\n\t\n\t\tlet cbpi = Object.keys( pixelobject )\n\t\t\n\t\tlet visited = {}, k=0, pixels = [], C = this.C\n\t\tlet labelComponent = function(seed, k){\n\t\t\tlet q = [seed]\n\t\t\tlet cellid = C.pixti(q)\n\t\t\tvisited[q[0]] = 1\n\t\t\tpixels[k] = []\n\t\t\twhile( q.length > 0 ){\n\t\t\t\tlet e = q.pop()\n\t\t\t\tpixels[k].push(C.grid.i2p(e) )\n\t\t\t\tlet ne = C.grid.neighi( e )\n\t\t\t\tfor( let i = 0 ; i < ne.length ; i ++ ){\n\t\t\t\t\tif( C.pixti( ne[i] ) == cellid &&\n\t\t\t\t\t\t!(ne[i] in visited) && (ne[i] in pixelobject) ){\n\t\t\t\t\t\tq.push(ne[i])\n\t\t\t\t\t\tvisited[ne[i]]=1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor( let i = 0 ; i < cbpi.length ; i ++ ){\n\t\t\tlet pi = parseInt( cbpi[i] )\n\t\t\tif( !(pi in visited) ){\n\t\t\t\tlabelComponent( pi, k )\n\t\t\t\tk++\n\t\t\t}\n\t\t}\n\t\treturn pixels\n\t}\n\t\t\n\t/** The postSetpixListener of the ConnectivityConstraint updates the internally\n\ttracked borderpixels after every copy.\n\t@param {IndexCoordinate} i - the pixel to change\n\t@param {CellId} t_old - the cell the pixel belonged to previously\n\t@param {CellId} t - the cell the pixel belongs to now.\t\n\t*/\n\tpostSetpixListener(  i, t_old, t ){\n\t\tthis.updateBorderPixels( i, t_old, t )\n\t}\t\n\t\n\t\n\t/** To speed things up: first check if a pixel change disrupts the local connectivity\n\tin its direct neighborhood. If local connectivity is not disrupted, we don't have to\n\tcheck global connectivity at all. This currently only works in 2D, so it returns \n\tfalse for 3D (ensuring that connectivity is checked globally).\n\t@param {IndexCoordinate} tgt_i - the pixel to change\n\t@param {CellId} tgt_type - the cell the pixel belonged to before the copy attempt.\n\t@return {boolean} does the local neighborhood remain connected if this pixel changes?\n\t*/\n\tlocalConnected( tgt_i, tgt_type ){\n\t\n\t\t// Get neighbors of the target pixel\n\t\tlet nbh = this.C.grid.neighi( tgt_i )\n\t\t\n\t\t// object storing the neighbors of tgt_type\n\t\tlet nbhobj = {}\n\t\t\n\t\tfor( let n of nbh ){\n\t\t\n\t\t\t// add it and its neighbors to the neighborhood object\n\t\t\tif( this.C.pixti(n) == tgt_type ){\n\t\t\t\tnbhobj[n] = true\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Get connected components.\n\t\tlet conn = this.connectedComponentsOf( nbhobj )\n\t\tthis.components = conn\n\t\t//console.log(conn.length)\n\t\t\n\t\tlet connected = ( conn.length == 1 )\n\t\t//console.log(connected)\n\t\treturn connected\n\t\t\n\t}\n\t\n\t/** Compute the 'connectivity' of a cell; a number between 0 and 1. If the cell\n\tis completely connected, this returns 1. A cell split into many parts gets a \n\tconnectivity approaching zero. It also matters how the cell is split: splitting\n\tthe cell in two near-equal parts results in a lower connectivity than separating\n\tone pixel from the rest of the cell.\n\t@param {Array} components - an array of arrays (one array per connected component, \n\tin which each entry is the {@link ArrayCoordinate} of a pixel belonging to that component).\n\t@param {CellId} cellid - the cell these components belong to.\n\t@return {number} connectivity of this cell.*/\n\tconnectivity( components, cellid ){\n\t\tif( components.length <= 1 ){\n\t\t\treturn 1\n\t\t} else {\n\t\t\t\n\t\t\tlet Vtot = Object.keys( this.borderpixelsbycell[cellid] ).length\n\t\t\tlet Ci = 0\n\t\t\tfor( let c of components ){\n\t\t\t\tlet Vc = c.length\n\t\t\t\tCi += (Vc/Vtot)*(Vc/Vtot)\n\t\t\t}\n\t\t\t//console.log( Ci )\n\t\t\treturn Ci\n\t\t\t\n\t\t}\n\t}\n\t\n\t/** This method checks the difference in connectivity when pixel tgt_i is changed from\n\ttgt_type to src_type. \n\t@param {IndexCoordinate} tgt_i - the pixel to change\n\t@param {CellId} src_type - the new cell for this pixel.\n\t@param {CellId} tgt_type - the cell the pixel belonged to previously. \t\n\t@return {number} conndiff - the difference: connectivity_after - connectivity_before.\n\t*/\n\tcheckConnected( tgt_i, src_type, tgt_type ){\n\t\n\t\t//return this.localConnected( tgt_i, tgt_type )\n\t\t\n\t\n\t\t\n\t\tif( this.localConnected( tgt_i, tgt_type ) ){\n\t\t\treturn 0\n\t\t} \n\t\t\n\t\t/*else {\n\t\t\tlet conn_new = this.connectivity( this.components, tgt_type )\n\t\t\t\n\t\t\t// current components\n\t\t\tlet nbh = this.C.grid.neighi( tgt_i )\n\t\t\tlet nbhobj = {}\n\t\t\tnbhobj[tgt_i] = true\n\t\t\n\t\t\tfor( let n of nbh ){\n\t\t\t\tif( this.C.pixti(n) == tgt_type ){\n\t\t\t\t\tnbhobj[n] = true\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis.components = this.connectedComponentsOf( nbhobj )\n\t\t\tlet conn_old = this.connectivity( this.components, tgt_type )\n\t\t\t\n\t\t\tlet conndiff = conn_old - conn_new\n\t\t\treturn conndiff\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}*/\n\t\t\n\t\t\n\t\n\t\tlet comp1 = this.connectedComponentsOfCellBorder( tgt_type )\n\t\tlet conn1 = Math.pow( (1-this.connectivity( comp1, tgt_type )),2 )\n\t\n\t\t// Update the borderpixels as if the change occurs\n\t\tthis.updateBorderPixels( tgt_i, tgt_type, src_type )\n\t\tlet comp = this.connectedComponentsOfCellBorder( tgt_type )\n\t\tlet conn2 = Math.pow((1-this.connectivity( comp, tgt_type )),2)\n\t\t\n\t\t\n\t\tlet conndiff = conn2 - conn1\n\t\t/*if( conn2 > conn1 ){\n\t\t\tconndiff = -conndiff\n\t\t} */\n\t\t\n\t\t// Change borderpixels back because the copy attempt hasn't actually gone through yet.\n\t\tthis.updateBorderPixels( tgt_i, src_type, tgt_type )\n\t\t\n\t\treturn conndiff\n\t\t\n\t}\n\n\t/** Method for hard constraints to compute whether the copy attempt fulfills the rule.\n\t @param {IndexCoordinate} src_i - coordinate of the source pixel that tries to copy.\n\t @param {IndexCoordinate} tgt_i - coordinate of the target pixel the source is trying\n\t to copy into.\n\t @param {CellId} src_type - cellid of the source pixel.\n\t @param {CellId} tgt_type - cellid of the target pixel. \n\t @return {boolean} whether the copy attempt satisfies the constraint.*/ \n\tdeltaH( src_i, tgt_i, src_type, tgt_type ){\n\t\t// connectedness of src cell cannot change if it was connected in the first place.\n\t\t\n\t\tlet lambda = this.cellParameter(\"LAMBDA_CONNECTIVITY\", tgt_type)\n\t\t\n\t\t// connectedness of tgt cell\n\t\tif( tgt_type != 0 && lambda > 0 ){\n\t\t\treturn lambda*this.checkConnected( tgt_i, src_type, tgt_type )\n\t\t}\n\t\t\n\t\treturn 0\n\t}\n}\n\nexport default SoftConnectivityConstraint\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/hamiltonian/SoftConnectivityConstraint.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 565,
    "kind": "class",
    "name": "SoftConnectivityConstraint",
    "memberof": "src/hamiltonian/SoftConnectivityConstraint.js",
    "static": true,
    "longname": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/hamiltonian/SoftConnectivityConstraint.js",
    "importStyle": "SoftConnectivityConstraint",
    "description": "This constraint encourages that cells stay 'connected' throughout any copy attempts.\nIn contrast to the hard version of the {@link ConnectivityConstraint}, this version does\nnot completely forbid copy attempts that break the cell connectivity, but punishes them\nthrough a positive term in the Hamiltonian. ",
    "lineNumber": 12,
    "experimental": true,
    "interface": false,
    "extends": [
      "src/hamiltonian/SoftConstraint.js~SoftConstraint"
    ]
  },
  {
    "__docId__": 566,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint#constructor",
    "access": "public",
    "description": "The constructor of the ConnectivityConstraint requires a conf object with one parameter.",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "conf",
        "description": "parameter object for this constraint."
      },
      {
        "nullable": null,
        "types": [
          "PerKindBoolean"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.LAMBDA_CONNECTIVITY",
        "description": "should the cellkind be connected or not?"
      }
    ]
  },
  {
    "__docId__": 567,
    "kind": "member",
    "name": "borderpixelsbycell",
    "memberof": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint",
    "static": false,
    "longname": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint#borderpixelsbycell",
    "access": "public",
    "description": "Object tracking the borderpixels of each cell. This is kept up to date after\nevery copy attempt.",
    "lineNumber": 24,
    "type": {
      "nullable": null,
      "types": [
        "CellObject"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 568,
    "kind": "member",
    "name": "components",
    "memberof": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint",
    "static": false,
    "longname": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint#components",
    "access": "public",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 569,
    "kind": "set",
    "name": "CPM",
    "memberof": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint#CPM",
    "access": "public",
    "description": "The set CPM method attaches the CPM to the constraint.",
    "lineNumber": 30
  },
  {
    "__docId__": 570,
    "kind": "member",
    "name": "_neighbours",
    "memberof": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint",
    "static": false,
    "longname": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint#_neighbours",
    "access": "private",
    "description": "Private property used by {@link updateBorderPixels} to track borders. ",
    "lineNumber": 36,
    "type": {
      "nullable": null,
      "types": [
        "Uint16Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 571,
    "kind": "method",
    "name": "confChecker",
    "memberof": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint#confChecker",
    "access": "public",
    "description": "This method checks that all required parameters are present in the object supplied to\nthe constructor, and that they are of the right format. It throws an error when this\nis not the case.",
    "lineNumber": 42,
    "params": [],
    "return": null
  },
  {
    "__docId__": 572,
    "kind": "method",
    "name": "updateBorderPixels",
    "memberof": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint#updateBorderPixels",
    "access": "public",
    "description": "Update the borderpixels when pixel i changes from t_old into t_new.",
    "lineNumber": 51,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "the pixel to change"
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "t_old",
        "description": "the cell the pixel belonged to previously"
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "t_new",
        "description": "the cell the pixel belongs to now."
      }
    ],
    "return": null
  },
  {
    "__docId__": 573,
    "kind": "method",
    "name": "connectedComponentsOfCellBorder",
    "memberof": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint#connectedComponentsOfCellBorder",
    "access": "public",
    "description": "Get the connected components of the borderpixels of the current cell.",
    "lineNumber": 111,
    "params": [
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "cellid",
        "description": "cell to check the connected components of."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "an array with an element for every connected component, which is in\nturn an array of the {@link ArrayCoordinate}s of the pixels belonging to that component."
    }
  },
  {
    "__docId__": 574,
    "kind": "method",
    "name": "connectedComponentsOf",
    "memberof": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint#connectedComponentsOf",
    "access": "public",
    "description": "Get the connected components of a set of pixels.",
    "lineNumber": 126,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "pixelobject",
        "description": "an object with as keys the {@link IndexCoordinate}s of the pixels to check."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "an array with an element for every connected component, which is in\nturn an array of the {@link ArrayCoordinate}s of the pixels belonging to that component."
    }
  },
  {
    "__docId__": 575,
    "kind": "method",
    "name": "postSetpixListener",
    "memberof": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint#postSetpixListener",
    "access": "public",
    "description": "The postSetpixListener of the ConnectivityConstraint updates the internally\ntracked borderpixels after every copy.",
    "lineNumber": 165,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "the pixel to change"
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "t_old",
        "description": "the cell the pixel belonged to previously"
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "t",
        "description": "the cell the pixel belongs to now."
      }
    ],
    "return": null
  },
  {
    "__docId__": 576,
    "kind": "method",
    "name": "localConnected",
    "memberof": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint#localConnected",
    "access": "public",
    "description": "To speed things up: first check if a pixel change disrupts the local connectivity\nin its direct neighborhood. If local connectivity is not disrupted, we don't have to\ncheck global connectivity at all. This currently only works in 2D, so it returns \nfalse for 3D (ensuring that connectivity is checked globally).",
    "lineNumber": 178,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_i",
        "description": "the pixel to change"
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_type",
        "description": "the cell the pixel belonged to before the copy attempt."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "does the local neighborhood remain connected if this pixel changes?"
    }
  },
  {
    "__docId__": 578,
    "kind": "method",
    "name": "connectivity",
    "memberof": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint#connectivity",
    "access": "public",
    "description": "Compute the 'connectivity' of a cell; a number between 0 and 1. If the cell\nis completely connected, this returns 1. A cell split into many parts gets a \nconnectivity approaching zero. It also matters how the cell is split: splitting\nthe cell in two near-equal parts results in a lower connectivity than separating\none pixel from the rest of the cell.",
    "lineNumber": 214,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "components",
        "description": "an array of arrays (one array per connected component, \nin which each entry is the {@link ArrayCoordinate} of a pixel belonging to that component)."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "cellid",
        "description": "the cell these components belong to."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "connectivity of this cell."
    }
  },
  {
    "__docId__": 579,
    "kind": "method",
    "name": "checkConnected",
    "memberof": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint#checkConnected",
    "access": "public",
    "description": "This method checks the difference in connectivity when pixel tgt_i is changed from\ntgt_type to src_type. ",
    "lineNumber": 238,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_i",
        "description": "the pixel to change"
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "src_type",
        "description": "the new cell for this pixel."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_type",
        "description": "the cell the pixel belonged to previously."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "conndiff - the difference: connectivity_after - connectivity_before."
    }
  },
  {
    "__docId__": 580,
    "kind": "method",
    "name": "deltaH",
    "memberof": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/SoftConnectivityConstraint.js~SoftConnectivityConstraint#deltaH",
    "access": "public",
    "description": "Method for hard constraints to compute whether the copy attempt fulfills the rule.",
    "lineNumber": 302,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "src_i",
        "description": "coordinate of the source pixel that tries to copy."
      },
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_i",
        "description": "coordinate of the target pixel the source is trying\nto copy into."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "src_type",
        "description": "cellid of the source pixel."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_type",
        "description": "cellid of the target pixel."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "whether the copy attempt satisfies the constraint."
    }
  },
  {
    "__docId__": 581,
    "kind": "file",
    "name": "src/hamiltonian/SoftConstraint.js",
    "content": "\nimport Constraint from \"./Constraint.js\"\n\n/** Extension of class {@link Constraint} used for a soft constraint. See description in\n {@link Constraint} for details. This class is not used on its own but serves as a base\n class for a soft constraint. */\nclass SoftConstraint extends Constraint {\n\n\t/** Let the CPM know that this is a soft constraint, so return 'soft'. \n\t@return {string} \"soft\"*/\n\tget CONSTRAINT_TYPE() {\n\t\treturn \"soft\"\n\t}\n\t\n\t/** Soft constraints must have a deltaH method to compute the Hamiltonian. This method\n\tmust be implemented in any SoftConstraint subclass before it works.\n\t@abstract\n\t @param {IndexCoordinate} src_i - coordinate of the source pixel that tries to copy.\n\t @param {IndexCoordinate} tgt_i - coordinate of the target pixel the source is trying\n\t to copy into.\n\t @param {CellId} src_type - cellid of the source pixel.\n\t @param {CellId} tgt_type - cellid of the target pixel. \n\t @return {number} the change in Hamiltonian for this copy attempt and this constraint.*/ \n\t// eslint-disable-next-line no-unused-vars\n\tdeltaH( src_i, tgt_i, src_type, tgt_type ){\n\t\tthrow(\"You need to implement the 'deltaH' method for this constraint!\")\n\t}\n}\n\nexport default SoftConstraint\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/hamiltonian/SoftConstraint.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 582,
    "kind": "class",
    "name": "SoftConstraint",
    "memberof": "src/hamiltonian/SoftConstraint.js",
    "static": true,
    "longname": "src/hamiltonian/SoftConstraint.js~SoftConstraint",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/hamiltonian/SoftConstraint.js",
    "importStyle": "SoftConstraint",
    "description": "Extension of class {@link Constraint} used for a soft constraint. See description in\n{@link Constraint} for details. This class is not used on its own but serves as a base\nclass for a soft constraint.",
    "lineNumber": 7,
    "interface": false,
    "extends": [
      "src/hamiltonian/Constraint.js~Constraint"
    ]
  },
  {
    "__docId__": 583,
    "kind": "get",
    "name": "CONSTRAINT_TYPE",
    "memberof": "src/hamiltonian/SoftConstraint.js~SoftConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/SoftConstraint.js~SoftConstraint#CONSTRAINT_TYPE",
    "access": "public",
    "description": "Let the CPM know that this is a soft constraint, so return 'soft'. ",
    "lineNumber": 11,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "\"soft\""
    },
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 584,
    "kind": "method",
    "name": "deltaH",
    "memberof": "src/hamiltonian/SoftConstraint.js~SoftConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/SoftConstraint.js~SoftConstraint#deltaH",
    "access": "public",
    "description": "Soft constraints must have a deltaH method to compute the Hamiltonian. This method\nmust be implemented in any SoftConstraint subclass before it works.",
    "lineNumber": 25,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "src_i",
        "description": "coordinate of the source pixel that tries to copy."
      },
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_i",
        "description": "coordinate of the target pixel the source is trying\nto copy into."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "src_type",
        "description": "cellid of the source pixel."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_type",
        "description": "cellid of the target pixel."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the change in Hamiltonian for this copy attempt and this constraint."
    },
    "abstract": true
  },
  {
    "__docId__": 585,
    "kind": "file",
    "name": "src/hamiltonian/SoftLocalConnectivityConstraint.js",
    "content": "\nimport SoftConstraint from \"./SoftConstraint.js\"\nimport ParameterChecker from \"./ParameterChecker.js\"\n\n/** Soft version of the {@link ConnectivityConstraint} which only checks local connectivity.\n@experimental\n*/\nclass SoftLocalConnectivityConstraint extends SoftConstraint {\n\n\t/** The constructor of the SoftLocalConnectivityConstraint requires a conf object with one or two parameters.\n\t@param {object} conf - parameter object for this constraint.\n\t@param {PerKindBoolean} conf.LAMBDA_CONNECTIVITY - strength of the penalty for breaking connectivity.\n\t#param {string} conf.NBH_TYPE - should a Neumann (default) or Moore neighborhood be used to determine\n\twhether the cell locally stays connected? The default is Neumann since the Moore neighborhood tends to\n\tgive artefacts. Also, LAMBDA should be much higher if the Moore neighborhood is used. \n\t*/\n\tconstructor( conf ){\n\t\tsuper(conf)\n\t\t\n\t\t/** Should a Neumann or Moore neighborhood be used for determining connectivity?\n\t\tSee {@link SoftLocalConnectivityConstraint#constructor} for details.\n\t\t@type {string}*/\n\t\tthis.nbhtype = \"Neumann\"\n\t}\n\t\n\t/** The set CPM method attaches the CPM to the constraint. It checks whether the\n\tCPM is 2D or 3D, because this constraint is currently only tested in 2D. */\n\tset CPM(C){\n\t\tsuper.CPM = C\n\t\t\n\t\tif( this.C.ndim != 2 ){\n\t\t\tthrow(\"You are trying to add a SoftLocalConnectivityConstraint to a 3D CPM, but this constraint is currently only supported in 2D!\")\n\t\t}\n\t}\n\t\n\t/** This method checks that all required parameters are present in the object supplied to\n\tthe constructor, and that they are of the right format. It throws an error when this\n\tis not the case.*/\n\tconfChecker(){\n\t\tlet checker = new ParameterChecker( this.conf, this.C )\n\t\tchecker.confCheckParameter( \"LAMBDA_CONNECTIVITY\", \"KindArray\", \"NonNegative\" )\n\n\t\t//\n\t\tif( \"NBH_TYPE\" in this.conf ){\n\t\t\tlet v = this.conf[\"NBH_TYPE\"]\n\t\t\tlet values = [ \"Neumann\", \"Moore\" ]\n\t\t\tlet found = false\n\t\t\tfor( let val of values ){\n\t\t\t\tif( val == v ){\n\t\t\t\t\tfound = true\n\t\t\t\t\tthis.nbhtype = val\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( !found ){\n\t\t\t\tthrow( \"In the SoftLocalConnectivityConstraint, NBH_TYPE must be either 'Neumann' or 'Moore'\")\n\t\t\t}\n\t\t}\n\n\t}\n\t\n\t/** Get the connected components of a set of pixels.\n\t@param {object} pixelobject - an object with as keys the {@link IndexCoordinate}s of the pixels to check.\n\t@return {object} an array with an element for every connected component, which is in\n\tturn an array of the {@link ArrayCoordinate}s of the pixels belonging to that component.  */\n\tconnectedComponentsOf( pixelobject ){\n\t\n\t\tlet cbpi = Object.keys( pixelobject )\n\t\t\n\t\tlet visited = {}, k=0, pixels = [], C = this.C, nbhtype = this.nbhtype\n\t\tlet labelComponent = function(seed, k){\n\t\t\tlet q = [seed]\n\t\t\tlet cellid = C.pixti(q)\n\t\t\tvisited[q[0]] = 1\n\t\t\tpixels[k] = []\n\t\t\twhile( q.length > 0 ){\n\t\t\t\tlet e = q.pop()\n\t\t\t\tpixels[k].push(C.grid.i2p(e) )\n\t\t\t\t\n\t\t\t\tif( nbhtype == \"Neumann\" ){\n\t\t\t\t\tfor( let i of C.grid.neighNeumanni( e ) ){\n\t\t\t\t\t\tif( C.pixti( i ) == cellid &&\n\t\t\t\t\t\t\t!(i in visited) && (i in pixelobject) ){\n\t\t\t\t\t\t\tq.push(i)\n\t\t\t\t\t\t\tvisited[i]=1\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet ne = C.grid.neighi(e)\n\t\t\t\t\tfor( let j = 0; j < ne.length; j++ ){\n\t\t\t\t\t\n\t\t\t\t\t\tlet i = ne[j]\n\t\t\t\t\t\tif( C.pixti( i ) == cellid &&\n\t\t\t\t\t\t\t!(i in visited) && (i in pixelobject) ){\n\t\t\t\t\t\t\tq.push(i)\n\t\t\t\t\t\t\tvisited[i]=1\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t//let ne = C.grid.neighi( e )\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor( let i = 0 ; i < cbpi.length ; i ++ ){\n\t\t\tlet pi = parseInt( cbpi[i] )\n\t\t\tif( !(pi in visited) ){\n\t\t\t\tlabelComponent( pi, k )\n\t\t\t\tk++\n\t\t\t}\n\t\t}\n\t\treturn pixels\n\t}\n\n\t/** This method checks if the connectivity still holds after pixel tgt_i is changed from\n\ttgt_type to src_type. \n\t@param {IndexCoordinate} tgt_i - the pixel to change\n\t@param {CellId} src_type - the new cell for this pixel.\n\t@param {CellId} tgt_type - the cell the pixel belonged to previously. \t\n\t@return {number} 1 if connectivity is broken, 0 if the connectivity remains. \n\t*/\n\tcheckConnected( tgt_i, src_type, tgt_type ){\n\t\n\t\t// Get neighbors of the target pixel\n\t\tlet nbh = this.C.grid.neighi( tgt_i )\n\t\t\n\t\t// object storing the neighbors of tgt_type\n\t\tlet nbhobj = {}\n\t\t\n\t\tfor( let n of nbh ){\n\t\t\n\t\t\t// add it and its neighbors to the neighborhood object\n\t\t\tif( this.C.pixti(n) == tgt_type ){\n\t\t\t\tnbhobj[n] = true\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Get connected components.\n\t\tlet conn = this.connectedComponentsOf( nbhobj )\n\t\t//console.log(conn.length)\n\t\t\n\t\tlet disconnected = 0\n\t\tif( conn.length > 1 ){\n\t\t\tdisconnected = 1\n\t\t}\n\t\treturn disconnected\n\t\t\n\t}\n\t\n\t/** Method for hard constraints to compute whether the copy attempt fulfills the rule.\n\t @param {IndexCoordinate} src_i - coordinate of the source pixel that tries to copy.\n\t @param {IndexCoordinate} tgt_i - coordinate of the target pixel the source is trying\n\t to copy into.\n\t @param {CellId} src_type - cellid of the source pixel.\n\t @param {CellId} tgt_type - cellid of the target pixel. \n\t @return {boolean} whether the copy attempt satisfies the constraint.*/ \n\tdeltaH( src_i, tgt_i, src_type, tgt_type ){\n\t\t// connectedness of src cell cannot change if it was connected in the first place.\n\t\t\n\t\tlet lambda = this.cellParameter(\"LAMBDA_CONNECTIVITY\", tgt_type)\n\t\t\n\t\t// connectedness of tgt cell. Only check when the lambda is non-zero.\n\t\tif( tgt_type != 0 && lambda > 0 ){\n\t\t\treturn lambda*this.checkConnected( tgt_i, src_type, tgt_type )\n\t\t}\n\t\t\n\t\treturn 0\n\t}\n\n\t\n\n}\n\nexport default SoftLocalConnectivityConstraint\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/hamiltonian/SoftLocalConnectivityConstraint.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 586,
    "kind": "class",
    "name": "SoftLocalConnectivityConstraint",
    "memberof": "src/hamiltonian/SoftLocalConnectivityConstraint.js",
    "static": true,
    "longname": "src/hamiltonian/SoftLocalConnectivityConstraint.js~SoftLocalConnectivityConstraint",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/hamiltonian/SoftLocalConnectivityConstraint.js",
    "importStyle": "SoftLocalConnectivityConstraint",
    "description": "Soft version of the {@link ConnectivityConstraint} which only checks local connectivity.",
    "lineNumber": 8,
    "experimental": true,
    "interface": false,
    "extends": [
      "src/hamiltonian/SoftConstraint.js~SoftConstraint"
    ]
  },
  {
    "__docId__": 587,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/hamiltonian/SoftLocalConnectivityConstraint.js~SoftLocalConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/SoftLocalConnectivityConstraint.js~SoftLocalConnectivityConstraint#constructor",
    "access": "public",
    "description": "The constructor of the SoftLocalConnectivityConstraint requires a conf object with one or two parameters.",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "conf",
        "description": "parameter object for this constraint."
      },
      {
        "nullable": null,
        "types": [
          "PerKindBoolean"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.LAMBDA_CONNECTIVITY",
        "description": "strength of the penalty for breaking connectivity.\n#param {string} conf.NBH_TYPE - should a Neumann (default) or Moore neighborhood be used to determine\nwhether the cell locally stays connected? The default is Neumann since the Moore neighborhood tends to\ngive artefacts. Also, LAMBDA should be much higher if the Moore neighborhood is used."
      }
    ]
  },
  {
    "__docId__": 588,
    "kind": "member",
    "name": "nbhtype",
    "memberof": "src/hamiltonian/SoftLocalConnectivityConstraint.js~SoftLocalConnectivityConstraint",
    "static": false,
    "longname": "src/hamiltonian/SoftLocalConnectivityConstraint.js~SoftLocalConnectivityConstraint#nbhtype",
    "access": "public",
    "description": "Should a Neumann or Moore neighborhood be used for determining connectivity?\nSee {@link SoftLocalConnectivityConstraint#constructor} for details.",
    "lineNumber": 23,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 589,
    "kind": "set",
    "name": "CPM",
    "memberof": "src/hamiltonian/SoftLocalConnectivityConstraint.js~SoftLocalConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/SoftLocalConnectivityConstraint.js~SoftLocalConnectivityConstraint#CPM",
    "access": "public",
    "description": "The set CPM method attaches the CPM to the constraint. It checks whether the\nCPM is 2D or 3D, because this constraint is currently only tested in 2D.",
    "lineNumber": 28
  },
  {
    "__docId__": 590,
    "kind": "method",
    "name": "confChecker",
    "memberof": "src/hamiltonian/SoftLocalConnectivityConstraint.js~SoftLocalConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/SoftLocalConnectivityConstraint.js~SoftLocalConnectivityConstraint#confChecker",
    "access": "public",
    "description": "This method checks that all required parameters are present in the object supplied to\nthe constructor, and that they are of the right format. It throws an error when this\nis not the case.",
    "lineNumber": 39,
    "params": [],
    "return": null
  },
  {
    "__docId__": 592,
    "kind": "method",
    "name": "connectedComponentsOf",
    "memberof": "src/hamiltonian/SoftLocalConnectivityConstraint.js~SoftLocalConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/SoftLocalConnectivityConstraint.js~SoftLocalConnectivityConstraint#connectedComponentsOf",
    "access": "public",
    "description": "Get the connected components of a set of pixels.",
    "lineNumber": 65,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "pixelobject",
        "description": "an object with as keys the {@link IndexCoordinate}s of the pixels to check."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "an array with an element for every connected component, which is in\nturn an array of the {@link ArrayCoordinate}s of the pixels belonging to that component."
    }
  },
  {
    "__docId__": 593,
    "kind": "method",
    "name": "checkConnected",
    "memberof": "src/hamiltonian/SoftLocalConnectivityConstraint.js~SoftLocalConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/SoftLocalConnectivityConstraint.js~SoftLocalConnectivityConstraint#checkConnected",
    "access": "public",
    "description": "This method checks if the connectivity still holds after pixel tgt_i is changed from\ntgt_type to src_type. ",
    "lineNumber": 124,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_i",
        "description": "the pixel to change"
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "src_type",
        "description": "the new cell for this pixel."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_type",
        "description": "the cell the pixel belonged to previously."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "1 if connectivity is broken, 0 if the connectivity remains."
    }
  },
  {
    "__docId__": 594,
    "kind": "method",
    "name": "deltaH",
    "memberof": "src/hamiltonian/SoftLocalConnectivityConstraint.js~SoftLocalConnectivityConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/SoftLocalConnectivityConstraint.js~SoftLocalConnectivityConstraint#deltaH",
    "access": "public",
    "description": "Method for hard constraints to compute whether the copy attempt fulfills the rule.",
    "lineNumber": 159,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "src_i",
        "description": "coordinate of the source pixel that tries to copy."
      },
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_i",
        "description": "coordinate of the target pixel the source is trying\nto copy into."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "src_type",
        "description": "cellid of the source pixel."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_type",
        "description": "cellid of the target pixel."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "whether the copy attempt satisfies the constraint."
    }
  },
  {
    "__docId__": 595,
    "kind": "file",
    "name": "src/hamiltonian/VolumeConstraint.js",
    "content": "import SoftConstraint from \"./SoftConstraint.js\"\nimport ParameterChecker from \"./ParameterChecker.js\"\n\n\n/** \n * Implements the volume constraint of Potts models. \n * \n * This constraint is typically used together with {@link Adhesion}.\n * \n * See {@link VolumeConstraint#constructor} for the required parameters.\n *\n * @example\n * // Build a CPM and add the constraint\n * let CPM = require( \"path/to/build\" )\n * let C = new CPM.CPM( [200,200], {\n * \tT : 20,\n * \tJ : [[0,20],[20,10]]\n * })\n * C.add( new CPM.VolumeConstraint( {\n * \tV : [0,500],\n * \tLAMBDA_V : [0,5] \t\n * } ) )\n * \n * // Or add automatically by entering the parameters in the CPM\n * let C2 = new CPM.CPM( [200,200], {\n * \tT : 20,\n * \tJ : [[0,20],[20,10]],\n * \tV : [0,500],\n * \tLAMBDA_V : [0,5]\n * })\n */\nclass VolumeConstraint extends SoftConstraint {\n\n\n\t/** The constructor of the VolumeConstraint requires a conf object with parameters.\n\t@param {object} conf - parameter object for this constraint\n\t@param {PerKindNonNegative} conf.LAMBDA_V - strength of the constraint per cellkind.\n\t@param {PerKindNonNegative} conf.V - Target volume per cellkind.\n\t*/\n\tconstructor( conf ){\n\t\tsuper( conf )\n\t}\n\t\n\t/** This method checks that all required parameters are present in the object supplied to\n\tthe constructor, and that they are of the right format. It throws an error when this\n\tis not the case.*/\n\tconfChecker(){\n\t\tlet checker = new ParameterChecker( this.conf, this.C )\n\t\tchecker.confCheckParameter( \"LAMBDA_V\", \"KindArray\", \"NonNegative\" )\n\t\tchecker.confCheckParameter( \"V\", \"KindArray\", \"NonNegative\" )\n\t}\n\n\t/** Method to compute the Hamiltonian for this constraint. \n\t @param {IndexCoordinate} sourcei - coordinate of the source pixel that tries to copy.\n\t @param {IndexCoordinate} targeti - coordinate of the target pixel the source is trying\n\t to copy into.\n\t @param {CellId} src_type - cellid of the source pixel.\n\t @param {CellId} tgt_type - cellid of the target pixel. \n\t @return {number} the change in Hamiltonian for this copy attempt and this constraint.*/ \n\tdeltaH( sourcei, targeti, src_type, tgt_type ){\n\t\t// volume gain of src cell\n\t\tlet deltaH = this.volconstraint( 1, src_type ) - \n\t\t\tthis.volconstraint( 0, src_type )\n\t\t// volume loss of tgt cell\n\t\tdeltaH += this.volconstraint( -1, tgt_type ) - \n\t\t\tthis.volconstraint( 0, tgt_type )\n\t\treturn deltaH\n\t}\n\t/* ======= VOLUME ======= */\n\n\t/** The volume constraint term of the Hamiltonian for the cell with id t.\n\t@param {number} vgain - Use vgain=0 for energy of current volume, vgain=1 \n\t\tfor energy if cell gains a pixel, and vgain = -1 for energy if cell loses a pixel.\n\t@param {CellId} t - the cellid of the cell whose volume energy we are computing.\n\t@return {number} the volume energy of this cell.\n\t*/\n\tvolconstraint ( vgain, t ){\n\t\tconst l = this.cellParameter(\"LAMBDA_V\", t)\n\t\t// the background \"cell\" has no volume constraint.\n\t\tif( t == 0 || l == 0 ) return 0\n\t\tconst vdiff = this.cellParameter(\"V\", t) - (this.C.getVolume(t) + vgain)\n\t\treturn l*vdiff*vdiff\n\t}\n}\n\nexport default VolumeConstraint\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/hamiltonian/VolumeConstraint.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 596,
    "kind": "class",
    "name": "VolumeConstraint",
    "memberof": "src/hamiltonian/VolumeConstraint.js",
    "static": true,
    "longname": "src/hamiltonian/VolumeConstraint.js~VolumeConstraint",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/hamiltonian/VolumeConstraint.js",
    "importStyle": "VolumeConstraint",
    "description": "Implements the volume constraint of Potts models. \n\nThis constraint is typically used together with {@link Adhesion}.\n\nSee {@link VolumeConstraint#constructor} for the required parameters.",
    "examples": [
      "// Build a CPM and add the constraint\nlet CPM = require( \"path/to/build\" )\nlet C = new CPM.CPM( [200,200], {\n\tT : 20,\n\tJ : [[0,20],[20,10]]\n})\nC.add( new CPM.VolumeConstraint( {\n\tV : [0,500],\n\tLAMBDA_V : [0,5] \t\n} ) )\n\n// Or add automatically by entering the parameters in the CPM\nlet C2 = new CPM.CPM( [200,200], {\n\tT : 20,\n\tJ : [[0,20],[20,10]],\n\tV : [0,500],\n\tLAMBDA_V : [0,5]\n})"
    ],
    "lineNumber": 32,
    "interface": false,
    "extends": [
      "src/hamiltonian/SoftConstraint.js~SoftConstraint"
    ]
  },
  {
    "__docId__": 597,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/hamiltonian/VolumeConstraint.js~VolumeConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/VolumeConstraint.js~VolumeConstraint#constructor",
    "access": "public",
    "description": "The constructor of the VolumeConstraint requires a conf object with parameters.",
    "lineNumber": 40,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "conf",
        "description": "parameter object for this constraint"
      },
      {
        "nullable": null,
        "types": [
          "PerKindNonNegative"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.LAMBDA_V",
        "description": "strength of the constraint per cellkind."
      },
      {
        "nullable": null,
        "types": [
          "PerKindNonNegative"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.V",
        "description": "Target volume per cellkind."
      }
    ]
  },
  {
    "__docId__": 598,
    "kind": "method",
    "name": "confChecker",
    "memberof": "src/hamiltonian/VolumeConstraint.js~VolumeConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/VolumeConstraint.js~VolumeConstraint#confChecker",
    "access": "public",
    "description": "This method checks that all required parameters are present in the object supplied to\nthe constructor, and that they are of the right format. It throws an error when this\nis not the case.",
    "lineNumber": 47,
    "params": [],
    "return": null
  },
  {
    "__docId__": 599,
    "kind": "method",
    "name": "deltaH",
    "memberof": "src/hamiltonian/VolumeConstraint.js~VolumeConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/VolumeConstraint.js~VolumeConstraint#deltaH",
    "access": "public",
    "description": "Method to compute the Hamiltonian for this constraint. ",
    "lineNumber": 60,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "sourcei",
        "description": "coordinate of the source pixel that tries to copy."
      },
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "targeti",
        "description": "coordinate of the target pixel the source is trying\nto copy into."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "src_type",
        "description": "cellid of the source pixel."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_type",
        "description": "cellid of the target pixel."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the change in Hamiltonian for this copy attempt and this constraint."
    }
  },
  {
    "__docId__": 600,
    "kind": "method",
    "name": "volconstraint",
    "memberof": "src/hamiltonian/VolumeConstraint.js~VolumeConstraint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hamiltonian/VolumeConstraint.js~VolumeConstraint#volconstraint",
    "access": "public",
    "description": "The volume constraint term of the Hamiltonian for the cell with id t.",
    "lineNumber": 77,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "vgain",
        "description": "Use vgain=0 for energy of current volume, vgain=1 \nfor energy if cell gains a pixel, and vgain = -1 for energy if cell loses a pixel."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "t",
        "description": "the cellid of the cell whose volume energy we are computing."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the volume energy of this cell."
    }
  },
  {
    "__docId__": 601,
    "kind": "file",
    "name": "src/hamiltonian/constraint-typedef.js",
    "content": "/** An array containing parameter values for each {@link CellKind}.\n * Each element in the array is a non-negative number, and the value for\n * CellKind k is stored in array[k].\n * @example\n * // V[0] is for the background, V[1] for the first real cellkind.\n * let V = [0,500]\n * @typedef {number[]} PerKindNonNegative\n * */\n\n/** An array containing parameter values for each {@link CellKind}.\n * Each element in the array is a number between 0 and 1, and the value for\n * CellKind k is stored in array[k].\n * @example\n * // PERSIST[0] is for the background\n * // PERSIST[1] for the first real cellkind.\n * let PERSIST = [0,0.8]\n * @typedef {number[]} PerKindProb\n * */\n\n/** An array containing parameter values for each {@link CellKind}.\n * Each element in the array is an array of some length, and the array for\n * CellKind k is stored in array[k].\n * @example\n * let LAMBDA_ACT_MBG = [[0,0],[0,0],[800,100]]\n * @typedef {number[]} PerKindArray */\n\n/** An array containing parameter values for each {@link CellKind}.\n * Each element in the array is a boolean, and the value for CellKind k is\n * stored in array[k].\n * @example\n * // IS_BARRIER[0] is for the background; cellkind 1 is the \"barrier\"\n * // and 2 is a real cell.\n * let IS_BARRIER = [false,true,false]\n * @typedef {boolean[]} PerKindBoolean */\n\n/** An array of arrays containing interaction parameter values for each\n * {@link CellKind} - combination. Each element in the array is a non-negative\n * number, and X[n][m] contains the value for an interaction between cellkinds\n * n and m.\n * @example\n * // J[0][0] between two background pixels is always zero.\n * // Not that it matters, because the background has a\n * // single cellid of zero -- so there are no pairs\n * // of background pixels from different cells anyway.\n * let J = [[0,20],[20,10]]\n * @typedef {number[]} CellKindInteractionMatrix */",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/hamiltonian/constraint-typedef.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 602,
    "kind": "typedef",
    "name": "PerKindNonNegative",
    "memberof": "src/hamiltonian/constraint-typedef.js",
    "static": true,
    "longname": "src/hamiltonian/constraint-typedef.js~PerKindNonNegative",
    "access": "public",
    "description": "An array containing parameter values for each {@link CellKind}.\nEach element in the array is a non-negative number, and the value for\nCellKind k is stored in array[k].",
    "examples": [
      "// V[0] is for the background, V[1] for the first real cellkind.\nlet V = [0,500]"
    ],
    "type": {
      "types": [
        "number[]"
      ],
      "optional": false,
      "name": "PerKindNonNegative"
    }
  },
  {
    "__docId__": 603,
    "kind": "typedef",
    "name": "PerKindProb",
    "memberof": "src/hamiltonian/constraint-typedef.js",
    "static": true,
    "longname": "src/hamiltonian/constraint-typedef.js~PerKindProb",
    "access": "public",
    "description": "An array containing parameter values for each {@link CellKind}.\nEach element in the array is a number between 0 and 1, and the value for\nCellKind k is stored in array[k].",
    "examples": [
      "// PERSIST[0] is for the background\n// PERSIST[1] for the first real cellkind.\nlet PERSIST = [0,0.8]"
    ],
    "type": {
      "types": [
        "number[]"
      ],
      "optional": false,
      "name": "PerKindProb"
    }
  },
  {
    "__docId__": 604,
    "kind": "typedef",
    "name": "PerKindArray",
    "memberof": "src/hamiltonian/constraint-typedef.js",
    "static": true,
    "longname": "src/hamiltonian/constraint-typedef.js~PerKindArray",
    "access": "public",
    "description": "An array containing parameter values for each {@link CellKind}.\nEach element in the array is an array of some length, and the array for\nCellKind k is stored in array[k].",
    "examples": [
      "let LAMBDA_ACT_MBG = [[0,0],[0,0],[800,100]]"
    ],
    "type": {
      "types": [
        "number[]"
      ],
      "optional": false,
      "name": "PerKindArray"
    }
  },
  {
    "__docId__": 605,
    "kind": "typedef",
    "name": "PerKindBoolean",
    "memberof": "src/hamiltonian/constraint-typedef.js",
    "static": true,
    "longname": "src/hamiltonian/constraint-typedef.js~PerKindBoolean",
    "access": "public",
    "description": "An array containing parameter values for each {@link CellKind}.\nEach element in the array is a boolean, and the value for CellKind k is\nstored in array[k].",
    "examples": [
      "// IS_BARRIER[0] is for the background; cellkind 1 is the \"barrier\"\n// and 2 is a real cell.\nlet IS_BARRIER = [false,true,false]"
    ],
    "type": {
      "types": [
        "boolean[]"
      ],
      "optional": false,
      "name": "PerKindBoolean"
    }
  },
  {
    "__docId__": 606,
    "kind": "typedef",
    "name": "CellKindInteractionMatrix",
    "memberof": "src/hamiltonian/constraint-typedef.js",
    "static": true,
    "longname": "src/hamiltonian/constraint-typedef.js~CellKindInteractionMatrix",
    "access": "public",
    "description": "An array of arrays containing interaction parameter values for each\n{@link CellKind} - combination. Each element in the array is a non-negative\nnumber, and X[n][m] contains the value for an interaction between cellkinds\nn and m.",
    "examples": [
      "// J[0][0] between two background pixels is always zero.\n// Not that it matters, because the background has a\n// single cellid of zero -- so there are no pairs\n// of background pixels from different cells anyway.\nlet J = [[0,20],[20,10]]"
    ],
    "type": {
      "types": [
        "number[]"
      ],
      "optional": false,
      "name": "CellKindInteractionMatrix"
    }
  },
  {
    "__docId__": 607,
    "kind": "file",
    "name": "src/models/CA.js",
    "content": "\"use strict\"\n\nimport GridBasedModel from \"./GridBasedModel.js\"\n\n\n/** Extension of the {@link GridBasedModel} class suitable for\na Cellular Automaton (CA). Currently only supports synchronous CAs.\n\n@example <caption>Conway's Game of Life </caption>\n*\tlet CPM = require( \"path/to/build\" )\n*\tlet C = new CPM.CA( [200,200], {\n*\t\t\"UPDATE_RULE\": \tfunction(p,N){\n*\t\t\tlet nalive = 0\n*\t\t\tfor( let pn of N ){\n*\t\t\t\tnalive += (this.pixt(pn)==1)\n*\t\t\t}\t\n*\t\t\tif( this.pixt(p) == 1 ){\n*\t\t\t\tif( nalive == 2 || nalive == 3 ){\n*\t\t\t\t\treturn 1\n*\t\t\t\t}\n*\t\t\t} else {\n*\t\t\t\tif( nalive == 3 ) return 1\n*\t\t\t}\n*\t\t\treturn 0\n*\t\t}\n*\t})\n*\tlet initialpixels = [ [100,100], [101,100], [102,100], [102,101], [101,102] ]\n*\tfor( p of initialpixels ){\n*\t\tC.setpix( p, 1 )\n* \t}\n*\t// Run it.\n*\tfor( let t = 0; t < 10; t++ ){ C.timeStep() }\n\n@todo Include asynchronous updating scheme?\n*/\nclass CA extends GridBasedModel {\n\n\t/** The constructor of class CA.\n\t@param {GridSize} extents - the size of the grid of the model.\n\t@param {object} conf - configuration options. \n\t@param {boolean} [conf.torus=[true,true,...]] - should the grid have linked borders?\n\t@param {number} [seed] - seed for the random number generator. If left unspecified,\n\ta random number from the Math.random() generator is used to make one.\n\t@param {updatePixelFunction} conf.UPDATE_RULE - the update rule of the CA. \n\t*/\n\tconstructor( extents, conf ){\n\t\tsuper( extents, conf )\n\t\t/** Bind the supplied updaterule to the object.\n\t\t@type {updatePixelFunction}*/\n\t\tthis.updateRule = conf[\"UPDATE_RULE\"].bind(this)\n\t}\n\n\t/** A timestep in a CA just applies the update rule and clears any cached stats after\n\tdoing so. */\n\ttimeStep(){\n\t\tthis.grid.applyLocally( this.updateRule )\n\t\t\n\t\t/** Cached values of these stats. Object with stat name as key and its cached\n\t\tvalue as value. The cache must be cleared when the grid changes!\n\t\t@type {object} */\n\t\tthis.stat_values = {}\n\t}\n}\n\nexport default CA\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/models/CA.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 608,
    "kind": "class",
    "name": "CA",
    "memberof": "src/models/CA.js",
    "static": true,
    "longname": "src/models/CA.js~CA",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/models/CA.js",
    "importStyle": "CA",
    "description": "Extension of the {@link GridBasedModel} class suitable for\na Cellular Automaton (CA). Currently only supports synchronous CAs.",
    "examples": [
      "<caption>Conway's Game of Life </caption>\nlet CPM = require( \"path/to/build\" )\nlet C = new CPM.CA( [200,200], {\n\t\"UPDATE_RULE\": \tfunction(p,N){\n\t\tlet nalive = 0\n\t\tfor( let pn of N ){\n\t\t\tnalive += (this.pixt(pn)==1)\n\t\t}\t\n\t\tif( this.pixt(p) == 1 ){\n\t\t\tif( nalive == 2 || nalive == 3 ){\n\t\t\t\treturn 1\n\t\t\t}\n\t\t} else {\n\t\t\tif( nalive == 3 ) return 1\n\t\t}\n\t\treturn 0\n\t}\n})\nlet initialpixels = [ [100,100], [101,100], [102,100], [102,101], [101,102] ]\nfor( p of initialpixels ){\n\tC.setpix( p, 1 )\n\t}\n// Run it.\nfor( let t = 0; t < 10; t++ ){ C.timeStep() }"
    ],
    "lineNumber": 36,
    "todo": [
      "Include asynchronous updating scheme?"
    ],
    "interface": false,
    "extends": [
      "src/models/GridBasedModel.js~GridBasedModel"
    ]
  },
  {
    "__docId__": 609,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/models/CA.js~CA",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/CA.js~CA#constructor",
    "access": "public",
    "description": "The constructor of class CA.",
    "lineNumber": 46,
    "params": [
      {
        "nullable": null,
        "types": [
          "GridSize"
        ],
        "spread": false,
        "optional": false,
        "name": "extents",
        "description": "the size of the grid of the model."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "conf",
        "description": "configuration options."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[true,true,...]",
        "defaultRaw": "[true,true,...]",
        "name": "conf.torus",
        "description": "should the grid have linked borders?"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "seed",
        "description": "seed for the random number generator. If left unspecified,\na random number from the Math.random() generator is used to make one."
      },
      {
        "nullable": null,
        "types": [
          "updatePixelFunction"
        ],
        "spread": false,
        "optional": false,
        "name": "conf.UPDATE_RULE",
        "description": "the update rule of the CA."
      }
    ]
  },
  {
    "__docId__": 610,
    "kind": "member",
    "name": "updateRule",
    "memberof": "src/models/CA.js~CA",
    "static": false,
    "longname": "src/models/CA.js~CA#updateRule",
    "access": "public",
    "description": "Bind the supplied updaterule to the object.",
    "lineNumber": 50,
    "type": {
      "nullable": null,
      "types": [
        "updatePixelFunction"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 611,
    "kind": "method",
    "name": "timeStep",
    "memberof": "src/models/CA.js~CA",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/CA.js~CA#timeStep",
    "access": "public",
    "description": "A timestep in a CA just applies the update rule and clears any cached stats after\ndoing so.",
    "lineNumber": 55,
    "params": [],
    "return": null
  },
  {
    "__docId__": 612,
    "kind": "member",
    "name": "stat_values",
    "memberof": "src/models/CA.js~CA",
    "static": false,
    "longname": "src/models/CA.js~CA#stat_values",
    "access": "public",
    "description": "Cached values of these stats. Object with stat name as key and its cached\nvalue as value. The cache must be cleared when the grid changes!",
    "lineNumber": 61,
    "type": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 613,
    "kind": "file",
    "name": "src/models/CPM.js",
    "content": "\"use strict\"\n\nimport GridBasedModel from \"./GridBasedModel.js\"\nimport DiceSet from \"../DiceSet.js\"\nimport AutoAdderConfig from \"../hamiltonian/AutoAdderConfig.js\"\n\n\n/** The core CPM class. Can be used for two- or three-dimensional simulations.\n*/\nclass CPM extends GridBasedModel {\n\n\t/** The constructor of class CA.\n\t * @param {GridSize} field_size - the size of the grid of the model.\n\t * @param {object} conf - configuration options; see below. In addition,\n\t * the conf object can have parameters to constraints added to the CPM.\n\t * See the different {@link Constraint} subclasses for options. For some\n\t * constraints, adding its parameter to the CPM conf object automatically\n\t * adds the constraint; see {@link AutoAdderConfig} to see for which\n\t * constraints this is supported.\n\t * @param {boolean[]} [conf.torus=[true,true,...]] - should the grid have\n\t * linked borders?\n\t * @param {number} [conf.T] - the temperature of this CPM. At higher\n\t * temperatures, unfavourable copy attempts are more likely to be accepted.\n\t * @param {number} [conf.seed] - seed for the random number generator. If\n\t * left unspecified, a random number from the Math.random() generator is\n\t * used to make one.\n\t * */\n\tconstructor( field_size, conf ){\n\t\tsuper( field_size, conf )\n\n\t\t/** To check from outside if an object is a CPM; doing this with\n\t\t * instanceof doesn't work in some cases. Any other object will\n\t\t * not have this variable and return 'undefined', which in an\n\t\t * if-statement equates to a 'false'.\n\t\t * @type{boolean}*/\n\t\tthis.isCPM = true\n\n\t\t/** Track time in MCS.\n\t\t * @type{number}*/\n\t\tthis.time = 0\n\n\t\t// ---------- CPM specific stuff here\n\t\t\n\t\t/** Number of non-background cells currently on the grid.\n\t\t@type{number}*/\n\t\tthis.nr_cells = 0\n\t\t/** Highest cell ID previously assigned. \n\t\t@type{number}*/\n\t\tthis.last_cell_id = 0\n\t\t/** track border pixels for speed \n\t\t@type {DiceSet}*/\n\t\tthis.borderpixels = new DiceSet( this.mt )\n\t\t/** Private property used by {@link updateborderneari} to track borders. \n\t\t@private\n\t\t@type {Uint16Array} */\n\t\tthis._neighbours = new Uint16Array(this.grid.p2i(field_size))\n\n\t\t//  ---------- Attributes per cell:\n\t\t/** Store the {@CellKind} of each cell on the grid. \n\t\t@example\n\t\tthis.t2k[1] // cellkind of cell with cellId 1\n\t\t@type {CellObject}\n\t\t*/\n\t\tthis.t2k = []\t// cell type (\"kind\"). Example: this.t2k[1] is the cellKind of cell 1.\n\t\tthis.t2k[0] = 0\t// Background cell; there is just one cell of this type.\n\n\t\t//  ---------- CPM constraints\n\t\t/** Array of objects of (@link SoftConstraint) subclasses attached to the CPM.\n\t\tThese are used to determine {@link deltaH}.\n\t\t@type {Array}*/\n\t\tthis.soft_constraints = []\n\t\t/** Object showing which constraints are where in {@link soft_constraints}. Used\n\t\tby the {@link getConstraint} method to find an attached constraint by name.\n\t\t@type {object}*/\n\t\tthis.soft_constraints_indices = {}\n\t\t/** Array of objects of (@link HardConstraint) subclasses attached to the CPM.\n\t\tThese are used to determine which copy attempts are allowed in a {@link timeStep}.\n\t\t@type {Array}*/\n\t\tthis.hard_constraints = []\n\t\t/** Object showing which constraints are where in {@link soft_constraints}. Used\n\t\tby the {@link getConstraint} method to find an attached constraint by name.\n\t\t@type {object}*/\n\t\tthis.hard_constraints_indices = {}\n\t\t/** Array of functions that need to be executed after every {@link setpixi} event.\n\t\tThese functions are often implemented in subclasses of {@link Constraint} that\n\t\tneed to track some specific property on the grid. \n\t\t@type {function[]}*/\n\t\tthis.post_setpix_listeners = []\n\t\t/** Array of functions that need to be executed after every {@link timeStep} event.\n\t\tThese functions are often implemented in subclasses of {@link Constraint} that\n\t\tneed to track some specific property on the grid. \n\t\t@type {function[]}*/\n\t\tthis.post_mcs_listeners = []\n\t\t\n\t\t/* Automatically add constraints by their parameters in conf. This only works\n\t\tfor some constraints specified in AutoAdderConfig. */\n\t\tfor( let x of Object.keys( conf ) ){\n\t\t\tif( x in AutoAdderConfig ){\n\t\t\t\tthis.add( new AutoAdderConfig[x]( conf ) )\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Completely reset; remove all cells and set time back to zero. Only the\n\t * constraints remain. */\n\treset(){\n\t\tfor( let p of this.cellPixels()){\n\t\t\tthis.setpix( p[0], 0 )\n\t\t}\n\t\tthis.last_cell_id = 0\n\t\tthis.t2k = []\n\t\tthis.t2k[0] = 0\n\t\tthis.time = 0\n\t\tthis.cellvolume = []\n\t\tthis.stat_values = {}\n\t}\n\n\t/* This is no different from the GridBasedModel function and can go. \n\tneigh(p, torus=this.conf.torus){\n\t\tlet g = this.grid\n\t\treturn g.neighi( g.p2i(p), torus ).map( function(i){ return g.i2p(i) } )\n\t}*/\n\n\t/** Iterator returning non-background pixels on the grid.\n\t@return {Pixel} for each pixel, return an array [p,v] where p are\n\t\tthe pixel's array coordinates on the grid, and v its value.*/\n\t* cellPixels() {\n\t\tfor( let p of this.grid.pixels() ){\n\t\t\tif( p[1] !== 0 ){\n\t\t\t\tyield p\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Iterator returning non-background border pixels on the grid.\n\tSee {@link cellBorderPixelIndices} for a version returning pixels\n\tby their {@link IndexCoordinate} instead of {@link ArrayCoordinate}.\n\t\n\t@return {Pixel} for each pixel, return an array [p,v] where p are\n\t\tthe pixel's array coordinates on the grid, and v its value.*/\n\t* cellBorderPixels() {\n\t\tfor( let i of this.borderpixels.elements ){\n\t\t\tconst t = this.grid.pixti(i)\n\t\t\tif( t !== 0 ){\n\t\t\t\tyield [this.grid.i2p(i),t]\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Iterator returning non-background border pixels on the grid.\n\tSee {@link cellBorderPixels} for a version returning pixels\n\tby their {@link ArrayCoordinate} instead of {@link IndexCoordinate}.\n\t\n\t@return {iPixel} for each pixel, return an array [p,v] where p are\n\t\tthe pixel's array coordinates on the grid, and v its value.*/\n\t* cellBorderPixelIndices() {\n\t\tfor( let i of this.borderpixels.elements ){\n\t\t\tconst t = this.grid.pixti(i)\n\t\t\tif( t !== 0 ){\n\t\t\t\tyield [i,t]\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Add a constraint to the CPM, ensuring that its {@link SoftConstraint#deltaH} or\n\t{@link HardConstraint#fulfilled} methods are called appropriately during a copy attempt.\n\tAny postSetpixListeners and postMCSListeners are also executed at the appropriate times.\n\t@param {Constraint} t - the constraint object to add.\n\t*/\n\tadd( t ){\n\t\tlet tName = t.constructor.name, i\n\t\tif( t.CONSTRAINT_TYPE ){\n\t\t\tswitch( t.CONSTRAINT_TYPE ){\n\t\t\t\n\t\t\tcase \"soft\": \n\t\t\t\t// Add constraint to the array of soft constraints\n\t\t\t\ti = this.soft_constraints.push( t )\n\t\t\t\t\n\t\t\t\t// Write this index to an array in the \n\t\t\t\t// this.soft_constraints_indices object, for lookup later. \n\t\t\t\tif( !this.soft_constraints_indices.hasOwnProperty(tName) ){\n\t\t\t\t\tthis.soft_constraints_indices[tName] = []\n\t\t\t\t}\n\t\t\t\tthis.soft_constraints_indices[tName].push( i-1 )\n\t\t\t\tbreak\n\t\t\t\t\n\t\t\tcase \"hard\": \n\t\t\t\t// Add constraint to the array of soft constraints\n\t\t\t\ti = this.hard_constraints.push( t )\n\t\t\t\t\n\t\t\t\t// Write this index to an array in the \n\t\t\t\t// this.hard_constraints_indices object, for lookup later.\n\t\t\t\tif( !this.hard_constraints_indices.hasOwnProperty(tName) ){\n\t\t\t\t\tthis.hard_constraints_indices[tName] = []\n\t\t\t\t}\n\t\t\t\tthis.hard_constraints_indices[tName].push( i-1 )\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif( typeof t[\"postSetpixListener\"] === \"function\" ){\n\t\t\tthis.post_setpix_listeners.push( t.postSetpixListener.bind(t) )\n\t\t}\n\t\tif( typeof t[\"postMCSListener\"] === \"function\" ){\n\t\t\tthis.post_mcs_listeners.push( t.postMCSListener.bind(t) )\n\t\t}\n\t\tt.CPM = this\n\t\tif( typeof t[\"postAdd\"] === \"function\" ){\n\t\t\tt.postAdd()\n\t\t}\n\t}\n\t\n\t/** Get a {@link Constraint} object linked to this CPM by the name of its class.\n\tBy default, the first constraint found of this class is returned. It is possible\n\tthat there are multiple constraints of the same type on the CPM; in that case,\n\tsupply its number (by order in which the constraints of this type were added) to \n\tget a specific one. \n\t\n\tThis function can be useful if you need to access information in the constraint object,\n\tsuch as the cell directions in a {@PersistenceConstraint}, from outside. You can use\n\tthis for stuff like drawing.\n\t\n\t@param {string} constraintname - name of the constraint class you are looking for.\n\t@param {number} [num = 0] - if multiple constraints of this class are present, \n\treturn the num-th one added to the CPM. \n\t*/\n\tgetConstraint( constraintname, num ){\n\t\n\t\tif( !num ){\n\t\t\tnum = 0\n\t\t}\n\t\tlet i\n\t\t\n\t\tif( this.hard_constraints_indices.hasOwnProperty( constraintname ) ){\n\t\t\ti = this.hard_constraints_indices[constraintname][num]\n\t\t\treturn this.hard_constraints[i]\n\t\t} else if ( this.soft_constraints_indices.hasOwnProperty( constraintname ) ){\n\t\t\ti = this.soft_constraints_indices[constraintname][num]\n\t\t\treturn this.soft_constraints[i]\n\t\t} else {\n\t\t\tthrow(\"No constraint of name \" + \" exists in this CPM!\")\n\t\t}\t\n\t\n\t}\n\n\tgetAllConstraints(){\n\t\tconst soft = Object.keys( this.soft_constraints_indices )\n\t\tconst hard = Object.keys( this.hard_constraints_indices )\n\t\tlet names = {}\n\t\tfor( let n of soft ){ names[n] = soft[n] }\n\t\tfor( let n of hard ){ names[n] = hard[n] }\n\t\treturn names\n\t}\n\n\t/** Get {@link CellId} of the pixel at coordinates p. \n\t@param {ArrayCoordinate} p - pixel to get cellid of.\n\t@return {CellId} ID of the cell p belongs to.*/\n\tpixt( p ){\n\t\treturn this.grid.pixti( this.grid.p2i(p) )\n\t}\n\n\t/** Get volume of the cell with {@link CellId} t \n\t@param {CellId} t - id of the cell to get volume of.\n\t@return {number} the cell's current volume. */ \n\tgetVolume( t ){\n\t\treturn this.cellvolume[t]\n\t}\n\n\t/** Get the {@link CellKind} of the cell with {@link CellId} t. \n\tOverwrites {@link GridBasedModel#cellKind} because in a CPM, the two are not the same.\n\t@param {CellId} t - id of the cell to get kind of.\n\t@return {CellKind} the cellkind. */\n\tcellKind( t ){\n\t\treturn this.t2k[ t ]\n\t}\n\n\t/** Assign the cell with {@link CellId} t to {@link CellKind} k.\n\t@param {CellId} t - id of the cell to assing\n\t@param {CellKind} k - cellkind to give it. \n\t*/\n\tsetCellKind( t, k ){\n\t\tthis.t2k[ t ] = k\n\t}\n\t\n\t\n\t/* ------------- COMPUTING THE HAMILTONIAN --------------- */\n\n\t/** returns total change in hamiltonian for all registered soft constraints together.\n\t @param {IndexCoordinate} sourcei - coordinate of the source pixel that tries to copy.\n\t @param {IndexCoordinate} targeti - coordinate of the target pixel the source is trying\n\t to copy into.\n\t @param {CellId} src_type - cellid of the source pixel.\n\t @param {CellId} tgt_type - cellid of the target pixel. \n\t @return {number} the change in Hamiltonian for this copy attempt.\n\t*/\n\tdeltaH ( sourcei, targeti, src_type, tgt_type ){\n\t\tlet r = 0.0\n\t\tfor( let t of this.soft_constraints ){\n\t\t\tr += t.deltaH( sourcei, targeti, src_type, tgt_type )\n\t\t}\n\t\treturn r\n\t}\n\t/* ------------- COPY ATTEMPTS --------------- */\n\n\t/** Simulate one Monte Carlo Step. We now just use {@link timeStep} for consistency\n\twith other {@link GridBasedModel}s, but we have kept this method for compatibility\n\twith earlier version. Internally, it just calls {@link timeStep}.\n\t*/\n\tmonteCarloStep () {\n\t\tthis.timeStep()\n\t}\n\t\n\t/** A time step in the CPM is a Monte Carlo step. This performs a \n\t  \t number of copy attempts depending on grid size:\n\t  \t \n\t\t1) Randomly sample one of the border pixels for the copy attempt.\n\t\t2) Compute the change in Hamiltonian for the suggested copy attempt.\n\t\t3) With a probability depending on this change, decline or accept the \n\t\t   copy attempt and update the grid accordingly. \n\n\t\t@todo TODO it is quite confusing that the \"borderpixels\" array also\n\t\tcontains border pixels of the background.\n\t*/\n\ttimeStep (){\n\t\tlet delta_t = 0.0\n\t\t// this loop tracks the number of copy attempts until one MCS is completed.\n\t\twhile( delta_t < 1.0 ){\n\t\t\t// This is the expected time (in MCS) you would expect it to take to\n\t\t\t// randomly draw another border pixel.\n\t\t\tdelta_t += 1./(this.borderpixels.length)\n\n\t\t\t// sample a random pixel that borders at least 1 cell of another type,\n\t\t\t// and pick a random neighbour of tha pixel\n\t\t\tconst tgt_i = this.borderpixels.sample()\n\t\t\tconst Ni = this.grid.neighi( tgt_i )\n\t\t\tconst src_i = Ni[this.ran(0,Ni.length-1)]\n\t\t\n\t\t\tconst src_type = this.grid.pixti( src_i )\n\t\t\tconst tgt_type = this.grid.pixti( tgt_i )\n\n\t\t\t// only compute the Hamiltonian if source and target belong to a different cell,\n\t\t\t// and do not allow a copy attempt into the stroma. Only continue if the copy attempt\n\t\t\t// would result in a viable cell.\n\t\t\tif( tgt_type != src_type ){\n\t\t\t\tlet ok = true\n\t\t\t\tfor( let h of this.hard_constraints ){\n\t\t\t\t\tif( !h.fulfilled( src_i, tgt_i, src_type, tgt_type ) ){\n\t\t\t\t\t\tok = false; break\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( ok ){\n\t\t\t\t\tconst hamiltonian = this.deltaH( src_i, tgt_i, src_type, tgt_type )\n\t\t\t\t\t// probabilistic success of copy attempt \n\t\t\t\t\tif( this.docopy( hamiltonian ) ){\n\t\t\t\t\t\tthis.setpixi( tgt_i, src_type )\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t\tthis.time++ // update time with one MCS.\n\t\t/** Cached values of these stats. Object with stat name as key and its cached\n\t\tvalue as value. The cache must be cleared when the grid changes!\n\t\t@type {object} */\n\t\tthis.stat_values = {} // invalidate stat value cache\n\t\tfor( let l of this.post_mcs_listeners ){\n\t\t\tl()\n\t\t}\n\t}\t\n\n\t/** Determine whether copy attempt will succeed depending on deltaH (stochastic). \n\t@param {number} deltaH - energy change associated with the potential copy.\n\t@return {boolean} whether the copy attempt succeeds.\n\t*/\n\tdocopy ( deltaH ){\n\t\tif( deltaH < 0 ) return true\n\t\treturn this.random() < Math.exp( -deltaH / this.conf.T )\n\t}\n\t\n\t/** Change the pixel at position i into {@link CellId} t. \n\tThis method overrides {@link GridBasedModel#setpixi} because we want to\n\tadd postSetpixListeners for all the constraints, to keep track of relevant information.\n\t\n\tSee also {@link setpix} for a method working with {@link ArrayCoordinate}s.\n\t\n\t@param {IndexCoordinate} i - coordinate of pixel to change.\n\t@param {CellId} t - cellid to change this pixel into.\n\t*/\n\tsetpixi ( i, t ){\t\t\n\t\tconst t_old = this.grid.pixti(i)\n\t\tif( t_old == t ){\n\t\t\treturn\n\t\t}\n\t\tif( t_old > 0 ){\n\t\t\t// also update volume of the old cell\n\t\t\t// (unless it is background/stroma)\n\t\t\tthis.cellvolume[t_old] --\n\t\t\t\n\t\t\t// if this was the last pixel belonging to this cell, \n\t\t\t// remove the cell altogether.\n\t\t\tif( this.cellvolume[t_old] == 0 ){\n\t\t\t\tdelete this.cellvolume[t_old]\n\t\t\t\tdelete this.t2k[t_old]\n\t\t\t\tthis.nr_cells--\n\t\t\t}\n\t\t}\n\t\t// update volume of the new cell and cellid of the pixel.\n\t\tthis.grid.setpixi(i,t)\n\t\tif( t > 0 ){\n\t\t\tthis.cellvolume[t] ++\n\t\t}\n\t\tthis.updateborderneari( i, t_old, t )\n\t\t//this.stat_values = {} // invalidate stat value cache\n\t\tfor( let l of this.post_setpix_listeners ){\n\t\t\tl( i, t_old, t )\n\t\t}\n\t}\n\n\tget perimeterNeighbours(){\n\t\treturn this._neighbours\n\t}\n\n\t/** Update border elements ({@link borderpixels}) after a successful copy attempt. \n\t@listens {setpixi} because borders change when a copy succeeds.\n\t@param {IndexCoordinate} i - coordinate of pixel that has changed.\n\t@param {CellId} t_old - id of the cell the pixel belonged to before the copy.\n\t@param {CellId} t_new - id of the cell the pixel has changed into.\n\t*/\n\tupdateborderneari ( i, t_old, t_new ){\n\t\tif( t_old == t_new ) return\n\t\tconst Ni = this.grid.neighi( i )\n\t\tconst wasborder = this._neighbours[i] > 0 \n\t\tthis._neighbours[i] = 0\n\t\tfor( let ni of Ni  ){\n\t\t\tconst nt = this.grid.pixti(ni)\n\t\t\tif( nt != t_new ){\n\t\t\t\tthis._neighbours[i] ++ \n\t\t\t}\n\t\t\tif( nt == t_old ){\n\t\t\t\tif( this._neighbours[ni] ++ == 0 ){\n\t\t\t\t\tthis.borderpixels.insert( ni )\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( nt == t_new ){\n\t\t\t\tif( --this._neighbours[ni] == 0 ){\n\t\t\t\t\tthis.borderpixels.remove( ni )\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif( !wasborder && this._neighbours[i] > 0 ){\n\t\t\tthis.borderpixels.insert( i )\n\t\t}\n\t\tif( wasborder &&  this._neighbours[i] == 0 ){\n\t\t\tthis.borderpixels.remove( i )\n\t\t}\n\t}\n\n\t/* ------------- MANIPULATING CELLS ON THE GRID --------------- */\n\n\t/** Initiate a new {@link CellId} for a cell of {@link CellKind} \"kind\", and create elements\n\t   for this cell in the relevant arrays (cellvolume, t2k).\n\t   @param {CellKind} kind - cellkind of the cell that has to be made.\n\t   @return {CellId} of the new cell.*/\n\tmakeNewCellID ( kind ){\n\t\tconst newid = ++ this.last_cell_id\n\t\tthis.cellvolume[newid] = 0\n\t\tthis.setCellKind( newid, kind )\n\t\treturn newid\n\t}\n\n}\n\nexport default CPM\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/models/CPM.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 614,
    "kind": "class",
    "name": "CPM",
    "memberof": "src/models/CPM.js",
    "static": true,
    "longname": "src/models/CPM.js~CPM",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/models/CPM.js",
    "importStyle": "CPM",
    "description": "The core CPM class. Can be used for two- or three-dimensional simulations.",
    "lineNumber": 10,
    "interface": false,
    "extends": [
      "src/models/GridBasedModel.js~GridBasedModel"
    ]
  },
  {
    "__docId__": 615,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/models/CPM.js~CPM",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/CPM.js~CPM#constructor",
    "access": "public",
    "description": "The constructor of class CA.",
    "lineNumber": 28,
    "params": [
      {
        "nullable": null,
        "types": [
          "GridSize"
        ],
        "spread": false,
        "optional": false,
        "name": "field_size",
        "description": "the size of the grid of the model."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "conf",
        "description": "configuration options; see below. In addition,\nthe conf object can have parameters to constraints added to the CPM.\nSee the different {@link Constraint} subclasses for options. For some\nconstraints, adding its parameter to the CPM conf object automatically\nadds the constraint; see {@link AutoAdderConfig} to see for which\nconstraints this is supported."
      },
      {
        "nullable": null,
        "types": [
          "boolean[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[true,true,...]",
        "defaultRaw": "[true,true,...]",
        "name": "conf.torus",
        "description": "should the grid have\nlinked borders?"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "conf.T",
        "description": "the temperature of this CPM. At higher\ntemperatures, unfavourable copy attempts are more likely to be accepted."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "conf.seed",
        "description": "seed for the random number generator. If\nleft unspecified, a random number from the Math.random() generator is\nused to make one."
      }
    ]
  },
  {
    "__docId__": 616,
    "kind": "member",
    "name": "isCPM",
    "memberof": "src/models/CPM.js~CPM",
    "static": false,
    "longname": "src/models/CPM.js~CPM#isCPM",
    "access": "public",
    "description": "To check from outside if an object is a CPM; doing this with\ninstanceof doesn't work in some cases. Any other object will\nnot have this variable and return 'undefined', which in an\nif-statement equates to a 'false'.\n@type{boolean}",
    "lineNumber": 36,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 617,
    "kind": "member",
    "name": "time",
    "memberof": "src/models/CPM.js~CPM",
    "static": false,
    "longname": "src/models/CPM.js~CPM#time",
    "access": "public",
    "description": "Track time in MCS.\n@type{number}",
    "lineNumber": 40,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 618,
    "kind": "member",
    "name": "nr_cells",
    "memberof": "src/models/CPM.js~CPM",
    "static": false,
    "longname": "src/models/CPM.js~CPM#nr_cells",
    "access": "public",
    "description": "Number of non-background cells currently on the grid.\n@type{number}",
    "lineNumber": 46,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 619,
    "kind": "member",
    "name": "last_cell_id",
    "memberof": "src/models/CPM.js~CPM",
    "static": false,
    "longname": "src/models/CPM.js~CPM#last_cell_id",
    "access": "public",
    "description": "Highest cell ID previously assigned. \n@type{number}",
    "lineNumber": 49,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 620,
    "kind": "member",
    "name": "borderpixels",
    "memberof": "src/models/CPM.js~CPM",
    "static": false,
    "longname": "src/models/CPM.js~CPM#borderpixels",
    "access": "public",
    "description": "track border pixels for speed ",
    "lineNumber": 52,
    "type": {
      "nullable": null,
      "types": [
        "DiceSet"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 621,
    "kind": "member",
    "name": "_neighbours",
    "memberof": "src/models/CPM.js~CPM",
    "static": false,
    "longname": "src/models/CPM.js~CPM#_neighbours",
    "access": "private",
    "description": "Private property used by {@link updateborderneari} to track borders. ",
    "lineNumber": 56,
    "type": {
      "nullable": null,
      "types": [
        "Uint16Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 622,
    "kind": "member",
    "name": "t2k",
    "memberof": "src/models/CPM.js~CPM",
    "static": false,
    "longname": "src/models/CPM.js~CPM#t2k",
    "access": "public",
    "description": "Store the {@CellKind} of each cell on the grid. ",
    "examples": [
      "this.t2k[1] // cellkind of cell with cellId 1"
    ],
    "lineNumber": 64,
    "type": {
      "nullable": null,
      "types": [
        "CellObject"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 623,
    "kind": "member",
    "name": "soft_constraints",
    "memberof": "src/models/CPM.js~CPM",
    "static": false,
    "longname": "src/models/CPM.js~CPM#soft_constraints",
    "access": "public",
    "description": "Array of objects of (@link SoftConstraint) subclasses attached to the CPM.\nThese are used to determine {@link deltaH}.",
    "lineNumber": 71,
    "type": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 624,
    "kind": "member",
    "name": "soft_constraints_indices",
    "memberof": "src/models/CPM.js~CPM",
    "static": false,
    "longname": "src/models/CPM.js~CPM#soft_constraints_indices",
    "access": "public",
    "description": "Object showing which constraints are where in {@link soft_constraints}. Used\nby the {@link getConstraint} method to find an attached constraint by name.",
    "lineNumber": 75,
    "type": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 625,
    "kind": "member",
    "name": "hard_constraints",
    "memberof": "src/models/CPM.js~CPM",
    "static": false,
    "longname": "src/models/CPM.js~CPM#hard_constraints",
    "access": "public",
    "description": "Array of objects of (@link HardConstraint) subclasses attached to the CPM.\nThese are used to determine which copy attempts are allowed in a {@link timeStep}.",
    "lineNumber": 79,
    "type": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 626,
    "kind": "member",
    "name": "hard_constraints_indices",
    "memberof": "src/models/CPM.js~CPM",
    "static": false,
    "longname": "src/models/CPM.js~CPM#hard_constraints_indices",
    "access": "public",
    "description": "Object showing which constraints are where in {@link soft_constraints}. Used\nby the {@link getConstraint} method to find an attached constraint by name.",
    "lineNumber": 83,
    "type": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 627,
    "kind": "member",
    "name": "post_setpix_listeners",
    "memberof": "src/models/CPM.js~CPM",
    "static": false,
    "longname": "src/models/CPM.js~CPM#post_setpix_listeners",
    "access": "public",
    "description": "Array of functions that need to be executed after every {@link setpixi} event.\nThese functions are often implemented in subclasses of {@link Constraint} that\nneed to track some specific property on the grid. ",
    "lineNumber": 88,
    "type": {
      "nullable": null,
      "types": [
        "function[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 628,
    "kind": "member",
    "name": "post_mcs_listeners",
    "memberof": "src/models/CPM.js~CPM",
    "static": false,
    "longname": "src/models/CPM.js~CPM#post_mcs_listeners",
    "access": "public",
    "description": "Array of functions that need to be executed after every {@link timeStep} event.\nThese functions are often implemented in subclasses of {@link Constraint} that\nneed to track some specific property on the grid. ",
    "lineNumber": 93,
    "type": {
      "nullable": null,
      "types": [
        "function[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 629,
    "kind": "method",
    "name": "reset",
    "memberof": "src/models/CPM.js~CPM",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/CPM.js~CPM#reset",
    "access": "public",
    "description": "Completely reset; remove all cells and set time back to zero. Only the\nconstraints remain.",
    "lineNumber": 106,
    "params": [],
    "return": null
  },
  {
    "__docId__": 633,
    "kind": "member",
    "name": "cellvolume",
    "memberof": "src/models/CPM.js~CPM",
    "static": false,
    "longname": "src/models/CPM.js~CPM#cellvolume",
    "access": "public",
    "description": null,
    "lineNumber": 114,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 634,
    "kind": "member",
    "name": "stat_values",
    "memberof": "src/models/CPM.js~CPM",
    "static": false,
    "longname": "src/models/CPM.js~CPM#stat_values",
    "access": "public",
    "description": null,
    "lineNumber": 115,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 635,
    "kind": "method",
    "name": "cellPixels",
    "memberof": "src/models/CPM.js~CPM",
    "generator": true,
    "async": false,
    "static": false,
    "longname": "src/models/CPM.js~CPM#cellPixels",
    "access": "public",
    "description": "Iterator returning non-background pixels on the grid.",
    "lineNumber": 127,
    "return": {
      "nullable": null,
      "types": [
        "Pixel"
      ],
      "spread": false,
      "description": "for each pixel, return an array [p,v] where p are\nthe pixel's array coordinates on the grid, and v its value."
    },
    "params": []
  },
  {
    "__docId__": 636,
    "kind": "method",
    "name": "cellBorderPixels",
    "memberof": "src/models/CPM.js~CPM",
    "generator": true,
    "async": false,
    "static": false,
    "longname": "src/models/CPM.js~CPM#cellBorderPixels",
    "access": "public",
    "description": "Iterator returning non-background border pixels on the grid.\nSee {@link cellBorderPixelIndices} for a version returning pixels\nby their {@link IndexCoordinate} instead of {@link ArrayCoordinate}.",
    "lineNumber": 141,
    "return": {
      "nullable": null,
      "types": [
        "Pixel"
      ],
      "spread": false,
      "description": "for each pixel, return an array [p,v] where p are\nthe pixel's array coordinates on the grid, and v its value."
    },
    "params": []
  },
  {
    "__docId__": 637,
    "kind": "method",
    "name": "cellBorderPixelIndices",
    "memberof": "src/models/CPM.js~CPM",
    "generator": true,
    "async": false,
    "static": false,
    "longname": "src/models/CPM.js~CPM#cellBorderPixelIndices",
    "access": "public",
    "description": "Iterator returning non-background border pixels on the grid.\nSee {@link cellBorderPixels} for a version returning pixels\nby their {@link ArrayCoordinate} instead of {@link IndexCoordinate}.",
    "lineNumber": 156,
    "return": {
      "nullable": null,
      "types": [
        "iPixel"
      ],
      "spread": false,
      "description": "for each pixel, return an array [p,v] where p are\nthe pixel's array coordinates on the grid, and v its value."
    },
    "params": []
  },
  {
    "__docId__": 638,
    "kind": "method",
    "name": "add",
    "memberof": "src/models/CPM.js~CPM",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/CPM.js~CPM#add",
    "access": "public",
    "description": "Add a constraint to the CPM, ensuring that its {@link SoftConstraint#deltaH} or\n{@link HardConstraint#fulfilled} methods are called appropriately during a copy attempt.\nAny postSetpixListeners and postMCSListeners are also executed at the appropriate times.",
    "lineNumber": 170,
    "params": [
      {
        "nullable": null,
        "types": [
          "Constraint"
        ],
        "spread": false,
        "optional": false,
        "name": "t",
        "description": "the constraint object to add."
      }
    ],
    "return": null
  },
  {
    "__docId__": 639,
    "kind": "method",
    "name": "getConstraint",
    "memberof": "src/models/CPM.js~CPM",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/CPM.js~CPM#getConstraint",
    "access": "public",
    "description": "Get a {@link Constraint} object linked to this CPM by the name of its class.\nBy default, the first constraint found of this class is returned. It is possible\nthat there are multiple constraints of the same type on the CPM; in that case,\nsupply its number (by order in which the constraints of this type were added) to \nget a specific one. \n\nThis function can be useful if you need to access information in the constraint object,\nsuch as the cell directions in a {@PersistenceConstraint}, from outside. You can use\nthis for stuff like drawing.",
    "lineNumber": 226,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "constraintname",
        "description": "name of the constraint class you are looking for."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " 0",
        "defaultRaw": 0,
        "name": "num",
        "description": "if multiple constraints of this class are present, \nreturn the num-th one added to the CPM."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 640,
    "kind": "method",
    "name": "getAllConstraints",
    "memberof": "src/models/CPM.js~CPM",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/CPM.js~CPM#getAllConstraints",
    "access": "public",
    "description": null,
    "lineNumber": 245,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 641,
    "kind": "method",
    "name": "pixt",
    "memberof": "src/models/CPM.js~CPM",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/CPM.js~CPM#pixt",
    "access": "public",
    "description": "Get {@link CellId} of the pixel at coordinates p. ",
    "lineNumber": 257,
    "params": [
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "p",
        "description": "pixel to get cellid of."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CellId"
      ],
      "spread": false,
      "description": "ID of the cell p belongs to."
    }
  },
  {
    "__docId__": 642,
    "kind": "method",
    "name": "getVolume",
    "memberof": "src/models/CPM.js~CPM",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/CPM.js~CPM#getVolume",
    "access": "public",
    "description": "Get volume of the cell with {@link CellId} t ",
    "lineNumber": 264,
    "params": [
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "t",
        "description": "id of the cell to get volume of."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the cell's current volume."
    }
  },
  {
    "__docId__": 643,
    "kind": "method",
    "name": "cellKind",
    "memberof": "src/models/CPM.js~CPM",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/CPM.js~CPM#cellKind",
    "access": "public",
    "description": "Get the {@link CellKind} of the cell with {@link CellId} t. \nOverwrites {@link GridBasedModel#cellKind} because in a CPM, the two are not the same.",
    "lineNumber": 272,
    "params": [
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "t",
        "description": "id of the cell to get kind of."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CellKind"
      ],
      "spread": false,
      "description": "the cellkind."
    }
  },
  {
    "__docId__": 644,
    "kind": "method",
    "name": "setCellKind",
    "memberof": "src/models/CPM.js~CPM",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/CPM.js~CPM#setCellKind",
    "access": "public",
    "description": "Assign the cell with {@link CellId} t to {@link CellKind} k.",
    "lineNumber": 280,
    "params": [
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "t",
        "description": "id of the cell to assing"
      },
      {
        "nullable": null,
        "types": [
          "CellKind"
        ],
        "spread": false,
        "optional": false,
        "name": "k",
        "description": "cellkind to give it."
      }
    ],
    "return": null
  },
  {
    "__docId__": 645,
    "kind": "method",
    "name": "deltaH",
    "memberof": "src/models/CPM.js~CPM",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/CPM.js~CPM#deltaH",
    "access": "public",
    "description": "returns total change in hamiltonian for all registered soft constraints together.",
    "lineNumber": 295,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "sourcei",
        "description": "coordinate of the source pixel that tries to copy."
      },
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "targeti",
        "description": "coordinate of the target pixel the source is trying\nto copy into."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "src_type",
        "description": "cellid of the source pixel."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "tgt_type",
        "description": "cellid of the target pixel."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the change in Hamiltonian for this copy attempt."
    }
  },
  {
    "__docId__": 646,
    "kind": "method",
    "name": "monteCarloStep",
    "memberof": "src/models/CPM.js~CPM",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/CPM.js~CPM#monteCarloStep",
    "access": "public",
    "description": "Simulate one Monte Carlo Step. We now just use {@link timeStep} for consistency\nwith other {@link GridBasedModel}s, but we have kept this method for compatibility\nwith earlier version. Internally, it just calls {@link timeStep}.",
    "lineNumber": 308,
    "params": [],
    "return": null
  },
  {
    "__docId__": 647,
    "kind": "method",
    "name": "timeStep",
    "memberof": "src/models/CPM.js~CPM",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/CPM.js~CPM#timeStep",
    "access": "public",
    "description": "A time step in the CPM is a Monte Carlo step. This performs a \nnumber of copy attempts depending on grid size:\n\n1) Randomly sample one of the border pixels for the copy attempt.\n2) Compute the change in Hamiltonian for the suggested copy attempt.\n3) With a probability depending on this change, decline or accept the \ncopy attempt and update the grid accordingly. ",
    "lineNumber": 323,
    "todo": [
      "TODO it is quite confusing that the \"borderpixels\" array also\ncontains border pixels of the background."
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 649,
    "kind": "method",
    "name": "docopy",
    "memberof": "src/models/CPM.js~CPM",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/CPM.js~CPM#docopy",
    "access": "public",
    "description": "Determine whether copy attempt will succeed depending on deltaH (stochastic). ",
    "lineNumber": 373,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "deltaH",
        "description": "energy change associated with the potential copy."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "whether the copy attempt succeeds."
    }
  },
  {
    "__docId__": 650,
    "kind": "method",
    "name": "setpixi",
    "memberof": "src/models/CPM.js~CPM",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/CPM.js~CPM#setpixi",
    "access": "public",
    "description": "Change the pixel at position i into {@link CellId} t. \nThis method overrides {@link GridBasedModel#setpixi} because we want to\nadd postSetpixListeners for all the constraints, to keep track of relevant information.\n\nSee also {@link setpix} for a method working with {@link ArrayCoordinate}s.",
    "lineNumber": 387,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "coordinate of pixel to change."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "t",
        "description": "cellid to change this pixel into."
      }
    ],
    "return": null
  },
  {
    "__docId__": 651,
    "kind": "get",
    "name": "perimeterNeighbours",
    "memberof": "src/models/CPM.js~CPM",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/CPM.js~CPM#perimeterNeighbours",
    "access": "public",
    "description": null,
    "lineNumber": 417,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 652,
    "kind": "method",
    "name": "updateborderneari",
    "memberof": "src/models/CPM.js~CPM",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/CPM.js~CPM#updateborderneari",
    "access": "public",
    "description": "Update border elements ({@link borderpixels}) after a successful copy attempt. ",
    "lineNumber": 427,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "coordinate of pixel that has changed."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "t_old",
        "description": "id of the cell the pixel belonged to before the copy."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "t_new",
        "description": "id of the cell the pixel has changed into."
      }
    ],
    "listens": [
      {
        "types": [
          "setpixi"
        ],
        "description": "because borders change when a copy succeeds."
      }
    ],
    "return": null
  },
  {
    "__docId__": 653,
    "kind": "method",
    "name": "makeNewCellID",
    "memberof": "src/models/CPM.js~CPM",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/CPM.js~CPM#makeNewCellID",
    "access": "public",
    "description": "Initiate a new {@link CellId} for a cell of {@link CellKind} \"kind\", and create elements\nfor this cell in the relevant arrays (cellvolume, t2k).",
    "lineNumber": 463,
    "params": [
      {
        "nullable": null,
        "types": [
          "CellKind"
        ],
        "spread": false,
        "optional": false,
        "name": "kind",
        "description": "cellkind of the cell that has to be made."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CellId"
      ],
      "spread": false,
      "description": "of the new cell."
    }
  },
  {
    "__docId__": 654,
    "kind": "file",
    "name": "src/models/CPMEvol.js",
    "content": "\"use strict\"\n\nimport CPM from \"./CPM.js\"\nimport Cell from \"../cells/Cell.js\"\n\n/** Extension of the CPM class that uses Cell objects to track internal state of Cells\n * Cell objects can override conf parameters, and track their lineage. \n*/\nclass CPMEvol extends CPM {\n\n\t/** The constructor of class CA.\n\t * @param {GridSize} field_size - the size of the grid of the model.\n\t * @param {object} conf - configuration options; see CPM base class.\n\t *  \n\t * @param {object[]} [conf.CELLS=[empty, CPM.Cell, CPM.StochasticCorrector]] - Array of objects of (@link Cell) \n\t * subclasses attached to the CPM. These define the internal state of the cell objects that are tracked\n\t * */\n\tconstructor( field_size, conf ){\n\t\tsuper( field_size, conf )\n\n\t\t/** Store the {@Cell} of each cell on the grid. \n\t\t@example\n\t\tthis.cells[1] // cell object of cell with cellId 1\n\t\t@type {Cell}\n\t\t*/\n\t\tthis.cells =[new Cell(conf, 0, -1, this)]\n\n\t\t/** Store the constructor of each cellKind on the grid, in order\n\t\t * 0th index currently unused - but this is explicitly left open for \n\t\t * further extension (granting background variable parameters through Cell)\n\t\t@type {CellObject}\n\t\t*/\n\t\tthis.cellclasses = conf[\"CELLS\"]\n\n\t\t/* adds cellDeath listener to record this if pixels change. */\n\t\tthis.post_setpix_listeners.push(this.cellDeath.bind(this))\n\t}\n\n\t/** Completely reset; remove all cells and set time back to zero. Only the\n\t * constraints and empty cell remain. */\n\treset(){\n\t\tsuper.reset()\n\t\tthis.cells = [this.cells[0]] // keep empty declared\n\t}\n\n\t/** The postSetpixListener of CPMEvol registers cell death.\n\t * @listens {CPM#setpixi}  as this records when cels no longer contain any pixels.\n\t * Note: CPM class already logs most of death, so it registers deleted entries.\n\t * @param {IndexCoordinate} i - the coordinate of the pixel that is changed.\n\t * @param {CellId} t_old - the cellid of this pixel before the copy\n\t * @param {CellId} t_new - the cellid of this pixel after the copy.\n\t*/\n\t/* eslint-disable no-unused-vars*/\n\tcellDeath( i, t_old, t_new){\n\t\tif (this.cellvolume[t_old] === undefined && t_old !== 0){\n\t\t\tthis.cells[t_old].death()\n\t\t\tdelete this.cells[t_old]\n\t\t} \n\t}\n\n\t/** Get the {@link Cell} of the cell with {@link CellId} t. \n\t@param {CellId} t - id of the cell to get kind of.\n\t@return {Cell} the cell object. */\n\tgetCell ( t ){\n\t\treturn this.cells[t]\n\t}\n\n\t/* ------------- MANIPULATING CELLS ON THE GRID --------------- */\n\t/** Initiate a new {@link CellId} for a cell of {@link CellKind} \"kind\", and create elements\n\t   for this cell in the relevant arrays. Overrides super to also add a new Cell object to track.\n\t   @param {CellKind} kind - cellkind of the cell that has to be made.\n\t   @return {CellId} newid of the new cell.*/\n\tmakeNewCellID ( kind ){\n\t\tlet newid = super.makeNewCellID(kind)\n\t\tthis.cells[newid] =new this.cellclasses[kind](this.conf, kind, newid, this)\n\t\treturn newid\n\t}\n\n\t/** Calls a birth event in a new daughter Cell object, and hands \n\t * the other daughter (as parent) on to the Cell.\n\t   @param {CellId} childId - id of the newly created Cell object\n\t   @param {CellId} parentId - id of the other daughter (that kept the parent id)*/\n\tbirth (childId, parentId){\n\t\tthis.cells[childId].birth(this.cells[parentId] )\n\t}\n}\n \nexport default CPMEvol\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/models/CPMEvol.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 655,
    "kind": "class",
    "name": "CPMEvol",
    "memberof": "src/models/CPMEvol.js",
    "static": true,
    "longname": "src/models/CPMEvol.js~CPMEvol",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/models/CPMEvol.js",
    "importStyle": "CPMEvol",
    "description": "Extension of the CPM class that uses Cell objects to track internal state of Cells\nCell objects can override conf parameters, and track their lineage. ",
    "lineNumber": 9,
    "interface": false,
    "extends": [
      "src/models/CPM.js~CPM"
    ]
  },
  {
    "__docId__": 656,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/models/CPMEvol.js~CPMEvol",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/CPMEvol.js~CPMEvol#constructor",
    "access": "public",
    "description": "The constructor of class CA.",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "GridSize"
        ],
        "spread": false,
        "optional": false,
        "name": "field_size",
        "description": "the size of the grid of the model."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "conf",
        "description": "configuration options; see CPM base class."
      },
      {
        "nullable": null,
        "types": [
          "object[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[empty, CPM.Cell, CPM.StochasticCorrector]",
        "defaultRaw": "[empty, CPM.Cell, CPM.StochasticCorrector]",
        "name": "conf.CELLS",
        "description": "Array of objects of (@link Cell) \nsubclasses attached to the CPM. These define the internal state of the cell objects that are tracked"
      }
    ]
  },
  {
    "__docId__": 657,
    "kind": "member",
    "name": "cells",
    "memberof": "src/models/CPMEvol.js~CPMEvol",
    "static": false,
    "longname": "src/models/CPMEvol.js~CPMEvol#cells",
    "access": "public",
    "description": "Store the {@Cell} of each cell on the grid. ",
    "examples": [
      "this.cells[1] // cell object of cell with cellId 1"
    ],
    "lineNumber": 26,
    "type": {
      "nullable": null,
      "types": [
        "Cell"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 658,
    "kind": "member",
    "name": "cellclasses",
    "memberof": "src/models/CPMEvol.js~CPMEvol",
    "static": false,
    "longname": "src/models/CPMEvol.js~CPMEvol#cellclasses",
    "access": "public",
    "description": "Store the constructor of each cellKind on the grid, in order\n0th index currently unused - but this is explicitly left open for \nfurther extension (granting background variable parameters through Cell)",
    "lineNumber": 33,
    "type": {
      "nullable": null,
      "types": [
        "CellObject"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 659,
    "kind": "method",
    "name": "reset",
    "memberof": "src/models/CPMEvol.js~CPMEvol",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/CPMEvol.js~CPMEvol#reset",
    "access": "public",
    "description": "Completely reset; remove all cells and set time back to zero. Only the\nconstraints and empty cell remain.",
    "lineNumber": 41,
    "params": [],
    "return": null
  },
  {
    "__docId__": 661,
    "kind": "method",
    "name": "cellDeath",
    "memberof": "src/models/CPMEvol.js~CPMEvol",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/CPMEvol.js~CPMEvol#cellDeath",
    "access": "public",
    "description": "The postSetpixListener of CPMEvol registers cell death.",
    "lineNumber": 54,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "the coordinate of the pixel that is changed."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "t_old",
        "description": "the cellid of this pixel before the copy"
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "t_new",
        "description": "the cellid of this pixel after the copy."
      }
    ],
    "listens": [
      {
        "types": [
          "CPM#setpixi"
        ],
        "description": "as this records when cels no longer contain any pixels.\nNote: CPM class already logs most of death, so it registers deleted entries."
      }
    ],
    "return": null
  },
  {
    "__docId__": 662,
    "kind": "method",
    "name": "getCell",
    "memberof": "src/models/CPMEvol.js~CPMEvol",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/CPMEvol.js~CPMEvol#getCell",
    "access": "public",
    "description": "Get the {@link Cell} of the cell with {@link CellId} t. ",
    "lineNumber": 64,
    "params": [
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "t",
        "description": "id of the cell to get kind of."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Cell"
      ],
      "spread": false,
      "description": "the cell object."
    }
  },
  {
    "__docId__": 663,
    "kind": "method",
    "name": "makeNewCellID",
    "memberof": "src/models/CPMEvol.js~CPMEvol",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/CPMEvol.js~CPMEvol#makeNewCellID",
    "access": "public",
    "description": "Initiate a new {@link CellId} for a cell of {@link CellKind} \"kind\", and create elements\nfor this cell in the relevant arrays. Overrides super to also add a new Cell object to track.",
    "lineNumber": 73,
    "params": [
      {
        "nullable": null,
        "types": [
          "CellKind"
        ],
        "spread": false,
        "optional": false,
        "name": "kind",
        "description": "cellkind of the cell that has to be made."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CellId"
      ],
      "spread": false,
      "description": "newid of the new cell."
    }
  },
  {
    "__docId__": 664,
    "kind": "method",
    "name": "birth",
    "memberof": "src/models/CPMEvol.js~CPMEvol",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/CPMEvol.js~CPMEvol#birth",
    "access": "public",
    "description": "Calls a birth event in a new daughter Cell object, and hands \nthe other daughter (as parent) on to the Cell.",
    "lineNumber": 83,
    "params": [
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "childId",
        "description": "id of the newly created Cell object"
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "parentId",
        "description": "id of the other daughter (that kept the parent id)"
      }
    ],
    "return": null
  },
  {
    "__docId__": 665,
    "kind": "file",
    "name": "src/models/GridBasedModel.js",
    "content": "\"use strict\"\n\nimport MersenneTwister from \"mersenne-twister\"\n//import HexGrid2D from \"../grid/HexGrid2D.js\"\nimport Grid2D from \"../grid/Grid2D.js\"\nimport Grid3D from \"../grid/Grid3D.js\"\n\n\n/** Base class for grid-based models. This class is not used by itself; see\n{@link CPM} for a Cellular Potts Model and {@link CA} for a Cellular Automaton. \n*/\nclass GridBasedModel {\n\n\t/** The constructor of a GridBasedModel automatically attaches a grid of \n\tclass {@link Grid2D} or {@link Grid3D}, depending on the grid dimensions\n\tgiven in the 'extents' parameter. Configuration options for the model can\n\tbe supplied in 'conf'.\n\t@param {GridSize} extents - the size of the grid of the model.\n\t@param {object} conf - configuration options. See below for its elements,\n\tbut subclasses can have more.\n\t@param {boolean[]} [conf.torus=[true,true,...]] - should the grid have linked borders?\n\t@param {boolean} [conf.hexGrid=false] - should the grid be hexagonal? Grids\n\t are square by default.\n\t@param {number} [seed] - seed for the random number generator. If left unspecified,\n\ta random number from the Math.random() generator is used to make one.  */\n\tconstructor( extents, conf ){\n\t\tlet seed = conf.seed || Math.floor(Math.random()*Number.MAX_SAFE_INTEGER)\n\t\t\n\t\t/** Attach a random number generation with a seed.\n\t\t@type {MersenneTwister}*/\n\t\tthis.mt = new MersenneTwister( seed )\n\t\tif( !(\"torus\" in conf) ){\n\t\t\tlet torus = []\n\t\t\tfor( let d = 0; d < extents.length; d++ ){\n\t\t\t\ttorus.push( true )\n\t\t\t}\n\t\t\tconf[\"torus\"] = torus\n\t\t}\n\n\t\t// Attributes based on input parameters\n\t\t/** Dimensionality of the grid \n\t\t@type {number}*/\n\t\tthis.ndim = extents.length // grid dimensions (2 or 3)\n\t\tif( this.ndim !== 2 && this.ndim !== 3 ){\n\t\t\tthrow(\"only 2D and 3D models are implemented!\")\n\t\t}\n\t\t\n\t\t/** Input parameter settings; see the constructor of subclasses documentation.\n\t\t@type {object}*/\n\t\tthis.conf = conf // input parameter settings; see documentation.\n\n\t\t// Some functions/attributes depend on ndim:\n\t\t//this.hexGrid = conf.hexGrid || false\n\n\t\tif( this.ndim === 2 ){\n\t\t\tthis.grid=new Grid2D(extents,conf.torus)\n\t\t\t//if( this.hexGrid ){\n\t\t\t//\t/** The grid.\n\t\t\t//\t@type {Grid2D|Grid3D|HexGrid2D}*/\n\t\t\t//\tthis.grid = new HexGrid2D(extents,conf.torus)\n\t\t\t//} else {\n\t\t\t//\tthis.grid = new Grid2D(extents,conf.torus)\n\t\t\t//}\n\n\t\t} else {\n\t\t\t/*if( this.hexGrid ){\n\t\t\t\tthrow( \"There is no 3D hexagonal grid!\" )\n\t\t\t}*/\n\t\t\tthis.grid = new Grid3D(extents,conf.torus)\n\t\t}\n\t\t// Pull up some things from the grid object so we don't have to access it\n\t\t// from the outside\n\t\t/** Midpoint of the grid.\n\t\t@type {ArrayCoordinate}*/\n\t\tthis.midpoint = this.grid.midpoint\n\t\t/** Size of the grid in object format.\n\t\t@type {object}*/\n\t\tthis.field_size = this.grid.field_size\n\t\t/** The {@link Grid2D#pixels} or {@link Grid3D#pixels} iterator function of the underlying grid.\n\t\t@type {function}*/\n\t\tthis.pixels = this.grid.pixels.bind(this.grid)\n\t\t/** The {@link Grid#pixti} iterator function of the underlying grid.\n\t\t@type {function}*/\n\t\tthis.pixti = this.grid.pixti.bind(this.grid)\n\t\t/** The {@link Grid2D#neighi} or {@link Grid3D#neighi} iterator function of the underlying grid.\n\t\t@type {function}*/\n\t\tthis.neighi = this.grid.neighi.bind(this.grid)\n\t\t/** Size of the grid.\n\t\t@type {GridSize}*/\n\t\tthis.extents = this.grid.extents\n\n\n\t\t/** This tracks the volumes of all non-background cells on the grid.\n\t\tcellvolumes will be added with key = {@link CellId}, value = volume.\n\t\t@type{number[]}*/\n\t\tthis.cellvolume = []\n\t\t/** Tracks the elapsed time in MCS\n\t\t@type {number}*/\n\t\tthis.time = 0\n\t\t/** Objects of class {@link Stat} that have been computed on this model.\n\t\t@type {Stat}*/\n\t\tthis.stats = []\n\t\t/** Cached values of these stats. Object with stat name as key and its cached\n\t\tvalue as value. The cache must be cleared when the grid changes!\n\t\t@type {object} */\n\t\tthis.stat_values = {}\n\t}\n\n\t/** Get the {@link CellKind} of the cell with {@link CellId} t. For this model, they\n\tare just the same.\n\t@param {CellId} t - id of the cell to get kind of.\n\t@return {CellKind} the cellkind. */\n\tcellKind( t ){\n\t\treturn t \n\t}\n\n\t/** Iterator for all the {@link CellId}s that are currently on the grid. \n\t@return {CellId}*/\n\t* cellIDs() {\n\t\tyield* Object.keys( this.cellvolume )\n\t}\n\n\t/** Get neighbourhood of position p, using neighborhood functions of the underlying\n\tgrid class.\n\t@param {ArrayCoordinate} p - coordinate of a pixel to get the neighborhood of.\n\t@param {boolean[]} [torus=[true,true,...]]  Does the grid have linked borders? If left unspecified,\n\tthis is determined by this.conf.torus.*/\n\tneigh(p, torus=this.conf.torus){\n\t\tlet g = this.grid\n\t\treturn g.neighi( g.p2i(p), torus ).map( function(i){ return g.i2p(i) } )\n\t}\n\n\t/** Get {@link CellId} of the pixel at coordinates p. \n\t@param {ArrayCoordinate} p - pixel to get cellid of.\n\t@return {CellId} ID of the cell p belongs to.*/\n\tpixt( p ){\n\t\treturn this.grid.pixti( this.grid.p2i(p) )\n\t}\n\n\t/** Change the pixel at position i into {@link CellId} t. \n\t\tThis standard implementation also keeps track of cell volumes\n\t\tfor all nonzero cell IDs. Subclasses may want to do more, \n\t\tsuch as also keeping track of perimeters or even centroids.\n\t\tIn that case, this method needs to be overridden. \n\t\t\n\t\tSee also {@link setpix} for a method working with {@link ArrayCoordinate}s.\n\t\t\n\t\t@param {IndexCoordinate} i - coordinate of pixel to change.\n\t\t@param {CellId} t - cellid to change this pixel into.\n\t\t*/\n\tsetpixi ( i, t ){\t\t\n\t\tconst t_old = this.grid.pixti(i)\n\t\tif( t_old > 0 ){\n\t\t\t// also update volume of the old cell\n\t\t\tthis.cellvolume[t_old] --\n\t\t\t// if this was the last pixel belonging to this cell, \n\t\t\t// remove the cell altogether.\n\t\t\tif( this.cellvolume[t_old] == 0 ){\n\t\t\t\tdelete this.cellvolume[t_old]\n\t\t\t}\n\t\t}\n\t\t// update volume of the new cell and cellid of the pixel.\n\t\tthis.grid.setpixi( i, t )\n\t\tif( t > 0 ){\n\t\t\tif( !this.cellvolume[t] ){\n\t\t\t\tthis.cellvolume[t] = 1\n\t\t\t} else {\n\t\t\t\tthis.cellvolume[t] ++\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Change the pixel at position p into {@link CellId} t. \n\t\tThis just calls the {@link setpixi} method internally.\n\t\t\n\t\t@param {ArrayCoordinate} p - coordinate of pixel to change.\n\t\t@param {CellId} t - cellid to change this pixel into.\n\t\t*/\n\tsetpix ( p, t ){\n\t\tthis.setpixi( this.grid.p2i(p), t )\n\t}\n\n\t/* ------------- MATH HELPER FUNCTIONS --------------- */\n\t/** Get a random number from the seeded number generator.\n\t@return {number} a random number between 0 and 1, uniformly sampled.*/\n\trandom (){\n\t\treturn this.mt.random()\n\t}\n\n\t/** Get a random integer number between incl_min and incl_max, uniformly sampled.\n\t@param {number} incl_min - lower end of the sampling range.\n\t@param {number} incl_max - upper end of the sampling range. \n\t@return {number} the randomly sampled integer.*/\n\tran (incl_min, incl_max) {\n\t\treturn Math.floor(this.random() * (1.0 + incl_max - incl_min)) + incl_min\n\t}\n\n\t/** Compute a statistic on this model. If necessary, this produces an object\n\tof the right {@link Stat} subclass and runs the compute method. Stats are \n\tcached because many stats use each other; this prevents that 'expensive' stats are\n\tcomputed twice. \n\t@param {Stat} s - the stat to compute.\n\t@return {anything} - the value of the computed stat. This is often a {@link CellObject}\n\tor a {@link CellArrayObject}. \n\t\n\t@example\n\t* let CPM = require( \"path/to/dir\")\n\t* let C = new CPM.CPM( [200,200], {T:20, torus:[false,false]} )\n\t* let gm = new CPM.GridManipulator( C )\n\t* gm.seedCell( 1 )\n\t* gm.seedCell( 1 )\n\t* C.getStat( Centroids )\n\t*/\n\tgetStat( s ){\n\t\t/* Instantiate stats class if it doesn't exist yet and bind to this model */\n\t\tif( !(s.name in this.stats) ){\n\t\t\tlet t = new s()\n\t\t\tthis.stats[s.name] = t\n\t\t\tt.model = this\n\t\t\t\n\t\t}\n\t\t/* Cache stat value if it hasn't been done yet */\n\t\tif( !(s.name in this.stat_values) ){\n\t\t\tthis.stat_values[s.name] = this.stats[s.name].compute()\n\t\t}\n\t\t/* Return cached value */\n\t\treturn this.stat_values[s.name]\n\t}\n\t\n\t/** Update the grid in one timestep. This method is model-dependent and \n\tmust be implemented in the subclass.\n\t@abstract */\n\ttimeStep (){\n\t\tthrow(\"implemented in subclasses\")\n\t}\n}\n\nexport default GridBasedModel \n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/models/GridBasedModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 666,
    "kind": "class",
    "name": "GridBasedModel",
    "memberof": "src/models/GridBasedModel.js",
    "static": true,
    "longname": "src/models/GridBasedModel.js~GridBasedModel",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/models/GridBasedModel.js",
    "importStyle": "GridBasedModel",
    "description": "Base class for grid-based models. This class is not used by itself; see\n{@link CPM} for a Cellular Potts Model and {@link CA} for a Cellular Automaton. ",
    "lineNumber": 12,
    "interface": false
  },
  {
    "__docId__": 667,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/models/GridBasedModel.js~GridBasedModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/GridBasedModel.js~GridBasedModel#constructor",
    "access": "public",
    "description": "The constructor of a GridBasedModel automatically attaches a grid of \nclass {@link Grid2D} or {@link Grid3D}, depending on the grid dimensions\ngiven in the 'extents' parameter. Configuration options for the model can\nbe supplied in 'conf'.",
    "lineNumber": 26,
    "params": [
      {
        "nullable": null,
        "types": [
          "GridSize"
        ],
        "spread": false,
        "optional": false,
        "name": "extents",
        "description": "the size of the grid of the model."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "conf",
        "description": "configuration options. See below for its elements,\nbut subclasses can have more."
      },
      {
        "nullable": null,
        "types": [
          "boolean[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[true,true,...]",
        "defaultRaw": "[true,true,...]",
        "name": "conf.torus",
        "description": "should the grid have linked borders?"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "conf.hexGrid",
        "description": "should the grid be hexagonal? Grids\nare square by default."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "seed",
        "description": "seed for the random number generator. If left unspecified,\na random number from the Math.random() generator is used to make one."
      }
    ]
  },
  {
    "__docId__": 668,
    "kind": "member",
    "name": "mt",
    "memberof": "src/models/GridBasedModel.js~GridBasedModel",
    "static": false,
    "longname": "src/models/GridBasedModel.js~GridBasedModel#mt",
    "access": "public",
    "description": "Attach a random number generation with a seed.",
    "lineNumber": 31,
    "type": {
      "nullable": null,
      "types": [
        "MersenneTwister"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 669,
    "kind": "member",
    "name": "ndim",
    "memberof": "src/models/GridBasedModel.js~GridBasedModel",
    "static": false,
    "longname": "src/models/GridBasedModel.js~GridBasedModel#ndim",
    "access": "public",
    "description": "Dimensionality of the grid ",
    "lineNumber": 43,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 670,
    "kind": "member",
    "name": "conf",
    "memberof": "src/models/GridBasedModel.js~GridBasedModel",
    "static": false,
    "longname": "src/models/GridBasedModel.js~GridBasedModel#conf",
    "access": "public",
    "description": "Input parameter settings; see the constructor of subclasses documentation.",
    "lineNumber": 50,
    "type": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 671,
    "kind": "member",
    "name": "grid",
    "memberof": "src/models/GridBasedModel.js~GridBasedModel",
    "static": false,
    "longname": "src/models/GridBasedModel.js~GridBasedModel#grid",
    "access": "public",
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 673,
    "kind": "member",
    "name": "midpoint",
    "memberof": "src/models/GridBasedModel.js~GridBasedModel",
    "static": false,
    "longname": "src/models/GridBasedModel.js~GridBasedModel#midpoint",
    "access": "public",
    "description": "Midpoint of the grid.",
    "lineNumber": 75,
    "type": {
      "nullable": null,
      "types": [
        "ArrayCoordinate"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 674,
    "kind": "member",
    "name": "field_size",
    "memberof": "src/models/GridBasedModel.js~GridBasedModel",
    "static": false,
    "longname": "src/models/GridBasedModel.js~GridBasedModel#field_size",
    "access": "public",
    "description": "Size of the grid in object format.",
    "lineNumber": 78,
    "type": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 675,
    "kind": "member",
    "name": "pixels",
    "memberof": "src/models/GridBasedModel.js~GridBasedModel",
    "static": false,
    "longname": "src/models/GridBasedModel.js~GridBasedModel#pixels",
    "access": "public",
    "description": "The {@link Grid2D#pixels} or {@link Grid3D#pixels} iterator function of the underlying grid.",
    "lineNumber": 81,
    "type": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 676,
    "kind": "member",
    "name": "pixti",
    "memberof": "src/models/GridBasedModel.js~GridBasedModel",
    "static": false,
    "longname": "src/models/GridBasedModel.js~GridBasedModel#pixti",
    "access": "public",
    "description": "The {@link Grid#pixti} iterator function of the underlying grid.",
    "lineNumber": 84,
    "type": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 677,
    "kind": "member",
    "name": "neighi",
    "memberof": "src/models/GridBasedModel.js~GridBasedModel",
    "static": false,
    "longname": "src/models/GridBasedModel.js~GridBasedModel#neighi",
    "access": "public",
    "description": "The {@link Grid2D#neighi} or {@link Grid3D#neighi} iterator function of the underlying grid.",
    "lineNumber": 87,
    "type": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 678,
    "kind": "member",
    "name": "extents",
    "memberof": "src/models/GridBasedModel.js~GridBasedModel",
    "static": false,
    "longname": "src/models/GridBasedModel.js~GridBasedModel#extents",
    "access": "public",
    "description": "Size of the grid.",
    "lineNumber": 90,
    "type": {
      "nullable": null,
      "types": [
        "GridSize"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 679,
    "kind": "member",
    "name": "cellvolume",
    "memberof": "src/models/GridBasedModel.js~GridBasedModel",
    "static": false,
    "longname": "src/models/GridBasedModel.js~GridBasedModel#cellvolume",
    "access": "public",
    "description": "This tracks the volumes of all non-background cells on the grid.\ncellvolumes will be added with key = {@link CellId}, value = volume.\n@type{number[]}",
    "lineNumber": 96,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 680,
    "kind": "member",
    "name": "time",
    "memberof": "src/models/GridBasedModel.js~GridBasedModel",
    "static": false,
    "longname": "src/models/GridBasedModel.js~GridBasedModel#time",
    "access": "public",
    "description": "Tracks the elapsed time in MCS",
    "lineNumber": 99,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 681,
    "kind": "member",
    "name": "stats",
    "memberof": "src/models/GridBasedModel.js~GridBasedModel",
    "static": false,
    "longname": "src/models/GridBasedModel.js~GridBasedModel#stats",
    "access": "public",
    "description": "Objects of class {@link Stat} that have been computed on this model.",
    "lineNumber": 102,
    "type": {
      "nullable": null,
      "types": [
        "Stat"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 682,
    "kind": "member",
    "name": "stat_values",
    "memberof": "src/models/GridBasedModel.js~GridBasedModel",
    "static": false,
    "longname": "src/models/GridBasedModel.js~GridBasedModel#stat_values",
    "access": "public",
    "description": "Cached values of these stats. Object with stat name as key and its cached\nvalue as value. The cache must be cleared when the grid changes!",
    "lineNumber": 106,
    "type": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 683,
    "kind": "method",
    "name": "cellKind",
    "memberof": "src/models/GridBasedModel.js~GridBasedModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/GridBasedModel.js~GridBasedModel#cellKind",
    "access": "public",
    "description": "Get the {@link CellKind} of the cell with {@link CellId} t. For this model, they\nare just the same.",
    "lineNumber": 113,
    "params": [
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "t",
        "description": "id of the cell to get kind of."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CellKind"
      ],
      "spread": false,
      "description": "the cellkind."
    }
  },
  {
    "__docId__": 684,
    "kind": "method",
    "name": "cellIDs",
    "memberof": "src/models/GridBasedModel.js~GridBasedModel",
    "generator": true,
    "async": false,
    "static": false,
    "longname": "src/models/GridBasedModel.js~GridBasedModel#cellIDs",
    "access": "public",
    "description": "Iterator for all the {@link CellId}s that are currently on the grid. ",
    "lineNumber": 119,
    "return": {
      "nullable": null,
      "types": [
        "CellId"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 685,
    "kind": "method",
    "name": "neigh",
    "memberof": "src/models/GridBasedModel.js~GridBasedModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/GridBasedModel.js~GridBasedModel#neigh",
    "access": "public",
    "description": "Get neighbourhood of position p, using neighborhood functions of the underlying\ngrid class.",
    "lineNumber": 128,
    "params": [
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "p",
        "description": "coordinate of a pixel to get the neighborhood of."
      },
      {
        "nullable": null,
        "types": [
          "boolean[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[true,true,...]",
        "defaultRaw": "[true,true,...]",
        "name": "torus",
        "description": "Does the grid have linked borders? If left unspecified,\nthis is determined by this.conf.torus."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 686,
    "kind": "method",
    "name": "pixt",
    "memberof": "src/models/GridBasedModel.js~GridBasedModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/GridBasedModel.js~GridBasedModel#pixt",
    "access": "public",
    "description": "Get {@link CellId} of the pixel at coordinates p. ",
    "lineNumber": 136,
    "params": [
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "p",
        "description": "pixel to get cellid of."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CellId"
      ],
      "spread": false,
      "description": "ID of the cell p belongs to."
    }
  },
  {
    "__docId__": 687,
    "kind": "method",
    "name": "setpixi",
    "memberof": "src/models/GridBasedModel.js~GridBasedModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/GridBasedModel.js~GridBasedModel#setpixi",
    "access": "public",
    "description": "Change the pixel at position i into {@link CellId} t. \nThis standard implementation also keeps track of cell volumes\nfor all nonzero cell IDs. Subclasses may want to do more, \nsuch as also keeping track of perimeters or even centroids.\nIn that case, this method needs to be overridden. \n\nSee also {@link setpix} for a method working with {@link ArrayCoordinate}s.",
    "lineNumber": 151,
    "params": [
      {
        "nullable": null,
        "types": [
          "IndexCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "coordinate of pixel to change."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "t",
        "description": "cellid to change this pixel into."
      }
    ],
    "return": null
  },
  {
    "__docId__": 688,
    "kind": "method",
    "name": "setpix",
    "memberof": "src/models/GridBasedModel.js~GridBasedModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/GridBasedModel.js~GridBasedModel#setpix",
    "access": "public",
    "description": "Change the pixel at position p into {@link CellId} t. \nThis just calls the {@link setpixi} method internally.",
    "lineNumber": 179,
    "params": [
      {
        "nullable": null,
        "types": [
          "ArrayCoordinate"
        ],
        "spread": false,
        "optional": false,
        "name": "p",
        "description": "coordinate of pixel to change."
      },
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "t",
        "description": "cellid to change this pixel into."
      }
    ],
    "return": null
  },
  {
    "__docId__": 689,
    "kind": "method",
    "name": "random",
    "memberof": "src/models/GridBasedModel.js~GridBasedModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/GridBasedModel.js~GridBasedModel#random",
    "access": "public",
    "description": "Get a random number from the seeded number generator.",
    "lineNumber": 186,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "a random number between 0 and 1, uniformly sampled."
    },
    "params": []
  },
  {
    "__docId__": 690,
    "kind": "method",
    "name": "ran",
    "memberof": "src/models/GridBasedModel.js~GridBasedModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/GridBasedModel.js~GridBasedModel#ran",
    "access": "public",
    "description": "Get a random integer number between incl_min and incl_max, uniformly sampled.",
    "lineNumber": 194,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "incl_min",
        "description": "lower end of the sampling range."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "incl_max",
        "description": "upper end of the sampling range."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the randomly sampled integer."
    }
  },
  {
    "__docId__": 691,
    "kind": "method",
    "name": "getStat",
    "memberof": "src/models/GridBasedModel.js~GridBasedModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/GridBasedModel.js~GridBasedModel#getStat",
    "access": "public",
    "description": "Compute a statistic on this model. If necessary, this produces an object\nof the right {@link Stat} subclass and runs the compute method. Stats are \ncached because many stats use each other; this prevents that 'expensive' stats are\ncomputed twice. ",
    "examples": [
      "let CPM = require( \"path/to/dir\")\nlet C = new CPM.CPM( [200,200], {T:20, torus:[false,false]} )\nlet gm = new CPM.GridManipulator( C )\ngm.seedCell( 1 )\ngm.seedCell( 1 )\nC.getStat( Centroids )"
    ],
    "lineNumber": 214,
    "params": [
      {
        "nullable": null,
        "types": [
          "Stat"
        ],
        "spread": false,
        "optional": false,
        "name": "s",
        "description": "the stat to compute."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "anything"
      ],
      "spread": false,
      "description": "the value of the computed stat. This is often a {@link CellObject}\nor a {@link CellArrayObject}."
    }
  },
  {
    "__docId__": 692,
    "kind": "method",
    "name": "timeStep",
    "memberof": "src/models/GridBasedModel.js~GridBasedModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/GridBasedModel.js~GridBasedModel#timeStep",
    "access": "public",
    "description": "Update the grid in one timestep. This method is model-dependent and \nmust be implemented in the subclass.",
    "lineNumber": 233,
    "abstract": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 693,
    "kind": "file",
    "name": "src/models/model-typedefs.js",
    "content": "/** \nA unique identifier number of a cell on the grid. In classic CPM language, this is often\nreferred to as 'type', but we use cellid to prevent confusion with the biological meaning\nof 'celltype' (which we call {@link CellKind} to prevent confusion).\n\nThe cellid must be a positive integer. The number 0 is reserved for the background.\n@typedef {number} CellId\n*/\n\n/** \nIndex specifying the 'kind' of cell we are dealing with. This corresponds to the biological\nidea of a 'celltype'; so the CPM parameters used depend on the cellkind. Convention is that\nwe store CPM parameters in number arrays param = number[], where param[i] is the parameter\nvalue for cellkind i. \n\nThis way, we can have multiple cells (each with their own {@link CellId}) of the same \"cellkind\", that\nget the same parameters (e.g. the same target volume). But we can also have multiple\ncellkinds on the grid, e.g. a small and a large cellkind.\n\nThe cellkind must be a positive integer. The number 0 is reserved for the background.\n@typedef {number} CellKind\n*/\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/models/model-typedefs.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 694,
    "kind": "typedef",
    "name": "CellId",
    "memberof": "src/models/model-typedefs.js",
    "static": true,
    "longname": "src/models/model-typedefs.js~CellId",
    "access": "public",
    "description": "A unique identifier number of a cell on the grid. In classic CPM language, this is often\nreferred to as 'type', but we use cellid to prevent confusion with the biological meaning\nof 'celltype' (which we call {@link CellKind} to prevent confusion).\n\nThe cellid must be a positive integer. The number 0 is reserved for the background.",
    "type": {
      "types": [
        "number"
      ],
      "optional": false,
      "name": "CellId"
    }
  },
  {
    "__docId__": 695,
    "kind": "typedef",
    "name": "CellKind",
    "memberof": "src/models/model-typedefs.js",
    "static": true,
    "longname": "src/models/model-typedefs.js~CellKind",
    "access": "public",
    "description": "Index specifying the 'kind' of cell we are dealing with. This corresponds to the biological\nidea of a 'celltype'; so the CPM parameters used depend on the cellkind. Convention is that\nwe store CPM parameters in number arrays param = number[], where param[i] is the parameter\nvalue for cellkind i. \n\nThis way, we can have multiple cells (each with their own {@link CellId}) of the same \"cellkind\", that\nget the same parameters (e.g. the same target volume). But we can also have multiple\ncellkinds on the grid, e.g. a small and a large cellkind.\n\nThe cellkind must be a positive integer. The number 0 is reserved for the background.",
    "type": {
      "types": [
        "number"
      ],
      "optional": false,
      "name": "CellKind"
    }
  },
  {
    "__docId__": 696,
    "kind": "file",
    "name": "src/simulation/Simulation.js",
    "content": "import CPM from \"../models/CPM.js\"\nimport CPMEvol from \"../models/CPMEvol.js\"\nimport Canvas from \"../Canvas.js\"\nimport GridManipulator from \"../grid/GridManipulator.js\"\nimport CentroidsWithTorusCorrection from \"../stats/CentroidsWithTorusCorrection.js\"\nimport Centroids from \"../stats/Centroids.js\"\n\n/** \nThis class provides some boilerplate code for creating simulations easily.\nIt comes with defaults for seeding cells, drawing, logging of statistics, saving output\nimages, and running the simulation. Each of these default methods can be overwritten\nby the user while keeping the other default methods intact. See the {@link Simulation#constructor}\nfor details on how to configure a simulation.\n@see ../examples\n*/\nclass Simulation {\n\t/** The constructor of class Simulation takes two arguments.\n\t\t@param {object} config - overall configuration settings. This is an object\n\t\twith multiple entries, see below.\n\t\t@param {GridSize} config.field_size - size of the CPM to build.\n\t \t@param {Constraint[]} config.constraints - array of additional\n\t \t\tconstraints to add to the CPM model.\n\t\t@param {object} config.conf - configuration settings for the CPM;\n\t\tsee its {@link CPM#constructor} for details.\n\t\t@param {object} simsettings - configuration settings for the simulation \n\t\titself and for controlling the outputs. See the parameters below for details.\n\t\t@param {number[]} simsettings.NRCELLS - array with number of cells to seed for\n\t\t\tevery non-background {@link CellKind}.\n\t\t@param {number} simsettings.BURNIN - number of MCS to run before the actual\n\t\t\tsimulation starts (let cells get their target volume before starting).\n\t\t@param {number} simsettings.RUNTIME - number of MCS the simulation should run.\n\t\t\tOnly necessary if you plan to use the {@link run} method.\n\t\t@param {number} [ simsettings.IMGFRAMERATE = 1 ]- draw the grid every [x] MCS.\n\t\t@param {number} [ simsettings.LOGRATE = 1 ] - log stats every [x] MCS.\n\t\t@param {object} [ simsettings.LOGSTATS = {browser:false,node:true} ] - \n\t\t\twhether stats should be logged in browser and node.\n\t\t@param {boolean} [ simsettings.SAVEIMG = false ] - should images be saved? (node only).\n\t\t@param {string} [ simsettings.SAVEPATH ] - where should images be saved? You only have\n\t\t\tto give this argument when SAVEIMG = true. \n\t\t@param {string} [ simsettings.EXPNAME = \"myexp\" ] - string used to construct the\n\t\t\tfilename of any saved image. \n\t\t@param {HexColor} [ simsettings.CANVASCOLOR = \"FFFFFF\" ] - color to draw the background in; defaults to white.\n\t\t@param {HexColor[]} [ simsettings.CELLCOLOR ] - color to draw each non-background \n\t\t\t{@link CellKind} in. If left unspecified, the {@link Canvas} will use black.\n\t\t@param {boolean[]} [simsettings.ACTCOLOR ] - should activities of the {@link ActivityConstraint}\n\t\t\tbe drawn for each {@link CellKind}? If left unspecified, these are not drawn.\n\t\t@param {boolean[]} [simsettings.SHOWBORDERS = false] - should borders of each {@link CellKind}\n\t\t\tbe drawn? Defaults to false.\n\t\t@param {HexColor[]} [simsettings.BORDERCOL = \"000000\"] - color to draw cellborders of\n\t\t\teach {@link CellKind} in. Defaults to black. \n\t\t*/\n\tconstructor( config, custommethods ){\n\n\t\t/** To check from outside if an object is a Simulation; doing this with\n\t\t * instanceof doesn't work in some cases. Any other object will\n\t\t * not have this variable and return 'undefined', which in an\n\t\t * if-statement equates to a 'false'.\n\t\t * @type{boolean}*/\n\t\tthis.isSimulation = true\n\n\t\t// ========= configuration and custom methods\n\n\t\t/** Custom methods added to / overwriting the default Simulation class.\n\t\t * These are stored so that the ArtistooImport can check them.\n\t\t@type {object}*/\n\t\tthis.custommethods = custommethods || {}\n\t\n\t\t// overwrite default method if methods are supplied in custommethods\n\t\t// these can be initializeGrid(), drawCanvas(), logStats(),\n\t\t// postMCSListener().\n\t\tfor( let m of Object.keys( this.custommethods ) ){\n\t\t\n\t\t\t/** Any function suplied in the custommethods argument to\n\t\t\tthe {@link constructor} is bound to the object. */\n\t\t\tthis[m] = this.custommethods[m]\n\t\t}\n\t\t\n\t\t/** Configuration of the simulation environment \n\t\t@type {object}*/\n\t\tthis.conf = config.simsettings\n\t\t\n\t\t// ========= controlling outputs\n\t\t\n\t\t/** Draw the canvas every [rate] MCS.\n\t\t@type {number}*/\n\t\tthis.imgrate = this.conf[\"IMGFRAMERATE\"] || 1\n\t\t\n\t\t/** Log stats every [rate] MCS.\n\t\t@type {number}*/\n\t\tthis.lograte = this.conf[\"LOGRATE\"] || 1\n\t\t\n\t\t/** See if code is run in browser or via node, which will be used\n\t\t\tbelow to determine what the output should be.\n\t\t\t@type {string}*/\n\t\tthis.mode = \"node\"\n\t\tif( typeof window !== \"undefined\" && typeof window.document !== \"undefined\" ){\n\t\t\t\n\t\t\tthis.mode = \"browser\"\n\t\t} \n\t\t\n\t\t/** Log stats or not.\n\t\t@type {boolean}*/\n\t\tthis.logstats = false\n\t\t\n\t\t/** Log stats or not, specified for both browser and node mode.\n\t\t@type {object} */\n\t\tthis.logstats2 = this.conf[\"STATSOUT\"] || { browser: false, node: true }\n\t\t\n\t\t\n\t\tthis.logstats = this.logstats2[this.mode]\n\t\t\n\t\t/** Saving images or not.\n\t\t@type {boolean}*/\n\t\tthis.saveimg = this.conf[\"SAVEIMG\"] || false\n\t\t/** Where to save images.\n\t\t@type {string}*/\n\t\tthis.savepath = this.conf[\"SAVEPATH\"] || \"undefined\"\n\t\t\n\t\tif( this.saveimg && this.savepath === \"undefined\" ){\n\t\t\tthrow( \"You need to specify the SAVEPATH option in the configuration object of your simulation!\")\n\t\t}\n\t\t\n\t\t// ========= tracking simulation progress\n\t\t\n\t\t/** Track the time of the simulation. \n\t\t@type {number}*/\n\t\tthis.time = 0\n\t\t\n\t\t/** Should the simulation be running? Change this to pause;\n\t\tsee the {@link toggleRunning} method.\n\t\t@private\n\t\t@type {boolean}*/\n\t\tthis.running = true\n\t\t\n\t\t// ========= Attached objects\n\t\t\n\t\t/** Make CPM object based on configuration settings and attach it.\n\t\t@type {CPM} */\n\t\tif (((config || {}).conf || {})[\"CELLS\"] !== undefined){\n\t\t\tthis.C = new CPMEvol( config.field_size, config.conf )\n\t\t} else {\n\t\t\tthis.C = new CPM( config.field_size, config.conf )\n\t\t}\n\t\t\t\t\n\t\t/** See if objects of class {@link Canvas} and {@link GridManipulator} already \n\t\texist. These are added automatically when required. This will set\n\t\ttheir values in helpClasses to 'true', so they don't have to be added again.\n\t\t@type {object}*/ \n\t\tthis.helpClasses = { gm: false, canvas: false }\n\n\t\t/** Add additional constraints.\n\t\t * @type {Constraint[]}\n\t\t * */\n\t\tthis.constraints = config.constraints || []\n\t\tthis.addConstraints()\n\n\t\t// ========= Begin.\n\t\t// Initialize the grid and run the burnin.\n\t\tthis.initializeGrid()\n\t\tthis.runBurnin()\n\t\t\n\t}\n\n\t/** Adds a {@link GridManipulator} object when required. */\n\taddGridManipulator(){\n\t\t/** Attached {@link GridManipulator} object.\n\t\t@type {GridManipulator}*/\n\t\tthis.gm = new GridManipulator( this.C )\n\t\tthis.helpClasses[ \"gm\" ] = true\n\t}\n\t\n\t/** Adds a {@link Canvas} object when required. */\n\taddCanvas(){\n\t\t//let zoom = this.conf.zoom || 2\n\t\t/** Attached {@link Canvas} object.\n\t\t@type {Canvas}*/\n\t\tthis.Cim = new Canvas( this.C, this.conf )\n\t\tthis.helpClasses[ \"canvas\" ] = true\n\t}\n\n\t/** Add additional constraints to the model before running; this\n\t * method is automatically called and adds constraints given in\n\t * the config object. */\n\taddConstraints(){\n\t\tfor( let constraint of this.constraints ){\n\t\t\tthis.C.add( constraint )\n\t\t}\n\t}\n\t\n\t/** Method to initialize the Grid should be implemented in each simulation. \n\tThe default method checks in the simsettings.NRCELLS array how many cells to\n\tseed for each {@CellKind}, and does this (at random positions). \n\t\n\tOften you'll want to do other things here. In that case you can use the \n\tcustommethods argument of the {@link constructor} to overwrite this with your\n\town initializeGrid method.\n\t*/\n\tinitializeGrid(){\n\t\n\t\t// add the initializer if not already there\n\t\tif( !this.helpClasses[\"gm\"] ){ this.addGridManipulator() }\n\n\t\t// reset C and clear cache (important if this method is called\n\t\t// again later in the sim).\n\t\tthis.C.reset()\n\n\t\tlet nrcells = this.conf[\"NRCELLS\"], cellkind, i\n\t\t\n\t\t// Seed the right number of cells for each cellkind\n\t\tfor( cellkind = 0; cellkind < nrcells.length; cellkind ++ ){\n\t\t\t\n\t\t\tfor( i = 0; i < nrcells[cellkind]; i++ ){\n\t\t\t\t// first cell always at the midpoint. Any other cells\n\t\t\t\t// randomly.\t\t\t\t\n\t\t\t\t\n\t\t\t\tthis.gm.seedCell( cellkind+1 )\n\t\t\t\t\n\t\t\t}\n\t\t}\n\n\n\t}\n\t\n\t/** Run the brunin period as defined by simsettings.BURNIN : run this number\n\tof MCS before the {@link time} of this simulation object starts ticking, and \n\tbefore we start drawing etc. \n\t*/\t\n\trunBurnin(){\n\t\t// Simulate the burnin phase\n\t\tlet burnin = this.conf[\"BURNIN\"] || 0\n\t\tfor( let i = 0; i < burnin; i++ ){\n\t\t\tthis.C.monteCarloStep()\n\t\t}\n\t}\n\n\t\n\t/** Method to draw the canvas.\n\tThe default method draws the canvas, cells, cellborders, and activityvalues\n\tas specified in the simsettings object (see the {@link constructor} for details).\n\t\n\tThis will be enough for most scenarios, but if you want to draw more complicated stuff,\n\tyou can use the custommethods argument of the {@link constructor} to overwrite \n\tthis with your own drawCanvas method.\n\t*/\n\tdrawCanvas(){\n\t\n\t\t// Add the canvas if required\n\t\tif( !this.helpClasses[\"canvas\"] ){ this.addCanvas() }\n\t\n\t\t// Clear canvas and draw stroma border\n\t\tthis.Cim.clear( this.conf[\"CANVASCOLOR\"] || \"FFFFFF\" )\n\n\n\t\t// Call the drawBelow method for if it is defined. \n\t\tthis.drawBelow()\n\n\t\t// Draw each cellkind appropriately\n\t\tlet cellcolor=( this.conf[\"CELLCOLOR\"] || [] ), actcolor=this.conf[\"ACTCOLOR\"], \n\t\t\tnrcells=this.conf[\"NRCELLS\"], cellkind, cellborders = this.conf[\"SHOWBORDERS\"]\n\t\tfor( cellkind = 0; cellkind < nrcells.length; cellkind ++ ){\n\t\t\n\t\t\t// draw the cells of each kind in the right color\n\t\t\tif( cellcolor[ cellkind ] !== -1 ){\n\t\t\t\tthis.Cim.drawCells( cellkind+1, cellcolor[cellkind] )\n\t\t\t}\n\t\t\t\n\t\t\t// Draw borders if required\n\t\t\tif(  this.conf.hasOwnProperty(\"SHOWBORDERS\") && cellborders[ cellkind  ] ){\n\t\t\t\tlet bordercol = \"000000\"\n\t\t\t\tif( this.conf.hasOwnProperty(\"BORDERCOL\") ){\n\t\t\t\t\tbordercol = this.conf[\"BORDERCOL\"][cellkind] || \"000000\"\n\t\t\t\t}\n\t\t\t\tthis.Cim.drawCellBorders( cellkind+1, bordercol )\n\t\t\t}\n\t\t\t\n\t\t\t// if there is an activity constraint, draw activity values depending on color.\n\t\t\tif( this.C.conf[\"LAMBDA_ACT\"] !== undefined && this.C.conf[\"LAMBDA_ACT\"][ cellkind + 1 ] > 0 ){ //this.constraints.hasOwnProperty( \"ActivityConstraint\" ) ){\n\t\t\t\tlet colorAct\n\t\t\t\tif( typeof actcolor !== \"undefined\" ){\n\t\t\t\t\tcolorAct = actcolor[ cellkind ] || false\n\t\t\t\t} else {\n\t\t\t\t\tcolorAct = false\n\t\t\t\t}\n\t\t\t\tif( ( colorAct ) ){\n\t\t\t\t\tthis.Cim.drawActivityValues( cellkind + 1 )//, this.constraints[\"ActivityConstraint\"] )\n\t\t\t\t}\t\t\t\n\t\t\t}\n\n\t\t}\n\t\t\n\t\t// Call the drawOnTop() method for if it is defined. \n\t\tthis.drawOnTop()\n\t\t\n\t}\n\t\n\t/** Methods drawBelow and {@link drawOnTop} allow you to draw extra stuff below and\n\ton top of the output from {@link drawCanvas}, respectively. You can use them if you\n\twish to visualize additional properties but don't want to remove the standard visualization.\n\tThey are called at the beginning and end of {@link drawCanvas}, so they do not work\n\tif you overwrite this method. \n\t*/\n\tdrawBelow(){\n\t\n\t}\n\t\n\t/** Methods drawBelow and {@link drawOnTop} allow you to draw extra stuff below and\n\ton top of the output from {@link drawCanvas}, respectively. You can use them if you\n\twish to visualize additional properties but don't want to remove the standard visualization.\n\tThey are called at the beginning and end of {@link drawCanvas}, so they do not work\n\tif you overwrite this method. \n\t*/\n\tdrawOnTop(){\n\t\n\t}\n\t\n\t\n\t/** Method to log statistics.\n\tThe default method logs time, {@link CellId}, {@link CellKind}, and the \n\t{@ArrayCoordinate} of the cell's centroid to the console.\n\t\n\tIf you want to compute other stats (see subclasses of {@link Stat} for options)\n\tyou can use the custommethods argument of the {@link constructor} to overwrite \n\tthis with your own drawCanvas method.\n\t*/\n\tlogStats(){\n\t\t\n\t\t// compute centroids for all cells\n\t\tlet allcentroids \n\t\tlet torus = false\n\t\tfor( let d = 0; d < this.C.grid.ndim; d++ ){\n\t\t\tif( this.C.grid.torus[d] ){\n\t\t\t\ttorus = true\n\t\t\t}\n\t\t}\n\t\tif( torus ){\n\t\t\tallcentroids = this.C.getStat( CentroidsWithTorusCorrection )\n\t\t} else {\n\t\t\tallcentroids = this.C.getStat( Centroids )\n\t\t} \n\t\t\n\t\tfor( let cid of this.C.cellIDs() ){\n\t\t\n\t\t\tlet thecentroid = allcentroids[cid]\n\t\t\t\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.log( this.time + \"\\t\" + cid + \"\\t\" + \n\t\t\t\tthis.C.cellKind(cid) + \"\\t\" + thecentroid.join(\"\\t\") )\n\t\t\t\n\t\t}\n\n\t}\n\t\n\t/** Listener for something that needs to be done after every monte carlo step.\n\tThis method is empty but can be overwritten via the custommethods \n\targument of the {@link constructor}.*/\n\tpostMCSListener(){\n\t\n\t}\n\t\n\t/** This automatically creates all outputs (images and logged stats) at the correct\n\trates. See the {@link constructor} documentation for options on how to control these\n\toutputs. */\n\tcreateOutputs(){\n\t\t// Draw the canvas every IMGFRAMERATE steps\n\t\tif( this.imgrate > 0 && this.time % this.imgrate == 0 ){\n\t\t\t\n\t\t\tif( this.mode == \"browser\" ){\n\t\t\t\tthis.drawCanvas()\n\t\t\t}\n\t\t\t\n\t\t\t// Save the image if required and if we're in node (not possible in browser)\n\t\t\tif( this.mode == \"node\" && this.saveimg ){\n\t\t\t\tthis.drawCanvas()\n\t\t\t\tlet outpath = this.conf[\"SAVEPATH\"], expname = this.conf[\"EXPNAME\"] || \"mysim\"\n\t\t\t\tthis.Cim.writePNG( outpath +\"/\" + expname + \"-t\"+this.time+\".png\" )\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Log stats every LOGRATE steps\n\t\tif( this.logstats && this.time % this.lograte == 0 ){\n\t\t\tthis.logStats()\n\t\t}\n\t}\n\t\n\t/** Run a montecarlostep, produce outputs if required, run any {@link postMCSListener},\n\tand update the time. */\n\tstep(){\n\t\tif( this.running ){\n\t\t\tthis.C.monteCarloStep()\n\t\t\tthis.postMCSListener()\n\t\t\tthis.createOutputs()\n\t\t\tthis.time++\n\t\t}\n\t}\n\t\n\t/** Use this to pause or restart the simulation from an HTML page. */\n\ttoggleRunning(){\n\t\tthis.running = !this.running\n\t}\n\t\n\t/** Run the entire simulation. This function is meant for nodejs, as you'll\n\twant to perform individual {@link step}s in a requestAnimationFrame for an \n\tanimation in a HTML page. */\n\trun(){\n\t\twhile( this.time < this.conf[\"RUNTIME\"] ){\n\t\t\n\t\t\tthis.step()\n\t\t\t\n\t\t}\n\t}\n\t\n}\n\n\nexport default Simulation",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/simulation/Simulation.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 697,
    "kind": "class",
    "name": "Simulation",
    "memberof": "src/simulation/Simulation.js",
    "static": true,
    "longname": "src/simulation/Simulation.js~Simulation",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/simulation/Simulation.js",
    "importStyle": "Simulation",
    "description": "This class provides some boilerplate code for creating simulations easily.\nIt comes with defaults for seeding cells, drawing, logging of statistics, saving output\nimages, and running the simulation. Each of these default methods can be overwritten\nby the user while keeping the other default methods intact. See the {@link Simulation#constructor}\nfor details on how to configure a simulation.",
    "see": [
      "../examples"
    ],
    "lineNumber": 16,
    "interface": false
  },
  {
    "__docId__": 698,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#constructor",
    "access": "public",
    "description": "The constructor of class Simulation takes two arguments.",
    "lineNumber": 52,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "config",
        "description": "overall configuration settings. This is an object\nwith multiple entries, see below."
      },
      {
        "nullable": null,
        "types": [
          "GridSize"
        ],
        "spread": false,
        "optional": false,
        "name": "config.field_size",
        "description": "size of the CPM to build."
      },
      {
        "nullable": null,
        "types": [
          "Constraint[]"
        ],
        "spread": false,
        "optional": false,
        "name": "config.constraints",
        "description": "array of additional\nconstraints to add to the CPM model."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "config.conf",
        "description": "configuration settings for the CPM;\nsee its {@link CPM#constructor} for details."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "simsettings",
        "description": "configuration settings for the simulation \nitself and for controlling the outputs. See the parameters below for details."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "simsettings.NRCELLS",
        "description": "array with number of cells to seed for\nevery non-background {@link CellKind}."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "simsettings.BURNIN",
        "description": "number of MCS to run before the actual\nsimulation starts (let cells get their target volume before starting)."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "simsettings.RUNTIME",
        "description": "number of MCS the simulation should run.\nOnly necessary if you plan to use the {@link run} method."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " 1 ",
        "defaultRaw": 1,
        "name": "simsettings.IMGFRAMERATE",
        "description": "draw the grid every [x] MCS."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " 1 ",
        "defaultRaw": 1,
        "name": "simsettings.LOGRATE",
        "description": "log stats every [x] MCS."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " {browser:false,node:true} ",
        "defaultRaw": " {browser:false,node:true} ",
        "name": "simsettings.LOGSTATS",
        "description": "whether stats should be logged in browser and node."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " false ",
        "defaultRaw": false,
        "name": "simsettings.SAVEIMG",
        "description": "should images be saved? (node only)."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "simsettings.SAVEPATH",
        "description": "where should images be saved? You only have\nto give this argument when SAVEIMG = true."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " \"myexp\" ",
        "defaultRaw": "myexp",
        "name": "simsettings.EXPNAME",
        "description": "string used to construct the\nfilename of any saved image."
      },
      {
        "nullable": null,
        "types": [
          "HexColor"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " \"FFFFFF\" ",
        "defaultRaw": "FFFFFF",
        "name": "simsettings.CANVASCOLOR",
        "description": "color to draw the background in; defaults to white."
      },
      {
        "nullable": null,
        "types": [
          "HexColor[]"
        ],
        "spread": false,
        "optional": true,
        "name": "simsettings.CELLCOLOR",
        "description": "color to draw each non-background \n{@link CellKind} in. If left unspecified, the {@link Canvas} will use black."
      },
      {
        "nullable": null,
        "types": [
          "boolean[]"
        ],
        "spread": false,
        "optional": true,
        "name": "simsettings.ACTCOLOR",
        "description": "should activities of the {@link ActivityConstraint}\nbe drawn for each {@link CellKind}? If left unspecified, these are not drawn."
      },
      {
        "nullable": null,
        "types": [
          "boolean[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " false",
        "defaultRaw": false,
        "name": "simsettings.SHOWBORDERS",
        "description": "should borders of each {@link CellKind}\nbe drawn? Defaults to false."
      },
      {
        "nullable": null,
        "types": [
          "HexColor[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " \"000000\"",
        "defaultRaw": "000000",
        "name": "simsettings.BORDERCOL",
        "description": "color to draw cellborders of\neach {@link CellKind} in. Defaults to black."
      }
    ]
  },
  {
    "__docId__": 699,
    "kind": "member",
    "name": "isSimulation",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#isSimulation",
    "access": "public",
    "description": "To check from outside if an object is a Simulation; doing this with\ninstanceof doesn't work in some cases. Any other object will\nnot have this variable and return 'undefined', which in an\nif-statement equates to a 'false'.\n@type{boolean}",
    "lineNumber": 59,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 700,
    "kind": "member",
    "name": "custommethods",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#custommethods",
    "access": "public",
    "description": "Custom methods added to / overwriting the default Simulation class.\nThese are stored so that the ArtistooImport can check them.",
    "lineNumber": 66,
    "type": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 701,
    "kind": "member",
    "name": "[m]",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#[m]",
    "access": "public",
    "description": "Any function suplied in the custommethods argument to\nthe {@link constructor} is bound to the object.",
    "lineNumber": 75,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 702,
    "kind": "member",
    "name": "conf",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#conf",
    "access": "public",
    "description": "Configuration of the simulation environment ",
    "lineNumber": 80,
    "type": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 703,
    "kind": "member",
    "name": "imgrate",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#imgrate",
    "access": "public",
    "description": "Draw the canvas every [rate] MCS.",
    "lineNumber": 86,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 704,
    "kind": "member",
    "name": "lograte",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#lograte",
    "access": "public",
    "description": "Log stats every [rate] MCS.",
    "lineNumber": 90,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 705,
    "kind": "member",
    "name": "mode",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#mode",
    "access": "public",
    "description": "See if code is run in browser or via node, which will be used\nbelow to determine what the output should be.",
    "lineNumber": 95,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 707,
    "kind": "member",
    "name": "logstats",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#logstats",
    "access": "public",
    "description": "Log stats or not.",
    "lineNumber": 103,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 708,
    "kind": "member",
    "name": "logstats2",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#logstats2",
    "access": "public",
    "description": "Log stats or not, specified for both browser and node mode.",
    "lineNumber": 107,
    "type": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 710,
    "kind": "member",
    "name": "saveimg",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#saveimg",
    "access": "public",
    "description": "Saving images or not.",
    "lineNumber": 114,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 711,
    "kind": "member",
    "name": "savepath",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#savepath",
    "access": "public",
    "description": "Where to save images.",
    "lineNumber": 117,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 712,
    "kind": "member",
    "name": "time",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#time",
    "access": "public",
    "description": "Track the time of the simulation. ",
    "lineNumber": 127,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 713,
    "kind": "member",
    "name": "running",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#running",
    "access": "private",
    "description": "Should the simulation be running? Change this to pause;\nsee the {@link toggleRunning} method.",
    "lineNumber": 133,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 714,
    "kind": "member",
    "name": "C",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#C",
    "access": "public",
    "description": null,
    "lineNumber": 140,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 716,
    "kind": "member",
    "name": "helpClasses",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#helpClasses",
    "access": "public",
    "description": "See if objects of class {@link Canvas} and {@link GridManipulator} already \nexist. These are added automatically when required. This will set\ntheir values in helpClasses to 'true', so they don't have to be added again.",
    "lineNumber": 149,
    "type": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 717,
    "kind": "member",
    "name": "constraints",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#constraints",
    "access": "public",
    "description": null,
    "lineNumber": 154,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 718,
    "kind": "method",
    "name": "addGridManipulator",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#addGridManipulator",
    "access": "public",
    "description": "Adds a {@link GridManipulator} object when required.",
    "lineNumber": 165,
    "params": [],
    "return": null
  },
  {
    "__docId__": 719,
    "kind": "member",
    "name": "gm",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#gm",
    "access": "public",
    "description": "Attached {@link GridManipulator} object.",
    "lineNumber": 168,
    "type": {
      "nullable": null,
      "types": [
        "GridManipulator"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 720,
    "kind": "method",
    "name": "addCanvas",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#addCanvas",
    "access": "public",
    "description": "Adds a {@link Canvas} object when required.",
    "lineNumber": 173,
    "params": [],
    "return": null
  },
  {
    "__docId__": 721,
    "kind": "member",
    "name": "Cim",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#Cim",
    "access": "public",
    "description": "Attached {@link Canvas} object.",
    "lineNumber": 177,
    "type": {
      "nullable": null,
      "types": [
        "Canvas"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 722,
    "kind": "method",
    "name": "addConstraints",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#addConstraints",
    "access": "public",
    "description": "Add additional constraints to the model before running; this\nmethod is automatically called and adds constraints given in\nthe config object.",
    "lineNumber": 184,
    "params": [],
    "return": null
  },
  {
    "__docId__": 723,
    "kind": "method",
    "name": "initializeGrid",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#initializeGrid",
    "access": "public",
    "description": "Method to initialize the Grid should be implemented in each simulation. \nThe default method checks in the simsettings.NRCELLS array how many cells to\nseed for each {@CellKind}, and does this (at random positions). \n\nOften you'll want to do other things here. In that case you can use the \ncustommethods argument of the {@link constructor} to overwrite this with your\nown initializeGrid method.",
    "lineNumber": 198,
    "params": [],
    "return": null
  },
  {
    "__docId__": 724,
    "kind": "method",
    "name": "runBurnin",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#runBurnin",
    "access": "public",
    "description": "Run the brunin period as defined by simsettings.BURNIN : run this number\nof MCS before the {@link time} of this simulation object starts ticking, and \nbefore we start drawing etc. ",
    "lineNumber": 228,
    "params": [],
    "return": null
  },
  {
    "__docId__": 725,
    "kind": "method",
    "name": "drawCanvas",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#drawCanvas",
    "access": "public",
    "description": "Method to draw the canvas.\nThe default method draws the canvas, cells, cellborders, and activityvalues\nas specified in the simsettings object (see the {@link constructor} for details).\n\nThis will be enough for most scenarios, but if you want to draw more complicated stuff,\nyou can use the custommethods argument of the {@link constructor} to overwrite \nthis with your own drawCanvas method.",
    "lineNumber": 245,
    "params": [],
    "return": null
  },
  {
    "__docId__": 726,
    "kind": "method",
    "name": "drawBelow",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#drawBelow",
    "access": "public",
    "description": "Methods drawBelow and {@link drawOnTop} allow you to draw extra stuff below and\non top of the output from {@link drawCanvas}, respectively. You can use them if you\nwish to visualize additional properties but don't want to remove the standard visualization.\nThey are called at the beginning and end of {@link drawCanvas}, so they do not work\nif you overwrite this method. ",
    "lineNumber": 302,
    "params": [],
    "return": null
  },
  {
    "__docId__": 727,
    "kind": "method",
    "name": "drawOnTop",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#drawOnTop",
    "access": "public",
    "description": "Methods drawBelow and {@link drawOnTop} allow you to draw extra stuff below and\non top of the output from {@link drawCanvas}, respectively. You can use them if you\nwish to visualize additional properties but don't want to remove the standard visualization.\nThey are called at the beginning and end of {@link drawCanvas}, so they do not work\nif you overwrite this method. ",
    "lineNumber": 312,
    "params": [],
    "return": null
  },
  {
    "__docId__": 728,
    "kind": "method",
    "name": "logStats",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#logStats",
    "access": "public",
    "description": "Method to log statistics.\nThe default method logs time, {@link CellId}, {@link CellKind}, and the \n{@ArrayCoordinate} of the cell's centroid to the console.\n\nIf you want to compute other stats (see subclasses of {@link Stat} for options)\nyou can use the custommethods argument of the {@link constructor} to overwrite \nthis with your own drawCanvas method.",
    "lineNumber": 325,
    "params": [],
    "return": null
  },
  {
    "__docId__": 729,
    "kind": "method",
    "name": "postMCSListener",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#postMCSListener",
    "access": "public",
    "description": "Listener for something that needs to be done after every monte carlo step.\nThis method is empty but can be overwritten via the custommethods \nargument of the {@link constructor}.",
    "lineNumber": 356,
    "params": [],
    "return": null
  },
  {
    "__docId__": 730,
    "kind": "method",
    "name": "createOutputs",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#createOutputs",
    "access": "public",
    "description": "This automatically creates all outputs (images and logged stats) at the correct\nrates. See the {@link constructor} documentation for options on how to control these\noutputs.",
    "lineNumber": 363,
    "params": [],
    "return": null
  },
  {
    "__docId__": 731,
    "kind": "method",
    "name": "step",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#step",
    "access": "public",
    "description": "Run a montecarlostep, produce outputs if required, run any {@link postMCSListener},\nand update the time.",
    "lineNumber": 387,
    "params": [],
    "return": null
  },
  {
    "__docId__": 732,
    "kind": "method",
    "name": "toggleRunning",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#toggleRunning",
    "access": "public",
    "description": "Use this to pause or restart the simulation from an HTML page.",
    "lineNumber": 397,
    "params": [],
    "return": null
  },
  {
    "__docId__": 734,
    "kind": "method",
    "name": "run",
    "memberof": "src/simulation/Simulation.js~Simulation",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/simulation/Simulation.js~Simulation#run",
    "access": "public",
    "description": "Run the entire simulation. This function is meant for nodejs, as you'll\nwant to perform individual {@link step}s in a requestAnimationFrame for an \nanimation in a HTML page.",
    "lineNumber": 404,
    "params": [],
    "return": null
  },
  {
    "__docId__": 735,
    "kind": "file",
    "name": "src/stats/BorderPixelsByCell.js",
    "content": "\nimport Stat from \"./Stat.js\"\nimport CPM from \"../models/CPM.js\"\n\n/**\tThis Stat creates a {@link CellArrayObject} with the border cellpixels of each cell on the grid. \n\tKeys are the {@link CellId} of cells on the grid, corresponding values are arrays\n\tcontaining the pixels belonging to that cell. Coordinates are stored as {@link ArrayCoordinate}.\n\t\n\t@example\n\t* let CPM = require( \"path/to/build\" )\n\t*\n\t* // Make a CPM, seed a cell, and get the BorderPixelsByCell\n\t* let C = new CPM.CPM( [100,100], { \n\t* \tT:20,\n\t* \tJ:[[0,20],[20,10]],\n\t* \tV:[0,200],\n\t* \tLAMBDA_V:[0,2]\n\t* } )\n\t* C.setpix( [50,50], 1 )\n\t* C.getStat( CPM.BorderPixelsByCell )\n*/\nclass BorderPixelsByCell extends Stat {\n\n\t/** The set model function of BorderPixelsByCell requires an object of type CPM.\n\t@param {CPM} M The CPM to compute cellborderpixels of.*/\n\tset model( M ){\n\t\tif( M instanceof CPM ){\n\t\t\t/** The CPM to compute borderpixels for.\n\t\t\t@type {CPM} */\n\t\t\tthis.M = M\n\t\t} else {\n\t\t\tthrow( \"The stat BorderPixelsByCell is only implemented for CPMs, where cellborderpixels are stored!\" )\n\t\t}\n\t\t\n\t}\n\n\t/** The compute method of BorderPixelsByCell creates an object with the borderpixels of\n\teach cell on the grid.\n\t@returns {CellArrayObject} An object with a key for each cell on the grid, and as\n\tcorresponding value an array with all the borderpixels of that \n\tcell. Each pixel is stored by its {@link ArrayCoordinate}.*/\n\tcompute(){\n\t\t// initialize the object\n\t\tlet cellborderpixels = { }\n\t\t\n\t\t// The this.M.cellBorderPixels() iterator returns coordinates and cellid for all \n\t\t// non-background pixels on the grid. See the appropriate Grid class for\n\t\t// its implementation.\n\t\tfor( let [p,i] of this.M.cellBorderPixels() ){\n\t\t\tif( !cellborderpixels[i] ){\n\t\t\t\tcellborderpixels[i] = [p]\n\t\t\t} else {\n\t\t\t\tcellborderpixels[i].push( p )\n\t\t\t}\n\t\t}\n\t\treturn cellborderpixels\n\t}\n}\n\nexport default BorderPixelsByCell\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/stats/BorderPixelsByCell.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 736,
    "kind": "class",
    "name": "BorderPixelsByCell",
    "memberof": "src/stats/BorderPixelsByCell.js",
    "static": true,
    "longname": "src/stats/BorderPixelsByCell.js~BorderPixelsByCell",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/stats/BorderPixelsByCell.js",
    "importStyle": "BorderPixelsByCell",
    "description": "This Stat creates a {@link CellArrayObject} with the border cellpixels of each cell on the grid. \nKeys are the {@link CellId} of cells on the grid, corresponding values are arrays\ncontaining the pixels belonging to that cell. Coordinates are stored as {@link ArrayCoordinate}.",
    "examples": [
      "let CPM = require( \"path/to/build\" )\n\n// Make a CPM, seed a cell, and get the BorderPixelsByCell\nlet C = new CPM.CPM( [100,100], { \n\tT:20,\n\tJ:[[0,20],[20,10]],\n\tV:[0,200],\n\tLAMBDA_V:[0,2]\n} )\nC.setpix( [50,50], 1 )\nC.getStat( CPM.BorderPixelsByCell )"
    ],
    "lineNumber": 22,
    "interface": false,
    "extends": [
      "src/stats/Stat.js~Stat"
    ]
  },
  {
    "__docId__": 737,
    "kind": "set",
    "name": "model",
    "memberof": "src/stats/BorderPixelsByCell.js~BorderPixelsByCell",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stats/BorderPixelsByCell.js~BorderPixelsByCell#model",
    "access": "public",
    "description": "The set model function of BorderPixelsByCell requires an object of type CPM.",
    "lineNumber": 26,
    "params": [
      {
        "nullable": null,
        "types": [
          "CPM"
        ],
        "spread": false,
        "optional": false,
        "name": "M",
        "description": "The CPM to compute cellborderpixels of."
      }
    ]
  },
  {
    "__docId__": 738,
    "kind": "member",
    "name": "M",
    "memberof": "src/stats/BorderPixelsByCell.js~BorderPixelsByCell",
    "static": false,
    "longname": "src/stats/BorderPixelsByCell.js~BorderPixelsByCell#M",
    "access": "public",
    "description": "The CPM to compute borderpixels for.",
    "lineNumber": 30,
    "type": {
      "nullable": null,
      "types": [
        "CPM"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 739,
    "kind": "method",
    "name": "compute",
    "memberof": "src/stats/BorderPixelsByCell.js~BorderPixelsByCell",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stats/BorderPixelsByCell.js~BorderPixelsByCell#compute",
    "access": "public",
    "description": "The compute method of BorderPixelsByCell creates an object with the borderpixels of\neach cell on the grid.",
    "lineNumber": 42,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{CellArrayObject} An object with a key for each cell on the grid, and as\ncorresponding value an array with all the borderpixels of that \ncell. Each pixel is stored by its {@link ArrayCoordinate}."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CellArrayObject"
      ],
      "spread": false,
      "description": "An object with a key for each cell on the grid, and as\ncorresponding value an array with all the borderpixels of that \ncell. Each pixel is stored by its {@link ArrayCoordinate}."
    },
    "params": []
  },
  {
    "__docId__": 740,
    "kind": "file",
    "name": "src/stats/CellNeighborList.js",
    "content": "\n\nimport Stat from \"./Stat.js\"\nimport BorderPixelsByCell from \"./PixelsByCell.js\"\nimport CPM from \"../models/CPM.js\"\n\n/** This stat computes a list of all cell ids of the cells that border to \"cell\" and \n\tbelong to a different cellid, also giving the interface length for each contact. \n\t@experimental \n\t@example\n\t* let CPM = require(\"path/to/build\")\n\t* \n\t* // Set up a CPM and manipulator\n\t* let C = new CPM.CPM( [300,300], {\n\t* \tT:20, \n\t* \ttorus:[false,false],\n\t* \tJ:[[0,20],[20,10]], \n\t* \tV:[0,200], \n\t* \tLAMBDA_V:[0,2]\n\t* })\n\t* let gm = new CPM.GridManipulator( C )\n\t* \n\t* // Seed a cells, run a little, then divide it\n\t* gm.seedCell(1)\n\t* for( let t = 0; t < 50; t++ ){\n\t* \tC.timeStep()\n\t* }\n\t* gm.divideCell(1)\n\t* \n\t* // Get neighborlist\n\t* console.log(  C.getStat( CPM.CellNeighborList ) )\t\n\t*/\t\nclass CellNeighborList extends Stat {\n\n\n\t/** The set model function of CellNeighborList requires an object of type CPM.\n\t@param {CPM} M The CPM to compute bordering cells for.*/\n\tset model( M ){\n\t\tif( M instanceof CPM ){\n\t\t\t/** The CPM to compute borderpixels for.\n\t\t\t@type {CPM} */\n\t\t\tthis.M = M\n\t\t} else {\n\t\t\tthrow( \"The stat CellNeighborList is only implemented for CPMs, where cellborderpixels are stored!\" )\n\t\t}\n\t\t\n\t}\n\n\t/** The getNeighborsOfCell method of CellNeighborList computes a list of all pixels\n\t\tthat border to \"cell\" and belong to a different cellid.\n\t\t@param {CellId} cellid the unique cell id of the cell to get neighbors from.\n\t\t@param {CellArrayObject} cellborderpixels object produced by {@link BorderPixelsByCell}, with keys for each cellid\n\t\tand as corresponding value the border pixel indices of their pixels.\n\t\t@returns {CellObject} a dictionairy with keys = neighbor cell ids, and \n\t\tvalues = number of neighbor cellpixels at the border.\n\t*/\n\tgetNeighborsOfCell( cellid, cellborderpixels ){\n\t\t\t\t\n\t\tlet neigh_cell_amountborder = { }\n\t\tlet cbp = cellborderpixels[cellid]\n\t\t\n\t\t//loop over border pixels of cell\n\t\tfor ( let cellpix = 0; cellpix < cbp.length; cellpix++ ) {\n\n\t\t\t//get neighbouring pixels of borderpixel of cell\n\t\t\tlet neighbours_of_borderpixel_cell = this.M.neigh( cbp[cellpix] )\n\n\t\t\t//don't add a pixel in cell more than twice\n\t\t\t//loop over neighbouring pixels and store the parent cell if it is different from\n\t\t\t//cell, add or increment the key corresponding to the neighbor in the dictionairy\n\t\t\tfor ( let neighborpix of neighbours_of_borderpixel_cell ) {\n\t\t\t\t\n\t\t\t\tlet neighbor_id = this.M.pixt( neighborpix )\n\n\t\t\t\tif (neighbor_id != cellid) {\n\t\t\t\t\tneigh_cell_amountborder[neighbor_id] = neigh_cell_amountborder[neighbor_id]+1 || 1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn neigh_cell_amountborder\n\n\t\n\t}\n\t\n\t/** The compute method of CellNeighborList computes for each cell on the grid \n\t\ta list of all pixels at its border that belong to a different cellid.\n\t\t@returns {CellObject} a dictionairy with keys = cell ids, and \n\t\tvalues = an object produced by {@link getNeighborsOfCell} (which has keys for each\n\t\tneighboring cellid and values the number of contacting pixels for that cell).\n\t*/\n\tcompute(){\n\t\t\n\t\tlet cellborderpixels = this.M.getStat( BorderPixelsByCell )\n\t\tlet neighborlist = {}\n\t\t\n\t\t// the this.M.cellIDs() iterator returns non-background cellids on the grid.\n\t\tfor( let i of this.M.cellIDs() ){\n\t\t\tneighborlist[i] = this.getNeighborsOfCell( i, cellborderpixels )\n\t\t}\n\t\t\n\t\treturn neighborlist\n\n\t}\n}\n\nexport default CellNeighborList\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/stats/CellNeighborList.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 741,
    "kind": "class",
    "name": "CellNeighborList",
    "memberof": "src/stats/CellNeighborList.js",
    "static": true,
    "longname": "src/stats/CellNeighborList.js~CellNeighborList",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/stats/CellNeighborList.js",
    "importStyle": "CellNeighborList",
    "description": "This stat computes a list of all cell ids of the cells that border to \"cell\" and \nbelong to a different cellid, also giving the interface length for each contact. ",
    "examples": [
      "let CPM = require(\"path/to/build\")\n\n// Set up a CPM and manipulator\nlet C = new CPM.CPM( [300,300], {\n\tT:20, \n\ttorus:[false,false],\n\tJ:[[0,20],[20,10]], \n\tV:[0,200], \n\tLAMBDA_V:[0,2]\n})\nlet gm = new CPM.GridManipulator( C )\n\n// Seed a cells, run a little, then divide it\ngm.seedCell(1)\nfor( let t = 0; t < 50; t++ ){\n\tC.timeStep()\n}\ngm.divideCell(1)\n\n// Get neighborlist\nconsole.log(  C.getStat( CPM.CellNeighborList ) )\t"
    ],
    "lineNumber": 33,
    "experimental": true,
    "interface": false,
    "extends": [
      "src/stats/Stat.js~Stat"
    ]
  },
  {
    "__docId__": 742,
    "kind": "set",
    "name": "model",
    "memberof": "src/stats/CellNeighborList.js~CellNeighborList",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stats/CellNeighborList.js~CellNeighborList#model",
    "access": "public",
    "description": "The set model function of CellNeighborList requires an object of type CPM.",
    "lineNumber": 38,
    "params": [
      {
        "nullable": null,
        "types": [
          "CPM"
        ],
        "spread": false,
        "optional": false,
        "name": "M",
        "description": "The CPM to compute bordering cells for."
      }
    ]
  },
  {
    "__docId__": 743,
    "kind": "member",
    "name": "M",
    "memberof": "src/stats/CellNeighborList.js~CellNeighborList",
    "static": false,
    "longname": "src/stats/CellNeighborList.js~CellNeighborList#M",
    "access": "public",
    "description": "The CPM to compute borderpixels for.",
    "lineNumber": 42,
    "type": {
      "nullable": null,
      "types": [
        "CPM"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 744,
    "kind": "method",
    "name": "getNeighborsOfCell",
    "memberof": "src/stats/CellNeighborList.js~CellNeighborList",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stats/CellNeighborList.js~CellNeighborList#getNeighborsOfCell",
    "access": "public",
    "description": "The getNeighborsOfCell method of CellNeighborList computes a list of all pixels\nthat border to \"cell\" and belong to a different cellid.",
    "lineNumber": 57,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{CellObject} a dictionairy with keys = neighbor cell ids, and \nvalues = number of neighbor cellpixels at the border."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "cellid",
        "description": "the unique cell id of the cell to get neighbors from."
      },
      {
        "nullable": null,
        "types": [
          "CellArrayObject"
        ],
        "spread": false,
        "optional": false,
        "name": "cellborderpixels",
        "description": "object produced by {@link BorderPixelsByCell}, with keys for each cellid\nand as corresponding value the border pixel indices of their pixels."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CellObject"
      ],
      "spread": false,
      "description": "a dictionairy with keys = neighbor cell ids, and \nvalues = number of neighbor cellpixels at the border."
    }
  },
  {
    "__docId__": 745,
    "kind": "method",
    "name": "compute",
    "memberof": "src/stats/CellNeighborList.js~CellNeighborList",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stats/CellNeighborList.js~CellNeighborList#compute",
    "access": "public",
    "description": "The compute method of CellNeighborList computes for each cell on the grid \na list of all pixels at its border that belong to a different cellid.",
    "lineNumber": 91,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{CellObject} a dictionairy with keys = cell ids, and \nvalues = an object produced by {@link getNeighborsOfCell} (which has keys for each\nneighboring cellid and values the number of contacting pixels for that cell)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CellObject"
      ],
      "spread": false,
      "description": "a dictionairy with keys = cell ids, and \nvalues = an object produced by {@link getNeighborsOfCell} (which has keys for each\nneighboring cellid and values the number of contacting pixels for that cell)."
    },
    "params": []
  },
  {
    "__docId__": 746,
    "kind": "file",
    "name": "src/stats/Centroids.js",
    "content": "\n\nimport Stat from \"./Stat.js\"\nimport PixelsByCell from \"./PixelsByCell.js\"\n\n/**\tThis Stat computes the centroid of a cell. When the cell resides on a torus, the\n\tcentroid may be well outside the cell, and other stats may be preferable (e.g.\n\t{@link CentroidsWithTorusCorrection}).\n\t\n\t@example\n\t* let CPM = require( \"path/to/build\" )\n\t*\n\t* // Make a CPM, seed two cells, run a little, and get their centroids\n\t* let C = new CPM.CPM( [100,100], { \n\t* \tT:20,\n\t*\ttorus:[false,false],\n\t* \tJ:[[0,20],[20,10]],\n\t* \tV:[0,200],\n\t* \tLAMBDA_V:[0,2]\n\t* } )\n\t* let gm = new CPM.GridManipulator( C )\n\t* gm.seedCell(1)\n\t* gm.seedCell(1)\n\t* for( let t = 0; t < 100; t++ ){ C.timeStep() }\n\t*\n\t* C.getStat( CPM.Centroids ) \n*/\nclass Centroids extends Stat {\n\n\t/** The set model method of class CentroidsWithTorusCorrection.\n\t@param {GridBasedModel} M - the model to compute centroids on. */\n\tset model( M ){\n\t\n\t\t/** The model to compute centroids on. \n\t\t@type {GridBasedModel}*/\n\t\tthis.M = M\n\t\t\n\t\t/* Check if the grid has a torus; if so, warn that this method may not be\n\t\tappropriate. */\n\t\tlet torus = false\n\t\tfor( let d = 0; d < this.M.ndim; d++ ){\n\t\t\tif( this.M.grid.torus[d] ){\n\t\t\t\ttorus = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(torus){\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.warn( \"Your model grid has a torus, and the 'Centroids' stat is not compatible with torus! Consider using 'CentroidsWithTorusCorrection' instead.\" )\n\t\t}\n\t\t\n\t\t// Half the grid dimensions; if pixels with the same cellid are further apart,\n\t\t// we assume they are on the border of the grid and that we need to correct\n\t\t// their positions to compute the centroid.\n\t\t/** @ignore */\n\t\tthis.halfsize = new Array( this.M.ndim).fill(0)\n\t\tfor( let i = 0 ; i < this.M.ndim ; i ++ ){\n\t\t\tthis.halfsize[i] = this.M.extents[i]/2\n\t\t}\n\t}\n\t/** @ignore */\n\tconstructor( conf ){\n\t\tsuper(conf)\n\t}\n\t/** This method computes the centroid of a specific cell. \n\t\t@param {CellId} cellid the unique cell id of the cell to get centroid of.\n\t\t@param {CellArrayObject} cellpixels object produced by {@link PixelsByCell}, \n\t\twith keys for each cellid\n\t\tand as corresponding value the pixel coordinates of their pixels.\n\t\t@returns {ArrayCoordinate} coordinate of the centroid.\n\t*/\n\tcomputeCentroidOfCell( cellid, cellpixels  ){\n\t\n\t\t//let cellpixels = this.M.getStat( PixelsByCell ) \n\t\n\t\tconst pixels = cellpixels[ cellid ]\n\t\t\n\t\t// cvec will contain the x, y, (z) coordinate of the centroid.\n\t\t// Loop over the dimensions to compute each element separately.\n\t\tlet cvec = new Array(this.M.ndim).fill(0)\n\t\tfor( let dim = 0 ; dim < this.M.ndim ; dim ++ ){\n\t\t\t\n\t\t\tlet mi = 0.\n\t\t\t// Loop over the pixels;\n\t\t\t// compute mean position per dimension with online algorithm\n\t\t\tfor( let j = 0 ; j < pixels.length ; j ++ ){\n\t\t\t\t// Check distance of current pixel to the accumulated mean in this dim.\n\t\t\t\t// Check if this distance is greater than half the grid size in this\n\t\t\t\t// dimension; if so, this indicates that the cell has moved to the\n\t\t\t\t// other end of the grid because of the torus. Note that this only\n\t\t\t\t// holds AFTER the first pixel (so for j > 0), when we actually have\n\t\t\t\t// an idea of where the cell is.\n\t\t\t\tlet dx = pixels[j][dim] - mi\n\t\t\t\t// Update the mean with the appropriate weight. \n\t\t\t\tmi += dx/(j+1)\n\t\t\t}\t\t\t\n\t\t\t// Set the mean position in the cvec vector.\n\t\t\tcvec[dim] = mi\n\t\t}\n\t\treturn cvec\n\t\t\n\t}\n\t\t\n\t/** Compute centroids for all cells on the grid. \n\t@return {CellObject} with an {@link ArrayCoordinate} of the centroid for each cell\n\t on the grid (see {@link computeCentroidOfCell}). */\n\tcompute(){\n\t\t// Get object with arrays of pixels for each cell on the grid, and get\n\t\t// the array for the current cell.\n\t\tlet cellpixels = this.M.getStat( PixelsByCell ) \n\t\t\n\t\t// Create an object for the centroids. Add the centroid array for each cell.\n\t\tlet centroids = {}\n\t\tfor( let cid of this.M.cellIDs() ){\n\t\t\tcentroids[cid] = this.computeCentroidOfCell( cid, cellpixels )\n\t\t}\n\t\treturn centroids\n\t}\n}\n\nexport default Centroids\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/stats/Centroids.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 747,
    "kind": "class",
    "name": "Centroids",
    "memberof": "src/stats/Centroids.js",
    "static": true,
    "longname": "src/stats/Centroids.js~Centroids",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/stats/Centroids.js",
    "importStyle": "Centroids",
    "description": "This Stat computes the centroid of a cell. When the cell resides on a torus, the\ncentroid may be well outside the cell, and other stats may be preferable (e.g.\n{@link CentroidsWithTorusCorrection}).",
    "examples": [
      "let CPM = require( \"path/to/build\" )\n\n// Make a CPM, seed two cells, run a little, and get their centroids\nlet C = new CPM.CPM( [100,100], { \n\tT:20,\ntorus:[false,false],\n\tJ:[[0,20],[20,10]],\n\tV:[0,200],\n\tLAMBDA_V:[0,2]\n} )\nlet gm = new CPM.GridManipulator( C )\ngm.seedCell(1)\ngm.seedCell(1)\nfor( let t = 0; t < 100; t++ ){ C.timeStep() }\n\nC.getStat( CPM.Centroids ) "
    ],
    "lineNumber": 28,
    "interface": false,
    "extends": [
      "src/stats/Stat.js~Stat"
    ]
  },
  {
    "__docId__": 748,
    "kind": "set",
    "name": "model",
    "memberof": "src/stats/Centroids.js~Centroids",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stats/Centroids.js~Centroids#model",
    "access": "public",
    "description": "The set model method of class CentroidsWithTorusCorrection.",
    "lineNumber": 32,
    "params": [
      {
        "nullable": null,
        "types": [
          "GridBasedModel"
        ],
        "spread": false,
        "optional": false,
        "name": "M",
        "description": "the model to compute centroids on."
      }
    ]
  },
  {
    "__docId__": 749,
    "kind": "member",
    "name": "M",
    "memberof": "src/stats/Centroids.js~Centroids",
    "static": false,
    "longname": "src/stats/Centroids.js~Centroids#M",
    "access": "public",
    "description": "The model to compute centroids on. ",
    "lineNumber": 36,
    "type": {
      "nullable": null,
      "types": [
        "GridBasedModel"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 750,
    "kind": "member",
    "name": "halfsize",
    "memberof": "src/stats/Centroids.js~Centroids",
    "static": false,
    "longname": "src/stats/Centroids.js~Centroids#halfsize",
    "access": "public",
    "description": null,
    "lineNumber": 57,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 751,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/stats/Centroids.js~Centroids",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stats/Centroids.js~Centroids#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 63,
    "ignore": true
  },
  {
    "__docId__": 752,
    "kind": "method",
    "name": "computeCentroidOfCell",
    "memberof": "src/stats/Centroids.js~Centroids",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stats/Centroids.js~Centroids#computeCentroidOfCell",
    "access": "public",
    "description": "This method computes the centroid of a specific cell. ",
    "lineNumber": 73,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ArrayCoordinate} coordinate of the centroid."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "cellid",
        "description": "the unique cell id of the cell to get centroid of."
      },
      {
        "nullable": null,
        "types": [
          "CellArrayObject"
        ],
        "spread": false,
        "optional": false,
        "name": "cellpixels",
        "description": "object produced by {@link PixelsByCell}, \nwith keys for each cellid\nand as corresponding value the pixel coordinates of their pixels."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ArrayCoordinate"
      ],
      "spread": false,
      "description": "coordinate of the centroid."
    }
  },
  {
    "__docId__": 753,
    "kind": "method",
    "name": "compute",
    "memberof": "src/stats/Centroids.js~Centroids",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stats/Centroids.js~Centroids#compute",
    "access": "public",
    "description": "Compute centroids for all cells on the grid. ",
    "lineNumber": 108,
    "return": {
      "nullable": null,
      "types": [
        "CellObject"
      ],
      "spread": false,
      "description": "with an {@link ArrayCoordinate} of the centroid for each cell\non the grid (see {@link computeCentroidOfCell})."
    },
    "params": []
  },
  {
    "__docId__": 754,
    "kind": "file",
    "name": "src/stats/CentroidsWithTorusCorrection.js",
    "content": "\nimport Stat from \"./Stat.js\"\nimport PixelsByCell from \"./PixelsByCell.js\"\n\n/**\tThis Stat computes the centroid of a cell when grid has a torus. \n\n\t!!! Assumption: cell pixels never extend for more than half the size of the grid.\n\tIf this assumption does not hold, centroids may be computed wrongly.\n\t\n\tSee also {@link Centroids} for a version without torus correction.\n\t\t\n\t@example\n\t* let CPM = require( \"path/to/build\" )\n\t*\n\t* // Make a CPM, seed two cells, run a little, and get their centroids\n\t* let C = new CPM.CPM( [100,100], { \n\t* \tT:20,\n\t* \ttorus:[true,true],\n\t* \tJ:[[0,20],[20,10]],\n\t* \tV:[0,200],\n\t* \tLAMBDA_V:[0,2]\n\t* } )\n\t* let gm = new CPM.GridManipulator( C )\n\t* gm.seedCell(1)\n\t* gm.seedCell(1)\n\t* for( let t = 0; t < 100; t++ ){ C.timeStep() }\n\t*\n\t* C.getStat( CPM.CentroidsWithTorusCorrection ) \n*/\n\nclass CentroidsWithTorusCorrection extends Stat {\n\n\t/** The set model method of class CentroidsWithTorusCorrection.\n\t@param {GridBasedModel} M - the model to compute centroids on. */\n\tset model( M ){\n\t\n\t\t/** The model to compute centroids on. \n\t\t@type {GridBasedModel}*/\n\t\tthis.M = M\n\t\t// Half the grid dimensions; if pixels with the same cellid are further apart,\n\t\t// we assume they are on the border of the grid and that we need to correct\n\t\t// their positions to compute the centroid.\n\t\t/** @ignore */\n\t\tthis.halfsize = new Array( this.M.ndim).fill(0)\n\t\tfor( let i = 0 ; i < this.M.ndim ; i ++ ){\n\t\t\tthis.halfsize[i] = this.M.extents[i]/2\n\t\t}\n\t}\n\t\n\t/** @ignore */\n\tconstructor( conf ){\n\t\tsuper(conf)\n\t}\n\t\t\n\t/** This method computes the centroid of a specific cell with id = <cellid>. \n\tThe cellpixels object is given as an argument so that it only has to be requested\n\tonce for all cells together.\n\t@param {CellId} cellid ID number of the cell to get centroid of. \n\t@param {CellArrayObject} cellpixels object produced by {@link PixelsByCell}, \n\twhere keys are the cellids\n\tof all non-background cells on the grid, and the corresponding value is an array\n\tof the pixels belonging to that cell specified by their {@link ArrayCoordinate}.\n\t@return {ArrayCoordinate} the centroid of the current cell.\n\t*/\n\tcomputeCentroidOfCell( cellid, cellpixels  ){\n\t\n\t\t//let cellpixels = this.M.getStat( PixelsByCell ) \n\t\n\t\tconst pixels = cellpixels[ cellid ]\n\t\t\n\t\t// cvec will contain the x, y, (z) coordinate of the centroid.\n\t\t// Loop over the dimensions to compute each element separately.\n\t\tlet cvec = new Array(this.M.ndim).fill(0)\n\t\tfor( let dim = 0 ; dim < this.M.ndim ; dim ++ ){\n\t\t\t\n\t\t\tlet mi = 0.\n\t\t\tconst hsi = this.halfsize[dim], si = this.M.extents[dim]\n\t\t\t\n\t\t\t// Loop over the pixels;\n\t\t\t// compute mean position per dimension with online algorithm\n\t\t\tfor( let j = 0 ; j < pixels.length ; j ++ ){\n\t\t\t\t\n\t\t\t\t// Check distance of current pixel to the accumulated mean in this dim.\n\t\t\t\t// Check if this distance is greater than half the grid size in this\n\t\t\t\t// dimension; if so, this indicates that the cell has moved to the\n\t\t\t\t// other end of the grid because of the torus. Note that this only\n\t\t\t\t// holds AFTER the first pixel (so for j > 0), when we actually have\n\t\t\t\t// an idea of where the cell is.\n\t\t\t\tlet dx = pixels[j][dim] - mi\n\t\t\t\tif( this.M.grid.torus[dim] && j > 0 ){\n\t\t\t\t\t// If distance is greater than half the grid size, correct the\n\t\t\t\t\t// coordinate.\n\t\t\t\t\tif( dx > hsi ){\n\t\t\t\t\t\tdx -= si\n\t\t\t\t\t} else if( dx < -hsi ){\n\t\t\t\t\t\tdx += si\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Update the mean with the appropriate weight. \n\t\t\t\tmi += dx/(j+1)\n\t\t\t}\n\t\t\t\n\t\t\t// Correct the final position so that it falls in the current grid.\n\t\t\t// (Because of the torus, it can happen to get a centroid at eg x = -1. )\n\t\t\tif( mi < 0 ){\n\t\t\t\tmi += si\n\t\t\t} else if( mi > si ){\n\t\t\t\tmi -= si\n\t\t\t}\n\t\t\t\n\t\t\t// Set the mean position in the cvec vector.\n\t\t\tcvec[dim] = mi\n\t\t}\n\t\treturn cvec\n\t\t\n\t}\n\t\t\n\t/** This method computes the centroids of all cells on the grid. \n\t@return {CellObject} with an {@link ArrayCoordinate} of the centroid for each cell\n\t on the grid (see {@link computeCentroidOfCell}). */\n\tcompute(){\n\t\t// Get object with arrays of pixels for each cell on the grid, and get\n\t\t// the array for the current cell.\n\t\tlet cellpixels = this.M.getStat( PixelsByCell ) \n\t\t\n\t\t// Create an object for the centroids. Add the centroid array for each cell.\n\t\tlet centroids = {}\n\t\tfor( let cid of this.M.cellIDs() ){\n\t\t\tcentroids[cid] = this.computeCentroidOfCell( cid, cellpixels )\n\t\t}\n\t\t\n\t\treturn centroids\n\t\t\n\t}\n}\n\nexport default CentroidsWithTorusCorrection\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/stats/CentroidsWithTorusCorrection.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 755,
    "kind": "class",
    "name": "CentroidsWithTorusCorrection",
    "memberof": "src/stats/CentroidsWithTorusCorrection.js",
    "static": true,
    "longname": "src/stats/CentroidsWithTorusCorrection.js~CentroidsWithTorusCorrection",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/stats/CentroidsWithTorusCorrection.js",
    "importStyle": "CentroidsWithTorusCorrection",
    "description": "This Stat computes the centroid of a cell when grid has a torus. \n\n!!! Assumption: cell pixels never extend for more than half the size of the grid.\nIf this assumption does not hold, centroids may be computed wrongly.\n\nSee also {@link Centroids} for a version without torus correction.",
    "examples": [
      "let CPM = require( \"path/to/build\" )\n\n// Make a CPM, seed two cells, run a little, and get their centroids\nlet C = new CPM.CPM( [100,100], { \n\tT:20,\n\ttorus:[true,true],\n\tJ:[[0,20],[20,10]],\n\tV:[0,200],\n\tLAMBDA_V:[0,2]\n} )\nlet gm = new CPM.GridManipulator( C )\ngm.seedCell(1)\ngm.seedCell(1)\nfor( let t = 0; t < 100; t++ ){ C.timeStep() }\n\nC.getStat( CPM.CentroidsWithTorusCorrection ) "
    ],
    "lineNumber": 31,
    "interface": false,
    "extends": [
      "src/stats/Stat.js~Stat"
    ]
  },
  {
    "__docId__": 756,
    "kind": "set",
    "name": "model",
    "memberof": "src/stats/CentroidsWithTorusCorrection.js~CentroidsWithTorusCorrection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stats/CentroidsWithTorusCorrection.js~CentroidsWithTorusCorrection#model",
    "access": "public",
    "description": "The set model method of class CentroidsWithTorusCorrection.",
    "lineNumber": 35,
    "params": [
      {
        "nullable": null,
        "types": [
          "GridBasedModel"
        ],
        "spread": false,
        "optional": false,
        "name": "M",
        "description": "the model to compute centroids on."
      }
    ]
  },
  {
    "__docId__": 757,
    "kind": "member",
    "name": "M",
    "memberof": "src/stats/CentroidsWithTorusCorrection.js~CentroidsWithTorusCorrection",
    "static": false,
    "longname": "src/stats/CentroidsWithTorusCorrection.js~CentroidsWithTorusCorrection#M",
    "access": "public",
    "description": "The model to compute centroids on. ",
    "lineNumber": 39,
    "type": {
      "nullable": null,
      "types": [
        "GridBasedModel"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 758,
    "kind": "member",
    "name": "halfsize",
    "memberof": "src/stats/CentroidsWithTorusCorrection.js~CentroidsWithTorusCorrection",
    "static": false,
    "longname": "src/stats/CentroidsWithTorusCorrection.js~CentroidsWithTorusCorrection#halfsize",
    "access": "public",
    "description": null,
    "lineNumber": 44,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 759,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/stats/CentroidsWithTorusCorrection.js~CentroidsWithTorusCorrection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stats/CentroidsWithTorusCorrection.js~CentroidsWithTorusCorrection#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 51,
    "ignore": true
  },
  {
    "__docId__": 760,
    "kind": "method",
    "name": "computeCentroidOfCell",
    "memberof": "src/stats/CentroidsWithTorusCorrection.js~CentroidsWithTorusCorrection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stats/CentroidsWithTorusCorrection.js~CentroidsWithTorusCorrection#computeCentroidOfCell",
    "access": "public",
    "description": "This method computes the centroid of a specific cell with id = <cellid>. \nThe cellpixels object is given as an argument so that it only has to be requested\nonce for all cells together.",
    "lineNumber": 65,
    "params": [
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "cellid",
        "description": "ID number of the cell to get centroid of."
      },
      {
        "nullable": null,
        "types": [
          "CellArrayObject"
        ],
        "spread": false,
        "optional": false,
        "name": "cellpixels",
        "description": "object produced by {@link PixelsByCell}, \nwhere keys are the cellids\nof all non-background cells on the grid, and the corresponding value is an array\nof the pixels belonging to that cell specified by their {@link ArrayCoordinate}."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ArrayCoordinate"
      ],
      "spread": false,
      "description": "the centroid of the current cell."
    }
  },
  {
    "__docId__": 761,
    "kind": "method",
    "name": "compute",
    "memberof": "src/stats/CentroidsWithTorusCorrection.js~CentroidsWithTorusCorrection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stats/CentroidsWithTorusCorrection.js~CentroidsWithTorusCorrection#compute",
    "access": "public",
    "description": "This method computes the centroids of all cells on the grid. ",
    "lineNumber": 121,
    "return": {
      "nullable": null,
      "types": [
        "CellObject"
      ],
      "spread": false,
      "description": "with an {@link ArrayCoordinate} of the centroid for each cell\non the grid (see {@link computeCentroidOfCell})."
    },
    "params": []
  },
  {
    "__docId__": 762,
    "kind": "file",
    "name": "src/stats/ConnectedComponentsByCell.js",
    "content": "\nimport Stat from \"./Stat.js\"\nimport PixelsByCell from \"./PixelsByCell.js\"\n\n/** This Stat creates an object with the connected components of each cell on the grid. \n\tKeys are the {@link CellId} of all cells on the grid, corresponding values are objects\n\twhere each element is a connected component. Each element of that array contains \n\tthe {@link ArrayCoordinate} for that pixel.\n\t\n\t@example\n\t* let CPM = require( \"path/to/build\" )\n\t*\n\t* // Make a CPM, seed a cell, and get the ConnectedComponentsByCell\n\t* let C = new CPM.CPM( [100,100], { \n\t* \tT:20,\n\t* \tJ:[[0,20],[20,10]],\n\t* \tV:[0,200],\n\t* \tLAMBDA_V:[0,2]\n\t* } )\n\t* let gm = new CPM.GridManipulator( C )\n\t* gm.seedCell(1)\n\t* gm.seedCell(1)\n\t* for( let t = 0; t < 100; t++ ){ C.timeStep() }\n\t* C.getStat( CPM.ConnectedComponentsByCell )\n*/\nclass ConnectedComponentsByCell extends Stat {\n\n\t/** This method computes the connected components of a specific cell. \n\t\t@param {CellId} cellid the unique cell id of the cell to get connected components of.\n\t\t@returns {object} object of cell connected components. These components in turn consist of the pixels \n\t(specified by {@link ArrayCoordinate}) belonging to that cell.\n\t*/\n\tconnectedComponentsOfCell( cellid ){\n\t\n\t\tconst cbp = this.M.getStat( PixelsByCell )\n\t\tconst cbpi = cbp[cellid]\n\t\tlet M = this.M\n\t\n\t\n\t\tlet visited = {}, k=0, pixels = []\n\t\tlet labelComponent = function(seed, k){\n\t\t\tlet q = [seed]\n\t\t\tvisited[q[0]] = 1\n\t\t\tpixels[k] = []\n\t\t\twhile( q.length > 0 ){\n\t\t\t\tlet e = q.pop()\n\t\t\t\tpixels[k].push( M.grid.i2p(e) )\n\t\t\t\tlet ne = M.grid.neighi( e )\n\t\t\t\tfor( let i = 0 ; i < ne.length ; i ++ ){\n\t\t\t\t\tif( M.pixti( ne[i] ) == cellid &&\n\t\t\t\t\t\t!(ne[i] in visited) ){\n\t\t\t\t\t\tq.push(ne[i])\n\t\t\t\t\t\tvisited[ne[i]]=1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor( let i = 0 ; i < cbpi.length ; i ++ ){\n\t\t\tlet pi = this.M.grid.p2i( cbpi[i] )\n\t\t\tif( !(pi in visited) ){\n\t\t\t\tlabelComponent( pi, k )\n\t\t\t\tk++\n\t\t\t}\n\t\t}\n\t\treturn pixels\n\t}\n\n\t/** The compute method of ConnectedComponentsByCell creates an object with \n\tconnected components of the border of each cell on the grid.\n\t@return {CellObject} object with for each cell on the grid\n\tan object of components. These components in turn consist of the pixels \n\t(specified by {@link ArrayCoordinate}) belonging to that cell.\n\t*/\n\tcompute(){\n\t\t// initialize the object\n\t\tlet components = { }\n\t\t// The this.M.pixels() iterator returns coordinates and cellid for all \n\t\t// non-background pixels on the grid. See the appropriate Grid class for\n\t\t// its implementation.\n\t\tfor( let ci of this.M.cellIDs() ){\n\t\t\tcomponents[ci] = this.connectedComponentsOfCell( ci )\n\t\t}\n\t\treturn components\n\t}\n}\n\nexport default ConnectedComponentsByCell\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/stats/ConnectedComponentsByCell.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 763,
    "kind": "class",
    "name": "ConnectedComponentsByCell",
    "memberof": "src/stats/ConnectedComponentsByCell.js",
    "static": true,
    "longname": "src/stats/ConnectedComponentsByCell.js~ConnectedComponentsByCell",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/stats/ConnectedComponentsByCell.js",
    "importStyle": "ConnectedComponentsByCell",
    "description": "This Stat creates an object with the connected components of each cell on the grid. \nKeys are the {@link CellId} of all cells on the grid, corresponding values are objects\nwhere each element is a connected component. Each element of that array contains \nthe {@link ArrayCoordinate} for that pixel.",
    "examples": [
      "let CPM = require( \"path/to/build\" )\n\n// Make a CPM, seed a cell, and get the ConnectedComponentsByCell\nlet C = new CPM.CPM( [100,100], { \n\tT:20,\n\tJ:[[0,20],[20,10]],\n\tV:[0,200],\n\tLAMBDA_V:[0,2]\n} )\nlet gm = new CPM.GridManipulator( C )\ngm.seedCell(1)\ngm.seedCell(1)\nfor( let t = 0; t < 100; t++ ){ C.timeStep() }\nC.getStat( CPM.ConnectedComponentsByCell )"
    ],
    "lineNumber": 26,
    "interface": false,
    "extends": [
      "src/stats/Stat.js~Stat"
    ]
  },
  {
    "__docId__": 764,
    "kind": "method",
    "name": "connectedComponentsOfCell",
    "memberof": "src/stats/ConnectedComponentsByCell.js~ConnectedComponentsByCell",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stats/ConnectedComponentsByCell.js~ConnectedComponentsByCell#connectedComponentsOfCell",
    "access": "public",
    "description": "This method computes the connected components of a specific cell. ",
    "lineNumber": 33,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} object of cell connected components. These components in turn consist of the pixels \n(specified by {@link ArrayCoordinate}) belonging to that cell."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "cellid",
        "description": "the unique cell id of the cell to get connected components of."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "object of cell connected components. These components in turn consist of the pixels \n(specified by {@link ArrayCoordinate}) belonging to that cell."
    }
  },
  {
    "__docId__": 765,
    "kind": "method",
    "name": "compute",
    "memberof": "src/stats/ConnectedComponentsByCell.js~ConnectedComponentsByCell",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stats/ConnectedComponentsByCell.js~ConnectedComponentsByCell#compute",
    "access": "public",
    "description": "The compute method of ConnectedComponentsByCell creates an object with \nconnected components of the border of each cell on the grid.",
    "lineNumber": 74,
    "return": {
      "nullable": null,
      "types": [
        "CellObject"
      ],
      "spread": false,
      "description": "object with for each cell on the grid\nan object of components. These components in turn consist of the pixels \n(specified by {@link ArrayCoordinate}) belonging to that cell."
    },
    "params": []
  },
  {
    "__docId__": 766,
    "kind": "file",
    "name": "src/stats/ConnectedComponentsByCellBorder.js",
    "content": "\nimport Stat from \"./Stat.js\"\nimport BorderPixelsByCell from \"./BorderPixelsByCell.js\"\n\n/** This Stat creates an object with the connected components of each cell's border on the grid. \n\tKeys are the {@link CellId} of all cells on the grid, corresponding values are objects\n\twhere each element is a connected component. Each element of that array contains \n\tthe {@link ArrayCoordinate} for that pixel.\n\t\n\t@example\n\t* let CPM = require( \"path/to/build\" )\n\t*\n\t* // Make a CPM, seed a cell, and get the ConnectedComponentsByCellBorder\n\t* let C = new CPM.CPM( [100,100], { \n\t* \tT:20,\n\t* \tJ:[[0,20],[20,10]],\n\t* \tV:[0,200],\n\t* \tLAMBDA_V:[0,2]\n\t* } )\n\t* let gm = new CPM.GridManipulator( C )\n\t* gm.seedCell(1)\n\t* gm.seedCell(1)\n\t* for( let t = 0; t < 100; t++ ){ C.timeStep() }\n\t* C.getStat( CPM.ConnectedComponentsByCellBorder )\n*/\nclass ConnectedComponentsByCellBorder extends Stat {\n\n\t/** This method computes the connected components of the border of a specific cell. \n\t\t@param {CellId} cellid the unique cell id of the cell to get the border's connected components of.\n\t\t@returns {object} object of cell border connected components. These components in turn consist of the pixels \n\t(specified by {@link ArrayCoordinate}) belonging to that cell border.\n\t*/\n\tconnectedComponentsOfCellBorder( cellid ){\n\t\n\t\t/* Note that to get connected components, we only need to look at cellborderpixels. */\n\t\tlet cbp = this.M.getStat( BorderPixelsByCell )\n\t\tcbpi = cbp[cellid]\n\t\n\t\n\t\tlet visited = {}, k=0, pixels = []\n\t\tlet labelComponent = function(seed, k){\n\t\t\tlet q = [seed]\n\t\t\tvisited[q[0]] = 1\n\t\t\tpixels[k] = []\n\t\t\twhile( q.length > 0 ){\n\t\t\t\tlet e = q.pop()\n\t\t\t\tpixels[k].push( this.M.grid.i2p(e) )\n\t\t\t\tlet ne = this.M.grid.neighi( e )\n\t\t\t\tfor( let i = 0 ; i < ne.length ; i ++ ){\n\t\t\t\t\tif( this.M.pixti( ne[i] ) == t &&\n\t\t\t\t\t\t!(ne[i] in visited) ){\n\t\t\t\t\t\tq.push(ne[i])\n\t\t\t\t\t\tvisited[ne[i]]=1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor( let i = 0 ; i < cbpi.length ; i ++ ){\n\t\t\tlet pi = this.M.grid.p2i( cbpi[i] )\n\t\t\tif( !(pi in visited) ){\n\t\t\t\tlabelComponent( pi, k )\n\t\t\t\tk++\n\t\t\t}\n\t\t}\n\t\treturn pixels\n\t}\n\n\t/** The compute method of ConnectedComponentsByCellBorder creates an object with \n\tconnected components of the border of each cell on the grid.\n\t@return {CellObject} object with for each cell on the grid\n\tan object of components. These components in turn consist of the pixels \n\t(specified by {@link ArrayCoordinate}) belonging to that cell.\n\t*/\n\tcompute(){\n\t\t// initialize the object\n\t\tlet components = { }\n\t\t// The this.M.pixels() iterator returns coordinates and cellid for all \n\t\t// non-background pixels on the grid. See the appropriate Grid class for\n\t\t// its implementation.\n\t\tfor( let ci of this.M.cellIDs() ){\n\t\t\tcomponents[ci] = this.connectedComponentsOfCellBorder( ci )\n\t\t}\n\t\treturn components\n\t}\n}\n\nexport default ConnectedComponentsByCellBorder\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/stats/ConnectedComponentsByCellBorder.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 767,
    "kind": "class",
    "name": "ConnectedComponentsByCellBorder",
    "memberof": "src/stats/ConnectedComponentsByCellBorder.js",
    "static": true,
    "longname": "src/stats/ConnectedComponentsByCellBorder.js~ConnectedComponentsByCellBorder",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/stats/ConnectedComponentsByCellBorder.js",
    "importStyle": "ConnectedComponentsByCellBorder",
    "description": "This Stat creates an object with the connected components of each cell's border on the grid. \nKeys are the {@link CellId} of all cells on the grid, corresponding values are objects\nwhere each element is a connected component. Each element of that array contains \nthe {@link ArrayCoordinate} for that pixel.",
    "examples": [
      "let CPM = require( \"path/to/build\" )\n\n// Make a CPM, seed a cell, and get the ConnectedComponentsByCellBorder\nlet C = new CPM.CPM( [100,100], { \n\tT:20,\n\tJ:[[0,20],[20,10]],\n\tV:[0,200],\n\tLAMBDA_V:[0,2]\n} )\nlet gm = new CPM.GridManipulator( C )\ngm.seedCell(1)\ngm.seedCell(1)\nfor( let t = 0; t < 100; t++ ){ C.timeStep() }\nC.getStat( CPM.ConnectedComponentsByCellBorder )"
    ],
    "lineNumber": 26,
    "interface": false,
    "extends": [
      "src/stats/Stat.js~Stat"
    ]
  },
  {
    "__docId__": 768,
    "kind": "method",
    "name": "connectedComponentsOfCellBorder",
    "memberof": "src/stats/ConnectedComponentsByCellBorder.js~ConnectedComponentsByCellBorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stats/ConnectedComponentsByCellBorder.js~ConnectedComponentsByCellBorder#connectedComponentsOfCellBorder",
    "access": "public",
    "description": "This method computes the connected components of the border of a specific cell. ",
    "lineNumber": 33,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} object of cell border connected components. These components in turn consist of the pixels \n(specified by {@link ArrayCoordinate}) belonging to that cell border."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "CellId"
        ],
        "spread": false,
        "optional": false,
        "name": "cellid",
        "description": "the unique cell id of the cell to get the border's connected components of."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "object of cell border connected components. These components in turn consist of the pixels \n(specified by {@link ArrayCoordinate}) belonging to that cell border."
    }
  },
  {
    "__docId__": 769,
    "kind": "method",
    "name": "compute",
    "memberof": "src/stats/ConnectedComponentsByCellBorder.js~ConnectedComponentsByCellBorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stats/ConnectedComponentsByCellBorder.js~ConnectedComponentsByCellBorder#compute",
    "access": "public",
    "description": "The compute method of ConnectedComponentsByCellBorder creates an object with \nconnected components of the border of each cell on the grid.",
    "lineNumber": 74,
    "return": {
      "nullable": null,
      "types": [
        "CellObject"
      ],
      "spread": false,
      "description": "object with for each cell on the grid\nan object of components. These components in turn consist of the pixels \n(specified by {@link ArrayCoordinate}) belonging to that cell."
    },
    "params": []
  },
  {
    "__docId__": 770,
    "kind": "file",
    "name": "src/stats/Connectedness.js",
    "content": "\nimport Stat from \"./Stat.js\"\nimport ConnectedComponentsByCell from \"./ConnectedComponentsByCell.js\"\n\n/** This Stat computes the 'connectedness' of cells on the grid. \n\tKeys are the {@link CellId} of all cells on the grid, corresponding values the\n\tconnectedness of the corresponding cell. \n\t\n\t@example\n\t* let CPM = require( \"path/to/build\" )\n\t*\n\t* // Make a CPM, seed a cell, and get the Connectedness\n\t* let C = new CPM.CPM( [100,100], { \n\t* \tT:20,\n\t* \tJ:[[0,20],[20,10]],\n\t* \tV:[0,200],\n\t* \tLAMBDA_V:[0,2]\n\t* } )\n\t* let gm = new CPM.GridManipulator( C )\n\t* gm.seedCell(1)\n\t* for( let t = 0; t < 100; t++ ){ C.timeStep() }\n\t* C.getStat( CPM.Connectedness )\n*/\nclass Connectedness extends Stat {\n\n\t/** This method computes the connectedness of a specific cell. \n\t@return {number} the connectedness value of this cell, a number between 0 and 1.\n\t*/\n\tconnectednessOfCell( cellid ){\n\t\n\t\tlet ccbc = this.M.getStat( ConnectedComponentsByCell )\n\t\tconst v = ccbc[cellid]\n\t\n\t\t//let s = {}, r = {}, i, j\n\t\tlet s = 0, r = 0\n\t\t\n\t\tfor( let comp in Object.keys( v ) ){\n\t\t\tlet volume = v[comp].length\n\t\t\ts += volume\n\t\t}\n\t\tfor( let comp in Object.keys( v ) ){\n\t\t\tlet volume = v[comp].length\n\t\t\tr += (volume/s)*(volume/s)\n\t\t}\n\t\t\n\t\treturn r\n\n\t}\n\n\t/** The compute method of Connectedness creates an object with \n\tconnectedness of each cell on the grid.\n\t@return {CellObject} object with for each cell on the grid\n\ta connectedness value. \n\t*/\n\tcompute(){\n\t\t// initialize the object\n\t\tlet connectedness = { }\n\t\t// The this.M.pixels() iterator returns coordinates and cellid for all \n\t\t// non-background pixels on the grid. See the appropriate Grid class for\n\t\t// its implementation.\n\t\tfor( let ci of this.M.cellIDs() ){\n\t\t\tconnectedness[ci] = this.connectednessOfCell( ci )\n\t\t}\n\t\treturn connectedness\n\t}\n}\n\nexport default Connectedness\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/stats/Connectedness.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 771,
    "kind": "class",
    "name": "Connectedness",
    "memberof": "src/stats/Connectedness.js",
    "static": true,
    "longname": "src/stats/Connectedness.js~Connectedness",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/stats/Connectedness.js",
    "importStyle": "Connectedness",
    "description": "This Stat computes the 'connectedness' of cells on the grid. \nKeys are the {@link CellId} of all cells on the grid, corresponding values the\nconnectedness of the corresponding cell. ",
    "examples": [
      "let CPM = require( \"path/to/build\" )\n\n// Make a CPM, seed a cell, and get the Connectedness\nlet C = new CPM.CPM( [100,100], { \n\tT:20,\n\tJ:[[0,20],[20,10]],\n\tV:[0,200],\n\tLAMBDA_V:[0,2]\n} )\nlet gm = new CPM.GridManipulator( C )\ngm.seedCell(1)\nfor( let t = 0; t < 100; t++ ){ C.timeStep() }\nC.getStat( CPM.Connectedness )"
    ],
    "lineNumber": 24,
    "interface": false,
    "extends": [
      "src/stats/Stat.js~Stat"
    ]
  },
  {
    "__docId__": 772,
    "kind": "method",
    "name": "connectednessOfCell",
    "memberof": "src/stats/Connectedness.js~Connectedness",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stats/Connectedness.js~Connectedness#connectednessOfCell",
    "access": "public",
    "description": "This method computes the connectedness of a specific cell. ",
    "lineNumber": 29,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the connectedness value of this cell, a number between 0 and 1."
    },
    "params": [
      {
        "name": "cellid",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 773,
    "kind": "method",
    "name": "compute",
    "memberof": "src/stats/Connectedness.js~Connectedness",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stats/Connectedness.js~Connectedness#compute",
    "access": "public",
    "description": "The compute method of Connectedness creates an object with \nconnectedness of each cell on the grid.",
    "lineNumber": 55,
    "return": {
      "nullable": null,
      "types": [
        "CellObject"
      ],
      "spread": false,
      "description": "object with for each cell on the grid\na connectedness value."
    },
    "params": []
  },
  {
    "__docId__": 774,
    "kind": "file",
    "name": "src/stats/PixelsByCell.js",
    "content": "\nimport Stat from \"./Stat.js\"\n\n/** This Stat creates an object with the cellpixels of each cell on the grid. \n\tKeys are the {@link CellId} of all cells on the grid, corresponding values are arrays\n\tcontaining the pixels belonging to that cell. Each element of that array contains\n\tthe {@link ArrayCoordinate} for that pixel.\n\t\n\t@example\n\t* let CPM = require( \"path/to/build\" )\n\t*\n\t* // Make a CPM, seed a cell, and get the PixelsByCell\n\t* let C = new CPM.CPM( [100,100], { \n\t* \tT:20,\n\t* \tJ:[[0,20],[20,10]],\n\t* \tV:[0,200],\n\t* \tLAMBDA_V:[0,2]\n\t* } )\n\t* let gm = new CPM.GridManipulator( C )\n\t* gm.seedCell(1)\n\t* gm.seedCell(1)\n\t* for( let t = 0; t < 100; t++ ){ C.timeStep() }\n\t* C.getStat( CPM.PixelsByCell )\n*/\nclass PixelsByCell extends Stat {\n\n\t/** The compute method of PixelsByCell creates an object with cellpixels of each\n\tcell on the grid.\n\t@return {CellArrayObject} object with for each cell on the grid\n\tan array of pixels (specified by {@link ArrayCoordinate}) belonging to that cell.\n\t*/\n\tcompute(){\n\t\t// initialize the object\n\t\tlet cellpixels = { }\n\t\t// The this.M.pixels() iterator returns coordinates and cellid for all \n\t\t// non-background pixels on the grid. See the appropriate Grid class for\n\t\t// its implementation.\n\t\tfor( let [p,i] of this.M.pixels() ){\n\t\t\tif( !cellpixels[i] ){\n\t\t\t\tcellpixels[i] = [p]\n\t\t\t} else {\n\t\t\t\tcellpixels[i].push( p )\n\t\t\t}\n\t\t}\n\t\treturn cellpixels\n\t}\n}\n\nexport default PixelsByCell\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/stats/PixelsByCell.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 775,
    "kind": "class",
    "name": "PixelsByCell",
    "memberof": "src/stats/PixelsByCell.js",
    "static": true,
    "longname": "src/stats/PixelsByCell.js~PixelsByCell",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/stats/PixelsByCell.js",
    "importStyle": "PixelsByCell",
    "description": "This Stat creates an object with the cellpixels of each cell on the grid. \nKeys are the {@link CellId} of all cells on the grid, corresponding values are arrays\ncontaining the pixels belonging to that cell. Each element of that array contains\nthe {@link ArrayCoordinate} for that pixel.",
    "examples": [
      "let CPM = require( \"path/to/build\" )\n\n// Make a CPM, seed a cell, and get the PixelsByCell\nlet C = new CPM.CPM( [100,100], { \n\tT:20,\n\tJ:[[0,20],[20,10]],\n\tV:[0,200],\n\tLAMBDA_V:[0,2]\n} )\nlet gm = new CPM.GridManipulator( C )\ngm.seedCell(1)\ngm.seedCell(1)\nfor( let t = 0; t < 100; t++ ){ C.timeStep() }\nC.getStat( CPM.PixelsByCell )"
    ],
    "lineNumber": 25,
    "interface": false,
    "extends": [
      "src/stats/Stat.js~Stat"
    ]
  },
  {
    "__docId__": 776,
    "kind": "method",
    "name": "compute",
    "memberof": "src/stats/PixelsByCell.js~PixelsByCell",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stats/PixelsByCell.js~PixelsByCell#compute",
    "access": "public",
    "description": "The compute method of PixelsByCell creates an object with cellpixels of each\ncell on the grid.",
    "lineNumber": 32,
    "return": {
      "nullable": null,
      "types": [
        "CellArrayObject"
      ],
      "spread": false,
      "description": "object with for each cell on the grid\nan array of pixels (specified by {@link ArrayCoordinate}) belonging to that cell."
    },
    "params": []
  },
  {
    "__docId__": 777,
    "kind": "file",
    "name": "src/stats/Stat.js",
    "content": "/** Base class for a statistic that can be computed on a GridBasedModel. \nThis class by itself is not usable; see its subclasses for stats that are \ncurrently supported. */\nclass Stat {\n\n\t/** The constructor of class Stat takes a 'conf' object as argument.\n\tHowever, Stats should not really be configurable in the sense that they should always\n\tprovide an expected output. The 'conf' object is mainly intended\n\tto provide an option to configure logging / debugging output. That\n\tis not implemented yet.\t\n\t@param {object} conf configuration options for the Stat, which should change nothing\n\tabout the return value produced by the compute() method but may be used for logging\n\tand debugging options.*/\n\tconstructor( conf ){\n\t\t/** Configuration object for the stat, which should not change its value but\n\t\tmay be used for logging and debugging options.\n\t\t@type {object}*/\n\t\tthis.conf = conf || {}\n\t}\n\t\n\t/** Every stat is linked to a specific model.\n\t@param {GridBasedModel} M the model to compute the stat on.*/\n\tset model( M ){\n\t\n\t\t/** The model to compute the stat on.\n\t\t@type {GridBasedModel} */\n\t\tthis.M = M\n\t}\n\t\n\t/** The compute method of the base Stat class throws an error, \n\tenforcing that you have to implement this method when you build a new \n\tstat class extending this base class. \n\t@abstract */\n\tcompute(){\n\t\tthrow(\"compute method not implemented for subclass of Stat\")\n\t}\n}\n\nexport default Stat\n\n\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/stats/Stat.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 778,
    "kind": "class",
    "name": "Stat",
    "memberof": "src/stats/Stat.js",
    "static": true,
    "longname": "src/stats/Stat.js~Stat",
    "access": "public",
    "export": true,
    "importPath": "Artistoo/src/stats/Stat.js",
    "importStyle": "Stat",
    "description": "Base class for a statistic that can be computed on a GridBasedModel. \nThis class by itself is not usable; see its subclasses for stats that are \ncurrently supported.",
    "lineNumber": 4,
    "interface": false
  },
  {
    "__docId__": 779,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/stats/Stat.js~Stat",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stats/Stat.js~Stat#constructor",
    "access": "public",
    "description": "The constructor of class Stat takes a 'conf' object as argument.\nHowever, Stats should not really be configurable in the sense that they should always\nprovide an expected output. The 'conf' object is mainly intended\nto provide an option to configure logging / debugging output. That\nis not implemented yet.\t",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "conf",
        "description": "configuration options for the Stat, which should change nothing\nabout the return value produced by the compute() method but may be used for logging\nand debugging options."
      }
    ]
  },
  {
    "__docId__": 780,
    "kind": "member",
    "name": "conf",
    "memberof": "src/stats/Stat.js~Stat",
    "static": false,
    "longname": "src/stats/Stat.js~Stat#conf",
    "access": "public",
    "description": "Configuration object for the stat, which should not change its value but\nmay be used for logging and debugging options.",
    "lineNumber": 18,
    "type": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 781,
    "kind": "set",
    "name": "model",
    "memberof": "src/stats/Stat.js~Stat",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stats/Stat.js~Stat#model",
    "access": "public",
    "description": "Every stat is linked to a specific model.",
    "lineNumber": 23,
    "params": [
      {
        "nullable": null,
        "types": [
          "GridBasedModel"
        ],
        "spread": false,
        "optional": false,
        "name": "M",
        "description": "the model to compute the stat on."
      }
    ]
  },
  {
    "__docId__": 782,
    "kind": "member",
    "name": "M",
    "memberof": "src/stats/Stat.js~Stat",
    "static": false,
    "longname": "src/stats/Stat.js~Stat#M",
    "access": "public",
    "description": "The model to compute the stat on.",
    "lineNumber": 27,
    "type": {
      "nullable": null,
      "types": [
        "GridBasedModel"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 783,
    "kind": "method",
    "name": "compute",
    "memberof": "src/stats/Stat.js~Stat",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stats/Stat.js~Stat#compute",
    "access": "public",
    "description": "The compute method of the base Stat class throws an error, \nenforcing that you have to implement this method when you build a new \nstat class extending this base class. ",
    "lineNumber": 34,
    "abstract": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 784,
    "kind": "file",
    "name": "src/stats/stat-typedef.js",
    "content": "/** An object where each cell on the grid has a key (its {@link CellId}), and the\ncorresponding value at that key is an array with some values for that cell. These\narrays do not have to be of the same length.\n@typedef {object} CellArrayObject\n*/\n\n/** An object where each cell on the grid has a key (its {@link CellId}), and the\ncorresponding value at that key is single property of that cell. \n@typedef {object} CellObject\n*/",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/src/stats/stat-typedef.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 785,
    "kind": "typedef",
    "name": "CellArrayObject",
    "memberof": "src/stats/stat-typedef.js",
    "static": true,
    "longname": "src/stats/stat-typedef.js~CellArrayObject",
    "access": "public",
    "description": "An object where each cell on the grid has a key (its {@link CellId}), and the\ncorresponding value at that key is an array with some values for that cell. These\narrays do not have to be of the same length.",
    "type": {
      "types": [
        "object"
      ],
      "optional": false,
      "name": "CellArrayObject"
    }
  },
  {
    "__docId__": 786,
    "kind": "typedef",
    "name": "CellObject",
    "memberof": "src/stats/stat-typedef.js",
    "static": true,
    "longname": "src/stats/stat-typedef.js~CellObject",
    "access": "public",
    "description": "An object where each cell on the grid has a key (its {@link CellId}), and the\ncorresponding value at that key is single property of that cell. ",
    "type": {
      "types": [
        "object"
      ],
      "optional": false,
      "name": "CellObject"
    }
  },
  {
    "kind": "index",
    "content": "# Artistoo (Artificial Tissue Toolbox)\n\nArtistoo (formerly called CPMjs) is a JavaScript library for building Cellular Potts Model (CPM) simulations that can be shared and explored in the web browser, without requiring installed software. Full documentation is available on [artistoo.net](https://artistoo.net).\n\nArtistoo is an open-source library, freely available under the terms of the MIT license. When using Artistoo for a publication please cite:\n\nWortel & Textor. *Artistoo, a Library to Build, Share, and Explore Simulations of Cells and Tissues in the Web Browser.* eLife 2021;10:e61288. DOI: [10.7554/eLife.61288](https://doi.org/10.7554/eLife.61288)\n\n\n## About\n\nArtistoo implements a simple Cellular Potts Model in JavaScript. The code includes several extensions, including the extension for cell migration published in \n\nIoana Niculescu, Johannes Textor, Rob J. de Boer:\n__Crawling and Gliding: A Computational Model for Shape-Driven Cell Migration__\nPLoS Computational Biology 11(10): e1004280\nhttp://dx.doi.org/10.1371/journal.pcbi.1004280\n\nCustom extensions can be plugged in where needed; please refer to [artistoo.net](https://artistoo.net) or use the Discussions section of this repository if you need help.\n\n\n## Documentation [![Inline docs](https://inch-ci.org/github/ingewortel/artistoo.svg?branch=master)](https://inch-ci.org/github/ingewortel/artistoo)\n\nYou can find full documentation of available methods \n[here](https://artistoo.net/identifiers.html), or have a look at\nthe [manual](https://artistoo.net/manual/index.html) for tutorials \nto get started. Alternatively, see below for a brief description and a list of examples.\n\n## How it works\n\nThis code has been ported over from our older \"cpm\" repository. This is now an ES6 module, \nwhich is compiled trough \"rollup\" for use in the browser. Users who wish to use this version\nof Artistoo can use the compiled code in the `build/` folder as it is; there is no\nneed to compile anything. See below for examples and how to use them, or visit \n[artistoo.net](https://artistoo.net) for more extensive documentation.\n\nDevelopers can extend the code with their own modules; documentation will follow later\n(see the Makefile).\n\n### Browser examples\n\nArtistoo can be used to create interactive simulations in the webbrowser. We have implemented\nseveral examples showing various processes that can be simulated with a CPM; see \n[artistoo.net/examples.html](https://artistoo.net/examples.html). \n(Please note that these examples may not work properly in Internet Explorer). \nThe page also contains a few examples of plain cellular automata (CA).\n\n### Node examples\n\nSimulations can also be run from the command line using Node.js. The first time you do this,\nyou have to install several dependencies. Go to the base folder of this package and run\n\n```\nnpm install\n```\n\nwhich will automatically install the dependencies as supplied in the `package.json` file.\n\nHere's an example of how to run the node script:\n\n```\ncd examples/node\nnode run-ActModel.js\n```\n\nThis may give an error the first time, because the script is trying to store images of\nthe simulation to a file `output/img/ActModel` which does not exist. Create this directory\nand try again:\n\n``` \nmkdir -p output/img/ActModel\nnode run-ActModel.js\n```\n\nThis will print some output to the console; typically the centroid of each \ncell at each timepoint. See the node script and the \n[Simulation class](https://artistoo.net/class/src/simulation/Simulation.js~Simulation.html)\nfor details.\n\n\nTo create a movie, run:\n```\nmkdir -p output/mp4\nffmpeg -r 60 -f image2 -i output/img/ActModel/ActModel-t%d.png -vcodec libx264 -crf 25 -pix_fmt yuv420p output/mp4/ActModel.mp4\n```\n",
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n\t\"name\": \"Artistoo\",\n\t\"version\": \"1.2.0\",\n\t\"dependencies\": {\n\t\t\"braces\": \"^3.0.2\",\n\t\t\"canvas\": \"^2.6.0\",\n\t\t\"fs\": \"0.0.1-security\",\n\t\t\"mersenne-twister\": \"^1.1.0\",\n\t\t\"websocket\": \"^1.0.28\"\n\t},\n\t\"devDependencies\": {\n\t\t\"esdoc2\": \"^2.1.5\",\n\t\t\"esdoc2-standard-plugin\": \"^2.1.2\",\n\t\t\"eslint\": \"^5.16.0\",\n\t\t\"jasmine\": \"^3.5.0\",\n\t\t\"rollup\": \"^1.2.3\",\n\t\t\"rollup-plugin-commonjs\": \"^9.2.0\",\n\t\t\"rollup-plugin-eslint\": \"^5.0.0\",\n\t\t\"rollup-plugin-node-resolve\": \"^4.0.0\"\n\t}\n}\n",
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  },
  {
    "__docId__": 787,
    "kind": "testFile",
    "name": "spec/CanvasSpec.js",
    "content": "/** Some tests for drawing methods in the Canvas class.\n *\n * @test {Canvas}*/\ndescribe(\"Canvas\", function () {\n\tlet CPM = require(\"../build/artistoo-cjs.js\")\n\tlet cpm, ca, cpmCanvas, caCanvas, cpmGM\n\n\tlet rgbToHex = function ( rgbArray ) {\n\n\t\tlet totalString = \"\"\n\n\t\tfor( let i = 0; i < 3; i++ ){\n\t\t\tlet hex = Number(rgbArray[i] ).toString(16)\n\t\t\tif (hex.length < 2) {\n\t\t\t\thex = \"0\" + hex\n\t\t\t}\n\t\t\ttotalString += hex\n\t\t}\n\n\t\treturn totalString\n\t}\n\n\tfunction getPixelOnCanvas( p, canvas ){\n\t\tcanvas.getImageData()\n\t\tconst dy = canvas.zoom*canvas.width\n\t\tconst off = (p[1]*dy + p[0])*4\n\t\tlet rgb = [ canvas.px[off], canvas.px[off+1], canvas.px[off+2] ]\n\t\treturn rgbToHex( rgb ).toUpperCase()\n\t}\n\n\tbeforeEach( function() {\n\t\t// Build a cpm and a ca\n\t\tcpm = new CPM.CPM( [200,200], [true,true],\n\t\t\t{\tT:20,\n\t\t\t\tJ : [[0,20],[20,0]],\n\t\t\t\tV : [0,100],\n\t\t\t\tLAMBDA_V:[0,50]\n\t\t\t} )\n\t\tca = new CPM.CA( [100,100], {\n\t\t\t/**\n\t\t\t * @return {number}\n\t\t\t */\n\t\t\t\"UPDATE_RULE\": \tfunction(p,N){\n\t\t\t\tlet nAlive = 0\n\t\t\t\tfor( let pn of N ){\n\t\t\t\t\tnAlive += (this.pixt(pn)===1)\n\t\t\t\t}\n\t\t\t\tif( this.pixt(p) === 1 ){\n\t\t\t\t\tif( nAlive === 2 || nAlive === 3 ){\n\t\t\t\t\t\treturn 1\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif( nAlive === 3 ) return 1\n\t\t\t\t}\n\t\t\t\treturn 0\n\t\t\t}\n\t\t})\n\n\t\t// initialize the canvas and grid manipulators\n\t\tcpmCanvas = new CPM.Canvas( cpm, {zoom:1} )\n\t\tcaCanvas = new CPM.Canvas( ca, {zoom:1} )\n\t\tcpmGM = new CPM.GridManipulator( cpm )\n\n\t\t// initialize the grids somehow\n\t\tcpmGM.seedCell(1 )\n\t\tca.setpix( [0,0], 1 )\n\t\tca.setpix( [0,1], 1 )\n\t\tca.setpix( [0,2], 2 )\n\n\t})\n\n\tit( \"drawCells should draw cells on CPM\", function(){\n\n\t\t// draw cellkind 1 in red\n\t\tcpmCanvas.drawCells(1,\"FF0000\")\n\n\t\t// check that the pixels are indeed red\n\t\tlet cp = cpm.getStat( CPM.PixelsByCell )\n\t\tfor( let p of cp[1] ){\n\t\t\texpect( getPixelOnCanvas( p, cpmCanvas ) ).toEqual( \"FF0000\" )\n\t\t}\n\n\t})\n\n\tit( \"drawCells should draw cells on CA\", function(){\n\t\tcaCanvas.drawCells(1,\"FF0000\")\n\n\t\t// check that the pixels are indeed black\n\t\texpect( getPixelOnCanvas( [0,0], caCanvas ) ).toEqual( \"FF0000\" )\n\n\t\t// check that other pixels are not colored\n\t\texpect( getPixelOnCanvas( [2,2], caCanvas ) ).not.toEqual( \"00FF00\")\n\t})\n\n\tit( \"drawOnCellBorders should draw borders on CPM\", function(){\n\n\t\t// draw cellkind 1 in red\n\t\tcpmCanvas.drawOnCellBorders(1,\"00FF00\")\n\n\t\t// check that the pixels are indeed red\n\t\tlet cp = cpm.getStat( CPM.BorderPixelsByCell )\n\t\tfor( let p of cp[1] ){\n\t\t\texpect( getPixelOnCanvas( p, cpmCanvas ) ).toEqual( \"00FF00\" )\n\t\t}\n\n\t})\n\n\tit( \"drawOnCellBorders should draw borders on CA\", function(){\n\t\tcaCanvas.drawOnCellBorders(1,\"00FF00\")\n\n\t\t// check that the pixels are indeed colored\n\t\texpect( getPixelOnCanvas( [0,0], caCanvas ) ).toEqual( \"00FF00\" )\n\n\t\t// check that other pixels are not colored\n\t\texpect( getPixelOnCanvas( [2,2], caCanvas ) ).not.toEqual( \"00FF00\")\n\t})\n\n\tit( \"drawCellBorders should work on CPM and CA\", function(){\n\t\texpect( function() { cpmCanvas.drawCellBorders(1,\"00FF00\") } ).not.toThrow()\n\t\texpect( function(){ caCanvas.drawCellBorders(1,\"00FF00\") } ).not.toThrow()\n\t})\n\n\n})\n\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/spec/CanvasSpec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 788,
    "kind": "test",
    "name": "describe0",
    "testId": 0,
    "memberof": "spec/CanvasSpec.js",
    "testDepth": 0,
    "static": true,
    "longname": "spec/CanvasSpec.js~describe0",
    "access": null,
    "description": "Some tests for drawing methods in the Canvas class.",
    "lineNumber": 4,
    "testTargets": [
      "Canvas"
    ]
  },
  {
    "__docId__": 789,
    "kind": "test",
    "name": "it1",
    "testId": 1,
    "memberof": "spec/CanvasSpec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "spec/CanvasSpec.js~describe0.it1",
    "access": null,
    "description": "drawCells should draw cells on CPM",
    "lineNumber": 72
  },
  {
    "__docId__": 790,
    "kind": "test",
    "name": "it2",
    "testId": 2,
    "memberof": "spec/CanvasSpec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "spec/CanvasSpec.js~describe0.it2",
    "access": null,
    "description": "drawCells should draw cells on CA",
    "lineNumber": 85
  },
  {
    "__docId__": 791,
    "kind": "test",
    "name": "it3",
    "testId": 3,
    "memberof": "spec/CanvasSpec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "spec/CanvasSpec.js~describe0.it3",
    "access": null,
    "description": "drawOnCellBorders should draw borders on CPM",
    "lineNumber": 95
  },
  {
    "__docId__": 792,
    "kind": "test",
    "name": "it4",
    "testId": 4,
    "memberof": "spec/CanvasSpec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "spec/CanvasSpec.js~describe0.it4",
    "access": null,
    "description": "drawOnCellBorders should draw borders on CA",
    "lineNumber": 108
  },
  {
    "__docId__": 793,
    "kind": "test",
    "name": "it5",
    "testId": 5,
    "memberof": "spec/CanvasSpec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "spec/CanvasSpec.js~describe0.it5",
    "access": null,
    "description": "drawCellBorders should work on CPM and CA",
    "lineNumber": 118
  },
  {
    "__docId__": 794,
    "kind": "testFile",
    "name": "spec/DiceSetSpec.js",
    "content": "/** Some tests for the DiceSet class.\n *\n * @test {DiceSet}*/\ndescribe(\"DiceSet\", function () {\n\tlet CPM = require(\"../build/artistoo-cjs.js\")\n\tlet cpm\n\n\tbeforeEach( function() {\n\t\t// Build a cpm and a ca\n\t\tcpm = new CPM.CPM( [100,1], [true,false],\n\t\t\t{\tT:20,\n\t\t\t\tJ : [[0,20],[20,0]]\n\t\t\t} )\n\t})\n\n\tit( \" should start empty\", function(){\n\n\t\texpect( cpm.borderpixels.elements.length ).toEqual( 0 )\n\n\t})\n\n\tit( \" should be empty after an element is added and removed\", function(){\n\n\t\tcpm.borderpixels.insert( 1 )\n\t\tcpm.borderpixels.remove( 1 )\n\t\texpect( cpm.borderpixels.elements.length ).toEqual( 0 )\n\n\t})\n\n})\n\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/spec/DiceSetSpec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 795,
    "kind": "test",
    "name": "describe6",
    "testId": 6,
    "memberof": "spec/DiceSetSpec.js",
    "testDepth": 0,
    "static": true,
    "longname": "spec/DiceSetSpec.js~describe6",
    "access": null,
    "description": "Some tests for the DiceSet class.",
    "lineNumber": 4,
    "testTargets": [
      "DiceSet"
    ]
  },
  {
    "__docId__": 796,
    "kind": "test",
    "name": "it7",
    "testId": 7,
    "memberof": "spec/DiceSetSpec.js~describe6",
    "testDepth": 1,
    "static": true,
    "longname": "spec/DiceSetSpec.js~describe6.it7",
    "access": null,
    "description": " should start empty",
    "lineNumber": 16
  },
  {
    "__docId__": 797,
    "kind": "test",
    "name": "it8",
    "testId": 8,
    "memberof": "spec/DiceSetSpec.js~describe6",
    "testDepth": 1,
    "static": true,
    "longname": "spec/DiceSetSpec.js~describe6.it8",
    "access": null,
    "description": " should be empty after an element is added and removed",
    "lineNumber": 22
  },
  {
    "__docId__": 798,
    "kind": "testFile",
    "name": "spec/grid/Grid2DSpec.js",
    "content": "/** Rigorous tests for Grid2D-specific methods. See GridExtensionSpec.js for\n * more general tests.\n *\n * @test {Grid2D}*/\ndescribe(\"Grid2D\", function () {\n\tlet CPM = require(\"../../build/artistoo-cjs.js\")\n\t//eslint-disable-next-line no-unused-vars\n\tlet grid2d, grid2dFloat, allPixelArray, simpleNeumanni, randomPixel,\n\t\tsamplePixels, borderPixelSample\n\n\n\tlet setupGrids = function(){\n\t\tgrid2d = new CPM.Grid2D([100, 131])\n\t\tgrid2dFloat = new CPM.Grid2D([200, 100], [false,false], \"Float32\" )\n\t}\n\n\tbeforeEach(function () {\n\t\tsetupGrids()\n\t\tallPixelArray = []\n\t\tfor( let x = 0; x < grid2d.extents[0]; x++ ){\n\t\t\tfor( let y = 0; y < grid2d.extents[1]; y++){\n\t\t\t\tallPixelArray.push( [x,y] )\n\t\t\t}\n\t\t}\n\n\t\t// Return a random pixel\n\t\trandomPixel = function( gridObject ) {\n\t\t\tlet p = []\n\t\t\tfor( let d=0; d < gridObject.ndim; d++ ){\n\t\t\t\tp.push( Math.round( Math.random()*( gridObject.extents[d]-1 ) ) )\n\t\t\t}\n\t\t\treturn p\n\t\t}\n\n\t\t// Return a sample of pixels\n\t\tsamplePixels = function( gridObject, n ){\n\t\t\tlet pixelArray = []\n\t\t\tfor( let i = 0; i < n; i++ ){\n\t\t\t\tpixelArray.push( randomPixel(gridObject) )\n\t\t\t}\n\t\t\treturn pixelArray\n\t\t}\n\n\t\t// Return some border pixels on the grid to check torus handling\n\t\tborderPixelSample = function( gridObject ){\n\t\t\tlet borderPixels = []\n\t\t\tborderPixels.push( [0,0] )\n\t\t\tborderPixels.push( [gridObject.extents[0]-1, 0 ] )\n\t\t\tborderPixels.push( [0, gridObject.extents[1]-1 ] )\n\t\t\tborderPixels.push( [gridObject.extents[0]-1, gridObject.extents[1]-1 ] )\n\t\t\tborderPixels.push( [0,gridObject.midpoint[1]] )\n\t\t\tborderPixels.push( [gridObject.midpoint[0],0] )\n\t\t\tborderPixels.push( [gridObject.extents[0]-1,gridObject.midpoint[1] ] )\n\t\t\tborderPixels.push( [gridObject.midpoint[0],gridObject.extents[1]-1 ] )\n\t\t\treturn borderPixels\n\t\t}\n\n\t\t// A simple function for the neumann neighborhood is used for testing.\n\t\tsimpleNeumanni = function* (i, grid){\n\t\t\tlet p = grid.i2p(i), x = p[0], y = p[1]\n\n\t\t\t// left\n\t\t\tlet l = [ x-1, y ]\n\t\t\tif( l[0] >= 0 ){\n\t\t\t\tyield grid.p2i(l)\n\t\t\t} else {\n\t\t\t\tif( grid.torus[0] ){\n\t\t\t\t\tl[0] += grid.extents[0]\n\t\t\t\t\tyield grid.p2i(l)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// right\n\t\t\tlet r = [x+1,y]\n\t\t\tif( r[0] < grid.extents[0] ){\n\t\t\t\tyield grid.p2i(r)\n\t\t\t} else {\n\t\t\t\tif( grid.torus[0] ){\n\t\t\t\t\tr[0] -= grid.extents[0]\n\t\t\t\t\tyield grid.p2i(r)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// top\n\t\t\tlet t = [ x, y-1 ]\n\t\t\tif( t[1] >= 0 ){\n\t\t\t\tyield grid.p2i(t)\n\t\t\t} else {\n\t\t\t\tif( grid.torus[1] ){\n\t\t\t\t\tt[1] += grid.extents[1]\n\t\t\t\t\tyield grid.p2i(t)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// bottom\n\t\t\tlet b = [x,y+1]\n\t\t\tif( b[1] < grid.extents[1] ){\n\t\t\t\tyield grid.p2i(b)\n\t\t\t} else {\n\t\t\t\tif( grid.torus[1] ){\n\t\t\t\t\tb[1] -= grid.extents[1]\n\t\t\t\t\tyield grid.p2i(b)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\n\tdescribe( \" [ unit tests ] \", function () {\n\n\t\t/** @test {Grid2D#pixelsi} */\n\t\tit( \"pixelsi generator reports correct IndexCoordinates\", function(){\n\t\t\tlet k = 0\n\t\t\tfor( let i of grid2d.pixelsi() ){\n\t\t\t\texpect( grid2d.i2p(i) ).toEqual( allPixelArray[k] )\n\t\t\t\tk++\n\t\t\t}\n\t\t})\n\n\t\t/** @test {Grid2D#neighi}\n\t\t * @test {Grid2D#neighiSimple} */\n\t\tit( \"neighi method should return same results as neighiSimple\", function(){\n\n\t\t\tlet checkNeighi = function( gridObject ){\n\n\t\t\t\t// Test neighi for a sample of pixels on the grid.\n\t\t\t\tfor( let pix of samplePixels( gridObject, 100 ) ){\n\t\t\t\t\tconst i = gridObject.p2i( pix )\n\t\t\t\t\tlet neigh1 = gridObject.neighiSimple( i )\n\t\t\t\t\tlet neigh2 = gridObject.neighi( i )\n\t\t\t\t\texpect( neigh1.sort() ).toEqual( neigh2.sort() )\n\t\t\t\t}\n\n\t\t\t\t// Specifically check some pixels at the borders as well\n\t\t\t\tfor( let p of borderPixelSample( gridObject ) ){\n\t\t\t\t\tconst i = gridObject.p2i( p )\n\t\t\t\t\tlet neigh1 = gridObject.neighiSimple( i )\n\t\t\t\t\tlet neigh2 = gridObject.neighi( i )\n\t\t\t\t\texpect( neigh1.sort() ).toEqual( neigh2.sort() )\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcheckNeighi( grid2d )\n\t\t\tcheckNeighi( grid2dFloat )\n\t\t})\n\n\t\t/** @test {Grid2D#neighi}*/\n\t\tdescribe( \"neighi method should return correct neighbors for specific cases: \", function(){\n\n\t\t\tlet checkExpected = function( gridObject, p, torus, expectedNbh ){\n\t\t\t\tconst nbh = gridObject.neighi( gridObject.p2i(p), torus )\n\t\t\t\tconst expectedNbh2 = expectedNbh.map( function(p) {\n\t\t\t\t\treturn gridObject.p2i(p)\n\t\t\t\t} )\n\t\t\t\texpect( nbh.length ).toEqual( expectedNbh2.length )\n\t\t\t\texpect( nbh.sort() ).toEqual( expectedNbh2.sort() )\n\t\t\t}\n\n\t\t\t// Check if neighborhoods are correct for different torus settings,\n\t\t\t// for all four corners of a gridObject.\n\t\t\tlet checkNeighi = function( gridObject ) {\n\n\t\t\t\tconst xMax = gridObject.extents[0] - 1, yMax = gridObject.extents[1] - 1\n\t\t\t\tit(\"...corner [0,0] \", function () {\n\t\t\t\t\t// case 1: corner point [0,0]\n\t\t\t\t\tcheckExpected(gridObject, [0, 0], [false, false],\n\t\t\t\t\t\t[[0, 1], [1, 1], [1, 0]])\n\t\t\t\t\tcheckExpected(gridObject, [0, 0], [false, true],\n\t\t\t\t\t\t[[0, 1], [1, 1], [1, 0], [0, yMax], [1, yMax]])\n\t\t\t\t\tcheckExpected(gridObject, [0, 0], [true, false],\n\t\t\t\t\t\t[[0, 1], [1, 1], [1, 0], [xMax, 0], [xMax, 1]])\n\t\t\t\t\tcheckExpected(gridObject, [0, 0], [true, true],\n\t\t\t\t\t\t[[0, 1], [1, 1], [1, 0],\n\t\t\t\t\t\t\t[xMax, 0], [xMax, 1], [0, yMax], [1, yMax], [xMax, yMax]])\n\t\t\t\t})\n\t\t\t\tit(\"...corner [xMax,0] \", function () {\n\t\t\t\t\t// case 2 : corner point [xMax,0]\n\t\t\t\t\tcheckExpected( gridObject, [xMax, 0], [false, false],\n\t\t\t\t\t\t[[xMax - 1, 0], [xMax - 1, 1], [xMax, 1]])\n\t\t\t\t\tcheckExpected( gridObject, [xMax,0], [false,true],\n\t\t\t\t\t\t[ [xMax - 1, 0], [xMax - 1, 1], [xMax, 1],\n\t\t\t\t\t\t\t[xMax-1,yMax], [xMax,yMax] ] )\n\t\t\t\t\tcheckExpected( gridObject, [xMax,0], [true,false],\n\t\t\t\t\t\t[ [xMax - 1, 0], [xMax - 1, 1], [xMax, 1],\n\t\t\t\t\t\t\t[0,0], [0,1] ] )\n\t\t\t\t\tcheckExpected( gridObject, [xMax,0], [true,true],\n\t\t\t\t\t\t[ [xMax - 1, 0], [xMax - 1, 1], [xMax, 1],\n\t\t\t\t\t\t\t[0,0], [0,1], [xMax-1,yMax], [xMax,yMax], [0,yMax] ] )\n\t\t\t\t})\n\t\t\t\tit(\"...corner [0,yMax] \", function () {\n\t\t\t\t\tcheckExpected( gridObject, [0,yMax], [false, false],\n\t\t\t\t\t\t[[0, yMax-1], [1,yMax], [1,yMax-1]])\n\t\t\t\t\tcheckExpected( gridObject, [0,yMax], [false,true],\n\t\t\t\t\t\t[ [0, yMax-1], [1,yMax], [1,yMax-1],\n\t\t\t\t\t\t\t[0,0], [1,0] ] )\n\t\t\t\t\tcheckExpected( gridObject, [0,yMax], [true,false],\n\t\t\t\t\t\t[ [0, yMax-1], [1,yMax], [1,yMax-1],\n\t\t\t\t\t\t\t[xMax,yMax], [xMax,yMax-1] ] )\n\t\t\t\t\tcheckExpected( gridObject, [0,yMax], [true,true],\n\t\t\t\t\t\t[  [0, yMax-1], [1,yMax], [1,yMax-1],\n\t\t\t\t\t\t\t[0,0], [1,0], [xMax,yMax-1], [xMax,yMax], [xMax,0] ] )\n\t\t\t\t})\n\t\t\t\tit(\"...corner [xMax,yMax] \", function () {\n\t\t\t\t\tcheckExpected( gridObject, [xMax,yMax], [false, false],\n\t\t\t\t\t\t[[xMax, yMax-1], [xMax-1,yMax], [xMax-1,yMax-1]])\n\t\t\t\t\tcheckExpected( gridObject, [xMax,yMax], [false, true],\n\t\t\t\t\t\t[[xMax, yMax-1], [xMax-1,yMax], [xMax-1,yMax-1],\n\t\t\t\t\t\t\t[xMax,0], [xMax-1,0] ] )\n\t\t\t\t\tcheckExpected( gridObject, [xMax,yMax], [true,false],\n\t\t\t\t\t\t[[xMax, yMax-1], [xMax-1,yMax], [xMax-1,yMax-1],\n\t\t\t\t\t\t\t[0,yMax], [0,yMax-1] ] )\n\t\t\t\t\tcheckExpected( gridObject, [xMax,yMax], [true,true],\n\t\t\t\t\t\t[[xMax, yMax-1], [xMax-1,yMax], [xMax-1,yMax-1],\n\t\t\t\t\t\t\t[0,yMax], [0,yMax-1], [xMax,0], [xMax-1,0], [0,0] ] )\n\t\t\t\t})\n\n\t\t\t}\n\n\t\t\tsetupGrids()\n\t\t\tcheckNeighi( grid2d )\n\t\t\tcheckNeighi( grid2dFloat )\n\n\t\t})\n\n\t\t/** @test {Grid2D#neighNeumanni} */\n\t\tit( \"neighNeumanni method should return correct neighbors\", function(){\n\n\t\t\tlet checkNeumanni = function( gridObject ){\n\t\t\t\t// test neighborhood of 100 random pixels\n\t\t\t\tfor( let pix of samplePixels( gridObject, 100 ) ){\n\t\t\t\t\tconst i = gridObject.p2i( pix )\n\t\t\t\t\tlet arr1=[], arr2=[]\n\t\t\t\t\tfor( let n of gridObject.neighNeumanni(i) ){ arr1.push(n) }\n\t\t\t\t\tfor( let n of simpleNeumanni(i,gridObject) ){ arr2.push(n) }\n\t\t\t\t\texpect( arr1 ).toEqual( arr2 )\n\t\t\t\t}\n\n\t\t\t\t// Specifically check some pixels at the borders as well\n\t\t\t\tfor( let p of borderPixelSample( gridObject ) ){\n\t\t\t\t\tconst i = gridObject.p2i( p )\n\t\t\t\t\tlet arr1=[], arr2=[]\n\t\t\t\t\tfor( let n of gridObject.neighNeumanni(i) ){ arr1.push(n) }\n\t\t\t\t\tfor( let n of simpleNeumanni(i,gridObject) ){ arr2.push(n) }\n\t\t\t\t\texpect( arr1 ).toEqual( arr2 )\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcheckNeumanni( grid2d )\n\t\t\tcheckNeumanni( grid2dFloat )\n\n\t\t})\n\t\t/** @test {Grid2D#neighNeumanni}*/\n\t\tdescribe( \"neighNeumanni method should return correct neighbors for specific cases: \", function(){\n\n\t\t\tlet checkExpected = function( gridObject, p, torus, expectedNbh ){\n\t\t\t\tlet nbh = []\n\t\t\t\tfor( let n of gridObject.neighNeumanni( gridObject.p2i(p), torus ) ){\n\t\t\t\t\tnbh.push( n )\n\t\t\t\t}\n\t\t\t\tconst expectedNbh2 = expectedNbh.map( function(p) {\n\t\t\t\t\treturn gridObject.p2i(p)\n\t\t\t\t} )\n\t\t\t\texpect( nbh.length ).toEqual( expectedNbh2.length )\n\t\t\t\texpect( nbh.sort() ).toEqual( expectedNbh2.sort() )\n\t\t\t}\n\n\t\t\t// Check if neighborhoods are correct for different torus settings,\n\t\t\t// for all four corners of a gridObject.\n\t\t\tlet checkNeighNeumanni = function( gridObject ) {\n\n\t\t\t\tconst xMax = gridObject.extents[0] - 1, yMax = gridObject.extents[1] - 1\n\t\t\t\tit(\"...corner [0,0] \", function () {\n\t\t\t\t\t// case 1: corner point [0,0]\n\t\t\t\t\tcheckExpected(gridObject, [0, 0], [false, false],\n\t\t\t\t\t\t[[0, 1], [1, 0]])\n\t\t\t\t\tcheckExpected(gridObject, [0, 0], [false, true],\n\t\t\t\t\t\t[[0, 1], [1, 0], [0, yMax] ])\n\t\t\t\t\tcheckExpected(gridObject, [0, 0], [true, false],\n\t\t\t\t\t\t[[0, 1], [1, 0], [xMax, 0] ])\n\t\t\t\t\tcheckExpected(gridObject, [0, 0], [true, true],\n\t\t\t\t\t\t[[0, 1], [1, 0], [xMax, 0], [0, yMax] ])\n\t\t\t\t})\n\t\t\t\tit(\"...corner [xMax,0] \", function () {\n\t\t\t\t\t// case 2 : corner point [xMax,0]\n\t\t\t\t\tcheckExpected( gridObject, [xMax, 0], [false, false],\n\t\t\t\t\t\t[[xMax - 1, 0], [xMax, 1]])\n\t\t\t\t\tcheckExpected( gridObject, [xMax,0], [false,true],\n\t\t\t\t\t\t[ [xMax - 1, 0], [xMax, 1], [xMax,yMax] ] )\n\t\t\t\t\tcheckExpected( gridObject, [xMax,0], [true,false],\n\t\t\t\t\t\t[ [xMax - 1, 0], [xMax, 1], [0,0] ] )\n\t\t\t\t\tcheckExpected( gridObject, [xMax,0], [true,true],\n\t\t\t\t\t\t[ [xMax - 1, 0], [xMax, 1], [0,0], [xMax,yMax] ] )\n\t\t\t\t})\n\t\t\t\tit(\"...corner [0,yMax] \", function () {\n\t\t\t\t\tcheckExpected( gridObject, [0,yMax], [false, false],\n\t\t\t\t\t\t[[0, yMax-1], [1,yMax] ])\n\t\t\t\t\tcheckExpected( gridObject, [0,yMax], [false,true],\n\t\t\t\t\t\t[ [0, yMax-1], [1,yMax], [0,0] ] )\n\t\t\t\t\tcheckExpected( gridObject, [0,yMax], [true,false],\n\t\t\t\t\t\t[ [0, yMax-1], [1,yMax], [xMax,yMax] ] )\n\t\t\t\t\tcheckExpected( gridObject, [0,yMax], [true,true],\n\t\t\t\t\t\t[  [0, yMax-1], [1,yMax], [0,0], [xMax,yMax] ] )\n\t\t\t\t})\n\t\t\t\tit(\"...corner [xMax,yMax] \", function () {\n\t\t\t\t\tcheckExpected( gridObject, [xMax,yMax], [false, false],\n\t\t\t\t\t\t[[xMax, yMax-1], [xMax-1,yMax] ])\n\t\t\t\t\tcheckExpected( gridObject, [xMax,yMax], [false, true],\n\t\t\t\t\t\t[[xMax, yMax-1], [xMax-1,yMax], [xMax,0] ] )\n\t\t\t\t\tcheckExpected( gridObject, [xMax,yMax], [true,false],\n\t\t\t\t\t\t[[xMax, yMax-1], [xMax-1,yMax], [0,yMax] ] )\n\t\t\t\t\tcheckExpected( gridObject, [xMax,yMax], [true,true],\n\t\t\t\t\t\t[[xMax, yMax-1], [xMax-1,yMax],\n\t\t\t\t\t\t\t[0,yMax], [xMax,0] ] )\n\t\t\t\t})\n\n\t\t\t}\n\n\t\t\tsetupGrids()\n\t\t\tcheckNeighNeumanni( grid2d )\n\t\t\tcheckNeighNeumanni( grid2dFloat )\n\n\t\t})\n\n\t\t/** @test {Grid2D#gradienti} */\n\t\tit( \"gradienti method should return correct gradients\", function(){\n\n\t\t\tlet simpleGradienti = function(i, grid){\n\n\t\t\t\tlet p = grid.i2p(i)\n\t\t\t\tlet vi = grid.pixti(i), dx, dy\n\n\t\t\t\tlet nbh = []\n\t\t\t\tfor( let n of simpleNeumanni(i,grid) ){\n\t\t\t\t\tnbh.push(n)\n\t\t\t\t}\n\n\t\t\t\tlet xNeighbors = [NaN, NaN]\n\t\t\t\tlet yNeighbors = [NaN, NaN]\n\t\t\t\t// check which neighbors there are\n\t\t\t\tfor( let n of nbh ){\n\t\t\t\t\tlet pn = grid.i2p(n)\n\t\t\t\t\t// x neighbors\n\t\t\t\t\tif( pn[1] === p[1] ){\n\t\t\t\t\t\tif( pn[0] < p[0] ){\n\t\t\t\t\t\t\txNeighbors[0] = n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\txNeighbors[1] = n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// y neighbors\n\t\t\t\t\tif( pn[0] === p[0] ){\n\t\t\t\t\t\tif( pn[1] < p[1]){\n\t\t\t\t\t\t\tyNeighbors[0] = n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tyNeighbors[1] = n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// this shouldn't happen.\n\t\t\t\tif( isNaN( xNeighbors[0] ) && isNaN(xNeighbors[1] ) ){\n\t\t\t\t\tthrow( \"no x neighbors found!\")\n\t\t\t\t}\n\t\t\t\tif( isNaN( yNeighbors[0] ) && isNaN(yNeighbors[1] ) ){\n\t\t\t\t\tthrow( \"no y neighbors found!\")\n\t\t\t\t}\n\n\t\t\t\t// compute gradients\n\t\t\t\tlet grad = function( nArr ){\n\t\t\t\t\tif( isNaN( nArr[0] ) ){\n\t\t\t\t\t\treturn grid.pixti(nArr[1]) - vi\n\t\t\t\t\t}\n\t\t\t\t\tif( isNaN( nArr[1] ) ){\n\t\t\t\t\t\treturn vi - grid.pixti(nArr[0])\n\t\t\t\t\t}\n\t\t\t\t\treturn ( ( grid.pixti(nArr[1]) - vi  ) + ( vi - grid.pixti(nArr[0])  ) )/2\n\t\t\t\t}\n\n\t\t\t\tdx = grad( xNeighbors )\n\t\t\t\tdy = grad( yNeighbors )\n\n\t\t\t\treturn [dx,dy]\n\t\t\t}\n\n\n\t\t\tlet checkGradienti = function( gridObject ){\n\n\t\t\t\t// set some random values on the float grid\n\t\t\t\tfor( let i of gridObject.pixelsi() ){\n\t\t\t\t\tgridObject.setpixi( i, Math.random()*1000 )\n\t\t\t\t}\n\n\t\t\t\t// test neighborhood of 100 random pixels\n\t\t\t\tfor( let pix of samplePixels( gridObject, 100 ) ){\n\t\t\t\t\tconst i = gridObject.p2i( pix )\n\t\t\t\t\texpect( gridObject.gradienti(i) ).toEqual( simpleGradienti(i,gridObject) )\n\t\t\t\t}\n\n\n\t\t\t\t// Specifically check some pixels at the borders as well\n\t\t\t\tfor( let p of borderPixelSample( gridObject ) ){\n\t\t\t\t\tconst i = gridObject.p2i( p )\n\t\t\t\t\texpect( gridObject.gradienti(i) ).toEqual( simpleGradienti(i,gridObject) )\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcheckGradienti( grid2dFloat )\n\n\t\t})\n\n\t})\n})",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/spec/grid/Grid2DSpec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 799,
    "kind": "test",
    "name": "describe9",
    "testId": 9,
    "memberof": "spec/grid/Grid2DSpec.js",
    "testDepth": 0,
    "static": true,
    "longname": "spec/grid/Grid2DSpec.js~describe9",
    "access": null,
    "description": "Rigorous tests for Grid2D-specific methods. See GridExtensionSpec.js for\nmore general tests.",
    "lineNumber": 5,
    "testTargets": [
      "Grid2D"
    ]
  },
  {
    "__docId__": 800,
    "kind": "test",
    "name": "describe10",
    "testId": 10,
    "memberof": "spec/grid/Grid2DSpec.js~describe9",
    "testDepth": 1,
    "static": true,
    "longname": "spec/grid/Grid2DSpec.js~describe9.describe10",
    "access": null,
    "description": " [ unit tests ] ",
    "lineNumber": 108
  },
  {
    "__docId__": 801,
    "kind": "test",
    "name": "it11",
    "testId": 11,
    "memberof": "spec/grid/Grid2DSpec.js~describe9.describe10",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/Grid2DSpec.js~describe9.describe10.it11",
    "access": null,
    "description": "pixelsi generator reports correct IndexCoordinates",
    "lineNumber": 111,
    "testTargets": [
      "Grid2D#pixelsi"
    ]
  },
  {
    "__docId__": 802,
    "kind": "test",
    "name": "it12",
    "testId": 12,
    "memberof": "spec/grid/Grid2DSpec.js~describe9.describe10",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/Grid2DSpec.js~describe9.describe10.it12",
    "access": null,
    "description": "neighi method should return same results as neighiSimple",
    "lineNumber": 121,
    "testTargets": [
      "Grid2D#neighi",
      "Grid2D#neighiSimple"
    ]
  },
  {
    "__docId__": 803,
    "kind": "test",
    "name": "describe13",
    "testId": 13,
    "memberof": "spec/grid/Grid2DSpec.js~describe9.describe10",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/Grid2DSpec.js~describe9.describe10.describe13",
    "access": null,
    "description": "neighi method should return correct neighbors for specific cases: ",
    "lineNumber": 147,
    "testTargets": [
      "Grid2D#neighi"
    ]
  },
  {
    "__docId__": 804,
    "kind": "test",
    "name": "it14",
    "testId": 14,
    "memberof": "spec/grid/Grid2DSpec.js~describe9.describe10.describe13",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/Grid2DSpec.js~describe9.describe10.describe13.it14",
    "access": null,
    "description": "...corner [0,0] ",
    "lineNumber": 163
  },
  {
    "__docId__": 805,
    "kind": "test",
    "name": "it15",
    "testId": 15,
    "memberof": "spec/grid/Grid2DSpec.js~describe9.describe10.describe13",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/Grid2DSpec.js~describe9.describe10.describe13.it15",
    "access": null,
    "description": "...corner [xMax,0] ",
    "lineNumber": 175
  },
  {
    "__docId__": 806,
    "kind": "test",
    "name": "it16",
    "testId": 16,
    "memberof": "spec/grid/Grid2DSpec.js~describe9.describe10.describe13",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/Grid2DSpec.js~describe9.describe10.describe13.it16",
    "access": null,
    "description": "...corner [0,yMax] ",
    "lineNumber": 189
  },
  {
    "__docId__": 807,
    "kind": "test",
    "name": "it17",
    "testId": 17,
    "memberof": "spec/grid/Grid2DSpec.js~describe9.describe10.describe13",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/Grid2DSpec.js~describe9.describe10.describe13.it17",
    "access": null,
    "description": "...corner [xMax,yMax] ",
    "lineNumber": 202
  },
  {
    "__docId__": 808,
    "kind": "test",
    "name": "it18",
    "testId": 18,
    "memberof": "spec/grid/Grid2DSpec.js~describe9.describe10",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/Grid2DSpec.js~describe9.describe10.it18",
    "access": null,
    "description": "neighNeumanni method should return correct neighbors",
    "lineNumber": 225,
    "testTargets": [
      "Grid2D#neighNeumanni"
    ]
  },
  {
    "__docId__": 809,
    "kind": "test",
    "name": "describe19",
    "testId": 19,
    "memberof": "spec/grid/Grid2DSpec.js~describe9.describe10",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/Grid2DSpec.js~describe9.describe10.describe19",
    "access": null,
    "description": "neighNeumanni method should return correct neighbors for specific cases: ",
    "lineNumber": 252,
    "testTargets": [
      "Grid2D#neighNeumanni"
    ]
  },
  {
    "__docId__": 810,
    "kind": "test",
    "name": "it20",
    "testId": 20,
    "memberof": "spec/grid/Grid2DSpec.js~describe9.describe10.describe19",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/Grid2DSpec.js~describe9.describe10.describe19.it20",
    "access": null,
    "description": "...corner [0,0] ",
    "lineNumber": 271
  },
  {
    "__docId__": 811,
    "kind": "test",
    "name": "it21",
    "testId": 21,
    "memberof": "spec/grid/Grid2DSpec.js~describe9.describe10.describe19",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/Grid2DSpec.js~describe9.describe10.describe19.it21",
    "access": null,
    "description": "...corner [xMax,0] ",
    "lineNumber": 282
  },
  {
    "__docId__": 812,
    "kind": "test",
    "name": "it22",
    "testId": 22,
    "memberof": "spec/grid/Grid2DSpec.js~describe9.describe10.describe19",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/Grid2DSpec.js~describe9.describe10.describe19.it22",
    "access": null,
    "description": "...corner [0,yMax] ",
    "lineNumber": 293
  },
  {
    "__docId__": 813,
    "kind": "test",
    "name": "it23",
    "testId": 23,
    "memberof": "spec/grid/Grid2DSpec.js~describe9.describe10.describe19",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/Grid2DSpec.js~describe9.describe10.describe19.it23",
    "access": null,
    "description": "...corner [xMax,yMax] ",
    "lineNumber": 303
  },
  {
    "__docId__": 814,
    "kind": "test",
    "name": "it24",
    "testId": 24,
    "memberof": "spec/grid/Grid2DSpec.js~describe9.describe10",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/Grid2DSpec.js~describe9.describe10.it24",
    "access": null,
    "description": "gradienti method should return correct gradients",
    "lineNumber": 324,
    "testTargets": [
      "Grid2D#gradienti"
    ]
  },
  {
    "__docId__": 815,
    "kind": "testFile",
    "name": "spec/grid/Grid3DSpec.js",
    "content": "/** Rigorous tests for Grid3D-specific methods. See GridExtensionSpec.js for\n * more general tests.\n *\n * @test {Grid3D}*/\ndescribe(\"Grid3D\", function () {\n\tlet CPM = require(\"../../build/artistoo-cjs.js\")\n\t//eslint-disable-next-line no-unused-vars\n\tlet grid3d, grid3dNoTorus, allPixelArray,  randomPixel //samplePixels, borderPixelSample, simpleNeumanni\n\n\n\tlet setupGrids = function(){\n\t\tgrid3d = new CPM.Grid3D([10, 13, 8] )\n\t\tgrid3dNoTorus = new CPM.Grid3D([10, 13, 8], [false,false,false] )\n\t}\n\n\tbeforeEach(function () {\n\t\tsetupGrids()\n\t\tallPixelArray = []\n\t\tfor( let x = 0; x < grid3d.extents[0]; x++ ){\n\t\t\tfor( let y = 0; y < grid3d.extents[1]; y++){\n\t\t\t\tfor( let z = 0; z < grid3d.extents[2]; z++ ) {\n\t\t\t\t\tallPixelArray.push( [x,y,z] )\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Return a random pixel\n\t\trandomPixel = function( gridObject ) {\n\t\t\tlet p = []\n\t\t\tfor( let d=0; d < gridObject.ndim; d++ ){\n\t\t\t\tp.push( Math.round( Math.random()*( gridObject.extents[d]-1 ) ) )\n\t\t\t}\n\t\t\treturn p\n\t\t}\n\n\t\t// Return a sample of pixels\n\t\t/*samplePixels = function( gridObject, n ){\n\t\t\tlet pixelArray = []\n\t\t\tfor( let i = 0; i < n; i++ ){\n\t\t\t\tpixelArray.push( randomPixel(gridObject) )\n\t\t\t}\n\t\t\treturn pixelArray\n\t\t}*/\n\n\t\t// Return corner pixels on the grid to check torus handling\n\t\t/*borderPixelSample = function( gridObject ){\n\t\t\tlet borderPixels = []\n\t\t\tconst xMax = gridObject.extents[0]-1\n\t\t\tconst yMax = gridObject.extents[1]-1\n\t\t\tconst zMax = gridObject.extents[2]-1\n\n\t\t\t// corners\n\t\t\tborderPixels.push( [0,0,0] )\n\t\t\tborderPixels.push( [xMax, 0, 0 ] )\n\t\t\tborderPixels.push( [0, yMax, 0 ] )\n\t\t\tborderPixels.push( [xMax,yMax,0 ] )\n\t\t\tborderPixels.push( [0,0,zMax] )\n\t\t\tborderPixels.push( [xMax, 0, zMax ] )\n\t\t\tborderPixels.push( [0, yMax, zMax ] )\n\t\t\tborderPixels.push( [xMax,yMax,zMax ] )\n\t\t\treturn borderPixels\n\t\t}*/\n\n\t})\n\n\tdescribe( \" [ unit tests ] \", function () {\n\n\t\t/** @test {Grid3D#pixelsi} */\n\t\tit( \"pixelsi generator reports correct IndexCoordinates\", function(){\n\t\t\tlet k = 0\n\t\t\tfor( let i of grid3d.pixelsi() ){\n\t\t\t\texpect( grid3d.i2p(i) ).toEqual( allPixelArray[k] )\n\t\t\t\tk++\n\t\t\t}\n\t\t})\n\n\n\t\t/** @test {Grid3D#neighi}*/\n\t\tdescribe( \"neighi method should return correct neighbors for specific cases: \", function(){\n\n\t\t\t//noinspection DuplicatedCode\n\t\t\tlet checkExpected = function( gridObject, p, torus, expectedNbh ){\n\t\t\t\tconst nbh = gridObject.neighi( gridObject.p2i(p), torus )\n\t\t\t\tconst expectedNbh2 = expectedNbh.map( function(p) {\n\t\t\t\t\treturn gridObject.p2i(p)\n\t\t\t\t} )\n\t\t\t\texpect( nbh.length ).toEqual( expectedNbh2.length )\n\t\t\t\texpect( nbh.sort() ).toEqual( expectedNbh2.sort() )\n\t\t\t}\n\n\t\t\t// Check if neighborhoods are correct for different torus settings,\n\t\t\t// for two opposing corners of the cubic grid (covering all faces).\n\t\t\tlet checkNeighi = function( gridObject ) {\n\n\t\t\t\tconst xMax = gridObject.extents[0] - 1,\n\t\t\t\t\tyMax = gridObject.extents[1] - 1,\n\t\t\t\t\tzMax = gridObject.extents[2] - 1\n\n\t\t\t\tit(\"...corner [0,0,0] \", function () {\n\t\t\t\t\tcheckExpected(gridObject, [0,0,0], [false,false,false],\n\t\t\t\t\t\t[ [1,0,0], [0,1,0], [0,0,1],\n\t\t\t\t\t\t\t[1,1,0], [1,0,1], [0,1,1], [1,1,1] ])\n\t\t\t\t\tcheckExpected(gridObject, [0,0,0], [true, false, false],\n\t\t\t\t\t\t[ [1,0,0], [0,1,0], [0,0,1],\n\t\t\t\t\t\t\t[1,1,0], [1,0,1], [0,1,1], [1,1,1],\n\t\t\t\t\t\t\t[xMax,0,0], [xMax,1,0], [xMax,0,1], [xMax,1,1] ])\n\t\t\t\t\tcheckExpected(gridObject, [0,0,0], [false, true, false],\n\t\t\t\t\t\t[ [1,0,0], [0,1,0], [0,0,1],\n\t\t\t\t\t\t\t[1,1,0], [1,0,1], [0,1,1], [1,1,1],\n\t\t\t\t\t\t\t[0,yMax,0], [1,yMax,0], [0,yMax,1], [1,yMax,1] ])\n\t\t\t\t\tcheckExpected(gridObject, [0,0,0], [false, false, true],\n\t\t\t\t\t\t[ [1,0,0], [0,1,0], [0,0,1],\n\t\t\t\t\t\t\t[1,1,0], [1,0,1], [0,1,1], [1,1,1],\n\t\t\t\t\t\t\t[0,0,zMax], [1,0,zMax], [0,1,zMax], [1,1,zMax] ])\n\t\t\t\t\tcheckExpected(gridObject, [0,0,0], [true, true, true],\n\t\t\t\t\t\t[ [1,0,0], [0,1,0], [0,0,1],\n\t\t\t\t\t\t\t[1,1,0], [1,0,1], [0,1,1], [1,1,1],\n\t\t\t\t\t\t\t[xMax,0,0], [xMax,1,0], [xMax,0,1], [xMax,1,1],\n\t\t\t\t\t\t\t[0,yMax,0], [1,yMax,0], [0,yMax,1], [1,yMax,1],\n\t\t\t\t\t\t\t[0,0,zMax], [1,0,zMax], [0,1,zMax], [1,1,zMax],\n\t\t\t\t\t\t\t[xMax,yMax,0], [xMax,0,zMax],  [0,yMax,zMax],\n\t\t\t\t\t\t\t[xMax,yMax,1], [xMax,1,zMax],  [1,yMax,zMax],\n\t\t\t\t\t\t\t[xMax,yMax,zMax] ])\n\n\t\t\t\t})\n\t\t\t\tit(\"...corner [xMax,yMax,zMax] \", function () {\n\t\t\t\t\tcheckExpected(gridObject, [xMax,yMax,zMax], [false,false,false],\n\t\t\t\t\t\t[ [xMax-1,yMax,zMax], [xMax,yMax-1,zMax],\n\t\t\t\t\t\t\t[xMax,yMax,zMax-1], [xMax-1,yMax-1,zMax],\n\t\t\t\t\t\t\t[xMax-1,yMax,zMax-1], [xMax,yMax-1,zMax-1],\n\t\t\t\t\t\t\t[xMax-1,yMax-1,zMax-1] ])\n\n\n\t\t\t\t\tcheckExpected(gridObject, [xMax,yMax,zMax], [true, true, true],\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\t[xMax-1,0,0], [0,yMax-1,0], [0,0,zMax-1],\n\t\t\t\t\t\t\t[xMax-1,yMax-1,0], [xMax-1,0,zMax-1], [0,yMax-1,zMax-1], [xMax-1,yMax-1,zMax-1],\n\t\t\t\t\t\t\t[xMax,0,0], [xMax,yMax-1,0], [xMax,0,zMax-1], [xMax,yMax-1,zMax-1],\n\t\t\t\t\t\t\t[0,yMax,0], [xMax-1,yMax,0], [0,yMax,zMax-1], [xMax-1,yMax,zMax-1],\n\t\t\t\t\t\t\t[0,0,zMax], [xMax-1,0,zMax], [0,yMax-1,zMax], [xMax-1,yMax-1,zMax],\n\t\t\t\t\t\t\t[xMax,yMax,0], [xMax,0,zMax],  [0,yMax,zMax],\n\t\t\t\t\t\t\t[xMax,yMax,zMax-1], [xMax,yMax-1,zMax],  [xMax-1,yMax,zMax],\n\t\t\t\t\t\t\t[0,0,0]\n\t\t\t\t\t\t])\n\n\t\t\t\t})\n\n\t\t\t}\n\n\t\t\tsetupGrids()\n\t\t\tcheckNeighi( grid3d )\n\t\t\tcheckNeighi( grid3dNoTorus )\n\n\t\t})\n\n\n\t})\n})",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/spec/grid/Grid3DSpec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 816,
    "kind": "test",
    "name": "describe25",
    "testId": 25,
    "memberof": "spec/grid/Grid3DSpec.js",
    "testDepth": 0,
    "static": true,
    "longname": "spec/grid/Grid3DSpec.js~describe25",
    "access": null,
    "description": "Rigorous tests for Grid3D-specific methods. See GridExtensionSpec.js for\nmore general tests.",
    "lineNumber": 5,
    "testTargets": [
      "Grid3D"
    ]
  },
  {
    "__docId__": 817,
    "kind": "test",
    "name": "describe26",
    "testId": 26,
    "memberof": "spec/grid/Grid3DSpec.js~describe25",
    "testDepth": 1,
    "static": true,
    "longname": "spec/grid/Grid3DSpec.js~describe25.describe26",
    "access": null,
    "description": " [ unit tests ] ",
    "lineNumber": 66
  },
  {
    "__docId__": 818,
    "kind": "test",
    "name": "it27",
    "testId": 27,
    "memberof": "spec/grid/Grid3DSpec.js~describe25.describe26",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/Grid3DSpec.js~describe25.describe26.it27",
    "access": null,
    "description": "pixelsi generator reports correct IndexCoordinates",
    "lineNumber": 69,
    "testTargets": [
      "Grid3D#pixelsi"
    ]
  },
  {
    "__docId__": 819,
    "kind": "test",
    "name": "describe28",
    "testId": 28,
    "memberof": "spec/grid/Grid3DSpec.js~describe25.describe26",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/Grid3DSpec.js~describe25.describe26.describe28",
    "access": null,
    "description": "neighi method should return correct neighbors for specific cases: ",
    "lineNumber": 79,
    "testTargets": [
      "Grid3D#neighi"
    ]
  },
  {
    "__docId__": 820,
    "kind": "test",
    "name": "it29",
    "testId": 29,
    "memberof": "spec/grid/Grid3DSpec.js~describe25.describe26.describe28",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/Grid3DSpec.js~describe25.describe26.describe28.it29",
    "access": null,
    "description": "...corner [0,0,0] ",
    "lineNumber": 99
  },
  {
    "__docId__": 821,
    "kind": "test",
    "name": "it30",
    "testId": 30,
    "memberof": "spec/grid/Grid3DSpec.js~describe25.describe26.describe28",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/Grid3DSpec.js~describe25.describe26.describe28.it30",
    "access": null,
    "description": "...corner [xMax,yMax,zMax] ",
    "lineNumber": 126
  },
  {
    "__docId__": 822,
    "kind": "testFile",
    "name": "spec/grid/GridExtensionSpec.js",
    "content": "/** General tests that every Grid subclass should pass\n * @test {Grid2D}\n * @test {Grid3D} */\ndescribe(\"Subclasses extending the Grid superclass\", function () {\n\t/*\n\tTesting for having a _pixelArray, and the p2i/i2p/neighi methods and the\n\tpixels(i) generators.\n\tOther methods that should be implemented in grid subclasses (gradienti,\n\tlaplaciani, neighNeumanni) are not enforced since they are not used by all\n\tCPMs.\n\t*/\n\n\n\tlet CPM = require(\"../../build/artistoo-cjs.js\")\n\tlet testObjects = [], testNames = []\n\tlet addTestObject = function( object, name ){\n\t\ttestObjects.push( object )\n\t\ttestNames.push( name )\n\t}\n\n\t// You can add your own grid subclasses to be tested here.\n\taddTestObject( new CPM.Grid2D( [50,50] ), \"Grid2D (torus-Uint16)\" )\n\taddTestObject( new CPM.Grid2D( [100,100],[false,false],\"Float32\" ),\n\t\t\"Grid2D (noTorus-Float32)\" )\n\taddTestObject( new CPM.Grid3D( [50,50,50] ), \"Grid3D\" )\n\n\n\t// Uncomment the following to see that the tests fail when the grid\n\t// extension does not implement the necessary methods.\n\t/*class MyGrid extends CPM.Grid {\n\t\tmyMethod(){\n\t\t\treturn 1\n\t\t}\n\t}\n\taddTestObject( new MyGrid( [50,50] ), \"MyGrid\" )*/\n\n\n\tfor( let i = 0; i < testObjects.length; i++ ){\n\n\t\tlet subclassName = \" \" + testNames[i] + \": \"\n\t\tlet obj = testObjects[i]\n\t\tlet p = []\n\t\tfor( let d = 0; d < obj.ndim; d++ ){\n\t\t\tp.push(0)\n\t\t}\n\n\t\tdescribe( subclassName, function(){\n\n\t\t\tit( \"should all have a _pixelArray\", function(){\n\t\t\t\texpect( obj._pixelArray ).toBeDefined()\n\t\t\t\texpect( obj._pixelArray.length ).toEqual( obj.p2i( obj.extents ) )\n\t\t\t})\n\n\t\t\tit( \"should all have a p2i method\", function(){\n\t\t\t\texpect( obj.p2i ).toBeDefined()\n\t\t\t\texpect( obj.p2i ).toEqual( jasmine.any(Function))\n\t\t\t\texpect( function() { obj.p2i(p) } ).not.toThrow(\n\t\t\t\t\t\"A p2i method should be implemented in every Grid subclass!\"\n\t\t\t\t)\n\t\t\t})\n\n\t\t\tit( \"should all have an i2p method\", function(){\n\t\t\t\texpect( obj.i2p ).toBeDefined()\n\t\t\t\texpect( obj.i2p ).toEqual( jasmine.any(Function))\n\t\t\t\texpect( function() { obj.i2p(0) } ).not.toThrow(\n\t\t\t\t\t\"An i2p method should be implemented in every Grid subclass!\"\n\t\t\t\t)\n\t\t\t})\n\n\t\t\t/** @test {Grid2D#i2p}\n\t\t\t * @test {Grid2D#p2i}\n\t\t\t * @test {Grid3D#p2i}\n\t\t\t * @test {Grid3D#i2p} */\n\t\t\tit( \"i2p and p2i should be inverse for valid grid coordinates\", function(){\n\n\t\t\t\t// Test 10 randomly sampled pixels on the grid.\n\t\t\t\tfor( let t = 0; t < 10; t++ ){\n\n\t\t\t\t\t// Pick random position on the grid\n\t\t\t\t\tlet validPosition = []\n\t\t\t\t\tfor( let d = 0; d < obj.ndim; d++ ){\n\t\t\t\t\t\tlet posD = Math.round( Math.random()*(obj.extents[d]-1) )\n\t\t\t\t\t\tvalidPosition.push( posD )\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if inverse relation holds.\n\t\t\t\t\tlet validPositionIndex = obj.p2i( validPosition )\n\t\t\t\t\texpect( obj.p2i( obj.i2p( validPositionIndex ) ) ).toEqual( validPositionIndex )\n\t\t\t\t\texpect( obj.i2p( obj.p2i( validPosition ) ) ).toEqual( validPosition )\n\t\t\t\t}\n\n\t\t\t})\n\n\t\t\tit( \"should all have a neighi method\", function(){\n\t\t\t\texpect( obj.neighi ).toBeDefined()\n\t\t\t\texpect( obj.neighi ).toEqual( jasmine.any(Function))\n\t\t\t\texpect( function(){ obj.neighi( 0 ) } ).not.toThrow(\n\t\t\t\t\t\"A neighi method should be implemented in every Grid subclass!\"\n\t\t\t\t)\n\t\t\t})\n\n\t\t\tit( \"should all have pixels(i) generator methods\", function(){\n\t\t\t\texpect( function() {\n\t\t\t\t\tlet arr = []\n\t\t\t\t\tfor( p of obj.pixelsi() ){\n\t\t\t\t\t\tarr.push(p)\n\t\t\t\t\t}\n\t\t\t\t\treturn arr\n\t\t\t\t}).not.toThrow()\n\t\t\t\texpect( function() {\n\t\t\t\t\tlet arr = []\n\t\t\t\t\tfor( p of obj.pixels() ){\n\t\t\t\t\t\tarr.push(p)\n\t\t\t\t\t}\n\t\t\t\t\treturn arr\n\t\t\t\t}).not.toThrow()\n\t\t\t})\n\t\t})\n\n\t}\n})\n\n/** Grid subclasses supporting diffusion.\n * @test {Grid2D} */\ndescribe(\"Grid subclasses supporting diffusion\", function () {\n\n\tlet CPM = require(\"../../build/artistoo-cjs.js\")\n\tlet testObjects2 = [], testNames2 = []\n\tlet addTestObject = function( object, name ){\n\t\ttestObjects2.push( object )\n\t\ttestNames2.push( name )\n\t}\n\n\t// You can add your own grid subclasses to be tested here.\n\taddTestObject( new CPM.Grid2D( [100,100],[false,false],\"Float32\" ),\n\t\t\"Grid2D (noTorus-Float32)\" )\n\t// 3D is not supported yet.\n\t//addTestObject( new CPM.Grid3D( [50,50,50], [false,false,false] ), \"Grid3D\" )\n\n\tfor( let i = 0; i < testObjects2.length; i++ ) {\n\n\t\tlet subclassName = \" \" + testNames2[i] + \": \"\n\t\tlet obj = testObjects2[i]\n\t\tlet p = []\n\t\tfor (let d = 0; d < obj.ndim; d++) {\n\t\t\tp.push(0)\n\t\t}\n\n\t\tdescribe( \" [ subclass \" + subclassName + \" ] \", function () {\n\n\t\t\tit( \"should support a Float datatype\", function() {\n\n\t\t\t\texpect( obj.datatype ).toBeDefined()\n\t\t\t\texpect( obj.datatype ).toEqual( \"Float32\" )\n\n\t\t\t})\n\n\t\t\tit( \"should be able to store Floating point and negative numbers\", function(){\n\n\t\t\t\texpect( function() { obj.setpixi(0,-1) } ).not.toThrow()\n\t\t\t\texpect( obj.pixti(0) ).toEqual( -1 )\n\t\t\t\texpect( function() { obj.setpixi(0,12.45) } ).not.toThrow()\n\t\t\t\texpect( obj.pixti(0) ).toBeCloseTo( 12.45, 6 )\n\n\t\t\t})\n\n\t\t\tit( \"should have a gradienti method\", function(){\n\t\t\t\texpect( obj.gradienti ).toBeDefined()\n\t\t\t\texpect( obj.gradienti ).toEqual( jasmine.any(Function))\n\t\t\t\texpect( function(){ obj.neighi( 0 ) } ).not.toThrow(\n\t\t\t\t\t\"method 'gradienti' not implemented! \"\n\t\t\t\t)\n\t\t\t})\n\n\t\t\tit( \"should have a neighNeumanni generator\", function(){\n\t\t\t\texpect( obj.neighNeumanni ).toBeDefined()\n\t\t\t\texpect( obj.neighNeumanni ).toEqual( jasmine.any(Function))\n\t\t\t\texpect( function() {\n\t\t\t\t\tobj.neighNeumanni( 0 ).next()\n\t\t\t\t}).not.toThrow(\n\t\t\t\t\t\"Trying to call the method neighNeumanni, but you haven't \" +\n\t\t\t\t\t\"implemented this method in the Grid subclass you are using!\"\n\t\t\t\t)\n\t\t\t})\n\n\n\t\t})\n\t}\n})\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/spec/grid/GridExtensionSpec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 823,
    "kind": "test",
    "name": "describe31",
    "testId": 31,
    "memberof": "spec/grid/GridExtensionSpec.js",
    "testDepth": 0,
    "static": true,
    "longname": "spec/grid/GridExtensionSpec.js~describe31",
    "access": null,
    "description": "General tests that every Grid subclass should pass",
    "lineNumber": 4,
    "testTargets": [
      "Grid2D",
      "Grid3D"
    ]
  },
  {
    "__docId__": 824,
    "kind": "test",
    "name": "describe32",
    "testId": 32,
    "memberof": "spec/grid/GridExtensionSpec.js~describe31",
    "testDepth": 1,
    "static": true,
    "longname": "spec/grid/GridExtensionSpec.js~describe31.describe32",
    "access": null,
    "lineNumber": 47
  },
  {
    "__docId__": 825,
    "kind": "test",
    "name": "it33",
    "testId": 33,
    "memberof": "spec/grid/GridExtensionSpec.js~describe31.describe32",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridExtensionSpec.js~describe31.describe32.it33",
    "access": null,
    "description": "should all have a _pixelArray",
    "lineNumber": 49
  },
  {
    "__docId__": 826,
    "kind": "test",
    "name": "it34",
    "testId": 34,
    "memberof": "spec/grid/GridExtensionSpec.js~describe31.describe32",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridExtensionSpec.js~describe31.describe32.it34",
    "access": null,
    "description": "should all have a p2i method",
    "lineNumber": 54
  },
  {
    "__docId__": 827,
    "kind": "test",
    "name": "it35",
    "testId": 35,
    "memberof": "spec/grid/GridExtensionSpec.js~describe31.describe32",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridExtensionSpec.js~describe31.describe32.it35",
    "access": null,
    "description": "should all have an i2p method",
    "lineNumber": 62
  },
  {
    "__docId__": 828,
    "kind": "test",
    "name": "it36",
    "testId": 36,
    "memberof": "spec/grid/GridExtensionSpec.js~describe31.describe32",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridExtensionSpec.js~describe31.describe32.it36",
    "access": null,
    "description": "i2p and p2i should be inverse for valid grid coordinates",
    "lineNumber": 74,
    "testTargets": [
      "Grid2D#i2p",
      "Grid2D#p2i",
      "Grid3D#p2i",
      "Grid3D#i2p"
    ]
  },
  {
    "__docId__": 829,
    "kind": "test",
    "name": "it37",
    "testId": 37,
    "memberof": "spec/grid/GridExtensionSpec.js~describe31.describe32",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridExtensionSpec.js~describe31.describe32.it37",
    "access": null,
    "description": "should all have a neighi method",
    "lineNumber": 94
  },
  {
    "__docId__": 830,
    "kind": "test",
    "name": "it38",
    "testId": 38,
    "memberof": "spec/grid/GridExtensionSpec.js~describe31.describe32",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridExtensionSpec.js~describe31.describe32.it38",
    "access": null,
    "description": "should all have pixels(i) generator methods",
    "lineNumber": 102
  },
  {
    "__docId__": 831,
    "kind": "test",
    "name": "describe39",
    "testId": 39,
    "memberof": "spec/grid/GridExtensionSpec.js",
    "testDepth": 0,
    "static": true,
    "longname": "spec/grid/GridExtensionSpec.js~describe39",
    "access": null,
    "description": "Grid subclasses supporting diffusion.",
    "lineNumber": 125,
    "testTargets": [
      "Grid2D"
    ]
  },
  {
    "__docId__": 832,
    "kind": "test",
    "name": "describe40",
    "testId": 40,
    "memberof": "spec/grid/GridExtensionSpec.js~describe39",
    "testDepth": 1,
    "static": true,
    "longname": "spec/grid/GridExtensionSpec.js~describe39.describe40",
    "access": null,
    "lineNumber": 149
  },
  {
    "__docId__": 833,
    "kind": "test",
    "name": "it41",
    "testId": 41,
    "memberof": "spec/grid/GridExtensionSpec.js~describe39.describe40",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridExtensionSpec.js~describe39.describe40.it41",
    "access": null,
    "description": "should support a Float datatype",
    "lineNumber": 151
  },
  {
    "__docId__": 834,
    "kind": "test",
    "name": "it42",
    "testId": 42,
    "memberof": "spec/grid/GridExtensionSpec.js~describe39.describe40",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridExtensionSpec.js~describe39.describe40.it42",
    "access": null,
    "description": "should be able to store Floating point and negative numbers",
    "lineNumber": 158
  },
  {
    "__docId__": 835,
    "kind": "test",
    "name": "it43",
    "testId": 43,
    "memberof": "spec/grid/GridExtensionSpec.js~describe39.describe40",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridExtensionSpec.js~describe39.describe40.it43",
    "access": null,
    "description": "should have a gradienti method",
    "lineNumber": 167
  },
  {
    "__docId__": 836,
    "kind": "test",
    "name": "it44",
    "testId": 44,
    "memberof": "spec/grid/GridExtensionSpec.js~describe39.describe40",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridExtensionSpec.js~describe39.describe40.it44",
    "access": null,
    "description": "should have a neighNeumanni generator",
    "lineNumber": 175
  },
  {
    "__docId__": 837,
    "kind": "testFile",
    "name": "spec/grid/GridManipulatorSpec.js",
    "content": "/** Tests for Grid Manipulator\n *\n * @test {GridManipulator}*/\ndescribe(\"GridManipulator\", function () {\n\tlet CPM = require(\"../../build/artistoo-cjs.js\")\n\t//eslint-disable-next-line no-unused-vars\n\tlet C, G\n\n\tlet setupSim = function ( ) {\n\n\t\tC = new CPM.CPM( [50,50], {\n\t\t\tT : 10,\n\t\t\tJ: [[0,10], [10,0]],\n\t\t\tV : [0,10],\n\t\t\tLAMBDA_V : [0,5]\n\t\t} )\n\n\t\tG = new CPM.GridManipulator( C )\n\t\tG.seedCell(1 )\n\t\tfor( let t = 0; t < 10; t++ ){ C.monteCarloStep() }\n\t}\n\n\tdescribe(\" [ unit tests ] \", function () {\n\n\t\t/** @test {GridManipulator#seedCellAt} */\n\t\tit(\"seedCellAt should not throw error normally\", function () {\n\t\t\tsetupSim()\n\t\t\texpect( function() { G.seedCellAt( 1, [0,0] ) }).not.toThrow()\n\t\t})\n\t\tit(\"seedCellAt should throw error when trying to seed outside of grid\", function () {\n\t\t\tsetupSim()\n\t\t\texpect( function() { G.seedCellAt( 1, [300,-5]) }).toThrow()\n\t\t})\n\n\t\t/** @test {GridManipulator#killCell} */\n\t\tit(\"should remove a cellID from the grid\", function () {\n\t\t\tsetupSim()\n\t\t\tconst cid = C.cellIDs().next().value\n\t\t\texpect( function() { G.killCell(cid) }).not.toThrow()\n\t\t\tlet pixels = []\n\t\t\tfor( let [p,i] of C.grid.pixels() ){\n\n\t\t\t\tif( i.toString() === cid ){\n\t\t\t\t\tpixels.push(p)\n\t\t\t\t}\n\t\t\t}\n\t\t\texpect( pixels.length ).toEqual( 0 )\n\t\t})\n\n\t\tit(\"should not mess up cellKinds etc\", function () {\n\t\t\tsetupSim()\n\t\t\tconst cid = C.cellIDs().next().value\n\n\t\t\t// seed a second cell\n\t\t\tG.seedCellAt( 1, [1,1] )\n\t\t\t// kill the first cell\n\t\t\tG.killCell(cid)\n\n\t\t\t// check that all pixt() and cellKind() are still defined.\n\t\t\tfor( let [p,i] of C.grid.pixels() ){\n\t\t\t\texpect( C.pixt(p) ).toBeDefined()\n\t\t\t\texpect( C.cellKind(i) ).toBeDefined()\n\t\t\t\texpect( C.cellKind(i) ).toEqual( 1 )\n\t\t\t}\n\t\t})\n\n\t})\n})",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/spec/grid/GridManipulatorSpec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 838,
    "kind": "test",
    "name": "describe45",
    "testId": 45,
    "memberof": "spec/grid/GridManipulatorSpec.js",
    "testDepth": 0,
    "static": true,
    "longname": "spec/grid/GridManipulatorSpec.js~describe45",
    "access": null,
    "description": "Tests for Grid Manipulator",
    "lineNumber": 4,
    "testTargets": [
      "GridManipulator"
    ]
  },
  {
    "__docId__": 839,
    "kind": "test",
    "name": "describe46",
    "testId": 46,
    "memberof": "spec/grid/GridManipulatorSpec.js~describe45",
    "testDepth": 1,
    "static": true,
    "longname": "spec/grid/GridManipulatorSpec.js~describe45.describe46",
    "access": null,
    "description": " [ unit tests ] ",
    "lineNumber": 23
  },
  {
    "__docId__": 840,
    "kind": "test",
    "name": "it47",
    "testId": 47,
    "memberof": "spec/grid/GridManipulatorSpec.js~describe45.describe46",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridManipulatorSpec.js~describe45.describe46.it47",
    "access": null,
    "description": "seedCellAt should not throw error normally",
    "lineNumber": 26,
    "testTargets": [
      "GridManipulator#seedCellAt"
    ]
  },
  {
    "__docId__": 841,
    "kind": "test",
    "name": "it48",
    "testId": 48,
    "memberof": "spec/grid/GridManipulatorSpec.js~describe45.describe46",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridManipulatorSpec.js~describe45.describe46.it48",
    "access": null,
    "description": "seedCellAt should throw error when trying to seed outside of grid",
    "lineNumber": 30
  },
  {
    "__docId__": 842,
    "kind": "test",
    "name": "it49",
    "testId": 49,
    "memberof": "spec/grid/GridManipulatorSpec.js~describe45.describe46",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridManipulatorSpec.js~describe45.describe46.it49",
    "access": null,
    "description": "should remove a cellID from the grid",
    "lineNumber": 36,
    "testTargets": [
      "GridManipulator#killCell"
    ]
  },
  {
    "__docId__": 843,
    "kind": "test",
    "name": "it50",
    "testId": 50,
    "memberof": "spec/grid/GridManipulatorSpec.js~describe45.describe46",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridManipulatorSpec.js~describe45.describe46.it50",
    "access": null,
    "description": "should not mess up cellKinds etc",
    "lineNumber": 50
  },
  {
    "__docId__": 844,
    "kind": "testFile",
    "name": "spec/grid/GridSpec.js",
    "content": "/** @test {Grid}*/\ndescribe(\"Grid\", function () {\n\tlet CPM = require(\"../../build/artistoo-cjs.js\")\n\t//eslint-disable-next-line no-unused-vars\n\tlet grid2d, grid3d, grid\n\n\tbeforeEach(function () {\n\t\tgrid2d = new CPM.Grid2D([100, 100])\n\t\tgrid3d = new CPM.Grid3D([100, 100, 100])\n\t})\n\n\n\tdescribe( \" [ unit tests ] \", function (){\n\t\t/** @test {Grid#constructor} */\n\t\tdescribe( \" constructor \", function(){\n\t\t\t/* Checking errors thrown by the constructor*/\n\t\t\tit(\"should throw an error when torus is specified for an incorrect number of dimensions\", function () {\n\t\t\t\texpect(function () {\n\t\t\t\t\tgrid = new CPM.Grid2D([100, 100], [true])\n\t\t\t\t}).toThrow(\"Torus should be specified for each dimension, or not at all!\")\n\t\t\t\texpect(function () {\n\t\t\t\t\t//noinspection JSCheckFunctionSignatures\n\t\t\t\t\tgrid = new CPM.Grid2D([100, 100], true)\n\t\t\t\t}).toThrow(\"Torus should be specified for each dimension, or not at all!\")\n\t\t\t\texpect(function () {\n\t\t\t\t\tgrid = new CPM.Grid2D([100, 100], [true, true, true])\n\t\t\t\t}).toThrow(\"Torus should be specified for each dimension, or not at all!\")\n\t\t\t\texpect(function () {\n\t\t\t\t\tgrid = new CPM.Grid3D([100, 100, 100], [true, true])\n\t\t\t\t}).toThrow(\"Torus should be specified for each dimension, or not at all!\")\n\t\t\t})\n\n\t\t\t/* Checking properties set by the constructor*/\n\t\t\tit(\"should set a size for each dimension\", function () {\n\t\t\t\texpect(grid2d.ndim).toEqual(grid2d.extents.length)\n\t\t\t\texpect(grid3d.ndim).toEqual(grid3d.extents.length)\n\t\t\t})\n\n\t\t\tit(\"should set a torus property in each dimension\", function () {\n\t\t\t\texpect(grid2d.ndim).toEqual(grid2d.torus.length)\n\t\t\t\texpect(grid3d.ndim).toEqual(grid3d.torus.length)\n\t\t\t})\n\n\t\t\tit(\"should by default set torus = true in each dimension\", function () {\n\t\t\t\tfor (let i = 0; i < grid2d.ndim; i++) {\n\t\t\t\t\texpect(grid2d.torus[i] = true)\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < grid3d.ndim; i++) {\n\t\t\t\t\texpect(grid3d.torus[i] = true)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tit(\"should be able to handle different torus settings for each dimension\", function () {\n\t\t\t\tlet grid = new CPM.Grid2D([100, 100], [true, false])\n\t\t\t\texpect(grid.torus[0]).toBe(true)\n\t\t\t\texpect(grid.torus[1]).toBe(false)\n\t\t\t})\n\n\t\t\tit(\"should be able to handle a different size in each dimension\", function () {\n\t\t\t\tlet grid = new CPM.Grid2D([100, 300])\n\t\t\t\texpect(grid.extents[0]).not.toEqual(grid.extents[1])\n\t\t\t})\n\n\t\t\tit(\"should compute a midpoint at the correct position\", function () {\n\t\t\t\texpect(grid2d.midpoint.length).toEqual(2)\n\t\t\t\texpect(grid3d.midpoint.length).toEqual(3)\n\n\t\t\t\tgrid2d = new CPM.Grid2D([101, 101])\n\t\t\t\texpect((grid2d.midpoint[0] - grid2d.extents[0]/2) <= 1).toBeTruthy()\n\t\t\t\texpect((grid2d.midpoint[1] - grid2d.extents[1]/2) <= 1).toBeTruthy()\n\t\t\t\texpect((grid3d.midpoint[2] - grid3d.extents[2]/2) <= 1).toBeTruthy()\n\t\t\t})\n\t\t})\n\n\t\t/** @test {Grid#neigh} */\n\t\tdescribe( \" neigh method \", function(){\n\t\t\tlet g2D\n\t\t\tbeforeEach( function() {\n\t\t\t\t// Create a grid 2D object with mock functions except neigh to test the\n\t\t\t\t// functionality of the Grid class independently of the\n\t\t\t\t// Grid2D and Grid3D subclasses.\n\t\t\t\tg2D = new CPM.Grid2D( [100,100] )\n\t\t\t\t//g2D = jasmine.createSpyObj(\"g2D\", [ \"neighi\",\"p2i\",\"i2p\" ])\n\t\t\t\t// A mock neighi method for the unit test\n\t\t\t\tspyOn( g2D, \"neighi\" ).and.callFake( function ( i, torus ){\n\t\t\t\t\tlet arr = []\n\t\t\t\t\tif( (i-1) >= 0 ){\n\t\t\t\t\t\tarr.push( i-1 )\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor( let d = 0; d < torus.length; d++ ){\n\t\t\t\t\t\t\tif( torus[d] ) { arr.push( -(1+d )) }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tarr.push( i + 1 )\n\n\t\t\t\t\treturn arr\n\t\t\t\t})\n\t\t\t\tspyOn( g2D, \"i2p\" ).and.callFake( function(i) {\n\t\t\t\t\treturn( [0,i] )\n\t\t\t\t})\n\t\t\t\tspyOn( g2D, \"p2i\" ).and.callFake( function(p) {\n\t\t\t\t\treturn p[1]\n\t\t\t\t})\n\t\t\t})\n\n\t\t\tit( \" should return an array coordinate\", function(){\n\t\t\t\tlet nbh = g2D.neigh( [0,0] )\n\t\t\t\tfor( let i = 0; i < nbh.length; i++ ){\n\t\t\t\t\tlet n = nbh[i]\n\t\t\t\t\texpect( n.length ).toEqual( 2 )\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tit( \" should listen to torus for each dimension\",\n\t\t\t\tfunction() {\n\t\t\t\t\t// the mock function adds a neighbor for each dim with a torus.\n\t\t\t\t\t// the mock function should return only one neighbor for [0,0]\n\t\t\t\t\t// when there is no torus.\n\t\t\t\t\tlet nNeighbors = g2D.neigh( [0,0], [false,false] ).length\n\t\t\t\t\texpect( nNeighbors ).toEqual(1)\n\t\t\t\t\tnNeighbors = g2D.neigh( [0,0], [false,true] ).length\n\t\t\t\t\texpect( nNeighbors ).toEqual( 2 )\n\t\t\t\t\tnNeighbors = g2D.neigh( [0,0], [true,false] ).length\n\t\t\t\t\texpect( nNeighbors ).toEqual( 2 )\n\t\t\t\t\tnNeighbors = g2D.neigh( [0,0], [true,true] ).length\n\t\t\t\t\texpect( nNeighbors ).toEqual( 3 )\n\n\t\t\t\t\t// torus doesn't matter when not at 'border'\n\t\t\t\t\tnNeighbors =  g2D.neigh( [1,1], [false,false] ).length\n\t\t\t\t\texpect( nNeighbors ).toEqual( 2 )\n\t\t\t\t\tnNeighbors = g2D.neigh( [1,1], [true,true] ).length\n\t\t\t\t\texpect( nNeighbors ).toEqual( 2 )\n\t\t\t\t})\n\t\t})\n\n\t\t/** @test {Grid#setpix}\n\t\t * @test {Grid#setpixi} */\n\t\tdescribe( \" setpix(i) methods \", function() {\n\t\t\tlet grid2D, grid2Db\n\n\t\t\tbeforeEach( function(){\n\t\t\t\tgrid2D = new CPM.Grid2D( [50,50] )\n\t\t\t\tgrid2Db = new CPM.Grid2D( [50,50], [false,false],\"Float32\" )\n\t\t\t\t// mock functions of the p2i and i2p implemented in the subclass.\n\t\t\t\tspyOn( grid2D, \"p2i\" ).and.returnValue( 0 )\n\t\t\t\tspyOn( grid2D, \"i2p\" ).and.returnValue( [0,0] )\n\t\t\t\tspyOn( grid2Db, \"p2i\" ).and.returnValue( 0 )\n\t\t\t\tspyOn( grid2Db, \"i2p\" ).and.returnValue( [0,0] )\n\t\t\t})\n\n\t\t\t/**\n\t\t\t * @test {Grid#setpix}\n\t\t\t * @test {Grid#setpixi}\n\t\t\t * */\n\t\t\tit( \"can be called\", function(){\n\n\t\t\t\texpect( grid2D.pixti( 0 ) ).toEqual( 0 )\n\t\t\t\texpect( function(){ grid2D.setpixi( 0, 1 ) } ).not.toThrow()\n\t\t\t\texpect( function(){ grid2D.setpix( [0,0], 2 ) } ).not.toThrow()\n\t\t\t\texpect( function(){ grid2Db.setpix( [0,0], -1 ) } ).not.toThrow()\n\t\t\t})\n\n\t\t\t/**\n\t\t\t * @test {Grid#setpix}\n\t\t\t * @test {Grid#setpixi}\n\t\t\t * @test {Grid#_isValidValue}\n\t\t\t * */\n\t\t\tit( \" should prohibit setting an invalid type on the grid to avoid bugs\", function() {\n\t\t\t\texpect( function(){ grid2D.setpix( [0,0], -1 ) } ).toThrow()\n\t\t\t\texpect( function(){ grid2D.setpix( [0,0], 2.5 ) } ).toThrow()\n\t\t\t\texpect( function(){ grid2D.setpixi( 0, -1 ) } ).toThrow()\n\t\t\t\texpect( function(){ grid2D.setpixi( 0, 2.5 ) } ).toThrow()\n\n\t\t\t\t// but small numeric differences are tolerated\n\t\t\t\texpect( function(){ grid2D.setpixi( 0, 1.00000001 )}).not.toThrow()\n\t\t\t\texpect( function(){ grid2D.setpix( [0,0], 1.00000001 )}).not.toThrow()\n\t\t\t})\n\n\t\t\t/**\n\t\t\t * @test {Grid#setpix}\n\t\t\t * @test {Grid#setpixi}\n\t\t\t * */\n\t\t\tit( \"store values in the Grid correctly\", function(){\n\n\t\t\t\t// ---- Case 1 : Uint16 grid\n\t\t\t\t// Before setpix, values are zero:\n\t\t\t\texpect( grid2D.pixti( 0 ) ).toEqual( 0 )\n\t\t\t\tlet randomInt1 = Math.round( Math.random()*100 )\n\t\t\t\tgrid2D.setpixi( 0, randomInt1 )\n\t\t\t\texpect( grid2D.pixti( 0 ) ).toEqual( randomInt1 )\n\n\t\t\t\tlet randomInt2 = Math.round( Math.random()*100 )\n\t\t\t\tgrid2D.setpix( [0,0], randomInt2 )\n\t\t\t\texpect( grid2D.pixti( 0 ) ).toEqual( randomInt2 )\n\n\t\t\t\t// --- Case 2 : Float32 grid\n\t\t\t\t// It should be possible to set a negative value.\n\t\t\t\texpect( function(){ grid2Db.setpix( [0,0], -1 ) } ).not.toThrow()\n\t\t\t\texpect( grid2Db.pixti( 0 ) ).toEqual( -1 )\n\n\t\t\t\t// ... Or a floating point number\n\t\t\t\tlet value = 2.345\n\t\t\t\texpect( function(){ grid2Db.setpix( [0,0], value ) } ).not.toThrow()\n\t\t\t\texpect( grid2Db.pixti( 0 ) ).toBeCloseTo( value, 6 )\n\t\t\t})\n\n\n\n\t\t})\n\n\t\t/** @test {Grid#pixt}\n\t\t * @test {Grid#pixti} */\n\t\tdescribe( \" pixt(i) methods \", function() {\n\t\t\tlet grid2D\n\n\t\t\tbeforeEach( function(){\n\t\t\t\tgrid2D = new CPM.Grid2D( [50,50] )\n\t\t\t\t// mock functions of the p2i and i2p implemented in the subclass.\n\t\t\t\tspyOn( grid2D, \"p2i\" ).and.returnValue( 0 )\n\t\t\t\tspyOn( grid2D, \"i2p\" ).and.returnValue( [0,0] )\n\t\t\t})\n\n\t\t\t/**\n\t\t\t * @test {Grid#pixt}\n\t\t\t * @test {Grid#pixti}\n\t\t\t * */\n\t\t\tit( \"pixt(i) can show types on the grid.\", function(){\n\t\t\t\t// before change, types are always zero.\n\t\t\t\texpect( grid2D.pixti( 0 ) ).toEqual( 0 )\n\t\t\t\t// pixt uses internally the p2i method from the grid subclass\n\t\t\t\t// (but not i2p)\n\t\t\t\texpect( grid2D.p2i ).not.toHaveBeenCalled()\n\t\t\t\texpect( grid2D.pixt( [0,0] ) ).toEqual( 0 )\n\t\t\t\texpect( grid2D.p2i ).toHaveBeenCalledWith( [0,0] )\n\t\t\t\texpect( grid2D.i2p ).not.toHaveBeenCalled()\n\t\t\t})\n\t\t})\n\n\t\t/** @test {Grid#pixelsBuffer} */\n\t\tdescribe( \" pixelsBuffer method \", function() {\n\t\t\tlet grid2D, grid2Db\n\n\t\t\tbeforeEach( function(){\n\t\t\t\tgrid2D = new CPM.Grid2D( [50,50] )\n\t\t\t\tgrid2Db = new CPM.Grid2D( [100,100], [false,false], \"Float32\" )\n\t\t\t})\n\n\t\t\tit( \"should work on Float32 and Uint16 grids\", function(){\n\t\t\t\t// before change, there is no buffer yet\n\t\t\t\texpect( grid2D._pixelsbuffer === undefined ).toBeTruthy()\n\t\t\t\texpect( grid2Db._pixelsbuffer === undefined ).toBeTruthy()\n\n\t\t\t\t// after calling the method, there is.\n\t\t\t\texpect( function(){ grid2D.pixelsBuffer() } ).not.toThrow()\n\t\t\t\texpect( function(){ grid2Db.pixelsBuffer() } ).not.toThrow()\n\t\t\t\texpect( grid2D._pixelsbuffer === undefined ).toBeFalse()\n\t\t\t\texpect( grid2Db._pixelsbuffer === undefined ).toBeFalse()\n\n\t\t\t})\n\t\t})\n\n\t\t/** @test {Grid#laplaciani} */\n\t\tdescribe( \" laplacian(i) method \", function() {\n\t\t\tlet grid2Db, grid2D\n\n\t\t\tbeforeEach( function(){\n\t\t\t\tgrid2D =  new CPM.Grid2D( [100,100] )\n\t\t\t\tgrid2Db = new CPM.Grid2D( [100,100], [false,false], \"Float32\" )\n\t\t\t})\n\n\t\t\tit( \"should work on Float32 grids\", function(){\n\t\t\t\texpect( function(){ grid2Db.laplaciani(1) } ).not.toThrow()\n\t\t\t\texpect( function(){ grid2Db.laplacian([1,1] ) } ).not.toThrow()\n\t\t\t})\n\n\t\t\tit( \"should throw error when you try to call it on Uint16 grid\", function(){\n\t\t\t\texpect( function(){ grid2D.laplaciani(1) } ).toThrow()\n\t\t\t\texpect( function(){ grid2D.laplacian([1,1] ) } ).toThrow()\n\t\t\t})\n\n\t\t\tdescribe( \" should compute laplacian correctly \", function() {\n\n\t\t\t\t// spy on the neighNeumanni method by returning always pixels 1,2,3,4\n\t\t\t\tbeforeEach( function (){\n\t\t\t\t\tgrid2Db.neighNeumanni = function * (){\n\t\t\t\t\t\tfor( let i = 0; i < 4; i++ ){\n\t\t\t\t\t\t\tyield i+1\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\n\n\t\t\t\tit( \" case 1 : everything zero \", function(){\n\t\t\t\t\t// spy on pixti method to let it always return 0\n\t\t\t\t\tspyOn( grid2Db, \"pixti\" ).and.returnValue(0)\n\n\t\t\t\t\t// check that the spying works, this value of 1000 should not\n\t\t\t\t\t// be detected.\n\t\t\t\t\tgrid2Db.setpixi( 1, 1000 )\n\n\t\t\t\t\t// check that laplacian returns zero\n\t\t\t\t\texpect( grid2Db.laplaciani(0) ).toEqual(0)\n\n\t\t\t\t})\n\n\t\t\t\tit( \" case 2 : everything a positive value \", function(){\n\n\t\t\t\t\tspyOn( grid2Db, \"pixti\" ).and.callFake( function( i ){\n\t\t\t\t\t\treturn i*1000\n\t\t\t\t\t})\n\t\t\t\t\texpect( grid2Db.laplaciani(0) ).toEqual( 10000 )\n\n\t\t\t\t})\n\n\t\t\t\tit( \" case 3 : everything a negative value \", function(){\n\t\t\t\t\tspyOn( grid2Db, \"pixti\" ).and.callFake( function( i ){\n\t\t\t\t\t\treturn -i*1000\n\t\t\t\t\t})\n\t\t\t\t\texpect( grid2Db.laplaciani(0) ).toEqual( -10000 )\n\t\t\t\t})\n\n\t\t\t\tit( \" case 4 : floating point values \", function(){\n\t\t\t\t\tspyOn( grid2Db, \"pixti\" ).and.callFake( function( i ){\n\t\t\t\t\t\treturn i*1000 + 0.1* Math.random()\n\t\t\t\t\t})\n\t\t\t\t\texpect( grid2Db.laplaciani(0) ).toBeCloseTo( 10000, 0 )\n\t\t\t\t})\n\n\t\t\t\tit( \" case 4 : positive and negative floating point values \", function(){\n\t\t\t\t\tspyOn( grid2Db, \"pixti\" ).and.callFake( function( i ){\n\t\t\t\t\t\tif( i >= 1 && i <= 4 ){\n\t\t\t\t\t\t\tlet num = 1000 + 0.1* Math.random()\n\t\t\t\t\t\t\tif( i % 2 === 0 ){ return -num }\n\t\t\t\t\t\t\treturn num\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn 0\n\t\t\t\t\t})\n\t\t\t\t\texpect( grid2Db.laplaciani(0) ).toBeCloseTo( 0, 0 )\n\t\t\t\t})\n\n\t\t\t})\n\n\t\t})\n\n\t\t/** @test {Grid#diffusion} */\n\t\tdescribe( \" diffusion method \", function() {\n\t\t\tlet grid2Db, grid2D\n\n\t\t\tbeforeEach(function () {\n\t\t\t\tgrid2D = new CPM.Grid2D([200, 200])\n\t\t\t\tgrid2Db = new CPM.Grid2D([200, 200], [false, false], \"Float32\")\n\t\t\t})\n\n\t\t\tit(\"can be called on Float32 grids\", function () {\n\t\t\t\texpect(function () {\n\t\t\t\t\tgrid2Db.diffusion(0.01)\n\t\t\t\t}).not.toThrow()\n\t\t\t})\n\n\t\t\tit(\"should throw error when you try to call it on Uint16 grid\", function () {\n\t\t\t\tlet message = \"Diffusion/laplacian methods do not work on a Uint16 grid! \" +\n\t\t\t\t\t\"Consider setting datatype='Float32'.\"\n\t\t\t\texpect(function () {\n\t\t\t\t\tgrid2D.diffusion(1)\n\t\t\t\t}).toThrow(message)\n\t\t\t})\n\n\t\t})\n\n\n\t})\n\n\tdescribe( \" [ class extension ] \", function (){\n\t\tlet g\n\n\t\tclass MyGrid extends CPM.Grid {\n\t\t\tmyMethod(){\n\t\t\t\treturn 1\n\t\t\t}\n\t\t}\n\t\tbeforeEach( function(){\n\t\t\tg = new MyGrid( [50,50] )\n\t\t})\n\n\t\tit( \"should be possible to extend with a method\", function() {\n\t\t\texpect( g.myMethod() ).toEqual(1)\n\t\t})\n\n\t\tit( \"should be possible to build a custom Grid subclass\" , function(){\n\t\t\t//eslint-disable-next-line no-unused-vars\n\t\t\texpect( function(){ new MyGrid( [ 50,50 ] ) } ).not.toThrow()\n\t\t\tlet g = new MyGrid( [ 50,50 ] )\n\t\t\texpect( g.extents[0] ).toEqual(50)\n\t\t})\n\n\t\t/** @test {Grid#_pixels} */\n\t\tit( \"should throw an error when _pixelArray is not set in subclass\", function(){\n\t\t\texpect( function(){ g._pixels }).toThrow()\n\t\t})\n\n\t\t/**\n\t\t * @test {Grid#p2i}\n\t\t * @test {Grid#i2p}\n\t\t */\n\t\tit( \"superclass should throw error when p2i/i2p not implemented\", function() {\n\t\t\texpect( function(){ g.p2i( [0,0] ) }).toThrow()\n\t\t\texpect( function(){ g.i2p( 0 )}).toThrow()\n\t\t})\n\n\t\t/** @test{Grid#neighi}\n\t\t * @test {Grid#neigh}\n\t\t * */\n\t\tit( \"should throw error when neighi not implemented\", function(){\n\t\t\texpect( function(){g.neigh([0,0])}).toThrow()\n\t\t\texpect( function(){g.neighi(0)}).toThrow()\n\n\t\t\t// but it should work as soon as p2i, i2p, and neighi are defined.\n\t\t\tspyOn( g, \"p2i\" ).and.returnValue( 0 )\n\t\t\tspyOn( g, \"i2p\" ).and.returnValue( [0,0] )\n\t\t\tspyOn( g, \"neighi\" ).and.returnValue( [0] )\n\t\t\texpect( function(){ g.neigh([0,0])} ).not.toThrow()\n\t\t})\n\n\t\t/** @test{Grid#pixelsi}\n\t\t * @test {Grid#pixels}\n\t\t * */\n\t\tit( \"should throw error when pixels/pixelsi not implemented\", function(){\n\n\t\t\tlet pixels = []\n\t\t\texpect( function(){ for( let p of g.pixels() ){ pixels.push(p) } }).toThrow()\n\t\t\texpect( function(){ for( let p of g.pixelsi() ){ pixels.push(p) } }).toThrow()\n\t\t\texpect( pixels.length ).toEqual(0)\n\t\t})\n\n\t\t/** @test{Grid#gradienti}\n\t\t * @test {Grid#gradient}\n\t\t * */\n\t\tit( \"should throw error when gradienti not implemented\", function(){\n\t\t\texpect( function(){g.gradient([0,0])}).toThrow()\n\t\t\texpect( function(){g.gradienti(0)}).toThrow()\n\t\t})\n\n\t\t/** @test{Grid#gradienti}\n\t\t * @test {Grid#gradient}\n\t\t * */\n\t\tit( \"gradient should work as soon as gradienti and p2i are implemented.\", function(){\n\t\t\tspyOn( g, \"p2i\" ).and.returnValue( 0 )\n\t\t\tspyOn( g, \"gradienti\" ).and.callFake( function(i){ return i + 10 } )\n\t\t\texpect( function(){ g.gradient([0,0] ) } ).not.toThrow()\n\t\t\texpect( g.gradient( [0,0] ) ).toEqual(10)\n\t\t})\n\n\t\t/** @test{Grid#neighNeumanni}\n\t\t * @test {Grid#laplacian}\n\t\t * @test {Grid#laplaciani}\n\t\t * */\n\t\tit( \"laplaciani should throw error when neighNeumanni not implemented\", function(){\n\t\t\tlet message = \"Trying to call the method neighNeumanni, but you haven't \" +\n\t\t\t\t\"implemented this method in the Grid subclass you are using!\"\n\t\t\texpect( function(){g.laplaciani(0)}).toThrow(message)\n\t\t})\n\n\t\t/** @test{Grid#neighNeumanni}\n\t\t * @test {Grid#laplacian}\n\t\t * @test {Grid#laplaciani}\n\t\t * */\n\t\tit( \"laplacian should throw error when p2i/neighNeumanni not implemented\", function(){\n\t\t\tlet message = \"A p2i method should be implemented in every Grid subclass!\"\n\t\t\texpect( function(){g.laplacian([0,0] ) } ).toThrow(message)\n\n\t\t\t// should still throw error when p2i is implemented but neighNeumanni is not\n\t\t\tspyOn( g, \"p2i\" ).and.returnValue(0)\n\t\t\tmessage = \"Trying to call the method neighNeumanni, but you haven't \" +\n\t\t\t\t\"implemented this method in the Grid subclass you are using!\"\n\t\t\texpect( function(){g.laplacian([0,0] ) } ).toThrow(message)\n\t\t})\n\n\t\t/** @test{Grid#neighNeumanni}\n\t\t * @test {Grid#laplacian}\n\t\t * @test {Grid#laplaciani}\n\t\t * */\n\t\tit( \"laplacian(i) should work if p2i, neighNeumanni, and _pixelArray exist\", function(){\n\n\t\t\tspyOn( g, \"p2i\" ).and.returnValue(0)\n\t\t\tg.neighNeumanni = function* (){\n\t\t\t\tfor( let k = 0; k < 4; k++ ){ yield k + 1 }\n\t\t\t}\n\t\t\tg._pixelArray = new Float32Array(1000)\n\t\t\texpect( function(){g.laplacian([0,0] ) } ).not.toThrow()\n\n\t\t})\n\n\t})\n\n\n})\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/spec/grid/GridSpec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 845,
    "kind": "test",
    "name": "describe51",
    "testId": 51,
    "memberof": "spec/grid/GridSpec.js",
    "testDepth": 0,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51",
    "access": null,
    "description": "Grid",
    "lineNumber": 2,
    "testTargets": [
      "Grid"
    ]
  },
  {
    "__docId__": 846,
    "kind": "test",
    "name": "describe52",
    "testId": 52,
    "memberof": "spec/grid/GridSpec.js~describe51",
    "testDepth": 1,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52",
    "access": null,
    "description": " [ unit tests ] ",
    "lineNumber": 13
  },
  {
    "__docId__": 847,
    "kind": "test",
    "name": "describe53",
    "testId": 53,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe53",
    "access": null,
    "description": " constructor ",
    "lineNumber": 15,
    "testTargets": [
      "Grid#constructor"
    ]
  },
  {
    "__docId__": 848,
    "kind": "test",
    "name": "it54",
    "testId": 54,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52.describe53",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe53.it54",
    "access": null,
    "description": "should throw an error when torus is specified for an incorrect number of dimensions",
    "lineNumber": 17
  },
  {
    "__docId__": 849,
    "kind": "test",
    "name": "it55",
    "testId": 55,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52.describe53",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe53.it55",
    "access": null,
    "description": "should set a size for each dimension",
    "lineNumber": 34
  },
  {
    "__docId__": 850,
    "kind": "test",
    "name": "it56",
    "testId": 56,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52.describe53",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe53.it56",
    "access": null,
    "description": "should set a torus property in each dimension",
    "lineNumber": 39
  },
  {
    "__docId__": 851,
    "kind": "test",
    "name": "it57",
    "testId": 57,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52.describe53",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe53.it57",
    "access": null,
    "description": "should by default set torus = true in each dimension",
    "lineNumber": 44
  },
  {
    "__docId__": 852,
    "kind": "test",
    "name": "it58",
    "testId": 58,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52.describe53",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe53.it58",
    "access": null,
    "description": "should be able to handle different torus settings for each dimension",
    "lineNumber": 53
  },
  {
    "__docId__": 853,
    "kind": "test",
    "name": "it59",
    "testId": 59,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52.describe53",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe53.it59",
    "access": null,
    "description": "should be able to handle a different size in each dimension",
    "lineNumber": 59
  },
  {
    "__docId__": 854,
    "kind": "test",
    "name": "it60",
    "testId": 60,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52.describe53",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe53.it60",
    "access": null,
    "description": "should compute a midpoint at the correct position",
    "lineNumber": 64
  },
  {
    "__docId__": 855,
    "kind": "test",
    "name": "describe61",
    "testId": 61,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe61",
    "access": null,
    "description": " neigh method ",
    "lineNumber": 76,
    "testTargets": [
      "Grid#neigh"
    ]
  },
  {
    "__docId__": 856,
    "kind": "test",
    "name": "it62",
    "testId": 62,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52.describe61",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe61.it62",
    "access": null,
    "description": " should return an array coordinate",
    "lineNumber": 106
  },
  {
    "__docId__": 857,
    "kind": "test",
    "name": "it63",
    "testId": 63,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52.describe61",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe61.it63",
    "access": null,
    "description": " should listen to torus for each dimension",
    "lineNumber": 114
  },
  {
    "__docId__": 858,
    "kind": "test",
    "name": "describe64",
    "testId": 64,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe64",
    "access": null,
    "description": " setpix(i) methods ",
    "lineNumber": 138,
    "testTargets": [
      "Grid#setpix",
      "Grid#setpixi"
    ]
  },
  {
    "__docId__": 859,
    "kind": "test",
    "name": "it65",
    "testId": 65,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52.describe64",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe64.it65",
    "access": null,
    "description": "can be called",
    "lineNumber": 155,
    "testTargets": [
      "Grid#setpix",
      "Grid#setpixi"
    ]
  },
  {
    "__docId__": 860,
    "kind": "test",
    "name": "it66",
    "testId": 66,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52.describe64",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe64.it66",
    "access": null,
    "description": " should prohibit setting an invalid type on the grid to avoid bugs",
    "lineNumber": 168,
    "testTargets": [
      "Grid#setpix",
      "Grid#setpixi",
      "Grid#_isValidValue"
    ]
  },
  {
    "__docId__": 861,
    "kind": "test",
    "name": "it67",
    "testId": 67,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52.describe64",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe64.it67",
    "access": null,
    "description": "store values in the Grid correctly",
    "lineNumber": 183,
    "testTargets": [
      "Grid#setpix",
      "Grid#setpixi"
    ]
  },
  {
    "__docId__": 862,
    "kind": "test",
    "name": "describe68",
    "testId": 68,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe68",
    "access": null,
    "description": " pixt(i) methods ",
    "lineNumber": 213,
    "testTargets": [
      "Grid#pixt",
      "Grid#pixti"
    ]
  },
  {
    "__docId__": 863,
    "kind": "test",
    "name": "it69",
    "testId": 69,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52.describe68",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe68.it69",
    "access": null,
    "description": "pixt(i) can show types on the grid.",
    "lineNumber": 227,
    "testTargets": [
      "Grid#pixt",
      "Grid#pixti"
    ]
  },
  {
    "__docId__": 864,
    "kind": "test",
    "name": "describe70",
    "testId": 70,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe70",
    "access": null,
    "description": " pixelsBuffer method ",
    "lineNumber": 240,
    "testTargets": [
      "Grid#pixelsBuffer"
    ]
  },
  {
    "__docId__": 865,
    "kind": "test",
    "name": "it71",
    "testId": 71,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52.describe70",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe70.it71",
    "access": null,
    "description": "should work on Float32 and Uint16 grids",
    "lineNumber": 248
  },
  {
    "__docId__": 866,
    "kind": "test",
    "name": "describe72",
    "testId": 72,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe72",
    "access": null,
    "description": " laplacian(i) method ",
    "lineNumber": 263,
    "testTargets": [
      "Grid#laplaciani"
    ]
  },
  {
    "__docId__": 867,
    "kind": "test",
    "name": "it73",
    "testId": 73,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52.describe72",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe72.it73",
    "access": null,
    "description": "should work on Float32 grids",
    "lineNumber": 271
  },
  {
    "__docId__": 868,
    "kind": "test",
    "name": "it74",
    "testId": 74,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52.describe72",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe72.it74",
    "access": null,
    "description": "should throw error when you try to call it on Uint16 grid",
    "lineNumber": 276
  },
  {
    "__docId__": 869,
    "kind": "test",
    "name": "describe75",
    "testId": 75,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52.describe72",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe72.describe75",
    "access": null,
    "description": " should compute laplacian correctly ",
    "lineNumber": 281
  },
  {
    "__docId__": 870,
    "kind": "test",
    "name": "it76",
    "testId": 76,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52.describe72.describe75",
    "testDepth": 4,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe72.describe75.it76",
    "access": null,
    "description": " case 1 : everything zero ",
    "lineNumber": 293
  },
  {
    "__docId__": 871,
    "kind": "test",
    "name": "it77",
    "testId": 77,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52.describe72.describe75",
    "testDepth": 4,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe72.describe75.it77",
    "access": null,
    "description": " case 2 : everything a positive value ",
    "lineNumber": 306
  },
  {
    "__docId__": 872,
    "kind": "test",
    "name": "it78",
    "testId": 78,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52.describe72.describe75",
    "testDepth": 4,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe72.describe75.it78",
    "access": null,
    "description": " case 3 : everything a negative value ",
    "lineNumber": 315
  },
  {
    "__docId__": 873,
    "kind": "test",
    "name": "it79",
    "testId": 79,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52.describe72.describe75",
    "testDepth": 4,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe72.describe75.it79",
    "access": null,
    "description": " case 4 : floating point values ",
    "lineNumber": 322
  },
  {
    "__docId__": 874,
    "kind": "test",
    "name": "it80",
    "testId": 80,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52.describe72.describe75",
    "testDepth": 4,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe72.describe75.it80",
    "access": null,
    "description": " case 4 : positive and negative floating point values ",
    "lineNumber": 329
  },
  {
    "__docId__": 875,
    "kind": "test",
    "name": "describe81",
    "testId": 81,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe81",
    "access": null,
    "description": " diffusion method ",
    "lineNumber": 346,
    "testTargets": [
      "Grid#diffusion"
    ]
  },
  {
    "__docId__": 876,
    "kind": "test",
    "name": "it82",
    "testId": 82,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52.describe81",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe81.it82",
    "access": null,
    "description": "can be called on Float32 grids",
    "lineNumber": 354
  },
  {
    "__docId__": 877,
    "kind": "test",
    "name": "it83",
    "testId": 83,
    "memberof": "spec/grid/GridSpec.js~describe51.describe52.describe81",
    "testDepth": 3,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe52.describe81.it83",
    "access": null,
    "description": "should throw error when you try to call it on Uint16 grid",
    "lineNumber": 360
  },
  {
    "__docId__": 878,
    "kind": "test",
    "name": "describe84",
    "testId": 84,
    "memberof": "spec/grid/GridSpec.js~describe51",
    "testDepth": 1,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe84",
    "access": null,
    "description": " [ class extension ] ",
    "lineNumber": 373
  },
  {
    "__docId__": 879,
    "kind": "test",
    "name": "it85",
    "testId": 85,
    "memberof": "spec/grid/GridSpec.js~describe51.describe84",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe84.it85",
    "access": null,
    "description": "should be possible to extend with a method",
    "lineNumber": 385
  },
  {
    "__docId__": 880,
    "kind": "test",
    "name": "it86",
    "testId": 86,
    "memberof": "spec/grid/GridSpec.js~describe51.describe84",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe84.it86",
    "access": null,
    "description": "should be possible to build a custom Grid subclass",
    "lineNumber": 389
  },
  {
    "__docId__": 881,
    "kind": "test",
    "name": "it87",
    "testId": 87,
    "memberof": "spec/grid/GridSpec.js~describe51.describe84",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe84.it87",
    "access": null,
    "description": "should throw an error when _pixelArray is not set in subclass",
    "lineNumber": 397,
    "testTargets": [
      "Grid#_pixels"
    ]
  },
  {
    "__docId__": 882,
    "kind": "test",
    "name": "it88",
    "testId": 88,
    "memberof": "spec/grid/GridSpec.js~describe51.describe84",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe84.it88",
    "access": null,
    "description": "superclass should throw error when p2i/i2p not implemented",
    "lineNumber": 405,
    "testTargets": [
      "Grid#p2i",
      "Grid#i2p"
    ]
  },
  {
    "__docId__": 883,
    "kind": "test",
    "name": "it89",
    "testId": 89,
    "memberof": "spec/grid/GridSpec.js~describe51.describe84",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe84.it89",
    "access": null,
    "description": "should throw error when neighi not implemented",
    "lineNumber": 413,
    "unknown": [
      {
        "tagName": "@test{Grid#neighi}\n",
        "tagValue": ""
      }
    ],
    "testTargets": [
      "Grid#neigh"
    ]
  },
  {
    "__docId__": 884,
    "kind": "test",
    "name": "it90",
    "testId": 90,
    "memberof": "spec/grid/GridSpec.js~describe51.describe84",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe84.it90",
    "access": null,
    "description": "should throw error when pixels/pixelsi not implemented",
    "lineNumber": 427,
    "unknown": [
      {
        "tagName": "@test{Grid#pixelsi}\n",
        "tagValue": ""
      }
    ],
    "testTargets": [
      "Grid#pixels"
    ]
  },
  {
    "__docId__": 885,
    "kind": "test",
    "name": "it91",
    "testId": 91,
    "memberof": "spec/grid/GridSpec.js~describe51.describe84",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe84.it91",
    "access": null,
    "description": "should throw error when gradienti not implemented",
    "lineNumber": 438,
    "unknown": [
      {
        "tagName": "@test{Grid#gradienti}\n",
        "tagValue": ""
      }
    ],
    "testTargets": [
      "Grid#gradient"
    ]
  },
  {
    "__docId__": 886,
    "kind": "test",
    "name": "it92",
    "testId": 92,
    "memberof": "spec/grid/GridSpec.js~describe51.describe84",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe84.it92",
    "access": null,
    "description": "gradient should work as soon as gradienti and p2i are implemented.",
    "lineNumber": 446,
    "unknown": [
      {
        "tagName": "@test{Grid#gradienti}\n",
        "tagValue": ""
      }
    ],
    "testTargets": [
      "Grid#gradient"
    ]
  },
  {
    "__docId__": 887,
    "kind": "test",
    "name": "it93",
    "testId": 93,
    "memberof": "spec/grid/GridSpec.js~describe51.describe84",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe84.it93",
    "access": null,
    "description": "laplaciani should throw error when neighNeumanni not implemented",
    "lineNumber": 457,
    "unknown": [
      {
        "tagName": "@test{Grid#neighNeumanni}\n",
        "tagValue": ""
      }
    ],
    "testTargets": [
      "Grid#laplacian",
      "Grid#laplaciani"
    ]
  },
  {
    "__docId__": 888,
    "kind": "test",
    "name": "it94",
    "testId": 94,
    "memberof": "spec/grid/GridSpec.js~describe51.describe84",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe84.it94",
    "access": null,
    "description": "laplacian should throw error when p2i/neighNeumanni not implemented",
    "lineNumber": 467,
    "unknown": [
      {
        "tagName": "@test{Grid#neighNeumanni}\n",
        "tagValue": ""
      }
    ],
    "testTargets": [
      "Grid#laplacian",
      "Grid#laplaciani"
    ]
  },
  {
    "__docId__": 889,
    "kind": "test",
    "name": "it95",
    "testId": 95,
    "memberof": "spec/grid/GridSpec.js~describe51.describe84",
    "testDepth": 2,
    "static": true,
    "longname": "spec/grid/GridSpec.js~describe51.describe84.it95",
    "access": null,
    "description": "laplacian(i) should work if p2i, neighNeumanni, and _pixelArray exist",
    "lineNumber": 482,
    "unknown": [
      {
        "tagName": "@test{Grid#neighNeumanni}\n",
        "tagValue": ""
      }
    ],
    "testTargets": [
      "Grid#laplacian",
      "Grid#laplaciani"
    ]
  },
  {
    "__docId__": 890,
    "kind": "testFile",
    "name": "spec/hamiltonian/LocalConnectivityConstraintSpec.js",
    "content": "/* \n\tTODO\n\t- implement some checks for a 3D CPM\n\t- further test paramChecker\n\t- implement a stress test (somewhere else?): run a simulation at parameters where the cell has risk of\n\tbreaking, and test at several times whether the connectedness remains intact.\n\n*/\n\n/** @test {LocalConnectivityConstraint} */\ndescribe(\"LocalConnectivityConstraint\", function () {\n\tlet CPM = require(\"../../build/artistoo-cjs.js\")\n\tlet C, conn\n\n\tlet fakeNeighi = function(i){\n\t\t//console.log( i + \" \" + testGrid.neighi( i ) )\n\t\tif( i === 3 ){ return [12674,12675,12676,2,4,130,131,132]}\n\t\tif( i === 259 ){ return [130,131,132,258,260,386,387,388]}\n\t\tif( i === 515 ){ return [386,387,388,514,516,642,643,644]}\n\t\tif( i === 131 ){ return [2,3,4,130,132,258,259,260]}\n\t\tif( i === 387 ){ return [258,259,260,386,388,514,515,516]}\n\t\tif( i === 0 ){ return [12771,12672,12673,99,1,227,128,129]}\n\t\tif( i === 129 ){ return [0,1,2,128,130,256,257,258]}\n\t\tif( i === 258 ){ return [129,130,131,257,259,385,386,387]}\n\t\tif( i === 516 ){ return [258,259,260,386,388,514,515,516]}\n\t}\n\n\tbeforeEach(function () {\n\t\tC = new CPM.CPM([100, 100], {T: 20})\n\t\tconn = new CPM.LocalConnectivityConstraint({\n\t\t\tCONNECTED: [false, true]\n\t\t})\n\t\tC.add( conn )\n\n\t})\n\n\tdescribe( \"[ Unit tests ]\", function() {\n\t\t/* Testing the connected components method for specific cases */\n\t\t/** @test {LocalConnectivityConstraint#connectedComponentsOf} */\n\t\tdescribe(\"method [ connectedComponentsOf ]\", function () {\n\n\t\t\tbeforeEach(function () {\n\t\t\t\t// Replace the .grid.p2i function with mock code for real unit tests.\n\t\t\t\tC = jasmine.createSpyObj(\"C\", [ \"pixti\",\"getConstraint\" ])\n\t\t\t\tC.grid = jasmine.createSpyObj( \"C.grid\", [\"p2i\",\"i2p\",\"neighi\",\"pixti\"] )\n\t\t\t\tC.grid.p2i.and.callFake( function(p) {\n\t\t\t\t\tlet x = p[0], y = p[1]\n\t\t\t\t\t// hard code the required values.\n\t\t\t\t\tif( x === 2 && y === 2 ){ return 258 }\n\t\t\t\t\tif( x === 3 && y === 3 ){ return 387 }\n\t\t\t\t\tif( x === 4 && y === 4 ){ return 516 }\n\t\t\t\t\tif( x === 2 && y === 3 ){ return 259 }\n\t\t\t\t\tif( x === 0 && y === 3 ){ return 3 }\n\t\t\t\t\tif( x === 4 && y === 3 ){ return 515 }\n\t\t\t\t\tif( x === 0 && y === 0 ){ return 0 }\n\t\t\t\t\tif( x === 1 && y === 3 ){ return 131 }\n\t\t\t\t\tif( x === 1 && y === 1 ){ return 129 }\n\n\t\t\t\t\t// This should not happen.\n\t\t\t\t\treturn NaN\n\t\t\t\t})\n\t\t\t\t// hard code the neighborhoods returned:\n\t\t\t\tC.grid.neighi.and.callFake( function(i){\n\t\t\t\t\t//console.log( i + \" \" + testGrid.neighi( i ) )\n\t\t\t\t\treturn fakeNeighi(i)\n\t\t\t\t})\n\n\t\t\t\t// i2p always returns the same array, this shouldn't matter because\n\t\t\t\t// only the length of the connected components is tested here.\n\t\t\t\tC.grid.i2p.and.returnValue( [0,0] )\n\n\t\t\t\tconn = new CPM.LocalConnectivityConstraint({\n\t\t\t\t\tCONNECTED: [false, true]\n\t\t\t\t})\n\t\t\t\tconn.C = C\n\t\t\t\tC.getConstraint.and.callFake( function(){\n\t\t\t\t\treturn conn\n\t\t\t\t})\n\n\t\t\t\t// pixti doesn't have to work, assume the whole neighborhood is\n\t\t\t\t// the same type and just look at whether a pixel is in the\n\t\t\t\t// object or not.\n\t\t\t\tC.pixti.and.returnValue( 1 )\n\t\t\t\tC.grid.pixti.and.returnValue( 1 )\n\t\t\t})\n\n\t\t\tit(\"should return only one component in connected case\", function () {\n\t\t\t\tlet nbhObj = {}\n\t\t\t\tfor (let x = 0; x < 5; x++) {\n\t\t\t\t\tnbhObj[C.grid.p2i([x, 3])] = true\n\t\t\t\t}\n\t\t\t\texpect(C.getConstraint(\"LocalConnectivityConstraint\").connectedComponentsOf(nbhObj).length).toEqual(1)\n\n\t\t\t\tnbhObj = {}\n\t\t\t\tfor (let x = 0; x < 5; x++) {\n\t\t\t\t\tnbhObj[C.grid.p2i([x, x])] = true\n\t\t\t\t}\n\t\t\t\texpect(C.getConstraint(\"LocalConnectivityConstraint\").connectedComponentsOf(nbhObj).length).toEqual(1)\n\t\t\t})\n\t\t\tit(\"should return multiple components in disconnected case\", function () {\n\t\t\t\tlet nbhObj = {}\n\t\t\t\tfor (let x = 0; x < 5; x++) {\n\t\t\t\t\tif (x % 2 === 0) {\n\t\t\t\t\t\tnbhObj[C.grid.p2i([x, 3])] = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\texpect(C.getConstraint(\"LocalConnectivityConstraint\").connectedComponentsOf(nbhObj).length).toEqual(3)\n\n\t\t\t})\n\n\t\t})\n\t})\n\n\n\n\t/* Testing if the overall constraint works, specific case*/\n\n\n\tdescribe( \"[ Integration tests ]\", function() {\n\n\t\t/* Integration test: Testing the parameter checker for this constraint*/\n\t\t/** @test {LocalConnectivityConstraint#confChecker} */\n\t\tdescribe(\"integration with ParameterChecker\", function () {\n\t\t\tit(\"should throw an error when CONNECTED parameter is unspecified\", function () {\n\t\t\t\texpect(function () {\n\t\t\t\t\t//noinspection JSCheckFunctionSignatures\n\t\t\t\t\tC.add(new CPM.LocalConnectivityConstraint({}))\n\t\t\t\t}).toThrow(\"Cannot find parameter CONNECTED in the conf object!\")\n\t\t\t})\n\t\t})\n\t\t/* Integration test: constraint as a whole but with a mock CPM*/\n\t\tdescribe(\"when copy attempt would disrupt local connectivity\", function () {\n\t\t\tlet src_i, tgt_i, src_type, tgt_type\n\n\t\t\tbeforeEach(function () {\n\t\t\t\tC = jasmine.createSpyObj(\"C\", [ \"pixti\",\"getConstraint\",\"cellKind\" ])\n\t\t\t\tC.grid = jasmine.createSpyObj( \"C.grid\", [\"neighi\",\"pixti\",\"i2p\",\"p2i\"] )\n\t\t\t\tconn = new CPM.LocalConnectivityConstraint({\n\t\t\t\t\tCONNECTED: [false, true]\n\t\t\t\t})\n\t\t\t\tconn.CPM = C\n\t\t\t\tC.getConstraint.and.callFake( function() {return conn})\n\t\t\t\tC.pixti.and.callFake(function(i){\n\t\t\t\t\tif( i === 0 || i === 1 || i === 2 ){\n\t\t\t\t\t\treturn 1\n\t\t\t\t\t}\n\t\t\t\t\treturn 0\n\t\t\t\t\t//if( i === 258 || i === 387 || i === 516  ){ return 1 }\n\n\t\t\t\t})\n\t\t\t\tC.grid.pixti.and.callFake( function(i) {\n\t\t\t\t\tif( i === 0 || i === 1 || i === 2 ){\n\t\t\t\t\t\treturn 1\n\t\t\t\t\t}\n\t\t\t\t\treturn 0\n\t\t\t\t})\n\t\t\t\tC.grid.neighi.and.callFake( function(i){\n\t\t\t\t\treturn [ i - 1, i + 1 ]\n\t\t\t\t})\n\t\t\t\tC.grid.i2p.and.callFake( function(i){\n\t\t\t\t\treturn [0,i]\n\t\t\t\t})\n\t\t\t\tC.grid.p2i.and.callFake( function(p){\n\t\t\t\t\treturn p[1]\n\t\t\t\t})\n\t\t\t\tC.cellKind.and.callFake( function(t){\n\t\t\t\t\tif( t === 1 ){return 1 }\n\t\t\t\t\treturn 0\n\t\t\t\t})\n\t\t\t\tsrc_i = 102 //259 //C.grid.p2i([2, 3])\n\t\t\t\ttgt_i = 1 //387 //C.grid.p2i([3, 3])\n\t\t\t\tsrc_type = C.pixti(src_i)\n\t\t\t\ttgt_type = C.pixti(tgt_i)\n\t\t\t})\n\n\t\t\t/** @test {LocalConnectivityConstraint#checkConnected} */\n\t\t\tit(\"#checkConnected should return false\", function () {\n\t\t\t\texpect(C.getConstraint(\"LocalConnectivityConstraint\").checkConnected(tgt_i, src_type, tgt_type)).toBeFalsy()\n\t\t\t})\n\n\t\t\t/** @test {LocalConnectivityConstraint#fulfilled} */\n\t\t\tdescribe(\"and when CONNECTED for the tgt cellKind\", function () {\n\t\t\t\tit(\"is true, constraint should not be fulfilled\", function () {\n\t\t\t\t\texpect(C.getConstraint(\"LocalConnectivityConstraint\").fulfilled(src_i, tgt_i, src_type, tgt_type)).toBeFalsy()\n\t\t\t\t})\n\t\t\t\tit(\"is false, constraint should be fulfilled\", function () {\n\t\t\t\t\tC.getConstraint(\"LocalConnectivityConstraint\").conf.CONNECTED[1] = false\n\t\t\t\t\texpect(C.getConstraint(\"LocalConnectivityConstraint\").fulfilled(src_i, tgt_i, src_type, tgt_type)).toBeTruthy()\n\t\t\t\t})\n\t\t\t})\n\n\t\t})\n\n\n\t\t/* Integration test: method connectedComponentsOf should listen to the torus property*/\n\t\tdescribe( \"method [ connectedComponentsOf ]\" , function () {\n\n\t\t\tit(\"should listen to the grid torus property correctly\", function () {\n\t\t\t\tlet nbhObj = {}\n\t\t\t\tlet pix = C.grid.p2i([0, 0])\n\n\t\t\t\t// add pixel and its whole neighborhood\n\t\t\t\tnbhObj[pix] = true\n\t\t\t\tfor (let n of C.grid.neighi(pix)) {\n\t\t\t\t\tnbhObj[n] = true\n\t\t\t\t}\n\t\t\t\texpect(C.getConstraint(\"LocalConnectivityConstraint\").connectedComponentsOf(nbhObj).length).toEqual(1)\n\n\t\t\t\t// now change torus to false in one or both dimensions while keeping the same nbhObj\n\t\t\t\tlet C_noTorus = new CPM.CPM([100, 100], {\n\t\t\t\t\tT: 20,\n\t\t\t\t\ttorus: [false, false]\n\t\t\t\t})\n\t\t\t\tC_noTorus.add(new CPM.LocalConnectivityConstraint({\n\t\t\t\t\tCONNECTED: [false, true]\n\t\t\t\t}))\n\t\t\t\texpect(C_noTorus.getConstraint(\"LocalConnectivityConstraint\").connectedComponentsOf(nbhObj).length).toEqual(4)\n\n\t\t\t\tlet C_yTorus = new CPM.CPM([100, 100], {\n\t\t\t\t\tT: 20,\n\t\t\t\t\ttorus: [false, true]\n\t\t\t\t})\n\t\t\t\tC_yTorus.add(new CPM.LocalConnectivityConstraint({\n\t\t\t\t\tCONNECTED: [false, true]\n\t\t\t\t}))\n\t\t\t\texpect(C_yTorus.getConstraint(\"LocalConnectivityConstraint\").connectedComponentsOf(nbhObj).length).toEqual(2)\n\n\t\t\t\tlet C_xTorus = new CPM.CPM([100, 100], {\n\t\t\t\t\tT: 20,\n\t\t\t\t\ttorus: [true, false]\n\t\t\t\t})\n\t\t\t\tC_xTorus.add(new CPM.LocalConnectivityConstraint({\n\t\t\t\t\tCONNECTED: [false, true]\n\t\t\t\t}))\n\t\t\t\texpect(C_xTorus.getConstraint(\"LocalConnectivityConstraint\").connectedComponentsOf(nbhObj).length).toEqual(2)\n\t\t\t})\n\t\t})\n\t})\n})",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/spec/hamiltonian/LocalConnectivityConstraintSpec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 891,
    "kind": "test",
    "name": "describe96",
    "testId": 96,
    "memberof": "spec/hamiltonian/LocalConnectivityConstraintSpec.js",
    "testDepth": 0,
    "static": true,
    "longname": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96",
    "access": null,
    "description": "LocalConnectivityConstraint",
    "lineNumber": 11,
    "testTargets": [
      "LocalConnectivityConstraint"
    ]
  },
  {
    "__docId__": 892,
    "kind": "test",
    "name": "describe97",
    "testId": 97,
    "memberof": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96",
    "testDepth": 1,
    "static": true,
    "longname": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96.describe97",
    "access": null,
    "description": "[ Unit tests ]",
    "lineNumber": 37
  },
  {
    "__docId__": 893,
    "kind": "test",
    "name": "describe98",
    "testId": 98,
    "memberof": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96.describe97",
    "testDepth": 2,
    "static": true,
    "longname": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96.describe97.describe98",
    "access": null,
    "description": "method [ connectedComponentsOf ]",
    "lineNumber": 40,
    "testTargets": [
      "LocalConnectivityConstraint#connectedComponentsOf"
    ]
  },
  {
    "__docId__": 894,
    "kind": "test",
    "name": "it99",
    "testId": 99,
    "memberof": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96.describe97.describe98",
    "testDepth": 3,
    "static": true,
    "longname": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96.describe97.describe98.it99",
    "access": null,
    "description": "should return only one component in connected case",
    "lineNumber": 87
  },
  {
    "__docId__": 895,
    "kind": "test",
    "name": "it100",
    "testId": 100,
    "memberof": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96.describe97.describe98",
    "testDepth": 3,
    "static": true,
    "longname": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96.describe97.describe98.it100",
    "access": null,
    "description": "should return multiple components in disconnected case",
    "lineNumber": 100
  },
  {
    "__docId__": 896,
    "kind": "test",
    "name": "describe101",
    "testId": 101,
    "memberof": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96",
    "testDepth": 1,
    "static": true,
    "longname": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96.describe101",
    "access": null,
    "description": "[ Integration tests ]",
    "lineNumber": 119
  },
  {
    "__docId__": 897,
    "kind": "test",
    "name": "describe102",
    "testId": 102,
    "memberof": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96.describe101",
    "testDepth": 2,
    "static": true,
    "longname": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96.describe101.describe102",
    "access": null,
    "description": "integration with ParameterChecker",
    "lineNumber": 123,
    "testTargets": [
      "LocalConnectivityConstraint#confChecker"
    ]
  },
  {
    "__docId__": 898,
    "kind": "test",
    "name": "it103",
    "testId": 103,
    "memberof": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96.describe101.describe102",
    "testDepth": 3,
    "static": true,
    "longname": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96.describe101.describe102.it103",
    "access": null,
    "description": "should throw an error when CONNECTED parameter is unspecified",
    "lineNumber": 124
  },
  {
    "__docId__": 899,
    "kind": "test",
    "name": "describe104",
    "testId": 104,
    "memberof": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96.describe101",
    "testDepth": 2,
    "static": true,
    "longname": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96.describe101.describe104",
    "access": null,
    "description": "when copy attempt would disrupt local connectivity",
    "lineNumber": 132
  },
  {
    "__docId__": 900,
    "kind": "test",
    "name": "it105",
    "testId": 105,
    "memberof": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96.describe101.describe104",
    "testDepth": 3,
    "static": true,
    "longname": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96.describe101.describe104.it105",
    "access": null,
    "description": "#checkConnected should return false",
    "lineNumber": 177,
    "testTargets": [
      "LocalConnectivityConstraint#checkConnected"
    ]
  },
  {
    "__docId__": 901,
    "kind": "test",
    "name": "describe106",
    "testId": 106,
    "memberof": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96.describe101.describe104",
    "testDepth": 3,
    "static": true,
    "longname": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96.describe101.describe104.describe106",
    "access": null,
    "description": "and when CONNECTED for the tgt cellKind",
    "lineNumber": 182,
    "testTargets": [
      "LocalConnectivityConstraint#fulfilled"
    ]
  },
  {
    "__docId__": 902,
    "kind": "test",
    "name": "it107",
    "testId": 107,
    "memberof": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96.describe101.describe104.describe106",
    "testDepth": 4,
    "static": true,
    "longname": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96.describe101.describe104.describe106.it107",
    "access": null,
    "description": "is true, constraint should not be fulfilled",
    "lineNumber": 183
  },
  {
    "__docId__": 903,
    "kind": "test",
    "name": "it108",
    "testId": 108,
    "memberof": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96.describe101.describe104.describe106",
    "testDepth": 4,
    "static": true,
    "longname": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96.describe101.describe104.describe106.it108",
    "access": null,
    "description": "is false, constraint should be fulfilled",
    "lineNumber": 186
  },
  {
    "__docId__": 904,
    "kind": "test",
    "name": "describe109",
    "testId": 109,
    "memberof": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96.describe101",
    "testDepth": 2,
    "static": true,
    "longname": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96.describe101.describe109",
    "access": null,
    "description": "method [ connectedComponentsOf ]",
    "lineNumber": 196
  },
  {
    "__docId__": 905,
    "kind": "test",
    "name": "it110",
    "testId": 110,
    "memberof": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96.describe101.describe109",
    "testDepth": 3,
    "static": true,
    "longname": "spec/hamiltonian/LocalConnectivityConstraintSpec.js~describe96.describe101.describe109.it110",
    "access": null,
    "description": "should listen to the grid torus property correctly",
    "lineNumber": 198
  },
  {
    "__docId__": 906,
    "kind": "testFile",
    "name": "spec/hamiltonian/PerimeterConstraintSpec.js",
    "content": "/** Tests for Perimeter Constraint\n *\n * @test {PerimeterConstraint}*/\ndescribe(\"PerimeterConstraint\", function () {\n\tlet CPM = require(\"../../build/artistoo-cjs.js\")\n\t//eslint-disable-next-line no-unused-vars\n\tlet sim, config1, config2\n\n\tlet setupSim = function ( withPC = true ) {\n\n\t\tconfig1 = {\n\t\t\tfield_size : [50,50],\n\t\t\tconf : {\n\t\t\t\t// Basic CPM parameters\n\t\t\t\ttorus : [true,true],\n\t\t\t\tT : 10,\n\t\t\t\tJ: [[0,10], [10,0]],\n\t\t\t\tLAMBDA_V: [0,5],\n\t\t\t\tV: [0,500],\n\t\t\t\tLAMBDA_P: [0,2],\n\t\t\t\tP : [0,260]\n\t\t\t},\n\n\t\t\t// Simulation setup and configuration\n\t\t\tsimsettings : {\n\t\t\t\tNRCELLS : [1],\n\t\t\t\tBURNIN : 10,\n\t\t\t\tRUNTIME : 10,\n\t\t\t\tCANVASCOLOR : \"eaecef\",\n\t\t\t\tSTATSOUT : { browser: false, node: false },\n\t\t\t}\n\t\t}\n\n\t\tconfig2 = {\n\t\t\tfield_size : [50,50],\n\t\t\tconf : {\n\t\t\t\t// Basic CPM parameters\n\t\t\t\ttorus : [true,true],\n\t\t\t\tT : 10,\n\t\t\t\tJ: [[0,10], [10,0]],\n\t\t\t\tLAMBDA_V: [0,5],\n\t\t\t\tV: [0,500]\n\t\t\t},\n\n\t\t\t// Simulation setup and configuration\n\t\t\tsimsettings : {\n\t\t\t\tNRCELLS : [1],\n\t\t\t\tBURNIN : 10,\n\t\t\t\tRUNTIME : 10,\n\t\t\t\tCANVASCOLOR : \"eaecef\",\n\t\t\t\tSTATSOUT : { browser: false, node: false },\n\t\t\t}\n\t\t}\n\n\t\tif( withPC ){\n\t\t\tsim = new CPM.Simulation( config1, {} )\n\t\t} else {\n\t\t\tsim = new CPM.Simulation( config2, {})\n\t\t}\n\t\tsim.initializeGrid()\n\t\tsim.runBurnin()\n\t}\n\n\tdescribe(\" [ unit tests ] \", function () {\n\n\t\t/** @test {PerimeterConstraint} */\n\t\tit(\"can be added to a non-empty grid without crashing:\", function () {\n\t\t\tsetupSim(false )\n\t\t\tlet pc = new CPM.PerimeterConstraint( {\n\t\t\t\tLAMBDA_P: [0,2],\n\t\t\t\tP : [0,260]\n\t\t\t} )\n\t\t\tsim.C.add(pc)\n\t\t\texpect( Object.keys( sim.C.getConstraint(\"PerimeterConstraint\").cellperimeters ).length ).not.toEqual( 0 )\n\t\t\texpect( function() { sim.run() }).not.toThrow()\n\t\t})\n\n\t\tit( \"can be added automatically through the conf object\", function(){\n\t\t\tsetupSim( true )\n\t\t\texpect( function() { sim.C.getConstraint(\"PerimeterConstraint\" ) }).not.toThrow()\n\n\t\t})\n\n\t})\n})",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/spec/hamiltonian/PerimeterConstraintSpec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 907,
    "kind": "test",
    "name": "describe111",
    "testId": 111,
    "memberof": "spec/hamiltonian/PerimeterConstraintSpec.js",
    "testDepth": 0,
    "static": true,
    "longname": "spec/hamiltonian/PerimeterConstraintSpec.js~describe111",
    "access": null,
    "description": "Tests for Perimeter Constraint",
    "lineNumber": 4,
    "testTargets": [
      "PerimeterConstraint"
    ]
  },
  {
    "__docId__": 908,
    "kind": "test",
    "name": "describe112",
    "testId": 112,
    "memberof": "spec/hamiltonian/PerimeterConstraintSpec.js~describe111",
    "testDepth": 1,
    "static": true,
    "longname": "spec/hamiltonian/PerimeterConstraintSpec.js~describe111.describe112",
    "access": null,
    "description": " [ unit tests ] ",
    "lineNumber": 64
  },
  {
    "__docId__": 909,
    "kind": "test",
    "name": "it113",
    "testId": 113,
    "memberof": "spec/hamiltonian/PerimeterConstraintSpec.js~describe111.describe112",
    "testDepth": 2,
    "static": true,
    "longname": "spec/hamiltonian/PerimeterConstraintSpec.js~describe111.describe112.it113",
    "access": null,
    "description": "can be added to a non-empty grid without crashing:",
    "lineNumber": 67,
    "testTargets": [
      "PerimeterConstraint"
    ]
  },
  {
    "__docId__": 910,
    "kind": "test",
    "name": "it114",
    "testId": 114,
    "memberof": "spec/hamiltonian/PerimeterConstraintSpec.js~describe111.describe112",
    "testDepth": 2,
    "static": true,
    "longname": "spec/hamiltonian/PerimeterConstraintSpec.js~describe111.describe112.it114",
    "access": null,
    "description": "can be added automatically through the conf object",
    "lineNumber": 78
  },
  {
    "__docId__": 911,
    "kind": "testFile",
    "name": "spec/hamiltonian/PersistenceConstraintSpec.js",
    "content": "/** Tests for Persistence Constraint\n *\n * @test {PersistenceConstraint}*/\ndescribe(\"PersistenceConstraint\", function () {\n    let CPM = require(\"../../build/artistoo-cjs.js\")\n    //eslint-disable-next-line no-unused-vars\n    let sim, config1, config2\n\n    let setupSim = function ( ) {\n\n        config = {\n            field_size : [50,50],\n            conf : {\n                // Basic CPM parameters\n                torus : [true,true],\n                T : 10,\n                LAMBDA_VRANGE_MIN : [0,1],\t\t\t// MIN/MAX volume for the hard volume constraint\n                LAMBDA_VRANGE_MAX : [0,1],\n                LAMBDA_DIR : [0,500],\n                PERSIST : [0,0.5],\n                DELTA_T : [0,1],\n            },\n\n            // Simulation setup and configuration\n            simsettings : {\n                NRCELLS : [1],\n                BURNIN : 0,\n                RUNTIME : 10,\n                CANVASCOLOR : \"eaecef\",\n                STATSOUT : { browser: false, node: false },\n            }\n        }\n        sim = new CPM.Simulation( config, {} )\n        sim.C.add( new CPM.HardVolumeRangeConstraint( config.conf ) )\n        sim.C.add( new CPM.PersistenceConstraint( config.conf ) )\n\n        sim.initializeGrid()\n    }\n\n    describe(\" [ unit tests ] \", function () {\n\n        /** @test {PersistenceConstraint} */\n        it(\"does not crash when cell doesn't move for a while:\", function() {\n            setupSim()\n            sim.run()\n            const pc = sim.C.getConstraint(\"PersistenceConstraint\")\n            for( let cid of sim.C.cellIDs() ){\n                for( let d = 0; d < sim.C.extents.length; d++ ){\n                    expect( Number.isNaN( pc.celldirections[cid][d] ) ).not.toBeTruthy()\n                }\n            }\n        })\n    })\n})",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/spec/hamiltonian/PersistenceConstraintSpec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 912,
    "kind": "test",
    "name": "describe115",
    "testId": 115,
    "memberof": "spec/hamiltonian/PersistenceConstraintSpec.js",
    "testDepth": 0,
    "static": true,
    "longname": "spec/hamiltonian/PersistenceConstraintSpec.js~describe115",
    "access": null,
    "description": "Tests for Persistence Constraint",
    "lineNumber": 4,
    "testTargets": [
      "PersistenceConstraint"
    ]
  },
  {
    "__docId__": 913,
    "kind": "test",
    "name": "describe116",
    "testId": 116,
    "memberof": "spec/hamiltonian/PersistenceConstraintSpec.js~describe115",
    "testDepth": 1,
    "static": true,
    "longname": "spec/hamiltonian/PersistenceConstraintSpec.js~describe115.describe116",
    "access": null,
    "description": " [ unit tests ] ",
    "lineNumber": 40
  },
  {
    "__docId__": 914,
    "kind": "test",
    "name": "it117",
    "testId": 117,
    "memberof": "spec/hamiltonian/PersistenceConstraintSpec.js~describe115.describe116",
    "testDepth": 2,
    "static": true,
    "longname": "spec/hamiltonian/PersistenceConstraintSpec.js~describe115.describe116.it117",
    "access": null,
    "description": "does not crash when cell doesn't move for a while:",
    "lineNumber": 43,
    "testTargets": [
      "PersistenceConstraint"
    ]
  },
  {
    "__docId__": 915,
    "kind": "testFile",
    "name": "spec/hamiltonian/SoftLocalConnectivityConstraintSpec.js",
    "content": "/* \n\tTODO\n\t\n*/\n\n\ndescribe(\"SoftLocalConnectivityConstraint\", function() {\n  let CPM = require('../../build/artistoo-cjs.js');\n  let C\n  \n  beforeEach(function() {\n\t  C = new CPM.CPM( [100,100], {T:20})\n\t  C.add( new CPM.SoftLocalConnectivityConstraint( {\n\t\tLAMBDA_CONNECTIVITY : [0,1000]\n\t  }))\n   \n  });\n\n/* Testing the parameter checker for this constraint*/\n  it(\"should throw an error when LAMBDA_CONNECTIVITY parameter is not specified\", function() {\n  \texpect(function() {\n        C.add( new CPM.SoftLocalConnectivityConstraint({}) );\n    }).toThrow(\"Cannot find parameter LAMBDA_CONNECTIVITY in the conf object!\");\n  });\n  it(\"should throw an error when NBH_TYPE is set incorrectly\", function() {\n  \texpect(function() {\n        C.add( new CPM.SoftLocalConnectivityConstraint({ LAMBDA_CONNECTIVITY : [0,1000], NBH_TYPE : \"a\" }) );\n    }).toThrow(\"In the SoftLocalConnectivityConstraint, NBH_TYPE must be either 'Neumann' or 'Moore'\");\n    \n    expect(function() {\n        C.add( new CPM.SoftLocalConnectivityConstraint({ LAMBDA_CONNECTIVITY : [0,1000], NBH_TYPE : 1}) );\n    }).toThrow(\"In the SoftLocalConnectivityConstraint, NBH_TYPE must be either 'Neumann' or 'Moore'\");\n    \n    expect(function() {\n        C.add( new CPM.SoftLocalConnectivityConstraint({ LAMBDA_CONNECTIVITY : [0,1000], NBH_TYPE : [1,2] }) );\n    }).toThrow(\"In the SoftLocalConnectivityConstraint, NBH_TYPE must be either 'Neumann' or 'Moore'\");\n    \n  });\n\n/* Testing the connected components method for specific cases */\n  describe(\"when computing connected components\", function() {\n  \n\tit(\"should return only one component in connected case\", function() {\n\t\tlet nbhobj = {}\n\t\tfor( let x = 0; x < 5; x++ ){\n\t\t\tnbhobj[ C.grid.p2i([x,3]) ] = true\n\t\t}\n\t\texpect( C.getConstraint(\"SoftLocalConnectivityConstraint\").connectedComponentsOf(nbhobj).length).toEqual(1);\n\t\t\n\t});\n\tit(\"should return multiple components in disconnected case\", function() {\n\t\tlet nbhobj = {}\n\t\tfor( let x = 0; x < 5; x++ ){\n\t\t\tif( x % 2 == 0 ){\n\t\t\t\tnbhobj[ C.grid.p2i([x,3]) ] = true\n\t\t\t}\n\t\t}\n\t\texpect( C.getConstraint(\"SoftLocalConnectivityConstraint\").connectedComponentsOf(nbhobj).length).toEqual(3);\n\t\t\n\t\t// diagonal connections don't count as connections\n\t\tnbhobj = {}\n\t\tfor( let x = 0; x < 5; x++ ){\n\t\t\tnbhobj[ C.grid.p2i([x,x]) ] = true\n\t\t}\n\t\texpect( C.getConstraint(\"SoftLocalConnectivityConstraint\").connectedComponentsOf(nbhobj).length).toEqual(5);\n\t\t\n\t});\n\tit(\"should listen to the neighborhood type property correctly\", function(){\n\t\t\n\t\t// diagonal connections don't count as connections if the Neumann neighborhood is used (default)\n\t\tnbhobj = {}\n\t\tfor( let x = 0; x < 5; x++ ){\n\t\t\tnbhobj[ C.grid.p2i([x,x]) ] = true\n\t\t}\n\t\texpect( C.getConstraint(\"SoftLocalConnectivityConstraint\").connectedComponentsOf(nbhobj).length).toEqual(5);\n\t\n\t\n\t\t// ... but this case is connected when the Moore neighborhood is used\n\t\tC.getConstraint(\"SoftLocalConnectivityConstraint\").nbhtype = \"Moore\"\n\t\texpect( C.getConstraint(\"SoftLocalConnectivityConstraint\").connectedComponentsOf(nbhobj).length).toEqual(1);\n\t\t\n\t\t// ... and this should be again 5 when we switch back to Neumann\n\t\tC.getConstraint(\"SoftLocalConnectivityConstraint\").nbhtype = \"Neumann\"\n\t\texpect( C.getConstraint(\"SoftLocalConnectivityConstraint\").connectedComponentsOf(nbhobj).length).toEqual(5);\n\t\t\n\t\t// Or we can start from scratch:\n\t\tlet C2 = new CPM.CPM( [100,100], {T:20})\n\t\t  C2.add( new CPM.SoftLocalConnectivityConstraint( {\n\t\t\tLAMBDA_CONNECTIVITY : [0,1000],\n\t\t\tNBH_TYPE : \"Moore\"\n\t\t  }))\n\t\texpect( C2.getConstraint(\"SoftLocalConnectivityConstraint\").connectedComponentsOf(nbhobj).length).toEqual(1);\n\t\t\n\t\t\n\t\n\t\n\t});\t\n\tit(\"should listen to the grid torus property correctly\", function() {\n\t\tlet nbhobj = {}\n\t\t\n\t\tlet pix = C.grid.p2i( [0,0] )\n\t\t\n\t\t// add pixel and its whole neighborhood\n\t\tnbhobj[pix] = true\n\t\tfor( let n of C.grid.neighi(pix) ){\n\t\t\tnbhobj[n] = true\n\t\t}\n\t\texpect( C.getConstraint(\"SoftLocalConnectivityConstraint\").connectedComponentsOf(nbhobj).length).toEqual(1);\n\t\t\n\t\t// now change torus to false in one or both dimensions while keeping the same nbhobj\n\t\tlet C_notorus = new CPM.CPM( [100,100], {\n\t\t\tT : 20,\n\t\t\ttorus : [false,false]\n\t\t  })\n\t\t C_notorus.add( new CPM.SoftLocalConnectivityConstraint( {\n\t\t\tLAMBDA_CONNECTIVITY : [0,1000]\n\t\t }))\n\t\t expect( C_notorus.getConstraint(\"SoftLocalConnectivityConstraint\").connectedComponentsOf(nbhobj).length).toEqual(4);\n\t\t\n\t\tlet C_ytorus = new CPM.CPM( [100,100], {\n\t\t\tT : 20,\n\t\t\ttorus : [false,true]\n\t\t  })\n\t\t C_ytorus.add( new CPM.SoftLocalConnectivityConstraint( {\n\t\t\tLAMBDA_CONNECTIVITY : [0,1000]\n\t\t }))\n\t\t expect( C_ytorus.getConstraint(\"SoftLocalConnectivityConstraint\").connectedComponentsOf(nbhobj).length).toEqual(2);\n\t\t \n\t\t let C_xtorus = new CPM.CPM( [100,100], {\n\t\t\tT : 20,\n\t\t\ttorus : [true,false]\n\t\t  })\n\t\t C_xtorus.add( new CPM.SoftLocalConnectivityConstraint( {\n\t\t\tLAMBDA_CONNECTIVITY : [0,1000]\n\t\t }))\n\t\t expect( C_xtorus.getConstraint(\"SoftLocalConnectivityConstraint\").connectedComponentsOf(nbhobj).length).toEqual(2);\n\n\t\t\n\t});\n  });\n\n/* Testing if the overall constraint works, specific case*/\n  describe(\"when copy attempt would disrupt local connectivity\", function() {\n  \tlet src_i, tgt_i, src_type, tgt_type \n  \n    beforeEach(function() {\n      let cid = C.makeNewCellID(1)\n    \n      C.setpix( [2,2], cid )\n      C.setpix( [3,3], cid )\n      C.setpix( [4,4], cid )\n      src_i = C.grid.p2i( [2,3] )\n      tgt_i = C.grid.p2i( [3,3] )\n      src_type = C.pixti( src_i )\n      tgt_type = C.pixti( tgt_i )\n    });\n\n\tit(\"#checkConnected should return 1\", function() {\n    \texpect(C.getConstraint(\"SoftLocalConnectivityConstraint\").checkConnected( tgt_i, src_type, tgt_type ) ).toEqual(1);\n    })\n    \n    describe(\"and when LAMBDA_CONNECTIVITY for the tgt celltype\", function() {\n    \tit(\"is non-zero, constraint should return positive deltaH\", function() {\n\t\t  expect(C.getConstraint(\"SoftLocalConnectivityConstraint\").deltaH( src_i, tgt_i, src_type, tgt_type ) > 0 ).toBeTruthy();\n\t\t}); \n\t\tit(\"is zero, constraint should return deltaH zero\", function() {\n\t\t  C.getConstraint(\"SoftLocalConnectivityConstraint\").conf.LAMBDA_CONNECTIVITY[1]=0\n\t\t  expect(C.getConstraint(\"SoftLocalConnectivityConstraint\").deltaH( src_i, tgt_i, src_type, tgt_type ) ).toEqual(0);\n\t\t}); \n    })\n\n  });\n\n \n});",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/spec/hamiltonian/SoftLocalConnectivityConstraintSpec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 916,
    "kind": "test",
    "name": "describe118",
    "testId": 118,
    "memberof": "spec/hamiltonian/SoftLocalConnectivityConstraintSpec.js",
    "testDepth": 0,
    "static": true,
    "longname": "spec/hamiltonian/SoftLocalConnectivityConstraintSpec.js~describe118",
    "access": null,
    "description": "SoftLocalConnectivityConstraint",
    "lineNumber": 7
  },
  {
    "__docId__": 917,
    "kind": "test",
    "name": "it119",
    "testId": 119,
    "memberof": "spec/hamiltonian/SoftLocalConnectivityConstraintSpec.js~describe118",
    "testDepth": 1,
    "static": true,
    "longname": "spec/hamiltonian/SoftLocalConnectivityConstraintSpec.js~describe118.it119",
    "access": null,
    "description": "should throw an error when LAMBDA_CONNECTIVITY parameter is not specified",
    "lineNumber": 20
  },
  {
    "__docId__": 918,
    "kind": "test",
    "name": "it120",
    "testId": 120,
    "memberof": "spec/hamiltonian/SoftLocalConnectivityConstraintSpec.js~describe118",
    "testDepth": 1,
    "static": true,
    "longname": "spec/hamiltonian/SoftLocalConnectivityConstraintSpec.js~describe118.it120",
    "access": null,
    "description": "should throw an error when NBH_TYPE is set incorrectly",
    "lineNumber": 25
  },
  {
    "__docId__": 919,
    "kind": "test",
    "name": "describe121",
    "testId": 121,
    "memberof": "spec/hamiltonian/SoftLocalConnectivityConstraintSpec.js~describe118",
    "testDepth": 1,
    "static": true,
    "longname": "spec/hamiltonian/SoftLocalConnectivityConstraintSpec.js~describe118.describe121",
    "access": null,
    "description": "when computing connected components",
    "lineNumber": 41
  },
  {
    "__docId__": 920,
    "kind": "test",
    "name": "it122",
    "testId": 122,
    "memberof": "spec/hamiltonian/SoftLocalConnectivityConstraintSpec.js~describe118.describe121",
    "testDepth": 2,
    "static": true,
    "longname": "spec/hamiltonian/SoftLocalConnectivityConstraintSpec.js~describe118.describe121.it122",
    "access": null,
    "description": "should return only one component in connected case",
    "lineNumber": 43
  },
  {
    "__docId__": 921,
    "kind": "test",
    "name": "it123",
    "testId": 123,
    "memberof": "spec/hamiltonian/SoftLocalConnectivityConstraintSpec.js~describe118.describe121",
    "testDepth": 2,
    "static": true,
    "longname": "spec/hamiltonian/SoftLocalConnectivityConstraintSpec.js~describe118.describe121.it123",
    "access": null,
    "description": "should return multiple components in disconnected case",
    "lineNumber": 51
  },
  {
    "__docId__": 922,
    "kind": "test",
    "name": "it124",
    "testId": 124,
    "memberof": "spec/hamiltonian/SoftLocalConnectivityConstraintSpec.js~describe118.describe121",
    "testDepth": 2,
    "static": true,
    "longname": "spec/hamiltonian/SoftLocalConnectivityConstraintSpec.js~describe118.describe121.it124",
    "access": null,
    "description": "should listen to the neighborhood type property correctly",
    "lineNumber": 68
  },
  {
    "__docId__": 923,
    "kind": "test",
    "name": "it125",
    "testId": 125,
    "memberof": "spec/hamiltonian/SoftLocalConnectivityConstraintSpec.js~describe118.describe121",
    "testDepth": 2,
    "static": true,
    "longname": "spec/hamiltonian/SoftLocalConnectivityConstraintSpec.js~describe118.describe121.it125",
    "access": null,
    "description": "should listen to the grid torus property correctly",
    "lineNumber": 98
  },
  {
    "__docId__": 924,
    "kind": "test",
    "name": "describe126",
    "testId": 126,
    "memberof": "spec/hamiltonian/SoftLocalConnectivityConstraintSpec.js~describe118",
    "testDepth": 1,
    "static": true,
    "longname": "spec/hamiltonian/SoftLocalConnectivityConstraintSpec.js~describe118.describe126",
    "access": null,
    "description": "when copy attempt would disrupt local connectivity",
    "lineNumber": 143
  },
  {
    "__docId__": 925,
    "kind": "test",
    "name": "it127",
    "testId": 127,
    "memberof": "spec/hamiltonian/SoftLocalConnectivityConstraintSpec.js~describe118.describe126",
    "testDepth": 2,
    "static": true,
    "longname": "spec/hamiltonian/SoftLocalConnectivityConstraintSpec.js~describe118.describe126.it127",
    "access": null,
    "description": "#checkConnected should return 1",
    "lineNumber": 158
  },
  {
    "__docId__": 926,
    "kind": "test",
    "name": "describe128",
    "testId": 128,
    "memberof": "spec/hamiltonian/SoftLocalConnectivityConstraintSpec.js~describe118.describe126",
    "testDepth": 2,
    "static": true,
    "longname": "spec/hamiltonian/SoftLocalConnectivityConstraintSpec.js~describe118.describe126.describe128",
    "access": null,
    "description": "and when LAMBDA_CONNECTIVITY for the tgt celltype",
    "lineNumber": 162
  },
  {
    "__docId__": 927,
    "kind": "test",
    "name": "it129",
    "testId": 129,
    "memberof": "spec/hamiltonian/SoftLocalConnectivityConstraintSpec.js~describe118.describe126.describe128",
    "testDepth": 3,
    "static": true,
    "longname": "spec/hamiltonian/SoftLocalConnectivityConstraintSpec.js~describe118.describe126.describe128.it129",
    "access": null,
    "description": "is non-zero, constraint should return positive deltaH",
    "lineNumber": 163
  },
  {
    "__docId__": 928,
    "kind": "test",
    "name": "it130",
    "testId": 130,
    "memberof": "spec/hamiltonian/SoftLocalConnectivityConstraintSpec.js~describe118.describe126.describe128",
    "testDepth": 3,
    "static": true,
    "longname": "spec/hamiltonian/SoftLocalConnectivityConstraintSpec.js~describe118.describe126.describe128.it130",
    "access": null,
    "description": "is zero, constraint should return deltaH zero",
    "lineNumber": 166
  },
  {
    "__docId__": 929,
    "kind": "testFile",
    "name": "spec/models/CPMSpec.js",
    "content": "/** Some tests for the CPM class.\n *\n * @test {CPM}*/\ndescribe(\"CPM\", function () {\n\tlet CPM = require(\"../../build/artistoo-cjs.js\")\n\tlet cpm\n\n\tbeforeEach( function() {\n\t\t// Build a cpm and a ca\n\t\tcpm = new CPM.CPM( [50,50],\n\t\t\t{\tT:20,\n\t\t\t\tJ : [[0,20],[20,0]]\n\t\t\t} )\n\t})\n\n\tdescribe( \"[ Unit tests ]\", function() {\n\t\t/* Testing the connected components method for specific cases */\n\t\t/** @test {CPM#setpixi} */\n\t\tdescribe(\"method [ setpixi ]\", function () {\n\n\t\t\tit(\"shouldn't mess up cell kinds\", function () {\n\t\t\t\tconst doublePixels = [[2,2]]\n\t\t\t\tconst cid = cpm.makeNewCellID(1)\n\t\t\t\tfor( let p of doublePixels ){\n\t\t\t\t\tcpm.setpix( p, cid )\n\t\t\t\t}\n\n\t\t\t\texpect(cpm.cellKind( cpm.pixt( [2,2] ) ) ).toBeDefined()\n\t\t\t})\n\n\t\t\tit(\"shouldn't mess up cell kinds if called twice on same pixel\", function () {\n\t\t\t\tconst doublePixels = [[2,2],[2,2]]\n\t\t\t\tconst cid = cpm.makeNewCellID(1)\n\t\t\t\tfor( let p of doublePixels ){\n\t\t\t\t\tcpm.setpix( p, cid )\n\t\t\t\t}\n\n\t\t\t\texpect(cpm.cellKind( cpm.pixt( [2,2] ) ) ).toBeDefined()\n\t\t\t})\n\n\n\t\t})\n\t})\n\n\n})\n\n",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/spec/models/CPMSpec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 930,
    "kind": "test",
    "name": "describe131",
    "testId": 131,
    "memberof": "spec/models/CPMSpec.js",
    "testDepth": 0,
    "static": true,
    "longname": "spec/models/CPMSpec.js~describe131",
    "access": null,
    "description": "Some tests for the CPM class.",
    "lineNumber": 4,
    "testTargets": [
      "CPM"
    ]
  },
  {
    "__docId__": 931,
    "kind": "test",
    "name": "describe132",
    "testId": 132,
    "memberof": "spec/models/CPMSpec.js~describe131",
    "testDepth": 1,
    "static": true,
    "longname": "spec/models/CPMSpec.js~describe131.describe132",
    "access": null,
    "description": "[ Unit tests ]",
    "lineNumber": 16
  },
  {
    "__docId__": 932,
    "kind": "test",
    "name": "describe133",
    "testId": 133,
    "memberof": "spec/models/CPMSpec.js~describe131.describe132",
    "testDepth": 2,
    "static": true,
    "longname": "spec/models/CPMSpec.js~describe131.describe132.describe133",
    "access": null,
    "description": "method [ setpixi ]",
    "lineNumber": 19,
    "testTargets": [
      "CPM#setpixi"
    ]
  },
  {
    "__docId__": 933,
    "kind": "test",
    "name": "it134",
    "testId": 134,
    "memberof": "spec/models/CPMSpec.js~describe131.describe132.describe133",
    "testDepth": 3,
    "static": true,
    "longname": "spec/models/CPMSpec.js~describe131.describe132.describe133.it134",
    "access": null,
    "description": "shouldn't mess up cell kinds",
    "lineNumber": 21
  },
  {
    "__docId__": 934,
    "kind": "test",
    "name": "it135",
    "testId": 135,
    "memberof": "spec/models/CPMSpec.js~describe131.describe132.describe133",
    "testDepth": 3,
    "static": true,
    "longname": "spec/models/CPMSpec.js~describe131.describe132.describe133.it135",
    "access": null,
    "description": "shouldn't mess up cell kinds if called twice on same pixel",
    "lineNumber": 31
  },
  {
    "__docId__": 935,
    "kind": "testFile",
    "name": "spec/simulation/SimulationSpec.js",
    "content": "/** Tests for Simulation class.\n *\n * @test {Simulation}*/\ndescribe(\"Simulation\", function () {\n\tlet CPM = require(\"../../build/artistoo-cjs.js\")\n\t//eslint-disable-next-line no-unused-vars\n\tlet sim\n\n\n\tlet setupSim = function () {\n\n\t\tlet config = {\n\t\t\tfield_size : [50,50],\n\t\t\tconf : {\n\t\t\t\t// Basic CPM parameters\n\t\t\t\ttorus : [true,true],\n\t\t\t\tT : 10,\n\t\t\t\tJ: [[0,10], [10,0]],\n\t\t\t\tLAMBDA_V: [0,5],\n\t\t\t\tV: [0,500],\n\t\t\t\tLAMBDA_P: [0,2],\n\t\t\t\tP : [0,260],\n\t\t\t\tLAMBDA_ACT : [0,300],\n\t\t\t\tMAX_ACT : [0,30],\n\t\t\t\tACT_MEAN : \"geometric\"\n\t\t\t},\n\n\t\t\t// Simulation setup and configuration\n\t\t\tsimsettings : {\n\t\t\t\tNRCELLS : [1],\n\t\t\t\tBURNIN : 0,\n\t\t\t\tRUNTIME : 10,\n\t\t\t\tCANVASCOLOR : \"eaecef\",\n\t\t\t\tCELLCOLOR : [\"000000\"],\n\t\t\t\tACTCOLOR : [true],\n\t\t\t\tSHOWBORDERS : [false],\n\n\t\t\t\t// Output images\n\t\t\t\tSAVEIMG : false,\n\n\t\t\t\t// Output stats etc\n\t\t\t\tSTATSOUT : { browser: false, node: false },\n\t\t\t\tLOGRATE : 10\n\t\t\t}\n\t\t}\n\n\t\tsim = new CPM.Simulation( config, {} )\n\t\tsim.initializeGrid()\n\t\tsim.run()\n\n\t}\n\n\tbeforeEach(function () {\n\t\tsetupSim()\n\t})\n\n\tdescribe(\" [ unit tests ] \", function () {\n\n\t\t/** @test {Simulation#drawCanvas} */\n\t\tdescribe(\"drawCanvas has sensible defaults:\", function () {\n\t\t\tit( \"should not throw error if ACTCOLOR undefined\", function(){\n\t\t\t\tsim.conf.ACTCOLOR = undefined\n\t\t\t\texpect( function() { sim.drawCanvas() }).not.toThrow()\n\t\t\t})\n\t\t})\n\n\t\t/** @test {Simulation#initializeGrid} */\n\t\tdescribe(\"initializeGrid method:\", function () {\n\t\t\tit( \"should correctly clear up stats if called twice\", function(){\n\n\t\t\t\tsim.C.getStat( CPM.PixelsByCell )\n\t\t\t\tsim.C.reset()\n\t\t\t\tsim.initializeGrid()\n\n\t\t\t\t// check that cids of PixelsByCell are still correct\n\t\t\t\tlet undef = 0\n\t\t\t\tfor( let cid of Object.keys( sim.C.getStat( CPM.PixelsByCell ) ) ){\n\t\t\t\t\tif( typeof sim.C.cellKind(cid) === \"undefined\" ){\n\t\t\t\t\t\tundef++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\texpect( undef ).toEqual(0)\n\n\t\t\t})\n\n\t\t\tit( \"should reset C if called twice\", function(){\n\n\t\t\t\tsim.C.reset()\n\t\t\t\tsim.initializeGrid()\n\t\t\t\tconst n0 = sim.C.t2k.length -1\n\t\t\t\t// second call\n\t\t\t\tsim.initializeGrid()\n\t\t\t\tconst n1 = sim.C.t2k.length -1\n\n\t\t\t\texpect( n0 ).toEqual(n1)\n\n\t\t\t})\n\t\t})\n\n\n\t})\n})",
    "static": true,
    "longname": "/Users/ingewortel/Documents/projects/Github/artistoo/spec/simulation/SimulationSpec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 936,
    "kind": "test",
    "name": "describe136",
    "testId": 136,
    "memberof": "spec/simulation/SimulationSpec.js",
    "testDepth": 0,
    "static": true,
    "longname": "spec/simulation/SimulationSpec.js~describe136",
    "access": null,
    "description": "Tests for Simulation class.",
    "lineNumber": 4,
    "testTargets": [
      "Simulation"
    ]
  },
  {
    "__docId__": 937,
    "kind": "test",
    "name": "describe137",
    "testId": 137,
    "memberof": "spec/simulation/SimulationSpec.js~describe136",
    "testDepth": 1,
    "static": true,
    "longname": "spec/simulation/SimulationSpec.js~describe136.describe137",
    "access": null,
    "description": " [ unit tests ] ",
    "lineNumber": 57
  },
  {
    "__docId__": 938,
    "kind": "test",
    "name": "describe138",
    "testId": 138,
    "memberof": "spec/simulation/SimulationSpec.js~describe136.describe137",
    "testDepth": 2,
    "static": true,
    "longname": "spec/simulation/SimulationSpec.js~describe136.describe137.describe138",
    "access": null,
    "description": "drawCanvas has sensible defaults:",
    "lineNumber": 60,
    "testTargets": [
      "Simulation#drawCanvas"
    ]
  },
  {
    "__docId__": 939,
    "kind": "test",
    "name": "it139",
    "testId": 139,
    "memberof": "spec/simulation/SimulationSpec.js~describe136.describe137.describe138",
    "testDepth": 3,
    "static": true,
    "longname": "spec/simulation/SimulationSpec.js~describe136.describe137.describe138.it139",
    "access": null,
    "description": "should not throw error if ACTCOLOR undefined",
    "lineNumber": 61
  },
  {
    "__docId__": 940,
    "kind": "test",
    "name": "describe140",
    "testId": 140,
    "memberof": "spec/simulation/SimulationSpec.js~describe136.describe137",
    "testDepth": 2,
    "static": true,
    "longname": "spec/simulation/SimulationSpec.js~describe136.describe137.describe140",
    "access": null,
    "description": "initializeGrid method:",
    "lineNumber": 68,
    "testTargets": [
      "Simulation#initializeGrid"
    ]
  },
  {
    "__docId__": 941,
    "kind": "test",
    "name": "it141",
    "testId": 141,
    "memberof": "spec/simulation/SimulationSpec.js~describe136.describe137.describe140",
    "testDepth": 3,
    "static": true,
    "longname": "spec/simulation/SimulationSpec.js~describe136.describe137.describe140.it141",
    "access": null,
    "description": "should correctly clear up stats if called twice",
    "lineNumber": 69
  },
  {
    "__docId__": 942,
    "kind": "test",
    "name": "it142",
    "testId": 142,
    "memberof": "spec/simulation/SimulationSpec.js~describe136.describe137.describe140",
    "testDepth": 3,
    "static": true,
    "longname": "spec/simulation/SimulationSpec.js~describe136.describe137.describe140.it142",
    "access": null,
    "description": "should reset C if called twice",
    "lineNumber": 86
  }
]