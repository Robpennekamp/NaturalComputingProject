Object.defineProperty(exports, '__esModule', { value: true });

const utils = require('@sentry/utils');

/** JSDoc */

/** Patch toString calls to return proper name for wrapped functions */
class ExtraErrorData  {
  /**
   * @inheritDoc
   */
   static __initStatic() {this.id = 'ExtraErrorData';}

  /**
   * @inheritDoc
   */
   __init() {this.name = ExtraErrorData.id;}

  /** JSDoc */

  /**
   * @inheritDoc
   */
   constructor(options) {ExtraErrorData.prototype.__init.call(this);
    this._options = {
      depth: 3,
      ...options,
    };
  }

  /**
   * @inheritDoc
   */
   setupOnce(addGlobalEventProcessor, getCurrentHub) {
    addGlobalEventProcessor((event, hint) => {
      const self = getCurrentHub().getIntegration(ExtraErrorData);
      if (!self) {
        return event;
      }
      return self.enhanceEventWithErrorData(event, hint);
    });
  }

  /**
   * Attaches extracted information from the Error object to extra field in the Event
   */
   enhanceEventWithErrorData(event, hint = {}) {
    if (!hint.originalException || !utils.isError(hint.originalException)) {
      return event;
    }
    const exceptionName = (hint.originalException ).name || hint.originalException.constructor.name;

    const errorData = this._extractErrorData(hint.originalException );

    if (errorData) {
      const contexts = {
        ...event.contexts,
      };

      const normalizedErrorData = utils.normalize(errorData, this._options.depth);

      if (utils.isPlainObject(normalizedErrorData)) {
        // We mark the error data as "already normalized" here, because we don't want other normalization procedures to
        // potentially truncate the data we just already normalized, with a certain depth setting.
        utils.addNonEnumerableProperty(normalizedErrorData, '__sentry_skip_normalization__', true);
        contexts[exceptionName] = normalizedErrorData;
      }

      return {
        ...event,
        contexts,
      };
    }

    return event;
  }

  /**
   * Extract extra information from the Error object
   */
   _extractErrorData(error) {
    // We are trying to enhance already existing event, so no harm done if it won't succeed
    try {
      const nativeKeys = [
        'name',
        'message',
        'stack',
        'line',
        'column',
        'fileName',
        'lineNumber',
        'columnNumber',
        'toJSON',
      ];

      const extraErrorInfo = {};

      // We want only enumerable properties, thus `getOwnPropertyNames` is redundant here, as we filter keys anyway.
      for (const key of Object.keys(error)) {
        if (nativeKeys.indexOf(key) !== -1) {
          continue;
        }
        const value = error[key];
        extraErrorInfo[key] = utils.isError(value) ? value.toString() : value;
      }

      // Check if someone attached `toJSON` method to grab even more properties (eg. axios is doing that)
      if (typeof error.toJSON === 'function') {
        const serializedError = error.toJSON() ;

        for (const key of Object.keys(serializedError)) {
          const value = serializedError[key];
          extraErrorInfo[key] = utils.isError(value) ? value.toString() : value;
        }
      }

      return extraErrorInfo;
    } catch (oO) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && utils.logger.error('Unable to extract extra data from the Error object:', oO);
    }

    return null;
  }
} ExtraErrorData.__initStatic();

exports.ExtraErrorData = ExtraErrorData;
//# sourceMappingURL=extraerrordata.js.map
