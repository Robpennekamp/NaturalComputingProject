"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mockRequest = exports.mockClient = exports.m = exports.lookupResponseAsync = exports.lookupResponse = exports.install = exports.clear = void 0;
Object.defineProperty(exports, "requestFactory", {
  enumerable: true,
  get: function get() {
    return _requestFactory.requestFactory;
  }
});
Object.defineProperty(exports, "responseFactory", {
  enumerable: true,
  get: function get() {
    return _responseFactory.responseFactory;
  }
});
exports.unusedMocks = exports.uninstall = void 0;
var _mockRequest = _interopRequireDefault(require("../mocks/mock-request"));
var _mockResource = _interopRequireDefault(require("../mocks/mock-resource"));
var _mock = _interopRequireDefault(require("../gateway/mock"));
var _index = require("../index");
var _utils = require("../utils");
var _requestFactory = require("./request-factory");
var _responseFactory = require("./response-factory");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
var store = [];
var ids = 1;
var originalGateway = null;

/**
 * High level abstraction, it works directly on your client mocking
 * the resources and their methods.
 * @param {Object} client - the client generated by {@link forge}
 *
 * @return {MockAssert}
 */
var mockClient = function mockClient(client) {
  var entry = new _mockResource["default"](ids++, client);
  store.push(entry);
  return entry;
};

/**
 * Low level abstraction, very useful for automations
 * @param {Object} props
 *   @param {String} props.method - request method (get, post, etc)
 *   @param {String} props.url - request url (http://example.com)
 *   @param {String} props.body - request body
 *   @param {String} props.response
 *     @param {String} props.response.status
 *     @param {String} props.response.headers
 *     @param {String} props.response.body
 *
 * @return {MockAssert}
 */
exports.mockClient = mockClient;
var mockRequest = function mockRequest(props) {
  var entry = new _mockRequest["default"](ids++, props);
  store.push(entry);
  return entry.assertObject();
};

/**
 * Setup the test library
 */
exports.mockRequest = mockRequest;
var install = function install() {
  originalGateway = _index.configs.gateway;
  _index.configs.gateway = _mock["default"];
};

/**
 * Teardown the test library
 */
exports.install = install;
var uninstall = function uninstall() {
  clear();
  if (originalGateway) {
    _index.configs.gateway = originalGateway;
    originalGateway = null;
  }
};

/**
 * Cleans up all mocks
 */
exports.uninstall = uninstall;
var clear = function clear() {
  store = [];
};

/**
 * Returns number of unused mocks
 * @returns {Number}
 */
exports.clear = clear;
var unusedMocks = function unusedMocks() {
  var mocks = store.map(function (mock) {
    return mock.toMockRequest();
  });
  var count = 0;
  mocks.forEach(function (mock) {
    if (mock.calls.length === 0) count++;
  });
  return count;
};

/**
 * Similar to "lookupResponse" but it also runs the request/prepareRequest phase of the middleware
 * stack
 *
 * @param {Request} request
 * @return {Promise<Response>}
 * @throws Will throw an error if it doesn't find a mock to match the given request
 */
exports.unusedMocks = unusedMocks;
var lookupResponseAsync = function lookupResponseAsync(request) {
  var mocksPendingMiddlewareExecution = store.filter(function (mock) {
    return mock.pendingMiddlewareExecution;
  });
  return _index.configs.Promise.all(mocksPendingMiddlewareExecution.map(function (mock) {
    return mock.executeMiddlewareStack();
  })).then(function () {
    return lookupResponse(request);
  });
};

/**
 * @param {Request} request
 * @return {Response}
 * @throws Will throw an error if it doesn't find a mock to match the given request
 */
exports.lookupResponseAsync = lookupResponseAsync;
var lookupResponse = function lookupResponse(request) {
  var mocks = store.map(function (mock) {
    return mock.toMockRequest();
  });
  var exactMatch = mocks.filter(function (mock) {
    return mock.isExactMatch(request);
  }).pop();
  if (exactMatch) {
    return exactMatch.call(request);
  }
  var partialMatch = mocks.filter(function (mock) {
    return mock.isPartialMatch(request);
  }).pop();
  if (partialMatch) {
    throw new Error("[Mappersmith Test] No exact match found for ".concat(requestToLog(request), ", partial match with ").concat(mockToLog(partialMatch), ", check your mock definition"));
  }
  throw new Error("[Mappersmith Test] No match found for ".concat(requestToLog(request), ", check your mock definition"));
};

/**
 * List of match functions
 */
exports.lookupResponse = lookupResponse;
var m = {
  stringMatching: function stringMatching(regexp) {
    if (!(regexp instanceof RegExp)) {
      throw new Error("[Mappersmith Test] \"stringMatching\" received an invalid regexp (".concat(regexp, ")"));
    }
    return function (string) {
      return regexp.test(string);
    };
  },
  stringContaining: function stringContaining(sample) {
    if (typeof sample !== 'string') {
      throw new Error("[Mappersmith Test] \"stringContaining\" received an invalid string (".concat(sample, ")"));
    }
    return function (string) {
      return stringIncludes(string, sample);
    };
  },
  uuid4: function uuid4() {
    // NOTE: based on https://github.com/chriso/validator.js/blob/3443132beccddf06c3f0a5e88c1dd2ee6513b612/src/lib/isUUID.js
    var uuid4Rx = /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i;
    return function (string) {
      return uuid4Rx.test(string);
    };
  },
  anything: function anything() {
    return function () {
      return true;
    };
  }
};
exports.m = m;
var requestToLog = function requestToLog(request) {
  return "\"".concat(request.method().toUpperCase(), " ").concat(request.url(), "\" (body: \"").concat((0, _utils.toQueryString)(request.body()), "\"; headers: \"").concat((0, _utils.toQueryString)(request.headers()), "\")");
};
var mockToLog = function mockToLog(requestMock) {
  return "\"".concat(requestMock.method.toUpperCase(), " ").concat(requestMock.url, "\" (body: \"").concat(requestMock.body, "\"; headers: \"").concat(requestMock.headers, "\")");
};
var stringIncludes = function stringIncludes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }
  if (typeof str.includes === 'function') {
    return str.includes(search, start);
  }
  if (start + search.length > str.length) {
    return false;
  }
  return str.indexOf(search, start) !== -1;
};