"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.Request = void 0;
var _utils = require("./utils");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var REGEXP_DYNAMIC_SEGMENT = /{([^}?]+)\??}/;
var REGEXP_OPTIONAL_DYNAMIC_SEGMENT = /\/?{([^}?]+)\?}/g;
var REGEXP_TRAILING_SLASH = /\/$/;
/**
 * @typedef Request
 * @param {MethodDescriptor} methodDescriptor
 * @param {RequestParams} requestParams, defaults to an empty object ({})
 * @param {RequestContext} request context store, defaults to an empty object ({})
 */
var Request = /*#__PURE__*/function () {
  function Request(methodDescriptor) {
    var requestParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var requestContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    _classCallCheck(this, Request);
    _defineProperty(this, "methodDescriptor", void 0);
    _defineProperty(this, "requestParams", void 0);
    _defineProperty(this, "requestContext", void 0);
    this.methodDescriptor = methodDescriptor;
    this.requestParams = requestParams;
    this.requestContext = requestContext;
  }
  _createClass(Request, [{
    key: "isParam",
    value: function isParam(key) {
      return key !== this.methodDescriptor.headersAttr && key !== this.methodDescriptor.bodyAttr && key !== this.methodDescriptor.authAttr && key !== this.methodDescriptor.timeoutAttr && key !== this.methodDescriptor.hostAttr && key !== this.methodDescriptor.pathAttr;
    }
  }, {
    key: "params",
    value: function params() {
      var _this = this;
      var params = (0, _utils.assign)({}, this.methodDescriptor.params, this.requestParams);
      return Object.keys(params).reduce(function (obj, key) {
        if (_this.isParam(key)) {
          obj[key] = params[key];
        }
        return obj;
      }, {});
    }

    /**
     * Returns the request context; a key value object.
     * Useful to pass information from upstream middleware to a downstream one.
     */
  }, {
    key: "context",
    value: function context() {
      return this.requestContext;
    }

    /**
     * Returns the HTTP method in lowercase
     */
  }, {
    key: "method",
    value: function method() {
      return this.methodDescriptor.method.toLowerCase();
    }

    /**
     * Returns host name without trailing slash
     * Example: 'http://example.org'
     */
  }, {
    key: "host",
    value: function host() {
      var _this$methodDescripto = this.methodDescriptor,
        allowResourceHostOverride = _this$methodDescripto.allowResourceHostOverride,
        hostAttr = _this$methodDescripto.hostAttr,
        host = _this$methodDescripto.host;
      var originalHost = allowResourceHostOverride ? this.requestParams[hostAttr] || host || '' : host || '';
      if (typeof originalHost === 'string') {
        return originalHost.replace(REGEXP_TRAILING_SLASH, '');
      }
      return '';
    }

    /**
     * Returns path with parameters and leading slash.
     * Example: '/some/path?param1=true'
     *
     * @throws {Error} if any dynamic segment is missing.
     * Example:
     *  Imagine the path '/some/{name}', the error will be similar to:
     *    '[Mappersmith] required parameter missing (name), "/some/{name}" cannot be resolved'
     */
  }, {
    key: "path",
    value: function path() {
      var _this2 = this;
      var _this$methodDescripto2 = this.methodDescriptor,
        mdPathAttr = _this$methodDescripto2.pathAttr,
        mdPath = _this$methodDescripto2.path;
      var originalPath = this.requestParams[mdPathAttr] || mdPath || '';
      var params = this.params();
      var path;
      if (typeof originalPath === 'function') {
        path = originalPath(params);
        if (typeof path !== 'string') {
          throw new Error("[Mappersmith] method descriptor function did not return a string, params=".concat(JSON.stringify(params)));
        }
      } else {
        path = originalPath;
      }

      // RegExp with 'g'-flag is stateful, therefore defining it locally
      var regexp = new RegExp(REGEXP_DYNAMIC_SEGMENT, 'g');
      var dynamicSegmentKeys = [];
      var match;
      while ((match = regexp.exec(path)) !== null) {
        dynamicSegmentKeys.push(match[1]);
      }
      for (var _i = 0, _dynamicSegmentKeys = dynamicSegmentKeys; _i < _dynamicSegmentKeys.length; _i++) {
        var key = _dynamicSegmentKeys[_i];
        var pattern = new RegExp("{".concat(key, "\\??}"), 'g');
        var value = params[key];
        if (value != null && _typeof(value) !== 'object') {
          path = path.replace(pattern, this.methodDescriptor.parameterEncoder(value));
          delete params[key];
        }
      }
      path = path.replace(REGEXP_OPTIONAL_DYNAMIC_SEGMENT, '');
      var missingDynamicSegmentMatch = path.match(REGEXP_DYNAMIC_SEGMENT);
      if (missingDynamicSegmentMatch) {
        throw new Error("[Mappersmith] required parameter missing (".concat(missingDynamicSegmentMatch[1], "), \"").concat(path, "\" cannot be resolved"));
      }
      var aliasedParams = Object.keys(params).reduce(function (aliased, key) {
        var aliasedKey = _this2.methodDescriptor.queryParamAlias[key] || key;
        var value = params[key];
        if (value != null) {
          /**
           * Here we use `ExcludeObject` to surgically remove the `object` type from `value`.
           * We need it as `object` is too broad to be useful, whereas `value` is also typed
           * as NestedParam, which is the correct shape for param objects.
           */
          aliased[aliasedKey] = value;
        }
        return aliased;
      }, {});
      var queryString = (0, _utils.toQueryString)(aliasedParams, this.methodDescriptor.parameterEncoder);
      if (typeof queryString === 'string' && queryString.length !== 0) {
        var hasQuery = path.includes('?');
        path += "".concat(hasQuery ? '&' : '?').concat(queryString);
      }

      // https://www.rfc-editor.org/rfc/rfc1738#section-3.3
      if (path[0] !== '/' && path.length > 0) {
        path = "/".concat(path);
      }
      return path;
    }

    /**
     * Returns the template path, without params, before interpolation.
     * If path is a function, returns the result of request.path()
     * Example: '/some/{param}/path'
     */
  }, {
    key: "pathTemplate",
    value: function pathTemplate() {
      var path = this.methodDescriptor.path;
      var prependSlash = function prependSlash(str) {
        return str[0] !== '/' ? "/".concat(str) : str;
      };
      if (typeof path === 'function') {
        return prependSlash(path(this.params()));
      }
      return prependSlash(path);
    }

    /**
     * Returns the full URL
     * Example: http://example.org/some/path?param1=true
     *
     */
  }, {
    key: "url",
    value: function url() {
      return "".concat(this.host()).concat(this.path());
    }

    /**
     * Returns an object with the headers. Header names are converted to
     * lowercase
     */
  }, {
    key: "headers",
    value: function headers() {
      var headerAttr = this.methodDescriptor.headersAttr;
      var headers = this.requestParams[headerAttr] || {};
      if (typeof headers === 'function') {
        return headers;
      }
      var mergedHeaders = _objectSpread(_objectSpread({}, this.methodDescriptor.headers), headers);
      return (0, _utils.lowerCaseObjectKeys)(mergedHeaders);
    }

    /**
     * Utility method to get a header value by name
     */
  }, {
    key: "header",
    value: function header(name) {
      var key = name.toLowerCase();
      if (key in this.headers()) {
        return this.headers()[key];
      }
      return undefined;
    }
  }, {
    key: "body",
    value: function body() {
      return this.requestParams[this.methodDescriptor.bodyAttr];
    }
  }, {
    key: "auth",
    value: function auth() {
      return this.requestParams[this.methodDescriptor.authAttr];
    }
  }, {
    key: "timeout",
    value: function timeout() {
      return this.requestParams[this.methodDescriptor.timeoutAttr];
    }

    /**
     * Enhances current request returning a new Request
     * @param {RequestParams} extras
     *   @param {Object} extras.auth - it will replace the current auth
     *   @param {String|Object} extras.body - it will replace the current body
     *   @param {Headers} extras.headers - it will be merged with current headers
     *   @param {String} extras.host - it will replace the current timeout
     *   @param {RequestParams} extras.params - it will be merged with current params
     *   @param {Number} extras.timeout - it will replace the current timeout
     * @param {Object} requestContext - Use to pass information between different middleware.
     */
  }, {
    key: "enhance",
    value: function enhance(extras, requestContext) {
      var authKey = this.methodDescriptor.authAttr;
      var bodyKey = this.methodDescriptor.bodyAttr;
      var headerKey = this.methodDescriptor.headersAttr;
      var hostKey = this.methodDescriptor.hostAttr;
      var timeoutKey = this.methodDescriptor.timeoutAttr;
      var pathKey = this.methodDescriptor.pathAttr;

      // Note: The result of merging an instance of RequestParams with instance of Params
      // is simply a RequestParams with even more [param: string]'s on it.
      var requestParams = (0, _utils.assign)({}, this.requestParams, extras.params);
      var headers = this.requestParams[headerKey];
      var mergedHeaders = (0, _utils.assign)({}, headers, extras.headers);
      requestParams[headerKey] = mergedHeaders;
      extras.auth && (requestParams[authKey] = extras.auth);
      extras.body && (requestParams[bodyKey] = extras.body);
      extras.host && (requestParams[hostKey] = extras.host);
      extras.timeout && (requestParams[timeoutKey] = extras.timeout);
      extras.path && (requestParams[pathKey] = extras.path);
      var nextContext = _objectSpread(_objectSpread({}, this.requestContext), requestContext);
      return new Request(this.methodDescriptor, requestParams, nextContext);
    }

    /**
     * Is the request expecting a binary response?
     */
  }, {
    key: "isBinary",
    value: function isBinary() {
      return this.methodDescriptor.binary;
    }
  }]);
  return Request;
}();
exports.Request = Request;
var _default = Request;
exports["default"] = _default;