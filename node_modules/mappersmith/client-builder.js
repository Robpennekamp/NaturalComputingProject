"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.ClientBuilder = void 0;
var _manifest = require("./manifest");
var _request = require("./request");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var isFactoryConfigured = function isFactoryConfigured(factory) {
  if (!factory || !factory()) {
    return false;
  }
  return true;
};

/**
 * @typedef ClientBuilder
 * @param {Object} manifestDefinition - manifest definition with at least the `resources` key
 * @param {Function} GatewayClassFactory - factory function that returns a gateway class
 */
var ClientBuilder = /*#__PURE__*/function () {
  function ClientBuilder(manifestDefinition, GatewayClassFactory, configs) {
    _classCallCheck(this, ClientBuilder);
    _defineProperty(this, "Promise", void 0);
    _defineProperty(this, "manifest", void 0);
    _defineProperty(this, "GatewayClassFactory", void 0);
    _defineProperty(this, "maxMiddlewareStackExecutionAllowed", void 0);
    if (!manifestDefinition) {
      throw new Error("[Mappersmith] invalid manifest (".concat(manifestDefinition, ")"));
    }
    if (!isFactoryConfigured(GatewayClassFactory)) {
      throw new Error('[Mappersmith] gateway class not configured (configs.gateway)');
    }
    if (!configs.Promise) {
      throw new Error('[Mappersmith] Promise not configured (configs.Promise)');
    }
    this.Promise = configs.Promise;
    this.manifest = new _manifest.Manifest(manifestDefinition, configs);
    this.GatewayClassFactory = GatewayClassFactory;
    this.maxMiddlewareStackExecutionAllowed = configs.maxMiddlewareStackExecutionAllowed;
  }
  _createClass(ClientBuilder, [{
    key: "build",
    value: function build() {
      var _this = this;
      var client = {
        _manifest: this.manifest
      };
      this.manifest.eachResource(function (resourceName, methods) {
        client[resourceName] = _this.buildResource(resourceName, methods);
      });
      return client;
    }
  }, {
    key: "buildResource",
    value: function buildResource(resourceName, methods) {
      var _this2 = this;
      var initialResourceValue = {};
      var resource = methods.reduce(function (resource, method) {
        var resourceMethod = function resourceMethod(requestParams, context) {
          var request = new _request.Request(method.descriptor, requestParams, context);
          // `resourceName` can be `PropertyKey`, making this `string | number | Symbol`, therefore the string conversion
          // to stop type bleeding.
          return _this2.invokeMiddlewares(String(resourceName), method.name, request);
        };
        return _objectSpread(_objectSpread({}, resource), {}, _defineProperty({}, method.name, resourceMethod));
      }, initialResourceValue);

      // @hint: This type assert is needed as the compiler cannot be made to understand that the reduce produce a
      // non-partial result on a partial input. This is due to a shortcoming of the type signature for Array<T>.reduce().
      // @link: https://github.com/microsoft/TypeScript/blob/v3.7.2/lib/lib.es5.d.ts#L1186
      return resource;
    }
  }, {
    key: "invokeMiddlewares",
    value: function invokeMiddlewares(resourceName, resourceMethod, initialRequest) {
      var _this3 = this;
      var middleware = this.manifest.createMiddleware({
        resourceName: resourceName,
        resourceMethod: resourceMethod
      });
      var GatewayClass = this.GatewayClassFactory();
      var gatewayConfigs = this.manifest.gatewayConfigs;
      var requestPhaseFailureContext = {
        middleware: null,
        returnedInvalidRequest: false,
        abortExecution: false
      };
      var getInitialRequest = function getInitialRequest() {
        return _this3.Promise.resolve(initialRequest);
      };
      var chainRequestPhase = function chainRequestPhase(next, middleware) {
        return function () {
          var abort = function abort(error) {
            requestPhaseFailureContext.abortExecution = true;
            throw error;
          };
          return _this3.Promise.resolve().then(function () {
            return middleware.prepareRequest(next, abort);
          }).then(function (request) {
            if (request instanceof _request.Request) {
              return request;
            }

            // FIXME: Here be dragons: prepareRequest is typed as Promise<Response | void>
            // but this code clearly expects it can be something else... anything.
            // Hence manual cast to `unknown` above.
            requestPhaseFailureContext.returnedInvalidRequest = true;
            var typeValue = _typeof(request);
            var prettyType = typeValue === 'object' || typeValue === 'function' ?
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            request.name || typeValue : typeValue;
            throw new Error("[Mappersmith] middleware \"".concat(middleware.__name, "\" should return \"Request\" but returned \"").concat(prettyType, "\""));
          })["catch"](function (e) {
            requestPhaseFailureContext.middleware = middleware.__name || null;
            throw e;
          });
        };
      };
      var prepareRequest = middleware.reduce(chainRequestPhase, getInitialRequest);
      var executions = 0;
      var executeMiddlewareStack = function executeMiddlewareStack() {
        return prepareRequest()["catch"](function (e) {
          var returnedInvalidRequest = requestPhaseFailureContext.returnedInvalidRequest,
            abortExecution = requestPhaseFailureContext.abortExecution,
            middleware = requestPhaseFailureContext.middleware;
          if (returnedInvalidRequest || abortExecution) {
            throw e;
          }
          var error = new Error("[Mappersmith] middleware \"".concat(middleware, "\" failed in the request phase: ").concat(e.message));
          error.stack = e.stack;
          throw error;
        }).then(function (finalRequest) {
          executions++;
          if (executions > _this3.maxMiddlewareStackExecutionAllowed) {
            throw new Error("[Mappersmith] infinite loop detected (middleware stack invoked ".concat(executions, " times). Check the use of \"renew\" in one of the middleware."));
          }
          var renew = executeMiddlewareStack;
          var chainResponsePhase = function chainResponsePhase(previousValue, currentValue) {
            return function () {
              // Deliberately putting this on two separate lines - to get typescript to not return "any"
              var nextValue = currentValue.response(previousValue, renew, finalRequest);
              return nextValue;
            };
          };
          var callGateway = function callGateway() {
            return new GatewayClass(finalRequest, gatewayConfigs).call();
          };
          var execute = middleware.reduce(chainResponsePhase, callGateway);
          return execute();
        });
      };
      return new this.Promise(function (resolve, reject) {
        executeMiddlewareStack().then(function (response) {
          return resolve(response);
        })["catch"](reject);
      });
    }
  }]);
  return ClientBuilder;
}();
exports.ClientBuilder = ClientBuilder;
var _default = ClientBuilder;
exports["default"] = _default;