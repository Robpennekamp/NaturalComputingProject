"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validKeys = exports.toQueryString = exports.performanceNow = exports.parseResponseHeaders = exports.lowerCaseObjectKeys = exports.isPlainObject = exports.isObject = exports.buildRecursive = exports.btoa = exports.assign = void 0;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var _process, getNanoSeconds, loadTime;
try {
  // eslint-disable-next-line no-eval
  _process = eval('typeof __TEST_WEB__ === "undefined" && typeof process === "object" ? process : undefined');
} catch (e) {} // eslint-disable-line no-empty

var hasProcessHrtime = function hasProcessHrtime() {
  return typeof _process !== 'undefined' && _process !== null && _process.hrtime;
};
if (hasProcessHrtime()) {
  getNanoSeconds = function getNanoSeconds() {
    var hr = _process.hrtime();
    return hr[0] * 1e9 + hr[1];
  };
  loadTime = getNanoSeconds();
}
var R20 = /%20/g;
var isNeitherNullNorUndefined = function isNeitherNullNorUndefined(x) {
  return x !== null && x !== undefined;
};
var validKeys = function validKeys(entry) {
  return Object.keys(entry).filter(function (key) {
    return isNeitherNullNorUndefined(entry[key]);
  });
};
exports.validKeys = validKeys;
var buildRecursive = function buildRecursive(key, value) {
  var suffix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var encoderFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : encodeURIComponent;
  if (Array.isArray(value)) {
    return value.map(function (v) {
      return buildRecursive(key, v, suffix + '[]', encoderFn);
    }).join('&');
  }
  if (_typeof(value) !== 'object') {
    return "".concat(encoderFn(key + suffix), "=").concat(encoderFn(value));
  }
  return Object.keys(value).map(function (nestedKey) {
    var nestedValue = value[nestedKey];
    if (isNeitherNullNorUndefined(nestedValue)) {
      return buildRecursive(key, nestedValue, suffix + '[' + nestedKey + ']', encoderFn);
    }
    return null;
  }).filter(isNeitherNullNorUndefined).join('&');
};
exports.buildRecursive = buildRecursive;
var toQueryString = function toQueryString(entry) {
  var encoderFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : encodeURIComponent;
  if (!isPlainObject(entry)) {
    return entry;
  }
  return Object.keys(entry).map(function (key) {
    var value = entry[key];
    if (isNeitherNullNorUndefined(value)) {
      return buildRecursive(key, value, '', encoderFn);
    }
    return null;
  }).filter(isNeitherNullNorUndefined).join('&').replace(R20, '+');
};

/**
 * Gives time in milliseconds, but with sub-millisecond precision for Browser
 * and Nodejs
 */
exports.toQueryString = toQueryString;
var performanceNow = function performanceNow() {
  if (hasProcessHrtime() && getNanoSeconds !== undefined) {
    var now = getNanoSeconds();
    if (now !== undefined && loadTime !== undefined) {
      return (now - loadTime) / 1e6;
    }
  }
  return Date.now();
};

/**
 * borrowed from: {@link https://gist.github.com/monsur/706839}
 * XmlHttpRequest's getAllResponseHeaders() method returns a string of response
 * headers according to the format described here:
 * {@link http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders-method}
 * This method parses that string into a user-friendly key/value pair object.
 */
exports.performanceNow = performanceNow;
var parseResponseHeaders = function parseResponseHeaders(headerStr) {
  var headers = {};
  if (!headerStr) {
    return headers;
  }
  var headerPairs = headerStr.split("\r\n");
  for (var i = 0; i < headerPairs.length; i++) {
    var headerPair = headerPairs[i];
    // Can't use split() here because it does the wrong thing
    // if the header value has the string ": " in it.
    var index = headerPair.indexOf(": ");
    if (index > 0) {
      var key = headerPair.substring(0, index).toLowerCase().trim();
      var val = headerPair.substring(index + 2).trim();
      headers[key] = val;
    }
  }
  return headers;
};
exports.parseResponseHeaders = parseResponseHeaders;
var lowerCaseObjectKeys = function lowerCaseObjectKeys(obj) {
  return Object.keys(obj).reduce(function (target, key) {
    target[key.toLowerCase()] = obj[key];
    return target;
  }, {});
};
exports.lowerCaseObjectKeys = lowerCaseObjectKeys;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var assign = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    // eslint-disable-next-line prefer-rest-params
    var source = arguments[i];
    for (var key in source) {
      if (hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
exports.assign = assign;
var toString = Object.prototype.toString;
var isPlainObject = function isPlainObject(value) {
  return toString.call(value) === '[object Object]' && Object.getPrototypeOf(value) === Object.getPrototypeOf({});
};
exports.isPlainObject = isPlainObject;
var isObject = function isObject(value) {
  return _typeof(value) === 'object' && value !== null && !Array.isArray(value);
};

/**
 * borrowed from: {@link https://github.com/davidchambers/Base64.js}
 */
exports.isObject = isObject;
var CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
var btoa = function btoa(input) {
  var output = '';
  var map = CHARS;
  var str = String(input);
  for (
  // initialize result and counter
  var block = 0, charCode, idx = 0;
  // if the next str index does not exist:
  //   change the mapping table to "="
  //   check if d has no fractional digits
  str.charAt(idx | 0) || (map = '=', idx % 1);
  // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
  output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
    charCode = str.charCodeAt(idx += 3 / 4);
    if (charCode > 0xff) {
      throw new Error("[Mappersmith] 'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
    }
    block = block << 8 | charCode;
  }
  return output;
};
exports.btoa = btoa;