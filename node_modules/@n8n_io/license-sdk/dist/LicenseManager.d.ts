import { X509Certificate } from 'node:crypto';

type TLicenseManagerConfig = {
    server?: string;
    tenantId: number;
    productIdentifier: string;
    autoRenewEnabled?: boolean;
    renewOnInit?: boolean;
    autoRenewOffset?: number;
    loadCertStr: () => Promise<TLicenseBlock>;
    saveCertStr: (cert: TLicenseBlock) => Promise<void>;
    deviceFingerprint?: () => string | Promise<string>;
    onFeatureChange?: (features: TFeatures) => any;
    logger?: TLogger;
};
type TLicenseBlock = string;
type TLicenseContainer = {
    licenseKey: string;
    x509: string;
};
type TFeatures = {
    [key: string]: boolean | number | string;
};
type TMetadata = {
    [key: string]: boolean | number | string | Array<any> | {};
};
type TEntitlement = {
    id: string;
    productId: string;
    productMetadata: TMetadata;
    features: TFeatures;
    featureOverrides: TFeatures;
    validFrom: Date;
    validTo: Date;
};
type TLicenseCertObj = {
    consumerId: string;
    version: number;
    tenantId: number;
    renewalToken: string;
    deviceLock: boolean;
    deviceFingerprint: string;
    createdAt: Date;
    issuedAt: Date;
    expiresAt: Date;
    terminatesAt: Date;
    entitlements: TEntitlement[];
    managementJwt: string;
    isEphemeral: boolean;
};
type TLogger = {
    error: Function;
    warn: Function;
    info: Function;
    debug: Function;
};
declare const enum LogLevel {
    ERROR = "error",
    WARN = "warn",
    INFO = "info",
    DEBUG = "debug"
}
declare class LicenseManager {
    config: TLicenseManagerConfig;
    private isInitializationCompleted;
    private key?;
    private logger;
    protected licenseCert?: TLicenseCertObj;
    private x509Cert?;
    private x509IssuerCert;
    private deviceFingerprint?;
    private renewalIntervalPointer?;
    private checkUpcomingEntitlementChangesCron?;
    private entitlementChangeTimeoutPointer?;
    private currentFeatures?;
    constructor(config: TLicenseManagerConfig);
    log(msg: string, logLevel: LogLevel): void;
    private isInitialized;
    initialize(): Promise<void>;
    reset(): void;
    computeDeviceFingerprint(): Promise<string>;
    activate(reservationId: string): Promise<void>;
    renew(): Promise<void>;
    private hasCert;
    isTerminated(): boolean;
    getExpiryDate(): Date;
    getTerminationDate(): Date;
    isValid(useLogger?: boolean): boolean;
    hasFeatureEnabled(feature: string, requireValidCert?: boolean): boolean;
    hasFeatureDefined(feature: string, requireValidCert?: boolean): boolean;
    hasQuotaLeft(quotaFeatureName: string, currentConsumption: number): boolean;
    getFeatureValue(feature: string, requireValidCert?: boolean): undefined | boolean | number | string;
    private updateCurrentFeatures;
    getFeatures(): TFeatures;
    getCurrentEntitlements(): TEntitlement[];
    getManagementJwt(): string;
    isRenewalDue(): boolean;
    toString(): string;
    private triggerOnFeatureChangeCallback;
    private setTimerForNextEntitlementChange;
    private renewalCron;
    private initCert;
    private stringifyCertContainer;
    private parseLicenseCertContainerStr;
    private parseLicenseKeyStr;
    private validateLicenseKey;
    getIssuerCert(): X509Certificate;
}

export { LicenseManager, TEntitlement, TFeatures, TLicenseBlock, TLicenseCertObj, TLicenseContainer, TLicenseManagerConfig, TLogger, TMetadata };
