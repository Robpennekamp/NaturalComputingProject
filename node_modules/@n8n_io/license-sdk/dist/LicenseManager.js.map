{"version":3,"sources":["../src/LicenseManager.ts","../src/httpRequest.ts"],"sourcesContent":["import CryptoJS from 'crypto-js'\nimport { machineId } from 'node-machine-id'\nimport NodeRSA from 'node-rsa'\nimport { X509Certificate } from 'node:crypto'\nimport { postRequest } from './httpRequest'\n\nexport type TLicenseManagerConfig = {\n  server?: string\n  tenantId: number\n  productIdentifier: string\n  autoRenewEnabled?: boolean\n  renewOnInit?: boolean\n  autoRenewOffset?: number\n  loadCertStr: () => Promise<TLicenseBlock>\n  saveCertStr: (cert: TLicenseBlock) => Promise<void>\n  deviceFingerprint?: () => string | Promise<string>\n  onFeatureChange?: (features: TFeatures) => any\n  logger?: TLogger\n}\n\nexport type TLicenseBlock = string\n\nexport type TLicenseContainer = {\n  licenseKey: string\n  x509: string\n}\n\nexport type TFeatures = { [key: string]: boolean | number | string }\n\nexport type TMetadata = {\n  [key: string]: boolean | number | string | Array<any> | {}\n}\n\nexport type TEntitlement = {\n  id: string\n  productId: string\n  productMetadata: TMetadata\n  features: TFeatures\n  featureOverrides: TFeatures\n  validFrom: Date\n  validTo: Date\n}\n\nexport type TLicenseCertObj = {\n  consumerId: string\n  version: number\n  tenantId: number\n  renewalToken: string\n  deviceLock: boolean\n  deviceFingerprint: string\n  createdAt: Date\n  issuedAt: Date\n  expiresAt: Date\n  terminatesAt: Date\n  entitlements: TEntitlement[]\n  managementJwt: string\n  isEphemeral: boolean\n}\n\nexport type TLogger = {\n  error: Function\n  warn: Function\n  info: Function\n  debug: Function\n}\n\nconst enum LogLevel {\n  ERROR = 'error',\n  WARN = 'warn',\n  INFO = 'info',\n  DEBUG = 'debug',\n}\n\nexport class LicenseManager {\n  public config: TLicenseManagerConfig\n\n  private isInitializationCompleted = false\n  private key?: NodeRSA\n  private logger: TLogger\n  protected licenseCert?: TLicenseCertObj\n  private x509Cert?: X509Certificate\n  private x509IssuerCert: X509Certificate\n  private deviceFingerprint?: string\n  private renewalIntervalPointer?: NodeJS.Timer\n  private checkUpcomingEntitlementChangesCron?: NodeJS.Timer\n  private entitlementChangeTimeoutPointer?: NodeJS.Timer\n  private currentFeatures?: TFeatures\n\n  constructor(config: TLicenseManagerConfig) {\n    this.config = config\n\n    if (this.config.logger) {\n      this.logger = this.config.logger\n    } else {\n      this.logger = {\n        error() {\n          console.log('ERROR:', ...arguments)\n        },\n        warn() {\n          console.log('WARN:', ...arguments)\n        },\n        info() {\n          console.log('INFO:', ...arguments)\n        },\n        debug() {\n          console.log('DEBUG:', ...arguments)\n        },\n      }\n    }\n\n    this.x509IssuerCert = new X509Certificate(\n      '-----BEGIN CERTIFICATE-----\\n' +\n        'MIIFDDCCAvQCCQCWGBewlWbp0DANBgkqhkiG9w0BAQsFADBIMQswCQYDVQQGEwJE\\n' +\n        'RTEPMA0GA1UECAwGQmVybGluMQ8wDQYDVQQHDAZCZXJsaW4xFzAVBgNVBAMMDmxp\\n' +\n        'Y2Vuc2UubjhuLmlvMB4XDTIyMDYyNDA0MDkzM1oXDTQ5MTEwOTA0MDkzM1owSDEL\\n' +\n        'MAkGA1UEBhMCREUxDzANBgNVBAgMBkJlcmxpbjEPMA0GA1UEBwwGQmVybGluMRcw\\n' +\n        'FQYDVQQDDA5saWNlbnNlLm44bi5pbzCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCC\\n' +\n        'AgoCggIBANK6Uj5CSyPaa2rf/bwH/AqzzINeWg4n94pECv4p8tsjy0+ZscodNn7Q\\n' +\n        'IvYW/6IUpax8fZvHCSqu0L7fsgLkw0+HDLlsln+ryI/3h1ElVZm67BfqOvhSfPj+\\n' +\n        'btxcP8EtS+6hbf74sqPEBFD0wikKhIPGdtBolp7rLXfTGs+5eMqSA5q4W1V+HUUU\\n' +\n        'zgaCdchzlHGTdIICNpbRozGeFTIIx1MPzMie+4zIs6i680efx2KJVZWsa2WuCSED\\n' +\n        '+b0gSRTgoKQ3B7JjxJKfzHdOdM6JxhkCjrJIkJCrZL7wFypn+wMHsVFrsw/80WkS\\n' +\n        'dwBj/RqCPzKcRwnxs0WNLhkyT/XCMS/1pNzPymdFADu2tEZjhFsa5ziIhdoQz8po\\n' +\n        'Efheyg3mOZDWyu6oyHCLH9lUlsNjV9zZ6RICgvHZvHPmPqOLPomy4Qymq2osuH+S\\n' +\n        '28rwEy0W3DCEfuS3dZHrSQfohGC9EAyyFAIPSGhTJSYJl0oNBZjpRM+jAm9ER7PM\\n' +\n        'K70/7g6z8uIgKa8/SD/Pezd/aWzxH/tOokAF5X5o5TzSOwVzqOJzY06EZC7CJnhs\\n' +\n        'sigAJTy1trZJBcZuWnKY5FqrK3QzjsQ9sWM0tRocfNOYmD21mubNo+RmMMo3kvYL\\n' +\n        'JoBfap/cuP6kx3OiRzBJ4luTEa6nRIYy+EjcPaN3+9L5iEZ9/NABAgMBAAEwDQYJ\\n' +\n        'KoZIhvcNAQELBQADggIBAIUpJ0Rh6C92cJqy6iehS8c77r1prj62gr6Acdy5QGh8\\n' +\n        'ax30ANDbPtkezVIIBk+0JjLkMxr3mwqCRsPgMshPcxhZwEafmZrWPPGRVsOfukB3\\n' +\n        'Gp10cIv1YmZ7AFY4i/izj5184+A+GjxrJBULQG1JfX4c7KW06Kaps85AaX/Tp0fl\\n' +\n        '/hZ6oUe48aSSTuAW38hWZ5jCpBqfFyQ15ablJZt0fB8NkXEdFUcUEt/OHJfqF5fP\\n' +\n        'Nt5PWC1AuBxzSbzjwabOy/M4r8m5CzCeXSIjqbcsAq52myMoxvNrjKRtucQ7CjqK\\n' +\n        'LR6WdhMf+NLvyTI+evXMoXpDzlevkCpz17uDiDt9XrmvLSf3Ff8mdTRwzVmOmHfc\\n' +\n        'Ruz5v7WBR4cpBR/sC+WxOw9heLMHgYhPyRUM4voo55EcJGusXr/iavblBAnI0GUw\\n' +\n        'uMNs3MjEmfbaBV1K0GKG5UToF9UmUxxVmTcRUZrAQX+yBkRezDTpOQuRnB58BDQP\\n' +\n        'A62lcgZlikzJw3lHue33qAudyUrUmjfHGll7GFQNeLO42jPMeM4NJiNIrBZ7j0uD\\n' +\n        '4slHdDi/44PHcKchvde/5k7ZJMi6OC1Vu+bOnKvzhnWQIOkHFQ55m13oslV2ozZT\\n' +\n        '/oqhn/8/LeV0ooZuYnBeRkRTveniUeho2OFe5xZvWSSfuBrbHt9+zBg+5MWPUTIJ\\n' +\n        '-----END CERTIFICATE-----'\n    )\n\n    //set defaults for not set config properties:\n    this.config.autoRenewEnabled = this.config.autoRenewEnabled ?? true\n    this.config.renewOnInit = this.config.renewOnInit ?? false\n    this.config.autoRenewOffset = this.config.autoRenewOffset ?? 60 * 60 * 72 // default: 72 hours\n    this.config.server = this.config.server ?? 'https://license.n8n.io/v1'\n  }\n\n  log(msg: string, logLevel: LogLevel) {\n    this.logger[logLevel](`[license] ${msg}`)\n  }\n\n  private isInitialized() {\n    return this.isInitializationCompleted\n  }\n\n  async initialize() {\n    if (this.isInitialized()) {\n      return\n    }\n\n    this.deviceFingerprint = await this.computeDeviceFingerprint()\n    this.log(\n      `initializing for deviceFingerprint ${this.deviceFingerprint}`,\n      LogLevel.DEBUG\n    )\n    await this.initCert()\n\n    //set up periodic timer to assess check upcoming entitlement / feature changes\n    this.checkUpcomingEntitlementChangesCron = setInterval(\n      () => this.setTimerForNextEntitlementChange(),\n      1000 * 60 * 15 //15 minutes\n    )\n\n    if (this.config.autoRenewEnabled) {\n      //invoke renewal immediately once, unless disabled:\n      if (this.config.renewOnInit) {\n        await this.renewalCron({ force: true })\n      }\n\n      //and periodically:\n      this.renewalIntervalPointer = setInterval(\n        () => this.renewalCron({ force: false }),\n        1000 * 60 * 15 //15 minutes\n      )\n    }\n\n    this.isInitializationCompleted = true\n  }\n\n  reset() {\n    if (this.config.autoRenewEnabled) {\n      clearInterval(this.renewalIntervalPointer)\n    }\n    if (this.checkUpcomingEntitlementChangesCron) {\n      clearInterval(this.checkUpcomingEntitlementChangesCron)\n    }\n    if (this.entitlementChangeTimeoutPointer) {\n      clearTimeout(this.entitlementChangeTimeoutPointer)\n    }\n    this.licenseCert = undefined\n    this.deviceFingerprint = undefined\n    this.isInitializationCompleted = false\n  }\n\n  async computeDeviceFingerprint() {\n    if (\n      this.config.deviceFingerprint &&\n      typeof this.config.deviceFingerprint === 'function'\n    ) {\n      return await this.config.deviceFingerprint()\n    }\n    return await machineId()\n  }\n\n  async activate(reservationId: string) {\n    if (!this.isInitialized()) {\n      throw new Error('activation failed because SDK was not yet initialized')\n    }\n\n    const postData: {\n      reservationId: string\n      tenantId: number\n      productIdentifier: string\n      deviceFingerprint: string\n      consumerId?: string\n      renewalToken?: string\n    } = {\n      reservationId,\n      tenantId: this.config.tenantId,\n      productIdentifier: this.config.productIdentifier,\n      deviceFingerprint: this.deviceFingerprint!,\n    }\n\n    if (this.hasCert()) {\n      postData.consumerId = this.licenseCert.consumerId\n      postData.renewalToken = this.licenseCert.renewalToken\n    }\n\n    type ResponseDataFormat = {\n      licenseKey?: string\n      x509?: string\n      message?: string\n      errorId?: string\n    }\n\n    type PostRequestResponse = Awaited<\n      ReturnType<typeof postRequest<ResponseDataFormat>>\n    >\n\n    let response: PostRequestResponse\n\n    try {\n      response = await postRequest<{\n        licenseKey?: string\n        x509?: string\n        message?: string\n        errorId?: string\n      }>(`${this.config.server!}/activate`, postData, { timeoutInMs: 10000 })\n    } catch (error) {\n      this.log(\n        'license activation failed: ' + (error as Error).message,\n        LogLevel.WARN\n      )\n      throw new Error((error as Error).message)\n    }\n\n    if (response.status == 200) {\n      if (\n        !response.data.hasOwnProperty('licenseKey') ||\n        !response.data.hasOwnProperty('x509')\n      ) {\n        this.log('unexpected server response', LogLevel.WARN)\n        throw new Error('unexpected server response')\n      }\n      const containerStr = this.stringifyCertContainer({\n        licenseKey: response.data.licenseKey,\n        x509: response.data.x509,\n      } as TLicenseContainer)\n      await this.config.saveCertStr(containerStr)\n      await this.initCert()\n      this.log('license successfully activated', LogLevel.INFO)\n    } else {\n      const errorMsg = `license activation failed: ${\n        response.data.message ?? 'unknown reason'\n      }`\n      const e = new Error(errorMsg) as Error & { errorId?: string }\n\n      if (response.data.errorId) {\n        e.errorId = response.data.errorId\n      }\n\n      this.log(errorMsg, LogLevel.WARN)\n      throw e\n    }\n  }\n\n  async renew() {\n    if (!this.hasCert()) {\n      throw new Error('renewal failed because current cert is not initialized')\n    }\n\n    if (this.licenseCert.isEphemeral) {\n      return\n    }\n\n    if (this.isTerminated()) {\n      throw new Error('renewal failed because current cert was terminated')\n    }\n\n    type ResponseDataFormat = {\n      licenseKey?: string\n      x509?: string\n      message?: string\n      errorId?: string\n    }\n\n    type PostRequestResponse = Awaited<\n      ReturnType<typeof postRequest<ResponseDataFormat>>\n    >\n\n    let response: PostRequestResponse\n\n    try {\n      response = await postRequest<ResponseDataFormat>(\n        `${this.config.server!}/renew`,\n        {\n          consumerId: this.licenseCert.consumerId,\n          tenantId: this.config.tenantId,\n          deviceFingerprint: this.deviceFingerprint,\n          renewalToken: this.licenseCert.renewalToken,\n        },\n        { timeoutInMs: 10000 }\n      )\n    } catch (error) {\n      this.log(\n        'license renewal failed: ' + (error as Error).message,\n        LogLevel.WARN\n      )\n      throw new Error((error as Error).message)\n    }\n\n    const responseData = response.data\n\n    if (response.status == 200) {\n      if (\n        !responseData.hasOwnProperty('licenseKey') ||\n        !responseData.hasOwnProperty('x509')\n      ) {\n        this.log(\n          'license renewal failed: unexpected server response',\n          LogLevel.WARN\n        )\n        throw new Error('unexpected server response')\n      }\n      const containerStr = this.stringifyCertContainer({\n        licenseKey: responseData.licenseKey,\n        x509: responseData.x509,\n      } as TLicenseContainer)\n      await this.config.saveCertStr(containerStr)\n      this.log('license successfully renewed', LogLevel.DEBUG)\n      await this.initCert()\n    } else {\n      const errorMsg = `license renewal failed: ${\n        responseData.message ?? 'unknown reason'\n      }`\n      const e = new Error(errorMsg) as Error & { errorId?: string }\n\n      if (responseData.errorId) {\n        e.errorId = responseData.errorId\n      }\n\n      this.log(errorMsg, LogLevel.WARN)\n      throw e\n    }\n  }\n\n  private hasCert(): this is { licenseCert: TLicenseCertObj } {\n    return !!this.licenseCert\n  }\n\n  isTerminated(): boolean {\n    if (!this.hasCert()) {\n      throw new Error('Cert is not initialized')\n    }\n\n    const now = new Date()\n\n    return this.licenseCert.terminatesAt < now\n  }\n\n  getExpiryDate(): Date {\n    if (!this.hasCert()) {\n      throw new Error('Cert is not initialized')\n    }\n\n    return this.licenseCert.expiresAt\n  }\n\n  getTerminationDate(): Date {\n    if (!this.hasCert()) {\n      throw new Error('Cert is not initialized')\n    }\n\n    return this.licenseCert.terminatesAt\n  }\n\n  isValid(useLogger = true): boolean {\n    const debug = (msg: string) => {\n      if (useLogger) {\n        this.log(msg, LogLevel.DEBUG)\n      }\n    }\n\n    if (!this.hasCert()) {\n      debug('cert is invalid because it is undefined')\n      return false\n    }\n\n    const cert = this.licenseCert as TLicenseCertObj\n    const now = new Date()\n\n    if (cert.expiresAt < now) {\n      debug('cert is invalid because it has expired')\n      return false\n    }\n\n    if (cert.terminatesAt < now) {\n      debug('cert is invalid because it was terminated')\n      return false\n    }\n\n    //allow clocks to be out of sync by no more than 300,000 ms / = 5 minutes\n    if (cert.createdAt.getTime() - 300000 > now.getTime()) {\n      debug('cert is invalid because system clock is out of sync')\n      return false\n    }\n\n    if (cert.deviceLock && this.deviceFingerprint !== cert.deviceFingerprint) {\n      debug('cert is invalid because device fingerprint does not match')\n      return false\n    }\n\n    if (this.config.tenantId !== cert.tenantId) {\n      debug('cert is invalid because tenant ID does not match')\n      return false\n    }\n\n    return true\n  }\n\n  hasFeatureEnabled(\n    feature: string,\n    requireValidCert: boolean = true\n  ): boolean {\n    return this.getFeatureValue(feature, requireValidCert) ? true : false\n  }\n\n  hasFeatureDefined(\n    feature: string,\n    requireValidCert: boolean = true\n  ): boolean {\n    return this.getFeatureValue(feature, requireValidCert) !== undefined\n      ? true\n      : false\n  }\n\n  hasQuotaLeft(quotaFeatureName: string, currentConsumption: number): boolean {\n    const quota = this.getFeatureValue(quotaFeatureName)\n\n    if (quota === undefined) {\n      return false\n    }\n\n    if (typeof quota !== 'number') {\n      throw new Error(\n        `${quotaFeatureName} cannot be used as quota as it is not numeric`\n      )\n    }\n\n    // -1 means unlimited quota!\n    if (quota === -1) {\n      return true\n    }\n\n    return Math.ceil(currentConsumption) < Math.ceil(quota)\n  }\n\n  getFeatureValue(\n    feature: string,\n    requireValidCert: boolean = true\n  ): undefined | boolean | number | string {\n    if (!this.hasCert()) {\n      return undefined\n    }\n\n    if (requireValidCert && !this.isValid()) {\n      return undefined\n    }\n\n    const currentFeatures = this.getFeatures()\n\n    if (!currentFeatures.hasOwnProperty(feature)) {\n      return undefined\n    }\n\n    return currentFeatures[feature]\n  }\n\n  private updateCurrentFeatures() {\n    if (!this.hasCert()) {\n      return\n    }\n\n    const now = new Date()\n\n    if (\n      this.licenseCert.expiresAt < now ||\n      this.licenseCert.terminatesAt < now\n    ) {\n      this.currentFeatures = {} as TFeatures\n    }\n\n    this.currentFeatures = this.licenseCert.entitlements\n      .filter(\n        (entitlement) =>\n          entitlement.validFrom <= now && entitlement.validTo > now\n      )\n      .sort(\n        (entitlement1, entitlement2) =>\n          entitlement1.validFrom.getTime() - entitlement2.validFrom.getTime()\n      )\n      .reduce((currentFeatures, entitlement) => {\n        return {\n          ...currentFeatures,\n          ...entitlement.features,\n          ...entitlement.featureOverrides,\n        }\n      }, {} as TFeatures)\n  }\n\n  getFeatures() {\n    if (!this.hasCert()) {\n      return {}\n    }\n\n    return this.currentFeatures ?? {}\n  }\n\n  getCurrentEntitlements() {\n    if (!this.hasCert()) {\n      return []\n    }\n\n    const now = new Date()\n\n    return this.licenseCert.entitlements.filter(\n      (entitlement) => entitlement.validFrom <= now && entitlement.validTo > now\n    )\n  }\n\n  getManagementJwt() {\n    if (!this.licenseCert) {\n      return ''\n    }\n\n    return this.licenseCert.managementJwt\n  }\n\n  isRenewalDue(): boolean {\n    if (!this.licenseCert || this.licenseCert.isEphemeral) {\n      return false\n    }\n\n    const now = new Date().getTime()\n    const mins15inMs = 1000 * 60 * 15\n    const mins20inMs = 1000 * 60 * 20\n    const expiry = this.licenseCert.expiresAt.getTime()\n    const issuedAt = this.licenseCert.issuedAt.getTime()\n    const termination = this.licenseCert.terminatesAt.getTime()\n\n    //consumerRenewalDue is TRUE when current time is close enough to consumer expiry and not after consumer termination\n    const consumerRenewalDue =\n      now > expiry - this.config.autoRenewOffset! * 1000 && now < termination\n\n    //entitlementRenewalDue is TRUE when one currently valid entitlement will expire in the next 15 minutes\n    //and the Cert was issued more than 20 minutes ago\n    const entitlementRenewalDue =\n      this.getCurrentEntitlements().find(\n        (entitlement) =>\n          now >= entitlement.validTo.getTime() - mins15inMs &&\n          now <= entitlement.validTo.getTime()\n      ) !== undefined && issuedAt < now - mins20inMs\n\n    return consumerRenewalDue || entitlementRenewalDue\n  }\n\n  toString() {\n    return (\n      `## CONSUMER CONFIG ##\\n` +\n      `tenantId: ${this.config.tenantId ?? '<n/a>'}\\n` +\n      `productIdentifier: ${this.config.productIdentifier ?? '<n/a>'}\\n` +\n      `deviceFingerprint: ${this.deviceFingerprint ?? '<n/a>'}\\n` +\n      '--\\n' +\n      `## LICENSE CERT ##\\n` +\n      `version: ${this.licenseCert?.version ?? '<n/a>'}\\n` +\n      `tenantId: ${this.licenseCert?.tenantId ?? '<n/a>'} ${\n        this.licenseCert?.tenantId !== this.config.tenantId ? '(!)' : ''\n      }\\n` +\n      `consumerId: ${this.licenseCert?.consumerId ?? '<n/a>'}\\n` +\n      `deviceFingerprint: ${this.licenseCert?.deviceFingerprint ?? '<n/a>'} ${\n        this.licenseCert?.deviceFingerprint !== this.deviceFingerprint\n          ? '(!)'\n          : ''\n      }\\n` +\n      `createdAt: ${this.licenseCert?.createdAt ?? '<n/a>'}\\n` +\n      `issuedAt: ${this.licenseCert?.issuedAt ?? '<n/a>'}\\n` +\n      `expiresAt: ${this.licenseCert?.expiresAt ?? '<n/a>'}\\n` +\n      `terminatesAt: ${this.licenseCert?.terminatesAt ?? '<n/a>'}\\n` +\n      `isEphemeral: ${this.licenseCert?.isEphemeral ?? '<n/a>'}\\n` +\n      `isValid: ${this.isValid(false)}\\n` +\n      `isRenewalDue: ${this.isRenewalDue()}\\n` +\n      `entitlements: ${this.licenseCert?.entitlements.length ?? 0}\\n` +\n      this.licenseCert?.entitlements\n        .map((entitlement, index) => {\n          return (\n            '--\\n' +\n            `## ENTITLEMENT ${index + 1} ##\\n` +\n            `id: ${entitlement.id}\\n` +\n            `productId: ${entitlement.productId}\\n` +\n            `validFrom: ${entitlement.validFrom}\\n` +\n            `validTo: ${entitlement.validTo}\\n` +\n            `features: ${JSON.stringify(entitlement.features)}\\n` +\n            `featureOverrides: ${JSON.stringify(\n              entitlement.featureOverrides\n            )}\\n`\n          )\n        })\n        .join('')\n    )\n  }\n\n  private triggerOnFeatureChangeCallback() {\n    if (this.config.onFeatureChange) {\n      this.config.onFeatureChange(this.currentFeatures ?? {})\n    }\n  }\n\n  private setTimerForNextEntitlementChange() {\n    if (!this.hasCert()) {\n      return\n    }\n\n    const now = new Date().getTime()\n    const offsets = new Set<number>()\n\n    offsets.add(this.licenseCert.expiresAt.getTime() - now)\n    offsets.add(this.licenseCert.terminatesAt.getTime() - now)\n\n    const upcomingEventOffsets = [\n      ...this.licenseCert.entitlements.reduce((offsets, entitlement) => {\n        offsets.add(entitlement.validFrom.getTime() - now)\n        offsets.add(entitlement.validTo.getTime() - now)\n        return offsets\n      }, offsets),\n    ]\n      .filter((offset) => offset >= 0 && offset <= 15 * 60 * 1000) // keep if offset is within the next 15 minutes\n      .sort((a, b) => a - b)\n\n    //console.dir(upcomingEventOffsets.map((offset) => offset / 1000 / 60))\n\n    if (upcomingEventOffsets.length === 0) {\n      return\n    }\n\n    const timeTillNextEventInMs = upcomingEventOffsets[0]\n\n    clearTimeout(this.entitlementChangeTimeoutPointer)\n    this.entitlementChangeTimeoutPointer = setTimeout(() => {\n      this.updateCurrentFeatures()\n      this.triggerOnFeatureChangeCallback()\n      this.setTimerForNextEntitlementChange()\n    }, timeTillNextEventInMs + 1000)\n  }\n\n  private async renewalCron({ force }: { force: boolean }) {\n    if (force || this.isRenewalDue()) {\n      this.log('attempting license renewal', LogLevel.DEBUG)\n      try {\n        await this.renew()\n      } catch (e) {}\n    }\n  }\n\n  private async initCert() {\n    try {\n      const containerStr = await this.config.loadCertStr()\n      if (!containerStr) {\n        return\n      }\n      if (containerStr.length < 50) {\n        throw new Error('cert string is undefined or too short')\n      }\n      const { x509, licenseKey } =\n        this.parseLicenseCertContainerStr(containerStr)\n      this.x509Cert = new X509Certificate(x509)\n      const hasApprovedIssuer = this.x509Cert.checkIssued(this.getIssuerCert())\n      if (!hasApprovedIssuer) {\n        throw new Error('cert was not issued by an approved issuer')\n      }\n      const publicKey = this.x509Cert.publicKey.export({\n        format: 'pem',\n        type: 'pkcs1',\n      })\n      this.key = new NodeRSA(publicKey)\n      this.licenseCert = this.parseLicenseKeyStr(licenseKey)\n      this.updateCurrentFeatures()\n      this.triggerOnFeatureChangeCallback()\n      this.setTimerForNextEntitlementChange()\n    } catch (e) {\n      this.log(\n        `cert could not be initialized. ${e instanceof Error ? e.message : ''}`,\n        LogLevel.ERROR\n      )\n    }\n  }\n\n  private stringifyCertContainer(container: TLicenseContainer): string {\n    const containerStr = JSON.stringify(container)\n    return Buffer.from(containerStr).toString('base64')\n  }\n\n  private parseLicenseCertContainerStr(\n    stringifiedContainer: string\n  ): TLicenseContainer {\n    const containerStr = Buffer.from(stringifiedContainer, 'base64').toString(\n      'ascii'\n    )\n    const container = JSON.parse(containerStr)\n    if (\n      !container.hasOwnProperty('licenseKey') ||\n      !container.hasOwnProperty('x509')\n    ) {\n      throw new Error('license cert container could not be parsed')\n    }\n\n    return container as TLicenseContainer\n  }\n\n  private parseLicenseKeyStr(certStr: string): TLicenseCertObj {\n    const certPayload = this.validateLicenseKey(certStr)\n\n    const cert = { ...certPayload } as TLicenseCertObj\n\n    // turn timestamp strings into Date objects\n    cert.createdAt = new Date(certPayload.createdAt)\n    cert.issuedAt = new Date(certPayload.issuedAt)\n    cert.expiresAt = new Date(certPayload.expiresAt)\n    cert.terminatesAt = new Date(certPayload.terminatesAt)\n\n    cert.entitlements = cert.entitlements.map((entitlement) => {\n      entitlement.validFrom = new Date(entitlement.validFrom)\n      entitlement.validTo = new Date(entitlement.validTo)\n      return entitlement\n    })\n\n    return cert\n  }\n\n  private validateLicenseKey(licenseKey: string) {\n    //remove all line breaks\n    licenseKey = licenseKey.replace(/(\\r\\n|\\n|\\r)/gm, '')\n\n    //extract parts\n    const match = licenseKey.match(\n      /^-----BEGIN LICENSE KEY-----(?<encryptedSymmetricKey>.+\\|\\|)(?<encryptedData>.+)\\|\\|(?<signature>.+)-----END LICENSE KEY-----$/\n    )\n\n    if (!match) {\n      throw new Error('license key could not be parsed')\n    }\n\n    const encryptedSymmetricKey = match.groups!.encryptedSymmetricKey\n    const payload = match.groups!.encryptedData\n    const signature = match.groups!.signature\n\n    let symmetricKey, decryptedData\n\n    //decrypt the random symmetric key\n    try {\n      symmetricKey = this.key!.decryptPublic(encryptedSymmetricKey, 'utf8')\n    } catch (e) {\n      throw new Error('Invalid data: Could not extract symmetric key')\n    }\n\n    //decrypt the payload\n    try {\n      decryptedData = CryptoJS.AES.decrypt(payload, symmetricKey).toString(\n        CryptoJS.enc.Utf8\n      )\n    } catch (e) {\n      throw new Error('Invalid Data: Could not decrypt data with key found')\n    }\n\n    //verify the signature.\n    if (\n      this.key!.verify(Buffer.from(decryptedData), signature, 'utf8', 'base64')\n    ) {\n      //return the decrypted data.\n      return JSON.parse(decryptedData)\n    } else {\n      throw new Error('License Key signature invalid')\n    }\n  }\n\n  public getIssuerCert() {\n    return this.x509IssuerCert\n  }\n}\n","import { fetch } from 'undici'\n\nexport async function postRequest<T>(\n  url: string,\n  data: {},\n  options: {\n    timeoutInMs?: number\n  } = {}\n) {\n  const controller = new AbortController()\n\n  const timeout = setTimeout(() => {\n    controller.abort()\n  }, options.timeoutInMs ?? 30000)\n\n  try {\n    const response = await fetch(url, {\n      method: 'post',\n      body: JSON.stringify(data),\n      headers: { 'Content-Type': 'application/json' },\n      signal: controller.signal,\n    })\n\n    const responseJson = await response.json()\n\n    return {\n      status: response.status,\n      data: responseJson as T,\n    }\n  } catch (err) {\n    ;(err as Error).message = 'Connection Error'\n    throw err\n  } finally {\n    clearTimeout(timeout)\n  }\n}\n\nexport default {\n  postRequest,\n}\n"],"mappings":"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","names":["LicenseManager_exports","__export","LicenseManager","__toCommonJS","import_crypto_js","import_node_machine_id","import_node_rsa","import_node_crypto","import_undici","postRequest","url","data","options","controller","timeout","response","responseJson","err","LicenseManager","config","msg","logLevel","reservationId","postData","response","postRequest","error","containerStr","errorMsg","e","responseData","now","useLogger","debug","cert","feature","requireValidCert","quotaFeatureName","currentConsumption","quota","currentFeatures","entitlement","entitlement1","entitlement2","mins15inMs","mins20inMs","expiry","issuedAt","termination","consumerRenewalDue","entitlementRenewalDue","_a","_b","_c","_d","_e","_f","_g","_h","_i","_j","_k","_l","_m","index","offsets","upcomingEventOffsets","offset","a","b","timeTillNextEventInMs","force","x509","licenseKey","publicKey","NodeRSA","container","stringifiedContainer","certStr","certPayload","match","encryptedSymmetricKey","payload","signature","symmetricKey","decryptedData","CryptoJS"]}