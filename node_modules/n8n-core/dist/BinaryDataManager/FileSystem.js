"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BinaryDataFileSystem = void 0;
const fs_1 = require("fs");
const promises_1 = __importDefault(require("fs/promises"));
const path_1 = __importDefault(require("path"));
const uuid_1 = require("uuid");
const n8n_workflow_1 = require("n8n-workflow");
const errors_1 = require("../errors");
const PREFIX_METAFILE = 'binarymeta';
const PREFIX_PERSISTED_METAFILE = 'persistedmeta';
class BinaryDataFileSystem {
    constructor(config) {
        this.storagePath = config.localStoragePath;
        this.binaryDataTTL = config.binaryDataTTL;
        this.persistedBinaryDataTTL = config.persistedBinaryDataTTL;
    }
    async init(startPurger = false) {
        if (startPurger) {
            setInterval(async () => {
                await this.deleteMarkedFiles();
            }, this.binaryDataTTL * 30000);
            setInterval(async () => {
                await this.deleteMarkedPersistedFiles();
            }, this.persistedBinaryDataTTL * 30000);
        }
        return promises_1.default
            .readdir(this.storagePath)
            .catch(async () => promises_1.default.mkdir(this.storagePath, { recursive: true }))
            .then(async () => promises_1.default.readdir(this.getBinaryDataMetaPath()))
            .catch(async () => promises_1.default.mkdir(this.getBinaryDataMetaPath(), { recursive: true }))
            .then(async () => promises_1.default.readdir(this.getBinaryDataPersistMetaPath()))
            .catch(async () => promises_1.default.mkdir(this.getBinaryDataPersistMetaPath(), { recursive: true }))
            .then(async () => this.deleteMarkedFiles())
            .then(async () => this.deleteMarkedPersistedFiles())
            .then(() => { });
    }
    async getFileSize(identifier) {
        const stats = await promises_1.default.stat(this.getBinaryPath(identifier));
        return stats.size;
    }
    async copyBinaryFile(filePath, executionId) {
        const binaryDataId = this.generateFileName(executionId);
        await this.addBinaryIdToPersistMeta(executionId, binaryDataId);
        await this.copyFileToLocalStorage(filePath, binaryDataId);
        return binaryDataId;
    }
    async storeBinaryMetadata(identifier, metadata) {
        await promises_1.default.writeFile(this.getMetadataPath(identifier), JSON.stringify(metadata), {
            encoding: 'utf-8',
        });
    }
    async getBinaryMetadata(identifier) {
        return (0, n8n_workflow_1.jsonParse)(await promises_1.default.readFile(this.getMetadataPath(identifier), { encoding: 'utf-8' }));
    }
    async storeBinaryData(binaryData, executionId) {
        const binaryDataId = this.generateFileName(executionId);
        await this.addBinaryIdToPersistMeta(executionId, binaryDataId);
        await this.saveToLocalStorage(binaryData, binaryDataId);
        return binaryDataId;
    }
    getBinaryStream(identifier, chunkSize) {
        return (0, fs_1.createReadStream)(this.getBinaryPath(identifier), { highWaterMark: chunkSize });
    }
    async retrieveBinaryDataByIdentifier(identifier) {
        return this.retrieveFromLocalStorage(identifier);
    }
    getBinaryPath(identifier) {
        return this.resolveStoragePath(identifier);
    }
    getMetadataPath(identifier) {
        return this.resolveStoragePath(`${identifier}.metadata`);
    }
    async markDataForDeletionByExecutionId(executionId) {
        const tt = new Date(new Date().getTime() + this.binaryDataTTL * 60000);
        return promises_1.default.writeFile(this.resolveStoragePath('meta', `${PREFIX_METAFILE}_${executionId}_${tt.valueOf()}`), '');
    }
    async deleteMarkedFiles() {
        return this.deleteMarkedFilesByMeta(this.getBinaryDataMetaPath(), PREFIX_METAFILE);
    }
    async deleteMarkedPersistedFiles() {
        return this.deleteMarkedFilesByMeta(this.getBinaryDataPersistMetaPath(), PREFIX_PERSISTED_METAFILE);
    }
    async addBinaryIdToPersistMeta(executionId, identifier) {
        const currentTime = new Date().getTime();
        const timeAtNextHour = currentTime + 3600000 - (currentTime % 3600000);
        const timeoutTime = timeAtNextHour + this.persistedBinaryDataTTL * 60000;
        const filePath = this.resolveStoragePath('persistMeta', `${PREFIX_PERSISTED_METAFILE}_${executionId}_${timeoutTime}`);
        return promises_1.default
            .readFile(filePath)
            .catch(async () => promises_1.default.writeFile(filePath, identifier))
            .then(() => { });
    }
    async deleteMarkedFilesByMeta(metaPath, filePrefix) {
        const currentTimeValue = new Date().valueOf();
        const metaFileNames = await promises_1.default.readdir(metaPath);
        const execsAdded = {};
        const promises = metaFileNames.reduce((prev, curr) => {
            const [prefix, executionId, ts] = curr.split('_');
            if (prefix !== filePrefix) {
                return prev;
            }
            const execTimestamp = parseInt(ts, 10);
            if (execTimestamp < currentTimeValue) {
                if (execsAdded[executionId]) {
                    prev.push(this.deleteMetaFileByPath(path_1.default.join(metaPath, curr)));
                    return prev;
                }
                execsAdded[executionId] = 1;
                prev.push(this.deleteBinaryDataByExecutionId(executionId).then(async () => this.deleteMetaFileByPath(path_1.default.join(metaPath, curr))));
            }
            return prev;
        }, []);
        await Promise.all(promises);
    }
    async duplicateBinaryDataByIdentifier(binaryDataId, prefix) {
        const newBinaryDataId = this.generateFileName(prefix);
        await promises_1.default.copyFile(this.resolveStoragePath(binaryDataId), this.resolveStoragePath(newBinaryDataId));
        return newBinaryDataId;
    }
    async deleteBinaryDataByExecutionId(executionId) {
        const regex = new RegExp(`${executionId}_*`);
        const filenames = await promises_1.default.readdir(this.storagePath);
        const promises = filenames.reduce((allProms, filename) => {
            if (regex.test(filename)) {
                allProms.push(promises_1.default.rm(this.resolveStoragePath(filename)));
            }
            return allProms;
        }, []);
        await Promise.all(promises);
    }
    async deleteBinaryDataByIdentifier(identifier) {
        return this.deleteFromLocalStorage(identifier);
    }
    async persistBinaryDataForExecutionId(executionId) {
        return promises_1.default.readdir(this.getBinaryDataPersistMetaPath()).then(async (metaFiles) => {
            const promises = metaFiles.reduce((prev, curr) => {
                if (curr.startsWith(`${PREFIX_PERSISTED_METAFILE}_${executionId}_`)) {
                    prev.push(promises_1.default.rm(path_1.default.join(this.getBinaryDataPersistMetaPath(), curr)));
                    return prev;
                }
                return prev;
            }, []);
            await Promise.all(promises);
        });
    }
    generateFileName(prefix) {
        return [prefix, (0, uuid_1.v4)()].join('');
    }
    getBinaryDataMetaPath() {
        return path_1.default.join(this.storagePath, 'meta');
    }
    getBinaryDataPersistMetaPath() {
        return path_1.default.join(this.storagePath, 'persistMeta');
    }
    async deleteMetaFileByPath(metaFilePath) {
        return promises_1.default.rm(metaFilePath);
    }
    async deleteFromLocalStorage(identifier) {
        return promises_1.default.rm(this.getBinaryPath(identifier));
    }
    async copyFileToLocalStorage(source, identifier) {
        await promises_1.default.cp(source, this.getBinaryPath(identifier));
    }
    async saveToLocalStorage(binaryData, identifier) {
        await promises_1.default.writeFile(this.getBinaryPath(identifier), binaryData);
    }
    async retrieveFromLocalStorage(identifier) {
        const filePath = this.getBinaryPath(identifier);
        try {
            return await promises_1.default.readFile(filePath);
        }
        catch (e) {
            throw new Error(`Error finding file: ${filePath}`);
        }
    }
    resolveStoragePath(...args) {
        const returnPath = path_1.default.join(this.storagePath, ...args);
        if (path_1.default.relative(this.storagePath, returnPath).startsWith('..'))
            throw new errors_1.FileNotFoundError('Invalid path detected');
        return returnPath;
    }
}
exports.BinaryDataFileSystem = BinaryDataFileSystem;
//# sourceMappingURL=FileSystem.js.map