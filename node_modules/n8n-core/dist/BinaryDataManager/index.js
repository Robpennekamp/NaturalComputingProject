"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BinaryDataManager = void 0;
const promises_1 = require("fs/promises");
const pretty_bytes_1 = __importDefault(require("pretty-bytes"));
const n8n_workflow_1 = require("n8n-workflow");
const FileSystem_1 = require("./FileSystem");
const utils_1 = require("./utils");
class BinaryDataManager {
    constructor(config) {
        this.binaryDataMode = config.mode;
        this.availableModes = config.availableModes.split(',');
        this.managers = {};
    }
    static async init(config, mainManager = false) {
        if (BinaryDataManager.instance) {
            throw new Error('Binary Data Manager already initialized');
        }
        BinaryDataManager.instance = new BinaryDataManager(config);
        if (BinaryDataManager.instance.availableModes.includes('filesystem')) {
            BinaryDataManager.instance.managers.filesystem = new FileSystem_1.BinaryDataFileSystem(config);
            await BinaryDataManager.instance.managers.filesystem.init(mainManager);
        }
        return undefined;
    }
    static getInstance() {
        if (!BinaryDataManager.instance) {
            throw new Error('Binary Data Manager not initialized');
        }
        return BinaryDataManager.instance;
    }
    async copyBinaryFile(binaryData, filePath, executionId) {
        const manager = this.managers[this.binaryDataMode];
        if (manager) {
            const identifier = await manager.copyBinaryFile(filePath, executionId);
            binaryData.id = this.generateBinaryId(identifier);
            binaryData.data = this.binaryDataMode;
            const fileSize = await manager.getFileSize(identifier);
            binaryData.fileSize = (0, pretty_bytes_1.default)(fileSize);
            await manager.storeBinaryMetadata(identifier, {
                fileName: binaryData.fileName,
                mimeType: binaryData.mimeType,
                fileSize,
            });
        }
        else {
            const { size } = await (0, promises_1.stat)(filePath);
            binaryData.fileSize = (0, pretty_bytes_1.default)(size);
            binaryData.data = await (0, promises_1.readFile)(filePath, { encoding: n8n_workflow_1.BINARY_ENCODING });
        }
        return binaryData;
    }
    async storeBinaryData(binaryData, input, executionId) {
        const manager = this.managers[this.binaryDataMode];
        if (manager) {
            const identifier = await manager.storeBinaryData(input, executionId);
            binaryData.id = this.generateBinaryId(identifier);
            binaryData.data = this.binaryDataMode;
            const fileSize = await manager.getFileSize(identifier);
            binaryData.fileSize = (0, pretty_bytes_1.default)(fileSize);
            await manager.storeBinaryMetadata(identifier, {
                fileName: binaryData.fileName,
                mimeType: binaryData.mimeType,
                fileSize,
            });
        }
        else {
            const buffer = await (0, utils_1.binaryToBuffer)(input);
            binaryData.data = buffer.toString(n8n_workflow_1.BINARY_ENCODING);
            binaryData.fileSize = (0, pretty_bytes_1.default)(buffer.length);
        }
        return binaryData;
    }
    getBinaryStream(identifier, chunkSize) {
        const { mode, id } = this.splitBinaryModeFileId(identifier);
        if (this.managers[mode]) {
            return this.managers[mode].getBinaryStream(id, chunkSize);
        }
        throw new Error('Storage mode used to store binary data not available');
    }
    async retrieveBinaryData(binaryData) {
        if (binaryData.id) {
            return this.retrieveBinaryDataByIdentifier(binaryData.id);
        }
        return Buffer.from(binaryData.data, n8n_workflow_1.BINARY_ENCODING);
    }
    async retrieveBinaryDataByIdentifier(identifier) {
        const { mode, id } = this.splitBinaryModeFileId(identifier);
        if (this.managers[mode]) {
            return this.managers[mode].retrieveBinaryDataByIdentifier(id);
        }
        throw new Error('Storage mode used to store binary data not available');
    }
    getBinaryPath(identifier) {
        const { mode, id } = this.splitBinaryModeFileId(identifier);
        if (this.managers[mode]) {
            return this.managers[mode].getBinaryPath(id);
        }
        throw new Error('Storage mode used to store binary data not available');
    }
    async getBinaryMetadata(identifier) {
        const { mode, id } = this.splitBinaryModeFileId(identifier);
        if (this.managers[mode]) {
            return this.managers[mode].getBinaryMetadata(id);
        }
        throw new Error('Storage mode used to store binary data not available');
    }
    async markDataForDeletionByExecutionId(executionId) {
        if (this.managers[this.binaryDataMode]) {
            await this.managers[this.binaryDataMode].markDataForDeletionByExecutionId(executionId);
        }
    }
    async markDataForDeletionByExecutionIds(executionIds) {
        if (this.managers[this.binaryDataMode]) {
            await Promise.all(executionIds.map(async (id) => this.managers[this.binaryDataMode].markDataForDeletionByExecutionId(id)));
        }
    }
    async persistBinaryDataForExecutionId(executionId) {
        if (this.managers[this.binaryDataMode]) {
            await this.managers[this.binaryDataMode].persistBinaryDataForExecutionId(executionId);
        }
    }
    async deleteBinaryDataByExecutionId(executionId) {
        if (this.managers[this.binaryDataMode]) {
            await this.managers[this.binaryDataMode].deleteBinaryDataByExecutionId(executionId);
        }
    }
    async duplicateBinaryData(inputData, executionId) {
        if (inputData && this.managers[this.binaryDataMode]) {
            const returnInputData = inputData.map(async (executionDataArray) => {
                if (executionDataArray) {
                    return Promise.all(executionDataArray.map(async (executionData) => {
                        if (executionData.binary) {
                            return this.duplicateBinaryDataInExecData(executionData, executionId);
                        }
                        return executionData;
                    }));
                }
                return executionDataArray;
            });
            return Promise.all(returnInputData);
        }
        return inputData;
    }
    generateBinaryId(filename) {
        return `${this.binaryDataMode}:${filename}`;
    }
    splitBinaryModeFileId(fileId) {
        const [mode, id] = fileId.split(':');
        return { mode, id };
    }
    async duplicateBinaryDataInExecData(executionData, executionId) {
        const binaryManager = this.managers[this.binaryDataMode];
        if (executionData.binary) {
            const binaryDataKeys = Object.keys(executionData.binary);
            const bdPromises = binaryDataKeys.map(async (key) => {
                if (!executionData.binary) {
                    return { key, newId: undefined };
                }
                const binaryDataId = executionData.binary[key].id;
                if (!binaryDataId) {
                    return { key, newId: undefined };
                }
                return binaryManager === null || binaryManager === void 0 ? void 0 : binaryManager.duplicateBinaryDataByIdentifier(this.splitBinaryModeFileId(binaryDataId).id, executionId).then((filename) => ({
                    newId: this.generateBinaryId(filename),
                    key,
                }));
            });
            return Promise.all(bdPromises).then((b) => {
                return b.reduce((acc, curr) => {
                    if (acc.binary && curr) {
                        acc.binary[curr.key].id = curr.newId;
                    }
                    return acc;
                }, executionData);
            });
        }
        return executionData;
    }
}
exports.BinaryDataManager = BinaryDataManager;
//# sourceMappingURL=index.js.map