"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkflowExecute = void 0;
const p_cancelable_1 = __importDefault(require("p-cancelable"));
const n8n_workflow_1 = require("n8n-workflow");
const lodash_get_1 = __importDefault(require("lodash.get"));
const NodeExecuteFunctions = __importStar(require("./NodeExecuteFunctions"));
class WorkflowExecute {
    constructor(additionalData, mode, runExecutionData) {
        this.additionalData = additionalData;
        this.mode = mode;
        this.status = 'new';
        this.runExecutionData = runExecutionData || {
            startData: {},
            resultData: {
                runData: {},
                pinData: {},
            },
            executionData: {
                contextData: {},
                nodeExecutionStack: [],
                waitingExecution: {},
                waitingExecutionSource: {},
            },
        };
    }
    run(workflow, startNode, destinationNode, pinData) {
        this.status = 'running';
        startNode = startNode || workflow.getStartNode(destinationNode);
        if (startNode === undefined) {
            throw new Error('No node to start the workflow from could be found!');
        }
        let runNodeFilter;
        if (destinationNode) {
            runNodeFilter = workflow.getParentNodes(destinationNode);
            runNodeFilter.push(destinationNode);
        }
        const nodeExecutionStack = [
            {
                node: startNode,
                data: {
                    main: [
                        [
                            {
                                json: {},
                            },
                        ],
                    ],
                },
                source: null,
            },
        ];
        this.runExecutionData = {
            startData: {
                destinationNode,
                runNodeFilter,
            },
            resultData: {
                runData: {},
                pinData,
            },
            executionData: {
                contextData: {},
                nodeExecutionStack,
                waitingExecution: {},
                waitingExecutionSource: {},
            },
        };
        return this.processRunExecutionData(workflow);
    }
    runPartialWorkflow(workflow, runData, startNodes, destinationNode, pinData) {
        let incomingNodeConnections;
        let connection;
        this.status = 'running';
        const runIndex = 0;
        const nodeExecutionStack = [];
        const waitingExecution = {};
        const waitingExecutionSource = {};
        for (const startNode of startNodes) {
            incomingNodeConnections = workflow.connectionsByDestinationNode[startNode];
            const incomingData = [];
            let incomingSourceData = null;
            if (incomingNodeConnections === undefined) {
                incomingData.push([
                    {
                        json: {},
                    },
                ]);
            }
            else {
                incomingSourceData = { main: [] };
                for (const connections of incomingNodeConnections.main) {
                    for (let inputIndex = 0; inputIndex < connections.length; inputIndex++) {
                        connection = connections[inputIndex];
                        const node = workflow.getNode(connection.node);
                        if (node === null || node === void 0 ? void 0 : node.disabled)
                            continue;
                        if (node && pinData && pinData[node.name]) {
                            incomingData.push(pinData[node.name]);
                        }
                        else {
                            incomingData.push(runData[connection.node][runIndex].data[connection.type][connection.index]);
                        }
                        incomingSourceData.main.push({
                            previousNode: connection.node,
                        });
                    }
                }
            }
            const executeData = {
                node: workflow.getNode(startNode),
                data: {
                    main: incomingData,
                },
                source: incomingSourceData,
            };
            nodeExecutionStack.push(executeData);
            incomingNodeConnections = workflow.connectionsByDestinationNode[destinationNode];
            if (incomingNodeConnections !== undefined) {
                for (const connections of incomingNodeConnections.main) {
                    for (let inputIndex = 0; inputIndex < connections.length; inputIndex++) {
                        connection = connections[inputIndex];
                        if (waitingExecution[destinationNode] === undefined) {
                            waitingExecution[destinationNode] = {};
                            waitingExecutionSource[destinationNode] = {};
                        }
                        if (waitingExecution[destinationNode][runIndex] === undefined) {
                            waitingExecution[destinationNode][runIndex] = {};
                            waitingExecutionSource[destinationNode][runIndex] = {};
                        }
                        if (waitingExecution[destinationNode][runIndex][connection.type] === undefined) {
                            waitingExecution[destinationNode][runIndex][connection.type] = [];
                            waitingExecutionSource[destinationNode][runIndex][connection.type] = [];
                        }
                        if (runData[connection.node] !== undefined) {
                            waitingExecution[destinationNode][runIndex][connection.type].push(runData[connection.node][runIndex].data[connection.type][connection.index]);
                            waitingExecutionSource[destinationNode][runIndex][connection.type].push({
                                previousNode: connection.node,
                                previousNodeOutput: connection.index || undefined,
                                previousNodeRun: runIndex || undefined,
                            });
                        }
                        else {
                            waitingExecution[destinationNode][runIndex][connection.type].push(null);
                            waitingExecutionSource[destinationNode][runIndex][connection.type].push(null);
                        }
                    }
                }
            }
        }
        let runNodeFilter;
        runNodeFilter = workflow
            .getParentNodes(destinationNode)
            .filter((parentNodeName) => { var _a; return !((_a = workflow.getNode(parentNodeName)) === null || _a === void 0 ? void 0 : _a.disabled); });
        runNodeFilter.push(destinationNode);
        this.runExecutionData = {
            startData: {
                destinationNode,
                runNodeFilter,
            },
            resultData: {
                runData,
                pinData,
            },
            executionData: {
                contextData: {},
                nodeExecutionStack,
                waitingExecution,
                waitingExecutionSource,
            },
        };
        return this.processRunExecutionData(workflow);
    }
    async executeHook(hookName, parameters) {
        if (this.additionalData.hooks === undefined) {
            return;
        }
        return this.additionalData.hooks.executeHookFunctions(hookName, parameters);
    }
    incomingConnectionIsEmpty(runData, inputConnections, runIndex) {
        for (const inputConnection of inputConnections) {
            const nodeIncomingData = (0, lodash_get_1.default)(runData, `[${inputConnection.node}][${runIndex}].data.main[${inputConnection.index}]`);
            if (nodeIncomingData !== undefined && nodeIncomingData.length !== 0) {
                return false;
            }
        }
        return true;
    }
    addNodeToBeExecuted(workflow, connectionData, outputIndex, parentNodeName, nodeSuccessData, runIndex) {
        let stillDataMissing = false;
        if (workflow.connectionsByDestinationNode[connectionData.node].main.length > 1) {
            let nodeWasWaiting = true;
            if (!this.runExecutionData.executionData.waitingExecutionSource) {
                this.runExecutionData.executionData.waitingExecutionSource = {};
            }
            if (this.runExecutionData.executionData.waitingExecution[connectionData.node] === undefined) {
                this.runExecutionData.executionData.waitingExecution[connectionData.node] = {};
                this.runExecutionData.executionData.waitingExecutionSource[connectionData.node] = {};
                nodeWasWaiting = false;
            }
            if (this.runExecutionData.executionData.waitingExecution[connectionData.node][runIndex] ===
                undefined) {
                this.runExecutionData.executionData.waitingExecution[connectionData.node][runIndex] = {
                    main: [],
                };
                this.runExecutionData.executionData.waitingExecutionSource[connectionData.node][runIndex] =
                    {
                        main: [],
                    };
                for (let i = 0; i < workflow.connectionsByDestinationNode[connectionData.node].main.length; i++) {
                    this.runExecutionData.executionData.waitingExecution[connectionData.node][runIndex].main.push(null);
                    this.runExecutionData.executionData.waitingExecutionSource[connectionData.node][runIndex].main.push(null);
                }
            }
            if (nodeSuccessData === null) {
                this.runExecutionData.executionData.waitingExecution[connectionData.node][runIndex].main[connectionData.index] = null;
                this.runExecutionData.executionData.waitingExecutionSource[connectionData.node][runIndex].main[connectionData.index] = null;
            }
            else {
                this.runExecutionData.executionData.waitingExecution[connectionData.node][runIndex].main[connectionData.index] = nodeSuccessData[outputIndex];
                this.runExecutionData.executionData.waitingExecutionSource[connectionData.node][runIndex].main[connectionData.index] = {
                    previousNode: parentNodeName,
                    previousNodeOutput: outputIndex || undefined,
                    previousNodeRun: runIndex || undefined,
                };
            }
            let thisExecutionData;
            let allDataFound = true;
            for (let i = 0; i <
                this.runExecutionData.executionData.waitingExecution[connectionData.node][runIndex].main
                    .length; i++) {
                thisExecutionData =
                    this.runExecutionData.executionData.waitingExecution[connectionData.node][runIndex].main[i];
                if (thisExecutionData === null) {
                    allDataFound = false;
                    break;
                }
            }
            if (allDataFound) {
                const executionStackItem = {
                    node: workflow.nodes[connectionData.node],
                    data: this.runExecutionData.executionData.waitingExecution[connectionData.node][runIndex],
                    source: this.runExecutionData.executionData.waitingExecutionSource[connectionData.node][runIndex],
                };
                if (this.runExecutionData.executionData.waitingExecutionSource !== null &&
                    this.runExecutionData.executionData.waitingExecutionSource !== undefined) {
                    executionStackItem.source =
                        this.runExecutionData.executionData.waitingExecutionSource[connectionData.node][runIndex];
                }
                this.runExecutionData.executionData.nodeExecutionStack.push(executionStackItem);
                delete this.runExecutionData.executionData.waitingExecution[connectionData.node][runIndex];
                delete this.runExecutionData.executionData.waitingExecutionSource[connectionData.node][runIndex];
                if (Object.keys(this.runExecutionData.executionData.waitingExecution[connectionData.node])
                    .length === 0) {
                    delete this.runExecutionData.executionData.waitingExecution[connectionData.node];
                    delete this.runExecutionData.executionData.waitingExecutionSource[connectionData.node];
                }
                return;
            }
            stillDataMissing = true;
            if (!nodeWasWaiting) {
                const checkOutputNodes = [];
                for (const outputIndexParent in workflow.connectionsBySourceNode[parentNodeName].main) {
                    if (!workflow.connectionsBySourceNode[parentNodeName].main.hasOwnProperty(outputIndexParent)) {
                        continue;
                    }
                    for (const connectionDataCheck of workflow.connectionsBySourceNode[parentNodeName].main[outputIndexParent]) {
                        checkOutputNodes.push(connectionDataCheck.node);
                    }
                }
                for (let inputIndex = 0; inputIndex < workflow.connectionsByDestinationNode[connectionData.node].main.length; inputIndex++) {
                    for (const inputData of workflow.connectionsByDestinationNode[connectionData.node].main[inputIndex]) {
                        if (inputData.node === parentNodeName) {
                            continue;
                        }
                        const executionStackNodes = this.runExecutionData.executionData.nodeExecutionStack.map((stackData) => stackData.node.name);
                        if (inputData.node !== parentNodeName && checkOutputNodes.includes(inputData.node)) {
                            if (!this.incomingConnectionIsEmpty(this.runExecutionData.resultData.runData, workflow.connectionsByDestinationNode[inputData.node].main[0], runIndex)) {
                                continue;
                            }
                        }
                        if (executionStackNodes.includes(inputData.node)) {
                            continue;
                        }
                        if (this.runExecutionData.resultData.runData[inputData.node] !== undefined) {
                            continue;
                        }
                        const parentNodes = workflow.getParentNodes(inputData.node, 'main', -1);
                        let nodeToAdd = inputData.node;
                        parentNodes.push(inputData.node);
                        parentNodes.reverse();
                        for (const parentNode of parentNodes) {
                            if (inputData.node !== parentNode && checkOutputNodes.includes(parentNode)) {
                                nodeToAdd = undefined;
                                break;
                            }
                            if (executionStackNodes.includes(parentNode)) {
                                nodeToAdd = undefined;
                                break;
                            }
                            if (this.runExecutionData.resultData.runData[parentNode] !== undefined) {
                                break;
                            }
                            nodeToAdd = parentNode;
                        }
                        const parentNodesNodeToAdd = workflow.getParentNodes(nodeToAdd);
                        if (parentNodesNodeToAdd.includes(parentNodeName) &&
                            nodeSuccessData[outputIndex].length === 0) {
                            nodeToAdd = undefined;
                        }
                        if (nodeToAdd === undefined) {
                            continue;
                        }
                        let addEmptyItem = false;
                        if (workflow.connectionsByDestinationNode[nodeToAdd] === undefined) {
                            addEmptyItem = true;
                        }
                        else if (this.incomingConnectionIsEmpty(this.runExecutionData.resultData.runData, workflow.connectionsByDestinationNode[nodeToAdd].main[0], runIndex)) {
                            addEmptyItem = true;
                        }
                        if (addEmptyItem) {
                            this.runExecutionData.executionData.nodeExecutionStack.push({
                                node: workflow.getNode(nodeToAdd),
                                data: {
                                    main: [
                                        [
                                            {
                                                json: {},
                                            },
                                        ],
                                    ],
                                },
                                source: {
                                    main: [
                                        {
                                            previousNode: parentNodeName,
                                            previousNodeOutput: outputIndex || undefined,
                                            previousNodeRun: runIndex || undefined,
                                        },
                                    ],
                                },
                            });
                        }
                    }
                }
            }
        }
        const connectionDataArray = [];
        for (let i = connectionData.index; i >= 0; i--) {
            connectionDataArray[i] = null;
        }
        if (nodeSuccessData === null) {
            connectionDataArray[connectionData.index] = null;
        }
        else {
            connectionDataArray[connectionData.index] = nodeSuccessData[outputIndex];
        }
        if (stillDataMissing) {
            if (!this.runExecutionData.executionData.waitingExecution.hasOwnProperty(connectionData.node)) {
                this.runExecutionData.executionData.waitingExecution[connectionData.node] = {};
            }
            this.runExecutionData.executionData.waitingExecution[connectionData.node][runIndex] = {
                main: connectionDataArray,
            };
        }
        else {
            this.runExecutionData.executionData.nodeExecutionStack.push({
                node: workflow.nodes[connectionData.node],
                data: {
                    main: connectionDataArray,
                },
                source: {
                    main: [
                        {
                            previousNode: parentNodeName,
                            previousNodeOutput: outputIndex || undefined,
                            previousNodeRun: runIndex || undefined,
                        },
                    ],
                },
            });
        }
    }
    processRunExecutionData(workflow) {
        var _a;
        n8n_workflow_1.LoggerProxy.verbose('Workflow execution started', { workflowId: workflow.id });
        const startedAt = new Date();
        this.status = 'running';
        const startNode = this.runExecutionData.executionData.nodeExecutionStack[0].node.name;
        let destinationNode;
        if (this.runExecutionData.startData && this.runExecutionData.startData.destinationNode) {
            destinationNode = this.runExecutionData.startData.destinationNode;
        }
        const pinDataNodeNames = Object.keys((_a = this.runExecutionData.resultData.pinData) !== null && _a !== void 0 ? _a : {});
        const workflowIssues = workflow.checkReadyForExecution({
            startNode,
            destinationNode,
            pinDataNodeNames,
        });
        if (workflowIssues !== null) {
            throw new Error('The workflow has issues and can for that reason not be executed. Please fix them first.');
        }
        let executionData;
        let executionError;
        let executionNode;
        let nodeSuccessData;
        let runIndex;
        let startTime;
        let taskData;
        if (this.runExecutionData.startData === undefined) {
            this.runExecutionData.startData = {};
        }
        if (this.runExecutionData.waitTill) {
            const lastNodeExecuted = this.runExecutionData.resultData.lastNodeExecuted;
            this.runExecutionData.executionData.nodeExecutionStack[0].node.disabled = true;
            this.runExecutionData.waitTill = undefined;
            this.runExecutionData.resultData.runData[lastNodeExecuted].pop();
        }
        let currentExecutionTry = '';
        let lastExecutionTry = '';
        let closeFunction;
        return new p_cancelable_1.default(async (resolve, reject, onCancel) => {
            let gotCancel = false;
            onCancel.shouldReject = false;
            onCancel(() => {
                gotCancel = true;
            });
            const returnPromise = (async () => {
                var _a, _b;
                try {
                    if (!this.additionalData.restartExecutionId) {
                        await this.executeHook('workflowExecuteBefore', [workflow]);
                    }
                }
                catch (error) {
                    executionError = {
                        ...error,
                        message: error.message,
                        stack: error.stack,
                    };
                    executionData = this.runExecutionData.executionData.nodeExecutionStack[0];
                    this.runExecutionData.resultData = {
                        runData: {
                            [executionData.node.name]: [
                                {
                                    startTime,
                                    executionTime: new Date().getTime() - startTime,
                                    data: {
                                        main: executionData.data.main,
                                    },
                                    source: [],
                                    executionStatus: 'error',
                                },
                            ],
                        },
                        lastNodeExecuted: executionData.node.name,
                        error: executionError,
                    };
                    throw error;
                }
                executionLoop: while (this.runExecutionData.executionData.nodeExecutionStack.length !== 0) {
                    if (this.additionalData.executionTimeoutTimestamp !== undefined &&
                        Date.now() >= this.additionalData.executionTimeoutTimestamp) {
                        gotCancel = true;
                    }
                    if (gotCancel) {
                        return;
                    }
                    nodeSuccessData = null;
                    executionError = undefined;
                    executionData =
                        this.runExecutionData.executionData.nodeExecutionStack.shift();
                    executionNode = executionData.node;
                    const newTaskDataConnections = {};
                    for (const inputName of Object.keys(executionData.data)) {
                        newTaskDataConnections[inputName] = executionData.data[inputName].map((input, inputIndex) => {
                            if (input === null) {
                                return input;
                            }
                            return input.map((item, itemIndex) => {
                                return {
                                    ...item,
                                    pairedItem: {
                                        item: itemIndex,
                                        input: inputIndex || undefined,
                                    },
                                };
                            });
                        });
                    }
                    executionData.data = newTaskDataConnections;
                    n8n_workflow_1.LoggerProxy.debug(`Start processing node "${executionNode.name}"`, {
                        node: executionNode.name,
                        workflowId: workflow.id,
                    });
                    await this.executeHook('nodeExecuteBefore', [executionNode.name]);
                    runIndex = 0;
                    if (this.runExecutionData.resultData.runData.hasOwnProperty(executionNode.name)) {
                        runIndex = this.runExecutionData.resultData.runData[executionNode.name].length;
                    }
                    currentExecutionTry = `${executionNode.name}:${runIndex}`;
                    if (currentExecutionTry === lastExecutionTry) {
                        throw new Error('Did stop execution because execution seems to be in endless loop.');
                    }
                    if (this.runExecutionData.startData.runNodeFilter !== undefined &&
                        this.runExecutionData.startData.runNodeFilter.indexOf(executionNode.name) === -1) {
                        continue;
                    }
                    if (workflow.connectionsByDestinationNode.hasOwnProperty(executionNode.name)) {
                        if (workflow.connectionsByDestinationNode[executionNode.name].hasOwnProperty('main')) {
                            let inputConnections;
                            let connectionIndex;
                            inputConnections = workflow.connectionsByDestinationNode[executionNode.name].main;
                            for (connectionIndex = 0; connectionIndex < inputConnections.length; connectionIndex++) {
                                if (workflow.getHighestNode(executionNode.name, 'main', connectionIndex).length === 0) {
                                    continue;
                                }
                                if (!executionData.data.hasOwnProperty('main')) {
                                    this.runExecutionData.executionData.nodeExecutionStack.push(executionData);
                                    lastExecutionTry = currentExecutionTry;
                                    continue executionLoop;
                                }
                                if (executionData.data.main.length < connectionIndex ||
                                    executionData.data.main[connectionIndex] === null) {
                                    this.runExecutionData.executionData.nodeExecutionStack.push(executionData);
                                    lastExecutionTry = currentExecutionTry;
                                    continue executionLoop;
                                }
                            }
                        }
                    }
                    startTime = new Date().getTime();
                    let maxTries = 1;
                    if (executionData.node.retryOnFail === true) {
                        maxTries = Math.min(5, Math.max(2, executionData.node.maxTries || 3));
                    }
                    let waitBetweenTries = 0;
                    if (executionData.node.retryOnFail === true) {
                        waitBetweenTries = Math.min(5000, Math.max(0, executionData.node.waitBetweenTries || 1000));
                    }
                    for (let tryIndex = 0; tryIndex < maxTries; tryIndex++) {
                        if (gotCancel) {
                            return;
                        }
                        try {
                            if (tryIndex !== 0) {
                                executionError = undefined;
                                if (waitBetweenTries !== 0) {
                                    await new Promise((resolve) => {
                                        setTimeout(() => {
                                            resolve(undefined);
                                        }, waitBetweenTries);
                                    });
                                }
                            }
                            const { pinData } = this.runExecutionData.resultData;
                            if (pinData && !executionNode.disabled && pinData[executionNode.name] !== undefined) {
                                const nodePinData = pinData[executionNode.name];
                                nodeSuccessData = [nodePinData];
                            }
                            else {
                                n8n_workflow_1.LoggerProxy.debug(`Running node "${executionNode.name}" started`, {
                                    node: executionNode.name,
                                    workflowId: workflow.id,
                                });
                                const runNodeData = await workflow.runNode(executionData, this.runExecutionData, runIndex, this.additionalData, NodeExecuteFunctions, this.mode);
                                nodeSuccessData = runNodeData.data;
                                if (runNodeData.closeFunction) {
                                    closeFunction = runNodeData.closeFunction();
                                }
                            }
                            n8n_workflow_1.LoggerProxy.debug(`Running node "${executionNode.name}" finished successfully`, {
                                node: executionNode.name,
                                workflowId: workflow.id,
                            });
                            if (nodeSuccessData) {
                                checkOutputData: for (const outputData of nodeSuccessData) {
                                    if (outputData === null) {
                                        continue;
                                    }
                                    for (const [index, item] of outputData.entries()) {
                                        if (!item.pairedItem) {
                                            if (executionData.data.main.length === 1 &&
                                                ((_a = executionData.data.main[0]) === null || _a === void 0 ? void 0 : _a.length) === 1) {
                                                item.pairedItem = {
                                                    item: 0,
                                                };
                                            }
                                            else if (nodeSuccessData.length === 1 &&
                                                executionData.data.main.length === 1 &&
                                                ((_b = executionData.data.main[0]) === null || _b === void 0 ? void 0 : _b.length) === nodeSuccessData[0].length) {
                                                item.pairedItem = {
                                                    item: index,
                                                };
                                            }
                                            else {
                                                break checkOutputData;
                                            }
                                        }
                                    }
                                }
                            }
                            if (nodeSuccessData === undefined) {
                                nodeSuccessData = null;
                            }
                            else {
                                this.runExecutionData.resultData.lastNodeExecuted = executionData.node.name;
                            }
                            if (nodeSuccessData === null || nodeSuccessData[0][0] === undefined) {
                                if (executionData.node.alwaysOutputData === true) {
                                    nodeSuccessData = nodeSuccessData || [];
                                    nodeSuccessData[0] = [
                                        {
                                            json: {},
                                        },
                                    ];
                                }
                            }
                            if (nodeSuccessData === null && !this.runExecutionData.waitTill) {
                                continue executionLoop;
                            }
                            break;
                        }
                        catch (error) {
                            this.runExecutionData.resultData.lastNodeExecuted = executionData.node.name;
                            executionError = {
                                ...error,
                                message: error.message,
                                stack: error.stack,
                            };
                            n8n_workflow_1.LoggerProxy.debug(`Running node "${executionNode.name}" finished with error`, {
                                node: executionNode.name,
                                workflowId: workflow.id,
                            });
                        }
                    }
                    if (!this.runExecutionData.resultData.runData.hasOwnProperty(executionNode.name)) {
                        this.runExecutionData.resultData.runData[executionNode.name] = [];
                    }
                    taskData = {
                        startTime,
                        executionTime: new Date().getTime() - startTime,
                        source: !executionData.source ? [] : executionData.source.main,
                        executionStatus: 'success',
                    };
                    if (executionError !== undefined) {
                        taskData.error = executionError;
                        taskData.executionStatus = 'error';
                        if (executionData.node.continueOnFail === true) {
                            if (executionData.data.hasOwnProperty('main') && executionData.data.main.length > 0) {
                                if (executionData.data.main[0] !== null) {
                                    nodeSuccessData = [executionData.data.main[0]];
                                }
                            }
                        }
                        else {
                            this.runExecutionData.resultData.runData[executionNode.name].push(taskData);
                            this.runExecutionData.executionData.nodeExecutionStack.unshift(executionData);
                            await this.executeHook('nodeExecuteAfter', [
                                executionNode.name,
                                taskData,
                                this.runExecutionData,
                            ]);
                            break;
                        }
                    }
                    for (const execution of nodeSuccessData) {
                        for (const lineResult of execution) {
                            if (lineResult.json !== undefined &&
                                lineResult.json.$error !== undefined &&
                                lineResult.json.$json !== undefined) {
                                lineResult.error = lineResult.json.$error;
                                lineResult.json = {
                                    error: lineResult.json.$error.message,
                                };
                            }
                            else if (lineResult.error !== undefined) {
                                lineResult.json = { error: lineResult.error.message };
                            }
                        }
                    }
                    taskData.data = {
                        main: nodeSuccessData,
                    };
                    this.runExecutionData.resultData.runData[executionNode.name].push(taskData);
                    if (this.runExecutionData.waitTill) {
                        await this.executeHook('nodeExecuteAfter', [
                            executionNode.name,
                            taskData,
                            this.runExecutionData,
                        ]);
                        this.runExecutionData.executionData.nodeExecutionStack.unshift(executionData);
                        break;
                    }
                    if (this.runExecutionData.startData &&
                        this.runExecutionData.startData.destinationNode &&
                        this.runExecutionData.startData.destinationNode === executionNode.name) {
                        await this.executeHook('nodeExecuteAfter', [
                            executionNode.name,
                            taskData,
                            this.runExecutionData,
                        ]);
                        continue;
                    }
                    if (workflow.connectionsBySourceNode.hasOwnProperty(executionNode.name)) {
                        if (workflow.connectionsBySourceNode[executionNode.name].hasOwnProperty('main')) {
                            let outputIndex;
                            let connectionData;
                            for (outputIndex in workflow.connectionsBySourceNode[executionNode.name].main) {
                                if (!workflow.connectionsBySourceNode[executionNode.name].main.hasOwnProperty(outputIndex)) {
                                    continue;
                                }
                                for (connectionData of workflow.connectionsBySourceNode[executionNode.name].main[outputIndex]) {
                                    if (!workflow.nodes.hasOwnProperty(connectionData.node)) {
                                        throw new Error(`The node "${executionNode.name}" connects to not found node "${connectionData.node}"`);
                                    }
                                    if (nodeSuccessData[outputIndex] &&
                                        (nodeSuccessData[outputIndex].length !== 0 || connectionData.index > 0)) {
                                        this.addNodeToBeExecuted(workflow, connectionData, parseInt(outputIndex, 10), executionNode.name, nodeSuccessData, runIndex);
                                    }
                                }
                            }
                        }
                    }
                    await this.executeHook('nodeExecuteAfter', [
                        executionNode.name,
                        taskData,
                        this.runExecutionData,
                    ]);
                }
                return;
            })()
                .then(async () => {
                if (gotCancel && executionError === undefined) {
                    return this.processSuccessExecution(startedAt, workflow, new n8n_workflow_1.WorkflowOperationError('Workflow has been canceled or timed out!'), closeFunction);
                }
                return this.processSuccessExecution(startedAt, workflow, executionError, closeFunction);
            })
                .catch(async (error) => {
                const fullRunData = this.getFullRunData(startedAt);
                fullRunData.data.resultData.error = {
                    ...error,
                    message: error.message,
                    stack: error.stack,
                };
                let newStaticData;
                if (workflow.staticData.__dataChanged === true) {
                    newStaticData = workflow.staticData;
                }
                await this.executeHook('workflowExecuteAfter', [fullRunData, newStaticData]).catch((error) => {
                    console.error('There was a problem running hook "workflowExecuteAfter"', error);
                });
                if (closeFunction) {
                    try {
                        await closeFunction;
                    }
                    catch (errorClose) {
                        n8n_workflow_1.LoggerProxy.error(`There was a problem deactivating trigger of workflow "${workflow.id}": "${errorClose.message}"`, {
                            workflowId: workflow.id,
                        });
                    }
                }
                return fullRunData;
            });
            return returnPromise.then(resolve);
        });
    }
    async processSuccessExecution(startedAt, workflow, executionError, closeFunction) {
        var _a;
        const fullRunData = this.getFullRunData(startedAt);
        if (executionError !== undefined) {
            n8n_workflow_1.LoggerProxy.verbose('Workflow execution finished with error', {
                error: executionError,
                workflowId: workflow.id,
            });
            fullRunData.data.resultData.error = {
                ...executionError,
                message: executionError.message,
                stack: executionError.stack,
            };
            if ((_a = executionError.message) === null || _a === void 0 ? void 0 : _a.includes('canceled')) {
                fullRunData.status = 'canceled';
            }
        }
        else if (this.runExecutionData.waitTill) {
            n8n_workflow_1.LoggerProxy.verbose(`Workflow execution will wait until ${this.runExecutionData.waitTill}`, {
                workflowId: workflow.id,
            });
            fullRunData.waitTill = this.runExecutionData.waitTill;
            fullRunData.status = 'waiting';
        }
        else {
            n8n_workflow_1.LoggerProxy.verbose('Workflow execution finished successfully', { workflowId: workflow.id });
            fullRunData.finished = true;
        }
        let newStaticData;
        if (workflow.staticData.__dataChanged === true) {
            newStaticData = workflow.staticData;
        }
        await this.executeHook('workflowExecuteAfter', [fullRunData, newStaticData]);
        if (closeFunction) {
            try {
                await closeFunction;
            }
            catch (error) {
                n8n_workflow_1.LoggerProxy.error(`There was a problem deactivating trigger of workflow "${workflow.id}": "${error.message}"`, {
                    workflowId: workflow.id,
                });
            }
        }
        return fullRunData;
    }
    getFullRunData(startedAt) {
        const fullRunData = {
            data: this.runExecutionData,
            mode: this.mode,
            startedAt,
            stoppedAt: new Date(),
            status: this.status,
        };
        return fullRunData;
    }
}
exports.WorkflowExecute = WorkflowExecute;
//# sourceMappingURL=WorkflowExecute.js.map