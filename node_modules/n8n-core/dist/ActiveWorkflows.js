"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActiveWorkflows = void 0;
const cron_1 = require("cron");
const n8n_workflow_1 = require("n8n-workflow");
class ActiveWorkflows {
    constructor() {
        this.workflowData = {};
    }
    isActive(id) {
        return this.workflowData.hasOwnProperty(id);
    }
    allActiveWorkflows() {
        return Object.keys(this.workflowData);
    }
    get(id) {
        return this.workflowData[id];
    }
    async add(id, workflow, additionalData, mode, activation, getTriggerFunctions, getPollFunctions) {
        this.workflowData[id] = {};
        const triggerNodes = workflow.getTriggerNodes();
        let triggerResponse;
        this.workflowData[id].triggerResponses = [];
        for (const triggerNode of triggerNodes) {
            try {
                triggerResponse = await workflow.runTrigger(triggerNode, getTriggerFunctions, additionalData, mode, activation);
                if (triggerResponse !== undefined) {
                    this.workflowData[id].triggerResponses.push(triggerResponse);
                }
            }
            catch (error) {
                throw new n8n_workflow_1.WorkflowActivationError(`There was a problem activating the workflow: "${error.message}"`, { cause: error, node: triggerNode });
            }
        }
        const pollNodes = workflow.getPollNodes();
        if (pollNodes.length) {
            this.workflowData[id].pollResponses = [];
            for (const pollNode of pollNodes) {
                try {
                    this.workflowData[id].pollResponses.push(await this.activatePolling(pollNode, workflow, additionalData, getPollFunctions, mode, activation));
                }
                catch (error) {
                    throw new n8n_workflow_1.WorkflowActivationError(`There was a problem activating the workflow: "${error.message}"`, { cause: error, node: pollNode });
                }
            }
        }
    }
    async activatePolling(node, workflow, additionalData, getPollFunctions, mode, activation) {
        const pollFunctions = getPollFunctions(workflow, node, additionalData, mode, activation);
        const pollTimes = pollFunctions.getNodeParameter('pollTimes');
        const cronTimes = (pollTimes.item || []).map(n8n_workflow_1.toCronExpression);
        const executeTrigger = async (testingTrigger = false) => {
            n8n_workflow_1.LoggerProxy.debug(`Polling trigger initiated for workflow "${workflow.name}"`, {
                workflowName: workflow.name,
                workflowId: workflow.id,
            });
            try {
                const pollResponse = await workflow.runPoll(node, pollFunctions);
                if (pollResponse !== null) {
                    pollFunctions.__emit(pollResponse);
                }
            }
            catch (error) {
                if (testingTrigger) {
                    throw error;
                }
                pollFunctions.__emitError(error);
            }
        };
        await executeTrigger(true);
        const timezone = pollFunctions.getTimezone();
        const cronJobs = [];
        for (const cronTime of cronTimes) {
            const cronTimeParts = cronTime.split(' ');
            if (cronTimeParts.length > 0 && cronTimeParts[0].includes('*')) {
                throw new Error('The polling interval is too short. It has to be at least a minute!');
            }
            cronJobs.push(new cron_1.CronJob(cronTime, executeTrigger, undefined, true, timezone));
        }
        async function closeFunction() {
            for (const cronJob of cronJobs) {
                cronJob.stop();
            }
        }
        return {
            closeFunction,
        };
    }
    async remove(id) {
        if (!this.isActive(id)) {
            throw new Error(`The workflow with the id "${id}" is currently not active and can so not be removed`);
        }
        const workflowData = this.workflowData[id];
        if (workflowData.triggerResponses) {
            for (const triggerResponse of workflowData.triggerResponses) {
                if (triggerResponse.closeFunction) {
                    try {
                        await triggerResponse.closeFunction();
                    }
                    catch (error) {
                        n8n_workflow_1.LoggerProxy.error(`There was a problem deactivating trigger of workflow "${id}": "${error.message}"`, {
                            workflowId: id,
                        });
                    }
                }
            }
        }
        if (workflowData.pollResponses) {
            for (const pollResponse of workflowData.pollResponses) {
                if (pollResponse.closeFunction) {
                    try {
                        await pollResponse.closeFunction();
                    }
                    catch (error) {
                        n8n_workflow_1.LoggerProxy.error(`There was a problem deactivating polling trigger of workflow "${id}": "${error.message}"`, {
                            workflowId: id,
                        });
                    }
                }
            }
        }
        delete this.workflowData[id];
    }
}
exports.ActiveWorkflows = ActiveWorkflows;
//# sourceMappingURL=ActiveWorkflows.js.map