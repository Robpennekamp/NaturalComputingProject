{"version":3,"file":"lossless-json.js","sources":["../lib/config.js","../lib/LosslessNumber.js","../lib/revive.js","../lib/pointer.js","../lib/parse.js","../lib/stringify.js"],"sourcesContent":["\nlet circularRefs = true;\n\n/**\n * Get and/or set configuration options\n * @param {{circularRefs: boolean}} [options]\n * @retrun {{circularRefs: boolean}}\n */\nexport function config (options) {\n  if (options) {\n    if (options.circularRefs !== undefined && options.circularRefs !== null) {\n      circularRefs = (options.circularRefs === true);\n    }\n  }\n\n  return { circularRefs }\n}\n","'use strict';\n\n/**\n * A lossless number. Stores it's value as string\n * @param {string | number} value\n * @constructor\n */\nexport class LosslessNumber {\n  constructor (value) {\n    // value as string\n    this.value = valueToString(value);\n\n    // type information\n    this.type = 'LosslessNumber';\n    this.isLosslessNumber = true;\n  }\n\n  /**\n   * Get the value of the LosslessNumber as number.\n   * Will throw an error when this conversion would result in a truncation\n   * of the number.\n   * @return {Number}\n   */\n  valueOf () {\n    let number = parseFloat(this.value);\n    let digits = getDigits(this.value);\n\n    // throw an error when the numeric value will lose information\n    if (digits.length > 15) {\n      throw new Error('Cannot convert to number: ' +\n          'number would be truncated (value: ' + this.value + ')');\n    }\n    if (!isFinite(number)) {\n      throw new Error('Cannot convert to number: number would overflow (value: ' + this.value + ')');\n    }\n    if (Math.abs(number) < Number.MIN_VALUE && !containsOnlyZeros(digits)) {\n      throw new Error('Cannot convert to number: number would underflow (value: ' + this.value + ')');\n    }\n\n    return number;\n  }\n\n  /**\n   * Get the value of the LosslessNumber as string.\n   * @return {string}\n   */\n  toString() {\n    return this.value;\n  }\n\n}\n\n/**\n * Convert input value to a string\n * If value is no number or string, the valueOf() of the object will be used.\n * @param {number | string} value\n * @return {string}\n */\nexport function valueToString (value) {\n  if (typeof value === 'string') {\n    if (!isValidNumber(value)) {\n      throw new Error('Invalid number (value: \"' + value +'\")');\n    }\n\n    return value;\n  }\n  else if (typeof value === 'number') {\n    // validate number\n    if (getDigits(value + '').length > 15) {\n      throw new Error('Invalid number: contains more than 15 digits (value: ' + value + ')');\n    }\n    if (isNaN(value)) {\n      throw new Error('Invalid number: NaN');\n    }\n    if (!isFinite(value)) {\n      throw new Error('Invalid number: Infinity');\n    }\n\n    return value + '';\n  }\n  else {\n    return valueToString(value && value.valueOf());\n  }\n}\n\n/**\n * Parse a string into a number. When the value can be represented in a number,\n * the function returns a number. Else, the function returns a LosslessNumber\n * @param {string} value\n * @returns {LosslessNumber | number} Returns a number when the value fits\n *                                    in a regular number, else returns a\n *                                    LosslessNumber.\n */\nexport function createNumber (value) {\n  let digits = getDigits(value);\n\n  if (digits.length > 15) {\n    // would truncate digits\n    return new LosslessNumber(value);\n  }\n\n  let number = parseFloat(value);\n  if (!isFinite(number)) {\n    // overflow, finite or NaN\n    return new LosslessNumber(value);\n  }\n  else if (Math.abs(number) < Number.MIN_VALUE && !containsOnlyZeros(digits)) {\n    // underflow\n    return new LosslessNumber(value);\n  }\n  else {\n    return number;\n  }\n}\n\n/**\n * Count the number of significant digits of a number.\n *\n * For example:\n *   '2.34' returns '234'\n *   '-77' returns '77'\n *   '0.0034' returns '34'\n *   '120.5e+30' returns '1205'\n *\n * @param {number | string} value\n * @return {string} Returns the significant digits\n */\nexport function getDigits (value) {\n  let _value = (typeof value !== 'string') ? (value + '') : value;\n\n  return _value\n      .replace(/^-/, '')            // remove sign\n      .replace(/e.*$/, '')          // remove exponential notation\n      .replace( /^0\\.?0*|\\./, '');  // remove decimal point and leading zeros\n}\n\n/**\n * Test whether a string contains only zeros or is empty\n * @param {string} text\n * @return {boolean}\n */\nexport function containsOnlyZeros (text) {\n  return /^0*$/.test(text);\n}\n\n/**\n * Test whether a string contains a valid number\n * http://stackoverflow.com/questions/13340717/json-numbers-regular-expression\n * @param {string} value\n * @return {boolean}\n */\nexport function isValidNumber(value) {\n  return /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?$/.test(value);\n}\n","/**\n * Revive a json object.\n * Applies the reviver function recursively on all values in the JSON object.\n * @param {*} json   A JSON Object, Array, or value\n * @param {function (key: string, value: *)} reviver\n *              A reviver function invoked with arguments `key` and `value`,\n *              which must return a replacement value. The function context\n *              (`this`) is the Object or Array that contains the currently\n *              handled value.\n * @return {*}\n */\nexport function revive (json, reviver) {\n  return reviveValue({'': json}, '', json, reviver);\n}\n\n/**\n * Revive a value\n * @param {Object | Array} context\n * @param {string} key\n * @param {*} value\n * @param {function(key: string, value: *)} reviver\n * @return {*}\n */\nfunction reviveValue (context, key, value, reviver) {\n  if (Array.isArray(value)) {\n    return reviver.call(context, key, reviveArray(value, reviver));\n  }\n  else if (value && typeof value === 'object' && !value.isLosslessNumber) {\n    // note the special case for LosslessNumber,\n    // we don't want to iterate over the internals of a LosslessNumber\n    return reviver.call(context, key, reviveObject(value, reviver))\n  }\n  else {\n    return reviver.call(context, key, value)\n  }\n}\n\n/**\n * Revive the properties of an object\n * @param {Object} object\n * @param {function} reviver\n * @return {Object}\n */\nfunction reviveObject (object, reviver) {\n  let revived = {};\n\n  for (let key in object) {\n    if (object.hasOwnProperty(key)) {\n      revived[key] = reviveValue(object, key, object[key], reviver);\n    }\n  }\n\n  return revived;\n}\n\n/**\n * Revive the properties of an Array\n * @param {Array} array\n * @param {function} reviver\n * @return {Array}\n */\nfunction reviveArray (array, reviver) {\n  let revived = [];\n\n  for (let i = 0; i < array.length; i++) {\n    revived[i] = reviveValue(array, i + '', array[i], reviver);\n  }\n\n  return revived;\n}\n","// JavaScript Object Notation (JSON) Pointer\n// https://tools.ietf.org/html/rfc6901\n\n/**\n * Escape a JSON Pointer\n *\n * @param {string} str\n * @returns {string}\n */\nexport function escape (str) {\n  return encodeURIComponent(str\n      .replace(/\\//g, '~1')\n      .replace(/~/g, '~0'));\n}\n\n/**\n * Unescape a JSON Pointer\n *\n * @param {string} str\n * @returns {string}\n */\nexport function unescape (str) {\n  return decodeURIComponent(str)\n      .replace(/~1/g, '/')\n      .replace(/~0/g, '~');\n}\n\n/**\n * Stringify an array of keys as a JSON Pointer URI fragment\n *\n * Example:\n *\n *     stringify(['foo', 'bar'])     // returns '#/foo/bar'\n *     stringify(['foo bar', 'baz']) // returns '#/foo%20bar/baz'\n *\n * @param {Array.<string>} array\n * @returns {string}\n */\nexport function stringify(array) {\n  return '#/' + array.map(escape).join('/');\n}\n\n/**\n * Parse a JSON Pointer URI fragment\n * @param {string} pointer\n * @return {Array.<string>}\n */\nexport function parse(pointer) {\n  let array = pointer.split('/').map(unescape);\n\n  // remove the hash\n  let hash = array.shift();\n  if (hash !== '#') {\n    throw SyntaxError('Cannot parse JSON Pointer: no valid URI fragment');\n  }\n\n  // remove last empty entry\n  if (array[array.length - 1] === '') {\n    array.pop();\n  }\n\n  return array;\n}\n","'use strict';\n\nimport { config } from './config';\nimport { LosslessNumber } from './LosslessNumber';\nimport { revive } from './revive';\nimport { parse as parsePointer } from './pointer';\n\n// token types enumeration\nconst TOKENTYPE = {\n  NULL: 0,\n  DELIMITER: 1,\n  NUMBER: 2,\n  STRING: 3,\n  SYMBOL: 4,\n  UNKNOWN: 5\n};\n\n// map with all delimiters\nconst DELIMITERS = {\n  '': true,\n  '{': true,\n  '}': true,\n  '[': true,\n  ']': true,\n  ':': true,\n  ',': true\n};\n\n// map with all escape characters\nconst ESCAPE_CHARACTERS = {\n  '\\\"': '\\\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  'b': '\\b',\n  'f': '\\f',\n  'n': '\\n',\n  'r': '\\r',\n  't': '\\t'\n  // \\u is handled by getToken()\n};\n\nlet jsonText = '';                // current json text\nlet index = 0;                    // current index in text\nlet c = '';                       // current token character in text\nlet token = '';                   // current token\nlet tokenType = TOKENTYPE.NULL;   // type of current token\n\n// Keep track of the stack to handle circular references\n// https://github.com/manuelstofer/json-pointer/blob/master/index.js\n// stack of currently stringified objects\nlet path = [];  // keys on the current stack\nlet stack = []; // objects (Object or Array) on the current stack\n\n/**\n * The LosslessJSON.parse() method parses a string as JSON, optionally transforming\n * the value produced by parsing.\n *\n * @param {string} text\n * The string to parse as JSON. See the JSON object for a description of JSON syntax.\n *\n * @param {function(key: string, value: *)} [reviver]\n * If a function, prescribes how the value originally produced by parsing is\n * transformed, before being returned.\n *\n * @returns Returns the Object corresponding to the given JSON text.\n *\n * @throws Throws a SyntaxError exception if the string to parse is not valid JSON.\n */\nexport function parse (text, reviver) {\n  // initialize\n  jsonText = text;\n  index = 0;\n  c = jsonText.charAt(0);\n  token = '';\n  tokenType = TOKENTYPE.NULL;\n\n  // clear stack\n  stack = [];\n  path = [];\n\n  // get first token\n  getToken();\n\n  // parse everything\n  let json = parseObject();\n\n  if (token !== '') {\n    throw createSyntaxError('Unexpected characters');\n  }\n\n  return reviver ? revive(json, reviver) : json;\n}\n\n/**\n * Get the next character from the expression.\n * The character is stored into the char c. If the end of the expression is\n * reached, the function puts an empty string in c.\n * @private\n */\nfunction next() {\n  index++;\n  c = jsonText.charAt(index);\n}\n\n/**\n * Get next token in the current text.\n * The token and token type are available as token and tokenType\n * @private\n */\nfunction getToken() {\n  tokenType = TOKENTYPE.NULL;\n  token = '';\n\n  // skip over whitespaces: space, tab, newline, and carriage return\n  while (c === ' ' || c === '\\t' || c === '\\n' || c === '\\r') {\n    next();\n  }\n\n  // check for delimiters\n  if (DELIMITERS[c]) {\n    tokenType = TOKENTYPE.DELIMITER;\n    token = c;\n    next();\n    return;\n  }\n\n  // check for a number\n  if (isDigit(c) || c === '-') {\n    tokenType = TOKENTYPE.NUMBER;\n\n    if (c === '-') {\n      token += c;\n      next();\n\n      if (!isDigit(c)) {\n        throw createSyntaxError('Invalid number, digit expected', index);\n      }\n    }\n    else if (c === '0') {\n      token += c;\n      next();\n    }\n    else {\n      // digit 1-9, nothing extra to do\n    }\n\n    while (isDigit(c)) {\n      token += c;\n      next();\n    }\n\n    if (c === '.') {\n      token += c;\n      next();\n\n      if (!isDigit(c)) {\n        throw createSyntaxError('Invalid number, digit expected', index);\n      }\n\n      while (isDigit(c)) {\n        token += c;\n        next();\n      }\n    }\n\n    if (c === 'e' || c === 'E') {\n      token += c;\n      next();\n\n      if (c === '+' || c === '-') {\n        token += c;\n        next();\n      }\n\n      if (!isDigit(c)) {\n        throw createSyntaxError('Invalid number, digit expected', index);\n      }\n\n      while (isDigit(c)) {\n        token += c;\n        next();\n      }\n    }\n\n    return;\n  }\n\n  // check for a string\n  if (c === '\"') {\n    tokenType = TOKENTYPE.STRING;\n    next();\n\n    while (c !== '' && c !== '\"') {\n\n      if (c === '\\\\') {\n        // handle escape characters\n        next();\n\n        let unescaped = ESCAPE_CHARACTERS[c];\n        if (unescaped !== undefined) {\n          token += unescaped;\n          next();\n        }\n        else if (c === 'u') {\n          // parse escaped unicode character, like '\\\\u260E'\n          next();\n\n          let hex = '';\n          for (let u = 0; u < 4; u++) {\n            if (!isHex(c)) {\n              throw createSyntaxError('Invalid unicode character');\n            }\n            hex += c;\n            next();\n          }\n\n          token += String.fromCharCode(parseInt(hex, 16));\n        }\n        else {\n          throw createSyntaxError('Invalid escape character \"\\\\' + c + '\"', index);\n        }\n      }\n      else {\n        // a regular character\n        token += c;\n        next();\n      }\n    }\n\n    if (c !== '\"') {\n      throw createSyntaxError('End of string expected');\n    }\n    next();\n\n    return;\n  }\n\n  // check for symbols (true, false, null)\n  if (isAlpha(c)) {\n    tokenType = TOKENTYPE.SYMBOL;\n\n    while (isAlpha(c)) {\n      token += c;\n      next();\n    }\n\n    return;\n  }\n\n  // something unknown is found, wrong characters -> a syntax error\n  tokenType = TOKENTYPE.UNKNOWN;\n  while (c !== '') {\n    token += c;\n    next();\n  }\n  throw createSyntaxError('Syntax error in part \"' + token + '\"');\n}\n\n/**\n * Check if the given character contains an alpha character, a-z, A-Z, _\n * @param {string} c   a string with one character\n * @return {boolean}\n */\nfunction isAlpha (c) {\n  return /^[a-zA-Z_]/.test(c);\n}\n\n/**\n * Check if the given character contains a hexadecimal character 0-9, a-f, A-F\n * @param {string} c   a string with one character\n * @return {boolean}\n */\nfunction isHex (c) {\n  return /^[0-9a-fA-F]/.test(c);\n}\n\n/**\n * checks if the given char c is a digit\n * @param {string} c   a string with one character\n * @return {boolean}\n * @private\n */\nfunction isDigit (c) {\n  return (c >= '0' && c <= '9');\n}\n\n/**\n * Create an error\n * @param {string} message\n * @param {number} [c]  Optional index (character position) where the\n *                      error happened. If not provided, the start of\n *                      the current token is taken\n * @return {SyntaxError} instantiated error\n * @private\n */\nfunction createSyntaxError (message, c) {\n  if (c === undefined) {\n    c = index - token.length;\n  }\n  let error = new SyntaxError(message + ' (char ' + c + ')');\n  error['char'] = c;\n\n  return error;\n}\n\n/**\n * Parse an object like '{\"key\": \"value\"}'\n * @return {*}\n */\nfunction parseObject () {\n  if (tokenType === TOKENTYPE.DELIMITER && token === '{') {\n    getToken();\n\n    let key;\n    let object = {};\n\n    if (tokenType === TOKENTYPE.DELIMITER && token === '}') {\n      // empty object\n      getToken();\n      return object;\n    }\n\n    // add this object to the stack\n    const stackIndex = stack.length;\n    stack[stackIndex] = object;\n\n    while (true) {\n      // parse key\n      if (tokenType !== TOKENTYPE.STRING) {\n        throw createSyntaxError('Object key expected');\n      }\n      key = token;\n      getToken();\n\n      // parse key/value separator\n      if (tokenType !== TOKENTYPE.DELIMITER || token !== ':') {\n        throw createSyntaxError('Colon expected');\n      }\n      getToken();\n\n      // parse value\n      path[stackIndex] = key;\n      object[key] = parseObject();\n\n      // parse key/value pair separator\n      if (tokenType !== TOKENTYPE.DELIMITER || token !== ',') {\n        break;\n      }\n      getToken();\n    }\n\n    if (tokenType !== TOKENTYPE.DELIMITER || token !== '}') {\n      throw createSyntaxError('Comma or end of object \"}\" expected');\n    }\n    getToken();\n\n    // check whether this is a circular reference\n    if (isCircular(object)) {\n      return parseCircular(object);\n    }\n\n    // remove current entry from the stack\n    stack.length = stackIndex;\n    path.length = stackIndex;\n\n    return object;\n  }\n\n  return parseArray();\n}\n\n/**\n * Parse an object like '[\"item1\", \"item2\", ...]'\n * @return {*}\n */\nfunction parseArray () {\n  if (tokenType === TOKENTYPE.DELIMITER && token === '[') {\n    getToken();\n\n    let array = [];\n\n    if (tokenType === TOKENTYPE.DELIMITER && token === ']') {\n      // empty array\n      getToken();\n      return array;\n    }\n\n    // add this array to the stack\n    const stackIndex = stack.length;\n    stack[stackIndex] = array;\n\n    while (true) {\n      // parse item\n      path[stackIndex] = array.length + '';\n      array.push(parseObject());\n\n      // parse item separator\n      if (tokenType !== TOKENTYPE.DELIMITER || token !== ',') {\n        break;\n      }\n      getToken();\n    }\n\n    if (tokenType !== TOKENTYPE.DELIMITER || token !== ']') {\n      throw createSyntaxError('Comma or end of array \"]\" expected');\n    }\n    getToken();\n\n    // remove current entry from the stack\n    stack.length = stackIndex;\n    path.length = stackIndex;\n\n    return array;\n  }\n\n  return parseString();\n}\n\n/**\n * Parse a string enclosed by double quotes \"...\". Can contain escaped quotes\n * @return {*}\n */\nfunction parseString () {\n  if (tokenType === TOKENTYPE.STRING) {\n    let str = token;\n    getToken();\n    return str;\n  }\n\n  return parseNumber();\n}\n\n/**\n * Parse a number. The number will be parsed as a LosslessNumber.\n * @return {*}\n */\nfunction parseNumber () {\n  if (tokenType === TOKENTYPE.NUMBER) {\n    let number = new LosslessNumber(token);\n    getToken();\n    return number;\n  }\n\n  return parseSymbol();\n}\n\n/**\n * Parse constants true, false, null\n * @return {boolean | null}\n */\nfunction parseSymbol () {\n  if (tokenType === TOKENTYPE.SYMBOL) {\n    if (token === 'true') {\n      getToken();\n      return true;\n    }\n    if (token === 'false') {\n      getToken();\n      return false;\n    }\n    if (token === 'null') {\n      getToken();\n      return null;\n    }\n\n    throw createSyntaxError('Unknown symbol \"' + token + '\"');\n  }\n\n  return parseEnd();\n}\n\n/**\n * Evaluated when the expression is not yet ended but expected to end\n */\nfunction parseEnd () {\n  if (token === '') {\n    // syntax error or unexpected end of expression\n    throw createSyntaxError('Unexpected end of json string');\n  } else {\n    throw createSyntaxError('Value expected');\n  }\n}\n\n/**\n * Test whether an object is a circular reference, like {$ref: '#/foo/bar'}\n * @param {Object} object\n * @return {boolean}\n */\nfunction isCircular (object) {\n  return typeof object.$ref === 'string' && Object.keys(object).length === 1;\n}\n\n/**\n * Resolve a circular reference.\n * Throws an error if the path cannot be resolved\n * @param {Object} object    An object with a JSON Pointer URI fragment\n *                           like {$ref: '#/foo/bar'}\n * @return {Object | Array}\n */\nfunction parseCircular(object) {\n  // if circular references are disabled, just return the refs object\n  if (!config().circularRefs) {\n    return object;\n  }\n\n  let pointerPath = parsePointer(object.$ref);\n\n  // validate whether the path corresponds with current stack\n  for (let i = 0; i < pointerPath.length; i++) {\n    if (pointerPath[i] !== path[i]) {\n      throw new Error('Invalid circular reference \"' +  object.$ref + '\"');\n    }\n  }\n\n  return stack[pointerPath.length];\n}\n","'use strict';\n\nimport { config } from './config'\nimport { stringify as stringifyPointer } from './pointer';\n\n// Keep track of the stack to handle circular references\n// https://github.com/manuelstofer/json-pointer/blob/master/index.js\n// stack of currently stringified objects\nlet path = [];  // keys on the current stack\nlet stack = []; // objects (Object or Array) on the current stack\n\n/**\n * The LosslessJSON.stringify() method converts a JavaScript value to a JSON string,\n * optionally replacing values if a replacer function is specified, or\n * optionally including only the specified properties if a replacer array is specified.\n *\n * @param {*} value\n * The value to convert to a JSON string.\n *\n * @param {function(key: string, value: *) | Array.<string | number>} [replacer]\n * A function that alters the behavior of the stringification process,\n * or an array of String and Number objects that serve as a whitelist for\n * selecting the properties of the value object to be included in the JSON string.\n * If this value is null or not provided, all properties of the object are\n * included in the resulting JSON string.\n *\n * @param {number | string} [space]\n * A String or Number object that's used to insert white space into the output\n * JSON string for readability purposes. If this is a Number, it indicates the\n * number of space characters to use as white space; this number is capped at 10\n * if it's larger than that. Values less than 1 indicate that no space should be\n * used. If this is a String, the string (or the first 10 characters of the string,\n * if it's longer than that) is used as white space. If this parameter is not\n * provided (or is null), no white space is used.\n *\n * @returns {string | undefined} Returns the string representation of the JSON object.\n */\nexport function stringify(value, replacer, space) {\n  // clear stack\n  stack = [];\n  path = [];\n\n  let _value = (typeof replacer === 'function')\n      ? replacer.call({'': value}, '', value)\n      : value;\n\n  let _space; // undefined by default\n  if (typeof space === 'number') {\n    if (space > 10) {\n      _space = repeat(' ', 10);\n    }\n    else if (space >= 1) {\n      _space = repeat(' ', space);\n    }\n    // else ignore\n  }\n  else if (typeof space === 'string' && space !== '') {\n    _space = space;\n  }\n\n  return stringifyValue(_value, replacer, _space, '');\n}\n\n/**\n * Stringify a value\n * @param {*} value\n * @param {function | Array.<string | number>} [replacer]\n * @param {string} [space]\n * @param {string} [indent]\n * @return {string | undefined}\n */\nfunction stringifyValue(value, replacer, space, indent) {\n  // boolean, null, number, string, or date\n  if (typeof value === 'boolean' || value instanceof Boolean ||\n      value === null ||\n      typeof value === 'number' || value instanceof Number ||\n      typeof value === 'string' || value instanceof String ||\n      value instanceof Date) {\n    return JSON.stringify(value);\n  }\n\n  // lossless number, the secret ingredient :)\n  if (value && value.isLosslessNumber) {\n    return value.value;\n  }\n\n  // array\n  if (Array.isArray(value)) {\n    return stringifyArray(value, replacer, space, indent);\n  }\n\n  // object (test lastly!)\n  if (value && typeof value === 'object') {\n    return stringifyObject(value, replacer, space, indent);\n  }\n\n  return undefined;\n}\n\n/**\n * Stringify an array\n * @param {Array} array\n * @param {function | Array.<string | number>} [replacer]\n * @param {string} [space]\n * @param {string} [indent]\n * @return {string}\n */\nfunction stringifyArray(array, replacer, space, indent) {\n  let childIndent = space ? (indent + space) : undefined;\n  let str = space ? '[\\n' : '[';\n\n  // check for circular reference\n  if (isCircular(array)) {\n    return stringifyCircular(array, replacer, space, indent);\n  }\n\n  // add this array to the stack\n  const stackIndex = stack.length;\n  stack[stackIndex] = array;\n\n  for (let i = 0; i < array.length; i++) {\n    let key = i + '';\n    let item = (typeof replacer === 'function')\n        ? replacer.call(array, key, array[i])\n        : array[i];\n\n    if (space) {\n      str += childIndent;\n    }\n\n    if (typeof item !== 'undefined' && typeof item !== 'function') {\n      path[stackIndex] = key;\n      str += stringifyValue(item, replacer, space, childIndent);\n    }\n    else {\n      str += 'null'\n    }\n\n    if (i < array.length - 1) {\n      str += space ? ',\\n' : ',';\n    }\n  }\n\n  // remove current entry from the stack\n  stack.length = stackIndex;\n  path.length = stackIndex;\n\n  str += space ? ('\\n' + indent + ']') : ']';\n  return str;\n}\n\n/**\n * Stringify an object\n * @param {Object} object\n * @param {function | Array.<string | number>} [replacer]\n * @param {string} [space]\n * @param {string} [indent]\n * @return {string}\n */\nfunction stringifyObject(object, replacer, space, indent) {\n  let childIndent = space ? (indent + space) : undefined;\n  let first = true;\n  let str = space ? '{\\n' : '{';\n\n  if (typeof object.toJSON === 'function') {\n    return stringify(object.toJSON(), replacer, space);\n  }\n\n  // check for circular reference\n  if (isCircular(object)) {\n    return stringifyCircular(object, replacer, space, indent);\n  }\n\n  // add this object to the stack\n  const stackIndex = stack.length;\n  stack[stackIndex] = object;\n\n  for (let key in object) {\n    if (object.hasOwnProperty(key)) {\n      let value = (typeof replacer === 'function')\n          ? replacer.call(object, key, object[key])\n          : object[key];\n\n      if (includeProperty(key, value, replacer)) {\n        if (first) {\n          first = false;\n        }\n        else {\n          str += space ? ',\\n' : ',';\n        }\n\n        const keyStr = JSON.stringify(key);\n\n        str += space\n            ? (childIndent + keyStr + ': ')\n            : keyStr + ':';\n\n        path[stackIndex] = key;\n        str += stringifyValue(value, replacer, space, childIndent);\n      }\n    }\n  }\n\n  // remove current entry from the stack\n  stack.length = stackIndex;\n  path.length = stackIndex;\n\n  str += space ? ('\\n' + indent + '}') : '}';\n  return str;\n}\n\n/**\n * Test whether an object or array is a circular reference\n * @param {Object | Array} value\n * @return {boolean}\n */\nfunction isCircular(value) {\n  return stack.indexOf(value) !== -1;\n}\n\n/**\n * Stringify a circular reference\n * @param {Object | Array} value\n * @param {function | Array.<string | number>} [replacer]\n * @param {string} [space]\n * @param {string} [indent]\n * @return {string}\n */\nfunction stringifyCircular (value, replacer, space, indent) {\n  if (!config().circularRefs) {\n    throw new Error('Circular reference at \"' + stringifyPointer(path) + '\"');\n  }\n\n  let pathIndex = stack.indexOf(value);\n\n  let circular = {\n    $ref: stringifyPointer(path.slice(0, pathIndex))\n  };\n\n  return stringifyObject(circular, replacer, space, indent);\n}\n\n/**\n * Test whether to include a property in a stringified object or not.\n * @param {string} key\n * @param {*} value\n * @param {function(key: string, value: *) | Array<string | number>} [replacer]\n * @return {boolean}\n */\nfunction includeProperty (key, value, replacer) {\n  return typeof value !== 'undefined'\n      && typeof value !== 'function'\n      && (!Array.isArray(replacer) || contains(replacer, key));\n}\n\n/**\n * Check whether an array contains some value.\n * Uses a non-strict comparison, so contains([1,2,3], '2') returns true\n * @param {Array} array\n * @param {*} value\n * @return {boolean}\n */\nfunction contains(array, value) {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] == value) { // non-strict equality check!\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Repeat a string a number of times.\n * Simple linear solution, we only need up to 10 iterations in practice\n * @param {string} text\n * @param {number} times\n * @return {string}\n */\nfunction repeat (text, times) {\n  let res = '';\n  while (times-- > 0) {\n    res += text;\n  }\n  return res;\n}\n"],"names":["circularRefs","config","options","undefined","LosslessNumber","value","valueToString","isValidNumber","Error","valueOf","getDigits","length","isNaN","isFinite","type","isLosslessNumber","number","parseFloat","this","digits","Math","abs","Number","MIN_VALUE","test","replace","reviveValue","context","key","reviver","Array","isArray","call","array","revived","i","reviveArray","_typeof","object","hasOwnProperty","reviveObject","escape","str","encodeURIComponent","unescape","decodeURIComponent","stringify","map","join","TOKENTYPE","NULL","DELIMITER","NUMBER","STRING","SYMBOL","UNKNOWN","DELIMITERS","ESCAPE_CHARACTERS","jsonText","index","c","token","tokenType","path","stack","next","charAt","getToken","isDigit","createSyntaxError","isAlpha","unescaped","hex","u","String","fromCharCode","parseInt","message","error","SyntaxError","parseObject","parseEnd","parseSymbol","parseNumber","parseString","stackIndex","push","parseArray","$ref","Object","keys","pointerPath","pointer","split","shift","pop","parsePointer","parseCircular","replacer","space","_space","_value","repeat","stringifyValue","indent","Boolean","Date","JSON","childIndent","isCircular","stringifyCircular","item","stringifyArray","stringifyObject","first","toJSON","contains","keyStr","indexOf","stringifyPointer","pathIndex","slice","text","times","res","json"],"mappings":"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"}