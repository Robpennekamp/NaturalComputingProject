var A={name:"teleport",props:{to:{type:String,required:!0},where:{type:String,default:"after"},disabled:Boolean},data:function(){return{nodes:[],waiting:!1,observer:null,parent:null}},watch:{to:"maybeMove",where:"maybeMove",disabled:function(n){n?(this.disable(),this.teardownObserver()):(this.bootObserver(),this.move())}},mounted:function(){this.nodes=Array.from(this.$el.childNodes),this.disabled||this.bootObserver(),this.maybeMove()},beforeDestroy:function(){this.disable(),this.teardownObserver()},computed:{classes:function(){return this.disabled?["teleporter"]:["teleporter","hidden"]}},methods:{maybeMove:function(){this.disabled||this.move()},move:function(){if(this.waiting=!1,this.parent=document.querySelector(this.to),!this.parent){this.disable(),this.waiting=!0;return}this.where==="before"?this.parent.prepend(this.getFragment()):this.parent.appendChild(this.getFragment())},disable:function(){this.$el.appendChild(this.getFragment()),this.parent=null},getFragment:function(){var n=document.createDocumentFragment();return this.nodes.forEach(function(i){return n.appendChild(i)}),n},onMutations:function(n){for(var i=this,t=!1,o=0;o<n.length;o++){var d=n[o],l=Array.from(d.addedNodes).filter(function(a){return!i.nodes.includes(a)});Array.from(d.removedNodes).includes(this.parent)?(this.disable(),this.waiting=!this.disabled):this.waiting&&l.length>0&&(t=!0)}t&&this.move()},bootObserver:function(){var n=this;this.observer||(this.observer=new MutationObserver(function(i){return n.onMutations(i)}),this.observer.observe(document.body,{childList:!0,subtree:!0,attributes:!1,characterData:!1}))},teardownObserver:function(){this.observer&&(this.observer.disconnect(),this.observer=null)}}};function C(e,n,i,t,o,d,l,a,m,g){typeof l!="boolean"&&(m=a,a=l,l=!1);var s=typeof i=="function"?i.options:i;e&&e.render&&(s.render=e.render,s.staticRenderFns=e.staticRenderFns,s._compiled=!0,o&&(s.functional=!0)),t&&(s._scopeId=t);var u;if(d?(u=function(r){r=r||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,!r&&typeof __VUE_SSR_CONTEXT__<"u"&&(r=__VUE_SSR_CONTEXT__),n&&n.call(this,m(r)),r&&r._registeredComponents&&r._registeredComponents.add(d)},s._ssrRegister=u):n&&(u=l?function(r){n.call(this,g(r,this.$root.$options.shadowRoot))}:function(r){n.call(this,a(r))}),u)if(s.functional){var y=s.render;s.render=function(w,c){return u.call(c),y(w,c)}}else{var p=s.beforeCreate;s.beforeCreate=p?[].concat(p,u):[u]}return i}var M=typeof navigator<"u"&&/msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());function O(e){return function(n,i){return S(n,i)}}var f,b={};function S(e,n){var i=M?n.media||"default":e,t=b[i]||(b[i]={ids:new Set,styles:[]});if(!t.ids.has(e)){t.ids.add(e);var o=n.source;if(n.map&&(o+=`
/*# sourceURL=`+n.map.sources[0]+" */",o+=`
/*# sourceMappingURL=data:application/json;base64,`+btoa(unescape(encodeURIComponent(JSON.stringify(n.map))))+" */"),t.element||(t.element=document.createElement("style"),t.element.type="text/css",n.media&&t.element.setAttribute("media",n.media),f===void 0&&(f=document.head||document.getElementsByTagName("head")[0]),f.appendChild(t.element)),"styleSheet"in t.element)t.styles.push(o),t.element.styleSheet.cssText=t.styles.filter(Boolean).join(`
`);else{var d=t.ids.size-1,l=document.createTextNode(o),a=t.element.childNodes;a[d]&&t.element.removeChild(a[d]),a.length?t.element.insertBefore(l,a[d]):t.element.appendChild(l)}}}var F=A,_=function(){var e=this,n=e.$createElement,i=e._self._c||n;return i("div",{class:e.classes},[e._t("default")],2)},T=[];_._withStripped=!0;var $=function(e){e&&e("data-v-d4e6e290_0",{source:`.hidden[data-v-d4e6e290] {
  visibility: hidden;
  display: none;
}

/*# sourceMappingURL=Teleport.vue.map */`,map:{version:3,sources:["/Users/shodan/Projects/vue2-teleport/src/Teleport.vue","Teleport.vue"],names:[],mappings:"AAuJA;EACA,kBAAA;EACA,aAAA;ACtJA;;AAEA,uCAAuC",file:"Teleport.vue",sourcesContent:[`<template>
  <div :class="classes">
    <slot/>
  </div>
</template>

<script>
export default {
  name: 'teleport',
  props: {
    to: {
      type: String,
      required: true,
    },
    where: {
      type: String,
      default: 'after',
    },
    disabled: Boolean,
  },
  data() {
    return {
      nodes: [],
      waiting: false,
      observer: null,
      parent: null,
    };
  },
  watch: {
    to: 'maybeMove',
    where: 'maybeMove',
    disabled(value) {
      if (value) {
        this.disable();
        this.teardownObserver();
      } else {
        this.bootObserver();
        this.move();
      }
    },
  },
  mounted() {
    // Store a reference to the nodes
    this.nodes = Array.from(this.$el.childNodes);

    if (!this.disabled) {
      this.bootObserver();
    }

    // Move slot content to target
    this.maybeMove();
  },
  beforeDestroy() {
    // Move back
    this.disable();

    // Stop observing
    this.teardownObserver();
  },
  computed: {
    classes() {
      if (this.disabled) {
        return ['teleporter'];
      }

      return ['teleporter', 'hidden'];
    },
  },
  methods: {
    maybeMove() {
      if (!this.disabled) {
        this.move();
      }
    },
    move() {
      this.waiting = false;

      this.parent = document.querySelector(this.to);

      if (!this.parent) {
        this.disable();

        this.waiting = true;

        return;
      }

      if (this.where === 'before') {
        this.parent.prepend(this.getFragment());
      } else {
        this.parent.appendChild(this.getFragment());
      }
    },
    disable() {
      this.$el.appendChild(this.getFragment());
      this.parent = null;
    },
    // Using a fragment is faster because it'll trigger only a single reflow
    // See https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment
    getFragment() {
      const fragment = document.createDocumentFragment();

      this.nodes.forEach(node => fragment.appendChild(node));

      return fragment;
    },
    onMutations(mutations) {
      // Makes sure the move operation is only done once
      let shouldMove = false;

      for (let i = 0; i < mutations.length; i++) {
        const mutation = mutations[i];
        const filteredAddedNodes = Array.from(mutation.addedNodes).filter(node => !this.nodes.includes(node));

        if (Array.from(mutation.removedNodes).includes(this.parent)) {
          this.disable();
          this.waiting = !this.disabled;
        } else if (this.waiting && filteredAddedNodes.length > 0) {
          shouldMove = true;
        }
      }

      if (shouldMove) {
        this.move();
      }
    },
    bootObserver() {
      if (this.observer) {
        return;
      }

      this.observer = new MutationObserver(mutations => this.onMutations(mutations));

      this.observer.observe(document.body, {
        childList: true,
        subtree: true,
        attributes: false,
        characterData: false,
      });
    },
    teardownObserver() {
      if (this.observer) {
        this.observer.disconnect();
        this.observer = null;
      }
    },
  },
};
<\/script>

<style scoped lang="scss">
.hidden {
  visibility: hidden;
  display: none;
}
</style>
`,`.hidden {
  visibility: hidden;
  display: none;
}

/*# sourceMappingURL=Teleport.vue.map */`]},media:void 0})},E="data-v-d4e6e290",N=void 0,R=!1,U=C({render:_,staticRenderFns:T},$,F,E,R,N,!1,O,void 0,void 0);function v(e){v.installed||(v.installed=!0,e.component("Teleport",U))}var D={install:v},h=null;typeof window<"u"?h=window.Vue:typeof globalThis<"u"&&(h=globalThis.Vue);h&&h.use(D);export{U as _};
//# sourceMappingURL=vue2-teleport-53e66c3b.js.map
