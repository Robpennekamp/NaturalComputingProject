import { completeFromList } from '@codemirror/autocomplete';
import { LRParser } from '@lezer/lr';
import { foldNodeProp, foldInside, LRLanguage, LanguageSupport } from '@codemirror/language';
import { styleTags, tags } from '@lezer/highlight';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const parser = LRParser.deserialize({
  version: 14,
  states: "nQQOPOOOOOO'#Cc'#CcOOOO'#Ca'#CaQQOPOOOOOO-E6_-E6_",
  stateData: "]~OQPORPOSPO~O",
  goto: "cWPPPPPXP_QRORSRTQOR",
  nodeNames: "âš  Program Plaintext Resolvable BrokenResolvable",
  maxTerm: 7,
  skippedNodes: [0],
  repeatNodeCount: 1,
  tokenData: "&U~RRO#o[#o#p{#p~[~aRQ~O#o[#o#pj#p~[~mRO#o[#p~[~~v~{OQ~~!OSO#o[#o#p![#p~[~~v~!aUS~O#O![#O#P!s#P#q![#q#r%v#rG|![G|~%c~!xUS~O#O![#O#P!s#P#q![#q#r#[#rG|![G|~%c~#aRS~O#q#j#q#r$l#r~#j~#mTO#O#j#O#P#|#P#q#j#q#r%Q#rG|#j~$PTO#O#j#O#P#|#P#q#j#q#r$`#rG|#j~$cRO#q#j#q#r$l#r~#j~$qTR~O#O#j#O#P#|#P#q#j#q#r%Q#rG|#j~%TRO#q#j#q#r%^#r~#j~%cOR~~%hRS~O#q%c#q#r%q#r~%c~%vOS~~%{RS~O#q#j#q#r%^#r~#j",
  tokenizers: [0],
  topRules: {"Program":[0,1]},
  tokenPrec: 0
});

const parserWithMetaData = parser.configure({
    props: [
        foldNodeProp.add({
            Application: foldInside,
        }),
        styleTags({
            OpenMarker: tags.brace,
            CloseMarker: tags.brace,
            Plaintext: tags.content,
            Resolvable: tags.string,
            BrokenResolvable: tags.className,
        }),
    ],
});
const n8nLanguage = LRLanguage.define({
    parser: parserWithMetaData,
    languageData: {
        commentTokens: { line: ";" },
    },
});
const completions = n8nLanguage.data.of({
    autocomplete: completeFromList([
    // { label: "test", type: "keyword" }, // to add in future
    ]),
});
function n8nExpression() {
    return new LanguageSupport(n8nLanguage, [completions]);
}

export { n8nExpression, n8nLanguage, parserWithMetaData };
