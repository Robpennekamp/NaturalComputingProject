"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.flattenObject = exports.unflattenExecutionData = exports.flattenExecutionData = exports.send = exports.sendErrorResponse = exports.sendSuccessResponse = exports.jwtAuthAuthorizationError = exports.basicAuthAuthorizationError = exports.ServiceUnavailableError = exports.InternalServerError = exports.UnprocessableRequestError = exports.ConflictError = exports.NotFoundError = exports.UnauthorizedError = exports.AuthError = exports.BadRequestError = void 0;
const flatted_1 = require("flatted");
const picocolors_1 = __importDefault(require("picocolors"));
const n8n_workflow_1 = require("n8n-workflow");
const constants_1 = require("./constants");
class ResponseError extends Error {
    constructor(message, httpStatusCode, errorCode = httpStatusCode, hint = undefined) {
        super(message);
        this.httpStatusCode = httpStatusCode;
        this.errorCode = errorCode;
        this.hint = hint;
        this.name = 'ResponseError';
    }
}
class BadRequestError extends ResponseError {
    constructor(message, errorCode) {
        super(message, 400, errorCode);
    }
}
exports.BadRequestError = BadRequestError;
class AuthError extends ResponseError {
    constructor(message) {
        super(message, 401);
    }
}
exports.AuthError = AuthError;
class UnauthorizedError extends ResponseError {
    constructor(message, hint = undefined) {
        super(message, 403, 403, hint);
    }
}
exports.UnauthorizedError = UnauthorizedError;
class NotFoundError extends ResponseError {
    constructor(message, hint = undefined) {
        super(message, 404, 404, hint);
    }
}
exports.NotFoundError = NotFoundError;
class ConflictError extends ResponseError {
    constructor(message, hint = undefined) {
        super(message, 409, 409, hint);
    }
}
exports.ConflictError = ConflictError;
class UnprocessableRequestError extends ResponseError {
    constructor(message) {
        super(message, 422);
    }
}
exports.UnprocessableRequestError = UnprocessableRequestError;
class InternalServerError extends ResponseError {
    constructor(message, errorCode = 500) {
        super(message, 500, errorCode);
    }
}
exports.InternalServerError = InternalServerError;
class ServiceUnavailableError extends ResponseError {
    constructor(message, errorCode = 503) {
        super(message, 503, errorCode);
    }
}
exports.ServiceUnavailableError = ServiceUnavailableError;
function basicAuthAuthorizationError(resp, realm, message) {
    resp.statusCode = 401;
    resp.setHeader('WWW-Authenticate', `Basic realm="${realm}"`);
    resp.json({ code: resp.statusCode, message });
}
exports.basicAuthAuthorizationError = basicAuthAuthorizationError;
function jwtAuthAuthorizationError(resp, message) {
    resp.statusCode = 403;
    resp.json({ code: resp.statusCode, message });
}
exports.jwtAuthAuthorizationError = jwtAuthAuthorizationError;
function sendSuccessResponse(res, data, raw, responseCode, responseHeader) {
    if (responseCode !== undefined) {
        res.status(responseCode);
    }
    if (responseHeader) {
        res.header(responseHeader);
    }
    if (raw === true) {
        if (typeof data === 'string') {
            res.send(data);
        }
        else {
            res.json(data);
        }
    }
    else {
        res.json({
            data,
        });
    }
}
exports.sendSuccessResponse = sendSuccessResponse;
function sendErrorResponse(res, error) {
    var _a;
    let httpStatusCode = 500;
    const response = {
        code: 0,
        message: (_a = error.message) !== null && _a !== void 0 ? _a : 'Unknown error',
    };
    if (error instanceof ResponseError) {
        if (constants_1.inDevelopment) {
            console.error(picocolors_1.default.red(error.httpStatusCode), error.message);
        }
        httpStatusCode = error.httpStatusCode;
        if (error.errorCode) {
            response.code = error.errorCode;
        }
        if (error.hint) {
            response.hint = error.hint;
        }
    }
    if (error instanceof n8n_workflow_1.NodeApiError) {
        if (constants_1.inDevelopment) {
            console.error(picocolors_1.default.red(error.name), error.message);
        }
        Object.assign(response, error);
    }
    if (error.stack && constants_1.inDevelopment) {
        response.stacktrace = error.stack;
    }
    res.status(httpStatusCode).json(response);
}
exports.sendErrorResponse = sendErrorResponse;
const isUniqueConstraintError = (error) => ['unique', 'duplicate'].some((s) => error.message.toLowerCase().includes(s));
function send(processFunction, raw = false) {
    return async (req, res) => {
        try {
            const data = await processFunction(req, res);
            if (!res.headersSent)
                sendSuccessResponse(res, data, raw);
        }
        catch (error) {
            if (error instanceof Error) {
                if (!(error instanceof ResponseError) || error.httpStatusCode > 404) {
                    n8n_workflow_1.ErrorReporterProxy.error(error);
                }
                if (isUniqueConstraintError(error)) {
                    error.message = 'There is already an entry with this name';
                }
            }
            sendErrorResponse(res, error);
        }
    };
}
exports.send = send;
function flattenExecutionData(fullExecutionData) {
    const returnData = {
        data: (0, flatted_1.stringify)(fullExecutionData.data),
        mode: fullExecutionData.mode,
        waitTill: fullExecutionData.waitTill,
        startedAt: fullExecutionData.startedAt,
        stoppedAt: fullExecutionData.stoppedAt,
        finished: fullExecutionData.finished ? fullExecutionData.finished : false,
        workflowId: fullExecutionData.workflowId,
        workflowData: fullExecutionData.workflowData,
        status: fullExecutionData.status,
    };
    if (fullExecutionData.id !== undefined) {
        returnData.id = fullExecutionData.id;
    }
    if (fullExecutionData.retryOf !== undefined) {
        returnData.retryOf = fullExecutionData.retryOf.toString();
    }
    if (fullExecutionData.retrySuccessId !== undefined) {
        returnData.retrySuccessId = fullExecutionData.retrySuccessId.toString();
    }
    return returnData;
}
exports.flattenExecutionData = flattenExecutionData;
function unflattenExecutionData(fullExecutionData) {
    const returnData = {
        id: fullExecutionData.id,
        workflowData: fullExecutionData.workflowData,
        data: (0, flatted_1.parse)(fullExecutionData.data),
        mode: fullExecutionData.mode,
        waitTill: fullExecutionData.waitTill ? fullExecutionData.waitTill : undefined,
        startedAt: fullExecutionData.startedAt,
        stoppedAt: fullExecutionData.stoppedAt,
        finished: fullExecutionData.finished ? fullExecutionData.finished : false,
        workflowId: fullExecutionData.workflowId,
        status: fullExecutionData.status,
    };
    return returnData;
}
exports.unflattenExecutionData = unflattenExecutionData;
const flattenObject = (obj, prefix = '') => Object.keys(obj).reduce((acc, k) => {
    const pre = prefix.length ? prefix + '.' : '';
    if (typeof obj[k] === 'object')
        Object.assign(acc, (0, exports.flattenObject)(obj[k], pre + k));
    else
        acc[pre + k] = obj[k];
    return acc;
}, {});
exports.flattenObject = flattenObject;
//# sourceMappingURL=ResponseHelper.js.map