"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.nodeFetchedData = exports.workflowExecutionCompleted = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const Db = __importStar(require("../Db"));
const UserManagementHelper_1 = require("../UserManagement/UserManagementHelper");
const typeorm_1 = require("typeorm");
const typedi_1 = require("typedi");
const InternalHooks_1 = require("../InternalHooks");
const config_1 = __importDefault(require("../config"));
const user_service_1 = require("../user/user.service");
var StatisticsUpsertResult;
(function (StatisticsUpsertResult) {
    StatisticsUpsertResult["insert"] = "insert";
    StatisticsUpsertResult["update"] = "update";
    StatisticsUpsertResult["failed"] = "failed";
})(StatisticsUpsertResult || (StatisticsUpsertResult = {}));
async function upsertWorkflowStatistics(eventName, workflowId) {
    const dbType = config_1.default.getEnv('database.type');
    const { tableName } = Db.collections.WorkflowStatistics.metadata;
    try {
        if (dbType === 'sqlite') {
            await Db.collections.WorkflowStatistics.query(`INSERT INTO "${tableName}" ("count", "name", "workflowId", "latestEvent")
					VALUES (1, "${eventName}", "${workflowId}", CURRENT_TIMESTAMP)
					ON CONFLICT (workflowId, name)
					DO UPDATE SET count = count + 1, latestEvent = CURRENT_TIMESTAMP`);
            const counter = await Db.collections.WorkflowStatistics.findOne({
                select: ['count'],
                where: {
                    name: eventName,
                    workflowId,
                },
            });
            if ((counter === null || counter === void 0 ? void 0 : counter.count) === 1) {
                return "insert";
            }
            return "update";
        }
        else if (dbType === 'postgresdb') {
            const queryResult = (await Db.collections.WorkflowStatistics.query(`INSERT INTO "${tableName}" ("count", "name", "workflowId", "latestEvent")
					VALUES (1, '${eventName}', '${workflowId}', CURRENT_TIMESTAMP)
					ON CONFLICT ("name", "workflowId")
					DO UPDATE SET "count" = "${tableName}"."count" + 1, "latestEvent" = CURRENT_TIMESTAMP
					RETURNING *;`));
            if (queryResult[0].count === 1) {
                return "insert";
            }
            return "update";
        }
        else {
            const queryResult = (await Db.collections.WorkflowStatistics.query(`INSERT INTO \`${tableName}\` (count, name, workflowId, latestEvent)
					VALUES (1, "${eventName}", "${workflowId}", NOW())
					ON DUPLICATE KEY
					UPDATE count = count + 1, latestEvent = NOW();`));
            if (queryResult.affectedRows === 1) {
                return "insert";
            }
            return "update";
        }
    }
    catch (error) {
        if (error instanceof typeorm_1.QueryFailedError)
            return "failed";
        throw error;
    }
}
async function workflowExecutionCompleted(workflowData, runData) {
    var _a;
    const finished = runData.finished ? runData.finished : false;
    const manual = runData.mode === 'manual';
    let name;
    if (finished) {
        if (manual)
            name = "manual_success";
        else
            name = "production_success";
    }
    else {
        if (manual)
            name = "manual_error";
        else
            name = "production_error";
    }
    const workflowId = workflowData.id;
    if (!workflowId)
        return;
    try {
        const upsertResult = await upsertWorkflowStatistics(name, workflowId);
        if (name === "production_success" &&
            upsertResult === "insert") {
            const owner = await (0, UserManagementHelper_1.getWorkflowOwner)(workflowId);
            const metrics = {
                user_id: owner.id,
                workflow_id: workflowId,
            };
            if (!((_a = owner.settings) === null || _a === void 0 ? void 0 : _a.userActivated)) {
                await user_service_1.UserService.updateUserSettings(owner.id, {
                    firstSuccessfulWorkflowId: workflowId,
                    userActivated: true,
                    showUserActivationSurvey: true,
                });
            }
            await typedi_1.Container.get(InternalHooks_1.InternalHooks).onFirstProductionWorkflowSuccess(metrics);
        }
    }
    catch (error) {
        n8n_workflow_1.LoggerProxy.verbose('Unable to fire first workflow success telemetry event');
    }
}
exports.workflowExecutionCompleted = workflowExecutionCompleted;
async function nodeFetchedData(workflowId, node) {
    if (!workflowId)
        return;
    const hasLoadedDataPreviously = await Db.collections.WorkflowStatistics.findOne({
        select: ['count'],
        where: {
            workflowId,
            name: "data_loaded",
        },
    });
    if (hasLoadedDataPreviously) {
        return;
    }
    try {
        await Db.collections.WorkflowStatistics.createQueryBuilder('workflowStatistics')
            .insert()
            .values({
            workflowId,
            name: "data_loaded",
            count: 1,
            latestEvent: new Date(),
        })
            .orIgnore()
            .execute();
    }
    catch (error) {
        n8n_workflow_1.LoggerProxy.warn('Failed saving loaded data statistics');
    }
    const owner = await (0, UserManagementHelper_1.getWorkflowOwner)(workflowId);
    let metrics = {
        user_id: owner.id,
        workflow_id: workflowId,
        node_type: node.type,
        node_id: node.id,
    };
    if (node.credentials) {
        Object.entries(node.credentials).forEach(([credName, credDetails]) => {
            metrics = Object.assign(metrics, {
                credential_type: credName,
                credential_id: credDetails.id,
            });
        });
    }
    await typedi_1.Container.get(InternalHooks_1.InternalHooks).onFirstWorkflowDataLoad(metrics);
}
exports.nodeFetchedData = nodeFetchedData;
//# sourceMappingURL=WorkflowStatistics.js.map