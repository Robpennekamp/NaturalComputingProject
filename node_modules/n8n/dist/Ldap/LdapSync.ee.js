"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LdapSync = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const QueryFailedError_1 = require("typeorm/error/QueryFailedError");
const helpers_1 = require("./helpers");
const typedi_1 = require("typedi");
const InternalHooks_1 = require("../InternalHooks");
class LdapSync {
    constructor() {
        this.intervalId = undefined;
    }
    set config(config) {
        this._config = config;
        if (this.intervalId && !this._config.synchronizationEnabled) {
            this.stop();
        }
        else if (!this.intervalId && this._config.synchronizationEnabled) {
            this.scheduleRun();
        }
        else if (this.intervalId && this._config.synchronizationEnabled) {
            this.stop();
            this.scheduleRun();
        }
    }
    set ldapService(service) {
        this._ldapService = service;
    }
    scheduleRun() {
        if (!this._config.synchronizationInterval) {
            throw new Error('Interval variable has to be defined');
        }
        this.intervalId = setInterval(async () => {
            await this.run('live');
        }, this._config.synchronizationInterval * 60000);
    }
    async run(mode) {
        n8n_workflow_1.LoggerProxy.debug(`LDAP - Starting a synchronization run in ${mode} mode`);
        let adUsers = [];
        try {
            adUsers = await this._ldapService.searchWithAdminBinding((0, helpers_1.createFilter)(`(${this._config.loginIdAttribute}=*)`, this._config.userFilter));
            n8n_workflow_1.LoggerProxy.debug('LDAP - Users return by the query', {
                users: adUsers,
            });
            (0, helpers_1.resolveBinaryAttributes)(adUsers);
        }
        catch (e) {
            if (e instanceof Error) {
                n8n_workflow_1.LoggerProxy.error(`LDAP - ${e.message}`);
                throw e;
            }
        }
        const startedAt = new Date();
        const localAdUsers = await (0, helpers_1.getLdapIds)();
        const role = await (0, helpers_1.getLdapUserRole)();
        const { usersToCreate, usersToUpdate, usersToDisable } = this.getUsersToProcess(adUsers, localAdUsers, role);
        if (usersToDisable.length) {
            void typedi_1.Container.get(InternalHooks_1.InternalHooks).onLdapUsersDisabled({
                reason: 'ldap_update',
                users: usersToDisable.length,
                user_ids: usersToDisable,
            });
        }
        n8n_workflow_1.LoggerProxy.debug('LDAP - Users processed', {
            created: usersToCreate.length,
            updated: usersToUpdate.length,
            disabled: usersToDisable.length,
        });
        const endedAt = new Date();
        let status = 'success';
        let errorMessage = '';
        try {
            if (mode === 'live') {
                await (0, helpers_1.processUsers)(usersToCreate, usersToUpdate, usersToDisable);
            }
        }
        catch (error) {
            if (error instanceof QueryFailedError_1.QueryFailedError) {
                status = 'error';
                errorMessage = `${error.message}`;
            }
        }
        await (0, helpers_1.saveLdapSynchronization)({
            startedAt,
            endedAt,
            created: usersToCreate.length,
            updated: usersToUpdate.length,
            disabled: usersToDisable.length,
            scanned: adUsers.length,
            runMode: mode,
            status,
            error: errorMessage,
        });
        void typedi_1.Container.get(InternalHooks_1.InternalHooks).onLdapSyncFinished({
            type: !this.intervalId ? 'scheduled' : `manual_${mode}`,
            succeeded: true,
            users_synced: usersToCreate.length + usersToUpdate.length + usersToDisable.length,
            error: errorMessage,
        });
        n8n_workflow_1.LoggerProxy.debug('LDAP - Synchronization finished successfully');
    }
    stop() {
        clearInterval(this.intervalId);
        this.intervalId = undefined;
    }
    getUsersToProcess(adUsers, localAdUsers, role) {
        return {
            usersToCreate: this.getUsersToCreate(adUsers, localAdUsers, role),
            usersToUpdate: this.getUsersToUpdate(adUsers, localAdUsers),
            usersToDisable: this.getUsersToDisable(adUsers, localAdUsers),
        };
    }
    getUsersToCreate(remoteAdUsers, localLdapIds, role) {
        return remoteAdUsers
            .filter((adUser) => !localLdapIds.includes(adUser[this._config.ldapIdAttribute]))
            .map((adUser) => (0, helpers_1.mapLdapUserToDbUser)(adUser, this._config, role));
    }
    getUsersToUpdate(remoteAdUsers, localLdapIds) {
        return remoteAdUsers
            .filter((adUser) => localLdapIds.includes(adUser[this._config.ldapIdAttribute]))
            .map((adUser) => (0, helpers_1.mapLdapUserToDbUser)(adUser, this._config));
    }
    getUsersToDisable(remoteAdUsers, localLdapIds) {
        const remoteAdUserIds = remoteAdUsers.map((adUser) => adUser[this._config.ldapIdAttribute]);
        return localLdapIds.filter((user) => !remoteAdUserIds.includes(user));
    }
}
exports.LdapSync = LdapSync;
//# sourceMappingURL=LdapSync.ee.js.map