"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateLdapUserOnLocalDb = exports.createLdapUserOnLocalDb = exports.createLdapAuthIdentity = exports.getMappingAttributes = exports.formatUrl = exports.getLdapSynchronizations = exports.saveLdapSynchronization = exports.processUsers = exports.mapLdapUserToDbUser = exports.getLdapUsers = exports.getLdapIds = exports.mapLdapAttributesToUser = exports.getUserByEmail = exports.getAuthIdentityByLdapId = exports.findAndAuthenticateLdapUser = exports.escapeFilter = exports.createFilter = exports.handleLdapInit = exports.updateLdapConfig = exports.resolveBinaryAttributes = exports.setGlobalLdapConfigVariables = exports.getLdapConfig = exports.decryptPassword = exports.encryptPassword = exports.validateLdapConfigurationSchema = exports.getLdapUserRole = exports.randomPassword = exports.isLdapLoginEnabled = exports.getLdapLoginLabel = exports.setLdapLoginEnabled = exports.setLdapLoginLabel = exports.isLdapDisabled = exports.isLdapEnabled = void 0;
const crypto_js_1 = require("crypto-js");
const Filter_1 = require("ldapts/filters/Filter");
const typedi_1 = require("typedi");
const n8n_core_1 = require("n8n-core");
const jsonschema_1 = require("jsonschema");
const Db = __importStar(require("../Db"));
const config_1 = __importDefault(require("../config"));
const User_1 = require("../databases/entities/User");
const AuthIdentity_1 = require("../databases/entities/AuthIdentity");
const repositories_1 = require("../databases/repositories");
const UserManagementHelper_1 = require("../UserManagement/UserManagementHelper");
const LdapManager_ee_1 = require("./LdapManager.ee");
const constants_1 = require("./constants");
const n8n_workflow_1 = require("n8n-workflow");
const License_1 = require("../License");
const InternalHooks_1 = require("../InternalHooks");
const ssoHelpers_1 = require("../sso/ssoHelpers");
const ResponseHelper_1 = require("../ResponseHelper");
const isLdapEnabled = () => {
    const license = typedi_1.Container.get(License_1.License);
    return (0, UserManagementHelper_1.isUserManagementEnabled)() && license.isLdapEnabled();
};
exports.isLdapEnabled = isLdapEnabled;
const isLdapDisabled = () => !(0, exports.isLdapEnabled)();
exports.isLdapDisabled = isLdapDisabled;
const setLdapLoginLabel = (value) => {
    config_1.default.set(constants_1.LDAP_LOGIN_LABEL, value);
};
exports.setLdapLoginLabel = setLdapLoginLabel;
async function setLdapLoginEnabled(enabled) {
    if ((0, ssoHelpers_1.isEmailCurrentAuthenticationMethod)() || (0, ssoHelpers_1.isLdapCurrentAuthenticationMethod)()) {
        if (enabled) {
            config_1.default.set(constants_1.LDAP_LOGIN_ENABLED, true);
            await (0, ssoHelpers_1.setCurrentAuthenticationMethod)('ldap');
        }
        else if (!enabled) {
            config_1.default.set(constants_1.LDAP_LOGIN_ENABLED, false);
            await (0, ssoHelpers_1.setCurrentAuthenticationMethod)('email');
        }
    }
    else {
        throw new ResponseHelper_1.InternalServerError(`Cannot switch LDAP login enabled state when an authentication method other than email or ldap is active (current: ${(0, ssoHelpers_1.getCurrentAuthenticationMethod)()})`);
    }
}
exports.setLdapLoginEnabled = setLdapLoginEnabled;
const getLdapLoginLabel = () => config_1.default.getEnv(constants_1.LDAP_LOGIN_LABEL);
exports.getLdapLoginLabel = getLdapLoginLabel;
const isLdapLoginEnabled = () => config_1.default.getEnv(constants_1.LDAP_LOGIN_ENABLED);
exports.isLdapLoginEnabled = isLdapLoginEnabled;
const randomPassword = () => {
    return Math.random().toString(36).slice(-8);
};
exports.randomPassword = randomPassword;
const getLdapUserRole = async () => {
    return typedi_1.Container.get(repositories_1.RoleRepository).findGlobalMemberRoleOrFail();
};
exports.getLdapUserRole = getLdapUserRole;
const validateLdapConfigurationSchema = (ldapConfig) => {
    const { valid, errors } = (0, jsonschema_1.validate)(ldapConfig, constants_1.LDAP_CONFIG_SCHEMA, { nestedErrors: true });
    let message = '';
    if (!valid) {
        message = errors.map((error) => `request.body.${error.path[0]} ${error.message}`).join(',');
    }
    return { valid, message };
};
exports.validateLdapConfigurationSchema = validateLdapConfigurationSchema;
const encryptPassword = async (password) => {
    const encryptionKey = await n8n_core_1.UserSettings.getEncryptionKey();
    return crypto_js_1.AES.encrypt(password, encryptionKey).toString();
};
exports.encryptPassword = encryptPassword;
const decryptPassword = async (password) => {
    const encryptionKey = await n8n_core_1.UserSettings.getEncryptionKey();
    return crypto_js_1.AES.decrypt(password, encryptionKey).toString(crypto_js_1.enc.Utf8);
};
exports.decryptPassword = decryptPassword;
const getLdapConfig = async () => {
    const configuration = await Db.collections.Settings.findOneByOrFail({
        key: constants_1.LDAP_FEATURE_NAME,
    });
    const configurationData = (0, n8n_workflow_1.jsonParse)(configuration.value);
    configurationData.bindingAdminPassword = await (0, exports.decryptPassword)(configurationData.bindingAdminPassword);
    return configurationData;
};
exports.getLdapConfig = getLdapConfig;
const setGlobalLdapConfigVariables = async (ldapConfig) => {
    await setLdapLoginEnabled(ldapConfig.loginEnabled);
    (0, exports.setLdapLoginLabel)(ldapConfig.loginLabel);
};
exports.setGlobalLdapConfigVariables = setGlobalLdapConfigVariables;
const resolveEntryBinaryAttributes = (entry) => {
    Object.entries(entry)
        .filter(([k]) => constants_1.BINARY_AD_ATTRIBUTES.includes(k))
        .forEach(([k]) => {
        entry[k] = entry[k].toString('hex');
    });
    return entry;
};
const resolveBinaryAttributes = (entries) => {
    entries.forEach((entry) => resolveEntryBinaryAttributes(entry));
};
exports.resolveBinaryAttributes = resolveBinaryAttributes;
const updateLdapConfig = async (ldapConfig) => {
    const { valid, message } = (0, exports.validateLdapConfigurationSchema)(ldapConfig);
    if (!valid) {
        throw new Error(message);
    }
    LdapManager_ee_1.LdapManager.updateConfig({ ...ldapConfig });
    ldapConfig.bindingAdminPassword = await (0, exports.encryptPassword)(ldapConfig.bindingAdminPassword);
    if (!ldapConfig.loginEnabled) {
        ldapConfig.synchronizationEnabled = false;
        const ldapUsers = await (0, exports.getLdapUsers)();
        if (ldapUsers.length) {
            await deleteAllLdapIdentities();
            void typedi_1.Container.get(InternalHooks_1.InternalHooks).onLdapUsersDisabled({
                reason: 'ldap_update',
                users: ldapUsers.length,
                user_ids: ldapUsers.map((user) => user.id),
            });
        }
    }
    await Db.collections.Settings.update({ key: constants_1.LDAP_FEATURE_NAME }, { value: JSON.stringify(ldapConfig), loadOnStartup: true });
    await (0, exports.setGlobalLdapConfigVariables)(ldapConfig);
};
exports.updateLdapConfig = updateLdapConfig;
const handleLdapInit = async () => {
    if (!(0, exports.isLdapEnabled)()) {
        const ldapUsers = await (0, exports.getLdapUsers)();
        if (ldapUsers.length) {
            void typedi_1.Container.get(InternalHooks_1.InternalHooks).onLdapUsersDisabled({
                reason: 'ldap_feature_deactivated',
                users: ldapUsers.length,
                user_ids: ldapUsers.map((user) => user.id),
            });
        }
        return;
    }
    const ldapConfig = await (0, exports.getLdapConfig)();
    try {
        await (0, exports.setGlobalLdapConfigVariables)(ldapConfig);
    }
    catch (error) {
        n8n_workflow_1.LoggerProxy.error(`Cannot set LDAP login enabled state when an authentication method other than email or ldap is active (current: ${(0, ssoHelpers_1.getCurrentAuthenticationMethod)()})`, error);
    }
    LdapManager_ee_1.LdapManager.init(ldapConfig);
};
exports.handleLdapInit = handleLdapInit;
const createFilter = (filter, userFilter) => {
    let _filter = `(&(|(objectClass=person)(objectClass=user))${filter})`;
    if (userFilter) {
        _filter = `(&${userFilter}${filter}`;
    }
    return _filter;
};
exports.createFilter = createFilter;
const escapeFilter = (filter) => {
    return new Filter_1.Filter().escape(filter);
};
exports.escapeFilter = escapeFilter;
const findAndAuthenticateLdapUser = async (loginId, password, loginIdAttribute, userFilter) => {
    const ldapService = LdapManager_ee_1.LdapManager.getInstance().service;
    let searchResult = [];
    try {
        searchResult = await ldapService.searchWithAdminBinding((0, exports.createFilter)(`(${loginIdAttribute}=${(0, exports.escapeFilter)(loginId)})`, userFilter));
    }
    catch (e) {
        if (e instanceof Error) {
            void typedi_1.Container.get(InternalHooks_1.InternalHooks).onLdapLoginSyncFailed({
                error: e.message,
            });
            n8n_workflow_1.LoggerProxy.error('LDAP - Error during search', { message: e.message });
        }
        return undefined;
    }
    if (!searchResult.length) {
        return undefined;
    }
    let user = searchResult.pop();
    if (user === undefined) {
        user = { dn: '' };
    }
    try {
        await ldapService.validUser(user.dn, password);
    }
    catch (e) {
        if (e instanceof Error) {
            n8n_workflow_1.LoggerProxy.error('LDAP - Error validating user against LDAP server', { message: e.message });
        }
        return undefined;
    }
    resolveEntryBinaryAttributes(user);
    return user;
};
exports.findAndAuthenticateLdapUser = findAndAuthenticateLdapUser;
const getAuthIdentityByLdapId = async (idAttributeValue) => {
    return Db.collections.AuthIdentity.findOne({
        relations: ['user', 'user.globalRole'],
        where: {
            providerId: idAttributeValue,
            providerType: 'ldap',
        },
    });
};
exports.getAuthIdentityByLdapId = getAuthIdentityByLdapId;
const getUserByEmail = async (email) => {
    return Db.collections.User.findOne({
        where: { email },
        relations: ['globalRole'],
    });
};
exports.getUserByEmail = getUserByEmail;
const mapLdapAttributesToUser = (ldapUser, ldapConfig) => {
    return [
        ldapUser[ldapConfig.ldapIdAttribute],
        {
            email: ldapUser[ldapConfig.emailAttribute],
            firstName: ldapUser[ldapConfig.firstNameAttribute],
            lastName: ldapUser[ldapConfig.lastNameAttribute],
        },
    ];
};
exports.mapLdapAttributesToUser = mapLdapAttributesToUser;
const getLdapIds = async () => {
    const identities = await Db.collections.AuthIdentity.find({
        select: ['providerId'],
        where: {
            providerType: 'ldap',
        },
    });
    return identities.map((i) => i.providerId);
};
exports.getLdapIds = getLdapIds;
const getLdapUsers = async () => {
    const identities = await Db.collections.AuthIdentity.find({
        relations: ['user'],
        where: {
            providerType: 'ldap',
        },
    });
    return identities.map((i) => i.user);
};
exports.getLdapUsers = getLdapUsers;
const mapLdapUserToDbUser = (ldapUser, ldapConfig, role) => {
    const user = new User_1.User();
    const [ldapId, data] = (0, exports.mapLdapAttributesToUser)(ldapUser, ldapConfig);
    Object.assign(user, data);
    if (role) {
        user.globalRole = role;
        user.password = (0, exports.randomPassword)();
        user.disabled = false;
    }
    else {
        user.disabled = true;
    }
    return [ldapId, user];
};
exports.mapLdapUserToDbUser = mapLdapUserToDbUser;
const processUsers = async (toCreateUsers, toUpdateUsers, toDisableUsers) => {
    await Db.transaction(async (transactionManager) => {
        return Promise.all([
            ...toCreateUsers.map(async ([ldapId, user]) => {
                const authIdentity = AuthIdentity_1.AuthIdentity.create(await transactionManager.save(user), ldapId);
                return transactionManager.save(authIdentity);
            }),
            ...toUpdateUsers.map(async ([ldapId, user]) => {
                const authIdentity = await transactionManager.findOneBy(AuthIdentity_1.AuthIdentity, {
                    providerId: ldapId,
                });
                if (authIdentity === null || authIdentity === void 0 ? void 0 : authIdentity.userId) {
                    await transactionManager.update(User_1.User, { id: authIdentity.userId }, { email: user.email, firstName: user.firstName, lastName: user.lastName });
                }
            }),
            ...toDisableUsers.map(async (ldapId) => {
                const authIdentity = await transactionManager.findOneBy(AuthIdentity_1.AuthIdentity, {
                    providerId: ldapId,
                });
                if (authIdentity === null || authIdentity === void 0 ? void 0 : authIdentity.userId) {
                    await transactionManager.update(User_1.User, { id: authIdentity === null || authIdentity === void 0 ? void 0 : authIdentity.userId }, { disabled: true });
                    await transactionManager.delete(AuthIdentity_1.AuthIdentity, { userId: authIdentity === null || authIdentity === void 0 ? void 0 : authIdentity.userId });
                }
            }),
        ]);
    });
};
exports.processUsers = processUsers;
const saveLdapSynchronization = async (data) => {
    await Db.collections.AuthProviderSyncHistory.save({
        ...data,
        providerType: 'ldap',
    });
};
exports.saveLdapSynchronization = saveLdapSynchronization;
const getLdapSynchronizations = async (page, perPage) => {
    const _page = Math.abs(page);
    return Db.collections.AuthProviderSyncHistory.find({
        where: { providerType: 'ldap' },
        order: { id: 'DESC' },
        take: perPage,
        skip: _page * perPage,
    });
};
exports.getLdapSynchronizations = getLdapSynchronizations;
const formatUrl = (url, port, security) => {
    const protocol = ['tls'].includes(security) ? 'ldaps' : 'ldap';
    return `${protocol}://${url}:${port}`;
};
exports.formatUrl = formatUrl;
const getMappingAttributes = (ldapConfig) => {
    return [
        ldapConfig.emailAttribute,
        ldapConfig.ldapIdAttribute,
        ldapConfig.firstNameAttribute,
        ldapConfig.lastNameAttribute,
        ldapConfig.emailAttribute,
    ];
};
exports.getMappingAttributes = getMappingAttributes;
const createLdapAuthIdentity = async (user, ldapId) => {
    return Db.collections.AuthIdentity.save(AuthIdentity_1.AuthIdentity.create(user, ldapId));
};
exports.createLdapAuthIdentity = createLdapAuthIdentity;
const createLdapUserOnLocalDb = async (role, data, ldapId) => {
    const user = await Db.collections.User.save({
        password: (0, exports.randomPassword)(),
        globalRole: role,
        ...data,
    });
    await (0, exports.createLdapAuthIdentity)(user, ldapId);
    return user;
};
exports.createLdapUserOnLocalDb = createLdapUserOnLocalDb;
const updateLdapUserOnLocalDb = async (identity, data) => {
    var _a;
    const userId = (_a = identity === null || identity === void 0 ? void 0 : identity.user) === null || _a === void 0 ? void 0 : _a.id;
    if (userId) {
        await Db.collections.User.update({ id: userId }, data);
    }
};
exports.updateLdapUserOnLocalDb = updateLdapUserOnLocalDb;
const deleteAllLdapIdentities = async () => {
    return Db.collections.AuthIdentity.delete({ providerType: 'ldap' });
};
//# sourceMappingURL=helpers.js.map