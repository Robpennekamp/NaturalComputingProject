"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkflowRunner = void 0;
const n8n_core_1 = require("n8n-core");
const n8n_workflow_1 = require("n8n-workflow");
const p_cancelable_1 = __importDefault(require("p-cancelable"));
const path_1 = require("path");
const child_process_1 = require("child_process");
const ActiveExecutions_1 = require("./ActiveExecutions");
const config_1 = __importDefault(require("./config"));
const Db = __importStar(require("./Db"));
const ExternalHooks_1 = require("./ExternalHooks");
const NodeTypes_1 = require("./NodeTypes");
const Queue_1 = require("./Queue");
const ResponseHelper = __importStar(require("./ResponseHelper"));
const WebhookHelpers = __importStar(require("./WebhookHelpers"));
const WorkflowHelpers = __importStar(require("./WorkflowHelpers"));
const WorkflowExecuteAdditionalData = __importStar(require("./WorkflowExecuteAdditionalData"));
const WorkflowHelpers_1 = require("./WorkflowHelpers");
const ErrorReporting_1 = require("./ErrorReporting");
const PermissionChecker_1 = require("./UserManagement/PermissionChecker");
const push_1 = require("./push");
const eventbus_1 = require("./eventbus");
const recoverEvents_1 = require("./eventbus/MessageEventBus/recoverEvents");
const typedi_1 = require("typedi");
const InternalHooks_1 = require("./InternalHooks");
class WorkflowRunner {
    constructor() {
        this.push = typedi_1.Container.get(push_1.Push);
        this.activeExecutions = typedi_1.Container.get(ActiveExecutions_1.ActiveExecutions);
    }
    processHookMessage(workflowHooks, hookData) {
        workflowHooks.executeHookFunctions(hookData.hook, hookData.parameters);
    }
    async processError(error, startedAt, executionMode, executionId, hooks) {
        n8n_workflow_1.ErrorReporterProxy.error(error);
        const fullRunData = {
            data: {
                resultData: {
                    error: {
                        ...error,
                        message: error.message,
                        stack: error.stack,
                    },
                    runData: {},
                },
            },
            finished: false,
            mode: executionMode,
            startedAt,
            stoppedAt: new Date(),
            status: 'error',
        };
        try {
            const eventLogMessages = await eventbus_1.eventBus.getEventsByExecutionId(executionId);
            if (eventLogMessages.length > 0) {
                const eventLogExecutionData = await (0, recoverEvents_1.recoverExecutionDataFromEventLogMessages)(executionId, eventLogMessages, false);
                if (eventLogExecutionData) {
                    fullRunData.data.resultData.runData = eventLogExecutionData.resultData.runData;
                    fullRunData.status = 'crashed';
                }
            }
            const executionFlattedData = await Db.collections.Execution.findOneBy({ id: executionId });
            void typedi_1.Container.get(InternalHooks_1.InternalHooks).onWorkflowCrashed(executionId, executionMode, executionFlattedData === null || executionFlattedData === void 0 ? void 0 : executionFlattedData.workflowData);
        }
        catch {
        }
        this.activeExecutions.remove(executionId, fullRunData);
        if (hooks) {
            await hooks.executeHookFunctions('workflowExecuteAfter', [fullRunData]);
        }
    }
    async run(data, loadStaticData, realtime, executionId, responsePromise) {
        const executionsMode = config_1.default.getEnv('executions.mode');
        const executionsProcess = config_1.default.getEnv('executions.process');
        await (0, ErrorReporting_1.initErrorHandling)();
        if (executionsMode === 'queue') {
            const queue = typedi_1.Container.get(Queue_1.Queue);
            this.jobQueue = queue.getBullObjectInstance();
        }
        if (executionsMode === 'queue' && data.executionMode !== 'manual') {
            executionId = await this.enqueueExecution(data, loadStaticData, realtime, executionId, responsePromise);
        }
        else if (executionsProcess === 'main') {
            executionId = await this.runMainProcess(data, loadStaticData, executionId, responsePromise);
        }
        else {
            executionId = await this.runSubprocess(data, loadStaticData, executionId, responsePromise);
        }
        void typedi_1.Container.get(InternalHooks_1.InternalHooks).onWorkflowBeforeExecute(executionId, data);
        const postExecutePromise = this.activeExecutions.getPostExecutePromise(executionId);
        const externalHooks = typedi_1.Container.get(ExternalHooks_1.ExternalHooks);
        postExecutePromise
            .then(async (executionData) => {
            void typedi_1.Container.get(InternalHooks_1.InternalHooks).onWorkflowPostExecute(executionId, data.workflowData, executionData, data.userId);
        })
            .catch((error) => {
            n8n_workflow_1.ErrorReporterProxy.error(error);
            console.error('There was a problem running internal hook "onWorkflowPostExecute"', error);
        });
        if (externalHooks.exists('workflow.postExecute')) {
            postExecutePromise
                .then(async (executionData) => {
                await externalHooks.run('workflow.postExecute', [
                    executionData,
                    data.workflowData,
                    executionId,
                ]);
            })
                .catch((error) => {
                n8n_workflow_1.ErrorReporterProxy.error(error);
                console.error('There was a problem running hook "workflow.postExecute"', error);
            });
        }
        return executionId;
    }
    async runMainProcess(data, loadStaticData, restartExecutionId, responsePromise) {
        var _a, _b, _c, _d, _e;
        const workflowId = data.workflowData.id;
        if (loadStaticData === true && workflowId) {
            data.workflowData.staticData = await WorkflowHelpers.getStaticDataById(workflowId);
        }
        const nodeTypes = typedi_1.Container.get(NodeTypes_1.NodeTypes);
        let executionTimeout;
        const workflowSettings = (_a = data.workflowData.settings) !== null && _a !== void 0 ? _a : {};
        let workflowTimeout = (_b = workflowSettings.executionTimeout) !== null && _b !== void 0 ? _b : config_1.default.getEnv('executions.timeout');
        if (workflowTimeout > 0) {
            workflowTimeout = Math.min(workflowTimeout, config_1.default.getEnv('executions.maxTimeout'));
        }
        const workflow = new n8n_workflow_1.Workflow({
            id: workflowId,
            name: data.workflowData.name,
            nodes: data.workflowData.nodes,
            connections: data.workflowData.connections,
            active: data.workflowData.active,
            nodeTypes,
            staticData: data.workflowData.staticData,
            settings: workflowSettings,
        });
        const additionalData = await WorkflowExecuteAdditionalData.getBase(data.userId, undefined, workflowTimeout <= 0 ? undefined : Date.now() + workflowTimeout * 1000);
        additionalData.restartExecutionId = restartExecutionId;
        const executionId = await this.activeExecutions.add(data, undefined, restartExecutionId);
        additionalData.executionId = executionId;
        n8n_workflow_1.LoggerProxy.verbose(`Execution for workflow ${data.workflowData.name} was assigned id ${executionId}`, { executionId });
        let workflowExecution;
        try {
            n8n_workflow_1.LoggerProxy.verbose(`Execution for workflow ${data.workflowData.name} was assigned id ${executionId}`, { executionId });
            additionalData.hooks = WorkflowExecuteAdditionalData.getWorkflowHooksMain(data, executionId, true);
            try {
                await PermissionChecker_1.PermissionChecker.check(workflow, data.userId);
            }
            catch (error) {
                n8n_workflow_1.ErrorReporterProxy.error(error);
                const failedExecution = (0, WorkflowHelpers_1.generateFailedExecutionFromError)(data.executionMode, error, error.node);
                additionalData.hooks
                    .executeHookFunctions('workflowExecuteAfter', [failedExecution])
                    .then(() => {
                    this.activeExecutions.remove(executionId, failedExecution);
                });
                return executionId;
            }
            additionalData.hooks.hookFunctions.sendResponse = [
                async (response) => {
                    if (responsePromise) {
                        responsePromise.resolve(response);
                    }
                },
            ];
            additionalData.setExecutionStatus = WorkflowExecuteAdditionalData.setExecutionStatus.bind({
                executionId,
            });
            additionalData.sendMessageToUI = WorkflowExecuteAdditionalData.sendMessageToUI.bind({
                sessionId: data.sessionId,
            });
            if (data.executionData !== undefined) {
                n8n_workflow_1.LoggerProxy.debug(`Execution ID ${executionId} had Execution data. Running with payload.`, {
                    executionId,
                });
                const workflowExecute = new n8n_core_1.WorkflowExecute(additionalData, data.executionMode, data.executionData);
                workflowExecution = workflowExecute.processRunExecutionData(workflow);
            }
            else if (data.runData === undefined ||
                data.startNodes === undefined ||
                data.startNodes.length === 0 ||
                data.destinationNode === undefined) {
                n8n_workflow_1.LoggerProxy.debug(`Execution ID ${executionId} will run executing all nodes.`, { executionId });
                let startNode;
                if (((_c = data.startNodes) === null || _c === void 0 ? void 0 : _c.length) === 1 &&
                    Object.keys((_d = data.pinData) !== null && _d !== void 0 ? _d : {}).includes(data.startNodes[0])) {
                    startNode = (_e = workflow.getNode(data.startNodes[0])) !== null && _e !== void 0 ? _e : undefined;
                }
                const workflowExecute = new n8n_core_1.WorkflowExecute(additionalData, data.executionMode);
                workflowExecution = workflowExecute.run(workflow, startNode, data.destinationNode, data.pinData);
            }
            else {
                n8n_workflow_1.LoggerProxy.debug(`Execution ID ${executionId} is a partial execution.`, { executionId });
                const workflowExecute = new n8n_core_1.WorkflowExecute(additionalData, data.executionMode);
                workflowExecution = workflowExecute.runPartialWorkflow(workflow, data.runData, data.startNodes, data.destinationNode, data.pinData);
            }
            this.activeExecutions.attachWorkflowExecution(executionId, workflowExecution);
            if (workflowTimeout > 0) {
                const timeout = Math.min(workflowTimeout, config_1.default.getEnv('executions.maxTimeout')) * 1000;
                executionTimeout = setTimeout(() => {
                    this.activeExecutions.stopExecution(executionId, 'timeout');
                }, timeout);
            }
            workflowExecution
                .then((fullRunData) => {
                clearTimeout(executionTimeout);
                if (workflowExecution.isCanceled) {
                    fullRunData.finished = false;
                }
                fullRunData.status = this.activeExecutions.getStatus(executionId);
                this.activeExecutions.remove(executionId, fullRunData);
            })
                .catch((error) => {
                this.processError(error, new Date(), data.executionMode, executionId, additionalData.hooks);
            });
        }
        catch (error) {
            await this.processError(error, new Date(), data.executionMode, executionId, additionalData.hooks);
            throw error;
        }
        return executionId;
    }
    async enqueueExecution(data, loadStaticData, realtime, restartExecutionId, responsePromise) {
        const executionId = await this.activeExecutions.add(data, undefined, restartExecutionId);
        if (responsePromise) {
            this.activeExecutions.attachResponsePromise(executionId, responsePromise);
        }
        const jobData = {
            executionId,
            loadStaticData: !!loadStaticData,
        };
        let priority = 100;
        if (realtime === true) {
            priority = 50;
        }
        const jobOptions = {
            priority,
            removeOnComplete: true,
            removeOnFail: true,
        };
        let job;
        let hooks;
        try {
            job = await this.jobQueue.add(jobData, jobOptions);
            console.log(`Started with job ID: ${job.id.toString()} (Execution ID: ${executionId})`);
            hooks = WorkflowExecuteAdditionalData.getWorkflowHooksWorkerMain(data.executionMode, executionId, data.workflowData, { retryOf: data.retryOf ? data.retryOf.toString() : undefined });
            hooks.executeHookFunctions('workflowExecuteBefore', []);
        }
        catch (error) {
            const hooks = WorkflowExecuteAdditionalData.getWorkflowHooksWorkerExecuter(data.executionMode, executionId, data.workflowData, { retryOf: data.retryOf ? data.retryOf.toString() : undefined });
            await this.processError(error, new Date(), data.executionMode, executionId, hooks);
            throw error;
        }
        const workflowExecution = new p_cancelable_1.default(async (resolve, reject, onCancel) => {
            var _a, _b, _c;
            onCancel.shouldReject = false;
            onCancel(async () => {
                const queue = typedi_1.Container.get(Queue_1.Queue);
                await queue.stopJob(job);
                const hooksWorker = WorkflowExecuteAdditionalData.getWorkflowHooksWorkerExecuter(data.executionMode, executionId, data.workflowData, { retryOf: data.retryOf ? data.retryOf.toString() : undefined });
                const error = new n8n_workflow_1.WorkflowOperationError('Workflow-Execution has been canceled!');
                await this.processError(error, new Date(), data.executionMode, executionId, hooksWorker);
                reject(error);
            });
            const jobData = job.finished();
            const queueRecoveryInterval = config_1.default.getEnv('queue.bull.queueRecoveryInterval');
            const racingPromises = [jobData];
            let clearWatchdogInterval;
            if (queueRecoveryInterval > 0) {
                let watchDogInterval;
                const watchDog = new Promise((res) => {
                    watchDogInterval = setInterval(async () => {
                        const currentJob = await this.jobQueue.getJob(job.id);
                        if (currentJob === null) {
                            res({ success: true });
                        }
                    }, queueRecoveryInterval * 1000);
                });
                racingPromises.push(watchDog);
                clearWatchdogInterval = () => {
                    if (watchDogInterval) {
                        clearInterval(watchDogInterval);
                        watchDogInterval = undefined;
                    }
                };
            }
            try {
                await Promise.race(racingPromises);
                if (clearWatchdogInterval !== undefined) {
                    clearWatchdogInterval();
                }
            }
            catch (error) {
                n8n_workflow_1.ErrorReporterProxy.error(error);
                const hooks = WorkflowExecuteAdditionalData.getWorkflowHooksWorkerExecuter(data.executionMode, executionId, data.workflowData, { retryOf: data.retryOf ? data.retryOf.toString() : undefined });
                n8n_workflow_1.LoggerProxy.error(`Problem with execution ${executionId}: ${error.message}. Aborting.`);
                if (clearWatchdogInterval !== undefined) {
                    clearWatchdogInterval();
                }
                await this.processError(error, new Date(), data.executionMode, executionId, hooks);
                reject(error);
            }
            const executionDb = (await Db.collections.Execution.findOneBy({
                id: executionId,
            }));
            const fullExecutionData = ResponseHelper.unflattenExecutionData(executionDb);
            const runData = {
                data: fullExecutionData.data,
                finished: fullExecutionData.finished,
                mode: fullExecutionData.mode,
                startedAt: fullExecutionData.startedAt,
                stoppedAt: fullExecutionData.stoppedAt,
            };
            this.activeExecutions.remove(executionId, runData);
            hooks.executeHookFunctions('workflowExecuteAfter', [runData]);
            try {
                const workflowSettings = (_a = data.workflowData.settings) !== null && _a !== void 0 ? _a : {};
                const saveDataErrorExecution = (_b = workflowSettings.saveDataErrorExecution) !== null && _b !== void 0 ? _b : config_1.default.getEnv('executions.saveDataOnError');
                const saveDataSuccessExecution = (_c = workflowSettings.saveDataSuccessExecution) !== null && _c !== void 0 ? _c : config_1.default.getEnv('executions.saveDataOnSuccess');
                const workflowDidSucceed = !runData.data.resultData.error;
                if ((workflowDidSucceed && saveDataSuccessExecution === 'none') ||
                    (!workflowDidSucceed && saveDataErrorExecution === 'none')) {
                    await Db.collections.Execution.delete(executionId);
                    await n8n_core_1.BinaryDataManager.getInstance().markDataForDeletionByExecutionId(executionId);
                }
            }
            catch (err) {
                console.log('Error removing saved execution from database. More details: ', err);
            }
            resolve(runData);
        });
        workflowExecution.catch(() => {
        });
        this.activeExecutions.attachWorkflowExecution(executionId, workflowExecution);
        return executionId;
    }
    async runSubprocess(data, loadStaticData, restartExecutionId, responsePromise) {
        var _a, _b;
        const workflowId = data.workflowData.id;
        let startedAt = new Date();
        const subprocess = (0, child_process_1.fork)((0, path_1.join)(__dirname, 'WorkflowRunnerProcess.js'));
        if (loadStaticData === true && workflowId) {
            data.workflowData.staticData = await WorkflowHelpers.getStaticDataById(workflowId);
        }
        data.restartExecutionId = restartExecutionId;
        const executionId = await this.activeExecutions.add(data, subprocess, restartExecutionId);
        data.executionId = executionId;
        const workflowHooks = WorkflowExecuteAdditionalData.getWorkflowHooksMain(data, executionId);
        try {
            subprocess.send({ type: 'startWorkflow', data });
        }
        catch (error) {
            await this.processError(error, new Date(), data.executionMode, executionId, workflowHooks);
            return executionId;
        }
        let executionTimeout;
        const workflowSettings = (_a = data.workflowData.settings) !== null && _a !== void 0 ? _a : {};
        let workflowTimeout = (_b = workflowSettings.executionTimeout) !== null && _b !== void 0 ? _b : config_1.default.getEnv('executions.timeout');
        const processTimeoutFunction = (timeout) => {
            this.activeExecutions.stopExecution(executionId, 'timeout');
            executionTimeout = setTimeout(() => subprocess.kill(), Math.max(timeout * 0.2, 5000));
        };
        if (workflowTimeout > 0) {
            workflowTimeout = Math.min(workflowTimeout, config_1.default.getEnv('executions.maxTimeout')) * 1000;
            executionTimeout = setTimeout(processTimeoutFunction, Math.max(5000, workflowTimeout), workflowTimeout);
        }
        const childExecutionIds = [];
        subprocess.on('message', async (message) => {
            var _a;
            n8n_workflow_1.LoggerProxy.debug(`Received child process message of type ${message.type} for execution ID ${executionId}.`, { executionId });
            if (message.type === 'start') {
                startedAt = new Date();
                if (workflowTimeout > 0) {
                    clearTimeout(executionTimeout);
                    executionTimeout = setTimeout(processTimeoutFunction, workflowTimeout, workflowTimeout);
                }
            }
            else if (message.type === 'end') {
                clearTimeout(executionTimeout);
                this.activeExecutions.remove(executionId, message.data.runData);
            }
            else if (message.type === 'sendResponse') {
                if (responsePromise) {
                    responsePromise.resolve(WebhookHelpers.decodeWebhookResponse(message.data.response));
                }
            }
            else if (message.type === 'sendMessageToUI') {
                WorkflowExecuteAdditionalData.sendMessageToUI.bind({ sessionId: data.sessionId })(message.data.source, message.data.message);
            }
            else if (message.type === 'processError') {
                clearTimeout(executionTimeout);
                const executionError = message.data.executionError;
                await this.processError(executionError, startedAt, data.executionMode, executionId, workflowHooks);
            }
            else if (message.type === 'processHook') {
                this.processHookMessage(workflowHooks, message.data);
            }
            else if (message.type === 'timeout') {
                const timeoutError = new n8n_workflow_1.WorkflowOperationError('Workflow execution timed out!');
                this.processError(timeoutError, startedAt, data.executionMode, executionId);
            }
            else if (message.type === 'startExecution') {
                const executionId = await this.activeExecutions.add(message.data.runData);
                childExecutionIds.push(executionId);
                subprocess.send({ type: 'executionId', data: { executionId } });
            }
            else if (message.type === 'finishExecution') {
                const executionIdIndex = childExecutionIds.indexOf(message.data.executionId);
                if (executionIdIndex !== -1) {
                    childExecutionIds.splice(executionIdIndex, 1);
                }
                if (message.data.result === undefined) {
                    const noDataError = new n8n_workflow_1.WorkflowOperationError('Workflow finished with no result data');
                    const subWorkflowHooks = WorkflowExecuteAdditionalData.getWorkflowHooksMain(data, message.data.executionId);
                    await this.processError(noDataError, startedAt, data.executionMode, (_a = message.data) === null || _a === void 0 ? void 0 : _a.executionId, subWorkflowHooks);
                }
                else {
                    this.activeExecutions.remove(message.data.executionId, message.data.result);
                }
            }
        });
        subprocess.on('exit', async (code, signal) => {
            if (signal === 'SIGTERM') {
                n8n_workflow_1.LoggerProxy.debug(`Subprocess for execution ID ${executionId} timed out.`, { executionId });
                const timeoutError = new n8n_workflow_1.WorkflowOperationError('Workflow execution timed out!');
                await this.processError(timeoutError, startedAt, data.executionMode, executionId, workflowHooks);
            }
            else if (code !== 0) {
                n8n_workflow_1.LoggerProxy.debug(`Subprocess for execution ID ${executionId} finished with error code ${code}.`, { executionId });
                const executionError = new n8n_workflow_1.WorkflowOperationError('Workflow execution process crashed for an unknown reason!');
                await this.processError(executionError, startedAt, data.executionMode, executionId, workflowHooks);
            }
            for (const executionId of childExecutionIds) {
                this.activeExecutions.remove(executionId);
            }
            clearTimeout(executionTimeout);
        });
        return executionId;
    }
}
exports.WorkflowRunner = WorkflowRunner;
//# sourceMappingURL=WorkflowRunner.js.map