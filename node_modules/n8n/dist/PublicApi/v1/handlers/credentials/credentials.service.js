"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toJsonSchema = exports.sanitizeCredentials = exports.encryptCredential = exports.removeCredential = exports.saveCredential = exports.createCredential = exports.getSharedCredentials = exports.getCredentials = void 0;
const n8n_core_1 = require("n8n-core");
const Db = __importStar(require("../../../../Db"));
const CredentialsEntity_1 = require("../../../../databases/entities/CredentialsEntity");
const SharedCredentials_1 = require("../../../../databases/entities/SharedCredentials");
const repositories_1 = require("../../../../databases/repositories");
const ExternalHooks_1 = require("../../../../ExternalHooks");
const typedi_1 = require("typedi");
async function getCredentials(credentialId) {
    return Db.collections.Credentials.findOneBy({ id: credentialId });
}
exports.getCredentials = getCredentials;
async function getSharedCredentials(userId, credentialId, relations) {
    return Db.collections.SharedCredentials.findOne({
        where: {
            userId,
            credentialsId: credentialId,
        },
        relations,
    });
}
exports.getSharedCredentials = getSharedCredentials;
async function createCredential(properties) {
    var _a, _b;
    const newCredential = new CredentialsEntity_1.CredentialsEntity();
    Object.assign(newCredential, properties);
    if (!newCredential.nodesAccess || newCredential.nodesAccess.length === 0) {
        newCredential.nodesAccess = [
            {
                nodeType: `n8n-nodes-base.${(_b = (_a = properties.type) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== null && _b !== void 0 ? _b : 'unknown'}`,
                date: new Date(),
            },
        ];
    }
    else {
        newCredential.nodesAccess.forEach((nodeAccess) => {
            nodeAccess.date = new Date();
        });
    }
    return newCredential;
}
exports.createCredential = createCredential;
async function saveCredential(credential, user, encryptedData) {
    const role = await typedi_1.Container.get(repositories_1.RoleRepository).findCredentialOwnerRoleOrFail();
    await typedi_1.Container.get(ExternalHooks_1.ExternalHooks).run('credentials.create', [encryptedData]);
    return Db.transaction(async (transactionManager) => {
        const savedCredential = await transactionManager.save(credential);
        savedCredential.data = credential.data;
        const newSharedCredential = new SharedCredentials_1.SharedCredentials();
        Object.assign(newSharedCredential, {
            role,
            user,
            credentials: savedCredential,
        });
        await transactionManager.save(newSharedCredential);
        return savedCredential;
    });
}
exports.saveCredential = saveCredential;
async function removeCredential(credentials) {
    await typedi_1.Container.get(ExternalHooks_1.ExternalHooks).run('credentials.delete', [credentials.id]);
    return Db.collections.Credentials.remove(credentials);
}
exports.removeCredential = removeCredential;
async function encryptCredential(credential) {
    const encryptionKey = await n8n_core_1.UserSettings.getEncryptionKey();
    const coreCredential = new n8n_core_1.Credentials({ id: null, name: credential.name }, credential.type, credential.nodesAccess);
    coreCredential.setData(credential.data, encryptionKey);
    return coreCredential.getDataToSave();
}
exports.encryptCredential = encryptCredential;
function sanitizeCredentials(credentials) {
    const argIsArray = Array.isArray(credentials);
    const credentialsList = argIsArray ? credentials : [credentials];
    const sanitizedCredentials = credentialsList.map((credential) => {
        const { data, nodesAccess, shared, ...rest } = credential;
        return rest;
    });
    return argIsArray ? sanitizedCredentials : sanitizedCredentials[0];
}
exports.sanitizeCredentials = sanitizeCredentials;
function toJsonSchema(properties) {
    const jsonSchema = {
        additionalProperties: false,
        type: 'object',
        properties: {},
        allOf: [],
        required: [],
    };
    const optionsValues = {};
    const resolveProperties = [];
    properties
        .filter((property) => property.type === 'options')
        .forEach((property) => {
        var _a;
        Object.assign(optionsValues, {
            [property.name]: (_a = property.options) === null || _a === void 0 ? void 0 : _a.map((option) => option.value),
        });
    });
    let requiredFields = [];
    const propertyRequiredDependencies = {};
    properties.forEach((property) => {
        var _a, _b, _c, _d, _e;
        if (property.required) {
            requiredFields.push(property.name);
        }
        if (property.type === 'options') {
            Object.assign(jsonSchema.properties, {
                [property.name]: {
                    type: 'string',
                    enum: (_a = property.options) === null || _a === void 0 ? void 0 : _a.map((data) => data.value),
                },
            });
        }
        else {
            Object.assign(jsonSchema.properties, {
                [property.name]: {
                    type: property.type,
                },
            });
        }
        if ((_b = property.displayOptions) === null || _b === void 0 ? void 0 : _b.show) {
            const dependantName = Object.keys((_c = property.displayOptions) === null || _c === void 0 ? void 0 : _c.show)[0] || '';
            const displayOptionsValues = property.displayOptions.show[dependantName];
            let dependantValue = '';
            if (displayOptionsValues && Array.isArray(displayOptionsValues) && displayOptionsValues[0]) {
                dependantValue = displayOptionsValues[0];
            }
            if (propertyRequiredDependencies[dependantName] === undefined) {
                propertyRequiredDependencies[dependantName] = {};
            }
            if (!resolveProperties.includes(dependantName)) {
                propertyRequiredDependencies[dependantName] = {
                    if: {
                        properties: {
                            [dependantName]: {
                                enum: [dependantValue],
                            },
                        },
                    },
                    then: {
                        allOf: [],
                    },
                    else: {
                        allOf: [],
                    },
                };
            }
            (_d = propertyRequiredDependencies[dependantName].then) === null || _d === void 0 ? void 0 : _d.allOf.push({ required: [property.name] });
            (_e = propertyRequiredDependencies[dependantName].else) === null || _e === void 0 ? void 0 : _e.allOf.push({
                not: { required: [property.name] },
            });
            resolveProperties.push(dependantName);
            requiredFields = requiredFields.filter((field) => field !== property.name);
        }
    });
    Object.assign(jsonSchema, { required: requiredFields });
    jsonSchema.allOf = Object.values(propertyRequiredDependencies);
    if (!jsonSchema.allOf.length) {
        delete jsonSchema.allOf;
    }
    return jsonSchema;
}
exports.toJsonSchema = toJsonSchema;
//# sourceMappingURL=credentials.service.js.map