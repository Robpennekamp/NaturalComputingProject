"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupExternalJWTAuth = void 0;
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const jwks_rsa_1 = __importDefault(require("jwks-rsa"));
const ResponseHelper_1 = require("../ResponseHelper");
const setupExternalJWTAuth = async (app, config, authIgnoreRegex) => {
    const jwtAuthHeader = config.getEnv('security.jwtAuth.jwtHeader');
    if (jwtAuthHeader === '') {
        throw new Error('JWT auth is activated but no request header was defined. Please set one!');
    }
    const jwksUri = config.getEnv('security.jwtAuth.jwksUri');
    if (jwksUri === '') {
        throw new Error('JWT auth is activated but no JWK Set URI was defined. Please set one!');
    }
    const jwtHeaderValuePrefix = config.getEnv('security.jwtAuth.jwtHeaderValuePrefix');
    const jwtIssuer = config.getEnv('security.jwtAuth.jwtIssuer');
    const jwtNamespace = config.getEnv('security.jwtAuth.jwtNamespace');
    const jwtAllowedTenantKey = config.getEnv('security.jwtAuth.jwtAllowedTenantKey');
    const jwtAllowedTenant = config.getEnv('security.jwtAuth.jwtAllowedTenant');
    function isTenantAllowed(decodedToken) {
        if (jwtNamespace === '' || jwtAllowedTenantKey === '' || jwtAllowedTenant === '') {
            return true;
        }
        for (const [k, v] of Object.entries(decodedToken)) {
            if (k === jwtNamespace) {
                for (const [kn, kv] of Object.entries(v)) {
                    if (kn === jwtAllowedTenantKey && kv === jwtAllowedTenant) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    app.use((req, res, next) => {
        if (authIgnoreRegex.exec(req.url)) {
            return next();
        }
        let token = req.header(jwtAuthHeader);
        if (token === undefined || token === '') {
            return (0, ResponseHelper_1.jwtAuthAuthorizationError)(res, 'Missing token');
        }
        if (jwtHeaderValuePrefix !== '' && token.startsWith(jwtHeaderValuePrefix)) {
            token = token.replace(`${jwtHeaderValuePrefix} `, '').trimStart();
        }
        const jwkClient = (0, jwks_rsa_1.default)({ cache: true, jwksUri });
        const getKey = (header, callbackFn) => {
            if (!header.kid)
                throw (0, ResponseHelper_1.jwtAuthAuthorizationError)(res, 'No JWT key found');
            jwkClient.getSigningKey(header.kid, (error, key) => {
                if (error)
                    throw (0, ResponseHelper_1.jwtAuthAuthorizationError)(res, error.message);
                callbackFn(null, key === null || key === void 0 ? void 0 : key.getPublicKey());
            });
        };
        const jwtVerifyOptions = {
            issuer: jwtIssuer !== '' ? jwtIssuer : undefined,
            ignoreExpiration: false,
        };
        jsonwebtoken_1.default.verify(token, getKey, jwtVerifyOptions, (error, decoded) => {
            if (error) {
                (0, ResponseHelper_1.jwtAuthAuthorizationError)(res, 'Invalid token');
            }
            else if (!isTenantAllowed(decoded)) {
                (0, ResponseHelper_1.jwtAuthAuthorizationError)(res, 'Tenant not allowed');
            }
            else {
                next();
            }
        });
    });
};
exports.setupExternalJWTAuth = setupExternalJWTAuth;
//# sourceMappingURL=externalJWTAuth.js.map