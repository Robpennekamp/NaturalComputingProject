"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PermissionChecker = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const typeorm_1 = require("typeorm");
const Db = __importStar(require("../Db"));
const config_1 = __importDefault(require("../config"));
const UserManagementHelper_1 = require("./UserManagementHelper");
const workflows_services_1 = require("../workflows/workflows.services");
const user_service_1 = require("../user/user.service");
class PermissionChecker {
    static async check(workflow, userId) {
        const credIdsToNodes = PermissionChecker.mapCredIdsToNodes(workflow);
        const workflowCredIds = Object.keys(credIdsToNodes);
        if (workflowCredIds.length === 0)
            return;
        const user = await Db.collections.User.findOneOrFail({
            where: { id: userId },
            relations: ['globalRole'],
        });
        if (user.globalRole.name === 'owner')
            return;
        let workflowUserIds = [userId];
        if (workflow.id && (0, UserManagementHelper_1.isSharingEnabled)()) {
            const workflowSharings = await Db.collections.SharedWorkflow.find({
                relations: ['workflow'],
                where: { workflowId: workflow.id },
            });
            workflowUserIds = workflowSharings.map((s) => s.userId);
        }
        const credentialsWhere = { userId: (0, typeorm_1.In)(workflowUserIds) };
        if (!(0, UserManagementHelper_1.isSharingEnabled)()) {
            credentialsWhere.roleId = await (0, UserManagementHelper_1.getRoleId)('credential', 'owner');
        }
        const credentialSharings = await Db.collections.SharedCredentials.find({
            where: credentialsWhere,
        });
        const accessibleCredIds = credentialSharings.map((s) => s.credentialsId);
        const inaccessibleCredIds = workflowCredIds.filter((id) => !accessibleCredIds.includes(id));
        if (inaccessibleCredIds.length === 0)
            return;
        const nodeToFlag = credIdsToNodes[inaccessibleCredIds[0]][0];
        throw new n8n_workflow_1.NodeOperationError(nodeToFlag, 'Node has no access to credential', {
            description: 'Please recreate the credential or ask its owner to share it with you.',
        });
    }
    static async checkSubworkflowExecutePolicy(subworkflow, userId, parentWorkflowId) {
        var _a, _b, _c, _d;
        if (!subworkflow.id) {
            return;
        }
        let policy = (_b = (_a = subworkflow.settings) === null || _a === void 0 ? void 0 : _a.callerPolicy) !== null && _b !== void 0 ? _b : config_1.default.getEnv('workflows.callerPolicyDefaultOption');
        if (!(0, UserManagementHelper_1.isSharingEnabled)()) {
            policy = 'workflowsFromSameOwner';
        }
        const subworkflowOwner = await (0, UserManagementHelper_1.getWorkflowOwner)(subworkflow.id);
        const errorToThrow = new n8n_workflow_1.SubworkflowOperationError(`Target workflow ID ${(_c = subworkflow.id) !== null && _c !== void 0 ? _c : ''} may not be called`, subworkflowOwner.id === userId
            ? 'Change the settings of the sub-workflow so it can be called by this one.'
            : `${subworkflowOwner.firstName} (${subworkflowOwner.email}) can make this change. You may need to tell them the ID of this workflow, which is ${subworkflow.id}`);
        if (policy === 'none') {
            throw errorToThrow;
        }
        if (policy === 'workflowsFromAList') {
            if (parentWorkflowId === undefined) {
                throw errorToThrow;
            }
            const allowedCallerIds = (_d = subworkflow.settings.callerIds) === null || _d === void 0 ? void 0 : _d.split(',').map((id) => id.trim()).filter((id) => id !== '');
            if (!(allowedCallerIds === null || allowedCallerIds === void 0 ? void 0 : allowedCallerIds.includes(parentWorkflowId))) {
                throw errorToThrow;
            }
        }
        if (policy === 'workflowsFromSameOwner') {
            const user = await user_service_1.UserService.get({ id: userId });
            if (!user) {
                throw new n8n_workflow_1.WorkflowOperationError('Fatal error: user not found. Please contact the system administrator.');
            }
            const sharing = await workflows_services_1.WorkflowsService.getSharing(user, subworkflow.id, ['role', 'user']);
            if (!sharing || sharing.role.name !== 'owner') {
                throw errorToThrow;
            }
        }
    }
    static mapCredIdsToNodes(workflow) {
        return Object.values(workflow.nodes).reduce((map, node) => {
            if (node.disabled || !node.credentials)
                return map;
            Object.values(node.credentials).forEach((cred) => {
                if (!cred.id) {
                    throw new n8n_workflow_1.NodeOperationError(node, 'Node uses invalid credential', {
                        description: 'Please recreate the credential.',
                    });
                }
                map[cred.id] = map[cred.id] ? [...map[cred.id], node] : [node];
            });
            return map;
        }, {});
    }
}
exports.PermissionChecker = PermissionChecker;
//# sourceMappingURL=PermissionChecker.js.map