"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCredentialsFromCredentialsEntity = exports.getCredentialWithoutUser = exports.getCredentialForUser = exports.CredentialsHelper = void 0;
const n8n_core_1 = require("n8n-core");
const lodash_get_1 = __importDefault(require("lodash.get"));
const n8n_workflow_1 = require("n8n-workflow");
const Db = __importStar(require("./Db"));
const WorkflowExecuteAdditionalData = __importStar(require("./WorkflowExecuteAdditionalData"));
const NodeTypes_1 = require("./NodeTypes");
const CredentialTypes_1 = require("./CredentialTypes");
const CredentialsOverwrites_1 = require("./CredentialsOverwrites");
const UserManagementHelper_1 = require("./UserManagement/UserManagementHelper");
const constants_1 = require("./constants");
const typedi_1 = require("typedi");
const mockNode = {
    name: '',
    typeVersion: 1,
    type: 'mock',
    position: [0, 0],
    parameters: {},
};
const mockNodesData = {
    mock: {
        sourcePath: '',
        type: {
            description: { properties: [] },
        },
    },
};
const mockNodeTypes = {
    getByName(nodeType) {
        var _a;
        return (_a = mockNodesData[nodeType]) === null || _a === void 0 ? void 0 : _a.type;
    },
    getByNameAndVersion(nodeType, version) {
        if (!mockNodesData[nodeType]) {
            throw new Error(`${constants_1.RESPONSE_ERROR_MESSAGES.NO_NODE}: ${nodeType}`);
        }
        return n8n_workflow_1.NodeHelpers.getVersionedNodeType(mockNodesData[nodeType].type, version);
    },
};
class CredentialsHelper extends n8n_workflow_1.ICredentialsHelper {
    constructor(encryptionKey, credentialTypes = typedi_1.Container.get(CredentialTypes_1.CredentialTypes), nodeTypes = typedi_1.Container.get(NodeTypes_1.NodeTypes)) {
        super(encryptionKey);
        this.credentialTypes = credentialTypes;
        this.nodeTypes = nodeTypes;
    }
    async authenticate(credentials, typeName, incomingRequestOptions, workflow, node, defaultTimezone) {
        const requestOptions = incomingRequestOptions;
        const credentialType = this.credentialTypes.getByName(typeName);
        if (credentialType.authenticate) {
            if (typeof credentialType.authenticate === 'function') {
                return credentialType.authenticate(credentials, requestOptions);
            }
            if (typeof credentialType.authenticate === 'object') {
                let keyResolved;
                let valueResolved;
                const { authenticate } = credentialType;
                if (requestOptions.headers === undefined) {
                    requestOptions.headers = {};
                }
                if (authenticate.type === 'generic') {
                    Object.entries(authenticate.properties).forEach(([outerKey, outerValue]) => {
                        Object.entries(outerValue).forEach(([key, value]) => {
                            keyResolved = this.resolveValue(key, { $credentials: credentials }, workflow, node, defaultTimezone);
                            valueResolved = this.resolveValue(value, { $credentials: credentials }, workflow, node, defaultTimezone);
                            if (!requestOptions[outerKey]) {
                                requestOptions[outerKey] = {};
                            }
                            requestOptions[outerKey][keyResolved] = valueResolved;
                        });
                    });
                }
            }
        }
        return requestOptions;
    }
    async preAuthentication(helpers, credentials, typeName, node, credentialsExpired) {
        var _a;
        const credentialType = this.credentialTypes.getByName(typeName);
        const expirableProperty = credentialType.properties.find((property) => { var _a; return property.type === 'hidden' && ((_a = property === null || property === void 0 ? void 0 : property.typeOptions) === null || _a === void 0 ? void 0 : _a.expirable) === true; });
        if (expirableProperty === undefined || expirableProperty.name === undefined) {
            return undefined;
        }
        const isTestingCredentials = ((_a = node === null || node === void 0 ? void 0 : node.parameters) === null || _a === void 0 ? void 0 : _a.temp) === '' && (node === null || node === void 0 ? void 0 : node.type) === 'n8n-nodes-base.noOp';
        if (credentialType.preAuthentication) {
            if (typeof credentialType.preAuthentication === 'function') {
                if (credentials[expirableProperty === null || expirableProperty === void 0 ? void 0 : expirableProperty.name] === '' ||
                    credentialsExpired ||
                    isTestingCredentials) {
                    const output = await credentialType.preAuthentication.call(helpers, credentials);
                    if (output[expirableProperty.name] === undefined) {
                        return undefined;
                    }
                    if (node.credentials) {
                        await this.updateCredentials(node.credentials[credentialType.name], credentialType.name, Object.assign(credentials, output));
                        return Object.assign(credentials, output);
                    }
                }
            }
        }
        return undefined;
    }
    resolveValue(parameterValue, additionalKeys, workflow, node, defaultTimezone) {
        if (typeof parameterValue !== 'string' || parameterValue.charAt(0) !== '=') {
            return parameterValue;
        }
        const returnValue = workflow.expression.getSimpleParameterValue(node, parameterValue, 'internal', defaultTimezone, additionalKeys, undefined, '');
        if (!returnValue) {
            return '';
        }
        return returnValue.toString();
    }
    getParentTypes(typeName) {
        return this.credentialTypes.getParentTypes(typeName);
    }
    async getCredentials(nodeCredential, type, userId) {
        if (!nodeCredential.id) {
            throw new Error(`Credential "${nodeCredential.name}" of type "${type}" has no ID.`);
        }
        const credential = userId
            ? await Db.collections.SharedCredentials.findOneOrFail({
                relations: ['credentials'],
                where: { credentials: { id: nodeCredential.id, type }, userId },
            }).then((shared) => shared.credentials)
            : await Db.collections.Credentials.findOneByOrFail({ id: nodeCredential.id, type });
        if (!credential) {
            throw new Error(`Credential with ID "${nodeCredential.id}" does not exist for type "${type}".`);
        }
        return new n8n_core_1.Credentials({ id: credential.id, name: credential.name }, credential.type, credential.nodesAccess, credential.data);
    }
    getCredentialsProperties(type) {
        const credentialTypeData = this.credentialTypes.getByName(type);
        if (credentialTypeData === undefined) {
            throw new Error(`The credentials of type "${type}" are not known.`);
        }
        if (credentialTypeData.extends === undefined) {
            if (['oAuth1Api', 'oAuth2Api'].includes(type)) {
                return [
                    ...credentialTypeData.properties,
                    {
                        displayName: 'oauthTokenData',
                        name: 'oauthTokenData',
                        type: 'json',
                        required: false,
                        default: {},
                    },
                ];
            }
            return credentialTypeData.properties;
        }
        const combineProperties = [];
        for (const credentialsTypeName of credentialTypeData.extends) {
            const mergeCredentialProperties = this.getCredentialsProperties(credentialsTypeName);
            n8n_workflow_1.NodeHelpers.mergeNodeProperties(combineProperties, mergeCredentialProperties);
        }
        n8n_workflow_1.NodeHelpers.mergeNodeProperties(combineProperties, credentialTypeData.properties);
        return combineProperties;
    }
    async getDecrypted(nodeCredentials, type, mode, defaultTimezone, raw, expressionResolveValues) {
        const credentials = await this.getCredentials(nodeCredentials, type);
        const decryptedDataOriginal = credentials.getData(this.encryptionKey);
        if (raw === true) {
            return decryptedDataOriginal;
        }
        return this.applyDefaultsAndOverwrites(decryptedDataOriginal, type, mode, defaultTimezone, expressionResolveValues);
    }
    applyDefaultsAndOverwrites(decryptedDataOriginal, type, mode, defaultTimezone, expressionResolveValues) {
        var _a;
        const credentialsProperties = this.getCredentialsProperties(type);
        const dataWithOverwrites = (0, CredentialsOverwrites_1.CredentialsOverwrites)().applyOverwrite(type, decryptedDataOriginal);
        let decryptedData = n8n_workflow_1.NodeHelpers.getNodeParameters(credentialsProperties, dataWithOverwrites, true, false, null);
        if (decryptedDataOriginal.oauthTokenData !== undefined) {
            decryptedData.oauthTokenData = decryptedDataOriginal.oauthTokenData;
        }
        if (expressionResolveValues) {
            const timezone = (_a = expressionResolveValues.workflow.settings.timezone) !== null && _a !== void 0 ? _a : defaultTimezone;
            try {
                decryptedData = expressionResolveValues.workflow.expression.getParameterValue(decryptedData, expressionResolveValues.runExecutionData, expressionResolveValues.runIndex, expressionResolveValues.itemIndex, expressionResolveValues.node.name, expressionResolveValues.connectionInputData, mode, timezone, {}, undefined, false, decryptedData);
            }
            catch (e) {
                e.message += ' [Error resolving credentials]';
                throw e;
            }
        }
        else {
            const workflow = new n8n_workflow_1.Workflow({
                nodes: [mockNode],
                connections: {},
                active: false,
                nodeTypes: mockNodeTypes,
            });
            decryptedData = workflow.expression.getComplexParameterValue(mockNode, decryptedData, mode, defaultTimezone, {}, undefined, undefined, decryptedData);
        }
        return decryptedData;
    }
    async updateCredentials(nodeCredentials, type, data) {
        const credentials = await this.getCredentials(nodeCredentials, type);
        credentials.setData(data, this.encryptionKey);
        const newCredentialsData = credentials.getDataToSave();
        newCredentialsData.updatedAt = new Date();
        const findQuery = {
            id: credentials.id,
            type,
        };
        await Db.collections.Credentials.update(findQuery, newCredentialsData);
    }
    getCredentialTestFunction(credentialType) {
        var _a, _b, _c;
        const type = this.credentialTypes.getByName(credentialType);
        if (type.test) {
            return {
                testRequest: type.test,
            };
        }
        const nodeTypesToTestWith = this.credentialTypes.getNodeTypesToTestWith(credentialType);
        for (const nodeName of nodeTypesToTestWith) {
            const node = this.nodeTypes.getByName(nodeName);
            const allNodeTypes = [];
            if (node instanceof n8n_workflow_1.VersionedNodeType) {
                allNodeTypes.push(...Object.values(node.nodeVersions));
            }
            else {
                allNodeTypes.push(node);
            }
            for (const nodeType of allNodeTypes) {
                for (const { name, testedBy } of (_a = nodeType.description.credentials) !== null && _a !== void 0 ? _a : []) {
                    if (name === credentialType && !!testedBy) {
                        if (typeof testedBy === 'string') {
                            if (node instanceof n8n_workflow_1.VersionedNodeType) {
                                const versions = Object.keys(node.nodeVersions).sort().reverse();
                                for (const version of versions) {
                                    const versionedNode = node.nodeVersions[parseInt(version, 10)];
                                    const credentialTest = (_b = versionedNode.methods) === null || _b === void 0 ? void 0 : _b.credentialTest;
                                    if (credentialTest && testedBy in credentialTest) {
                                        return credentialTest[testedBy];
                                    }
                                }
                            }
                            return (_c = node.methods) === null || _c === void 0 ? void 0 : _c.credentialTest[testedBy];
                        }
                        return {
                            nodeType,
                            testRequest: testedBy,
                        };
                    }
                }
            }
        }
        return undefined;
    }
    async testCredentials(user, credentialType, credentialsDecrypted) {
        var _a, _b;
        const credentialTestFunction = this.getCredentialTestFunction(credentialType);
        if (credentialTestFunction === undefined) {
            return {
                status: 'Error',
                message: 'No testing function found for this credential.',
            };
        }
        if (credentialsDecrypted.data) {
            credentialsDecrypted.data = (0, CredentialsOverwrites_1.CredentialsOverwrites)().applyOverwrite(credentialType, credentialsDecrypted.data);
        }
        if (typeof credentialTestFunction === 'function') {
            const credentialTestFunctions = n8n_core_1.NodeExecuteFunctions.getCredentialTestFunctions();
            return credentialTestFunction.call(credentialTestFunctions, credentialsDecrypted);
        }
        let nodeType;
        if (credentialTestFunction.nodeType) {
            nodeType = credentialTestFunction.nodeType;
        }
        else {
            nodeType = this.nodeTypes.getByNameAndVersion('n8n-nodes-base.noOp');
        }
        const node = {
            id: 'temp',
            parameters: {},
            name: 'Temp-Node',
            type: nodeType.description.name,
            typeVersion: Array.isArray(nodeType.description.version)
                ? nodeType.description.version.slice(-1)[0]
                : nodeType.description.version,
            position: [0, 0],
            credentials: {
                [credentialType]: {
                    id: credentialsDecrypted.id,
                    name: credentialsDecrypted.name,
                },
            },
        };
        const workflowData = {
            nodes: [node],
            connections: {},
        };
        const nodeTypeCopy = {
            description: {
                ...nodeType.description,
                credentials: [
                    {
                        name: credentialType,
                        required: true,
                    },
                ],
                properties: [
                    {
                        displayName: 'Temp',
                        name: 'temp',
                        type: 'string',
                        routing: {
                            request: credentialTestFunction.testRequest.request,
                        },
                        default: '',
                    },
                ],
            },
        };
        mockNodesData[nodeTypeCopy.description.name] = {
            sourcePath: '',
            type: nodeTypeCopy,
        };
        const workflow = new n8n_workflow_1.Workflow({
            nodes: workflowData.nodes,
            connections: workflowData.connections,
            active: false,
            nodeTypes: mockNodeTypes,
        });
        const mode = 'internal';
        const runIndex = 0;
        const inputData = {
            main: [[{ json: {} }]],
        };
        const connectionInputData = [];
        const runExecutionData = {
            resultData: {
                runData: {},
            },
        };
        const additionalData = await WorkflowExecuteAdditionalData.getBase(user.id, node.parameters);
        const routingNode = new n8n_workflow_1.RoutingNode(workflow, node, connectionInputData, runExecutionData !== null && runExecutionData !== void 0 ? runExecutionData : null, additionalData, mode);
        let response;
        try {
            response = await routingNode.runNode(inputData, runIndex, nodeTypeCopy, { node, data: {}, source: null }, n8n_core_1.NodeExecuteFunctions, credentialsDecrypted);
        }
        catch (error) {
            n8n_workflow_1.ErrorReporterProxy.error(error);
            if ((_a = error.cause) === null || _a === void 0 ? void 0 : _a.response) {
                const errorResponseData = {
                    statusCode: error.cause.response.status,
                    statusMessage: error.cause.response.statusText,
                };
                if (credentialTestFunction.testRequest.rules) {
                    for (const rule of credentialTestFunction.testRequest.rules) {
                        if (rule.type === 'responseCode') {
                            if (errorResponseData.statusCode === rule.properties.value) {
                                return {
                                    status: 'Error',
                                    message: rule.properties.message,
                                };
                            }
                        }
                    }
                }
                if (errorResponseData.statusCode < 199 || errorResponseData.statusCode > 299) {
                    return {
                        status: 'Error',
                        message: errorResponseData.statusMessage ||
                            `Received HTTP status code: ${errorResponseData.statusCode}`,
                    };
                }
            }
            else if ((_b = error.cause) === null || _b === void 0 ? void 0 : _b.code) {
                return {
                    status: 'Error',
                    message: error.cause.code,
                };
            }
            n8n_workflow_1.LoggerProxy.debug('Credential test failed', error);
            return {
                status: 'Error',
                message: error.message.toString(),
            };
        }
        finally {
            delete mockNodesData[nodeTypeCopy.description.name];
        }
        if (credentialTestFunction.testRequest.rules &&
            Array.isArray(credentialTestFunction.testRequest.rules)) {
            for (const rule of credentialTestFunction.testRequest.rules) {
                if (rule.type === 'responseSuccessBody') {
                    const responseData = response[0][0].json;
                    if ((0, lodash_get_1.default)(responseData, rule.properties.key) === rule.properties.value) {
                        return {
                            status: 'Error',
                            message: rule.properties.message,
                        };
                    }
                }
            }
        }
        return {
            status: 'OK',
            message: 'Connection successful!',
        };
    }
}
exports.CredentialsHelper = CredentialsHelper;
async function getCredentialForUser(credentialId, user) {
    const sharedCredential = await Db.collections.SharedCredentials.findOne({
        relations: ['credentials'],
        where: (0, UserManagementHelper_1.whereClause)({
            user,
            entityType: 'credentials',
            entityId: credentialId,
        }),
    });
    if (!sharedCredential)
        return null;
    return sharedCredential.credentials;
}
exports.getCredentialForUser = getCredentialForUser;
async function getCredentialWithoutUser(credentialId) {
    return Db.collections.Credentials.findOneBy({ id: credentialId });
}
exports.getCredentialWithoutUser = getCredentialWithoutUser;
function createCredentialsFromCredentialsEntity(credential, encrypt = false) {
    const { id, name, type, nodesAccess, data } = credential;
    if (encrypt) {
        return new n8n_core_1.Credentials({ id: null, name }, type, nodesAccess);
    }
    return new n8n_core_1.Credentials({ id, name }, type, nodesAccess, data);
}
exports.createCredentialsFromCredentialsEntity = createCredentialsFromCredentialsEntity;
//# sourceMappingURL=CredentialsHelper.js.map