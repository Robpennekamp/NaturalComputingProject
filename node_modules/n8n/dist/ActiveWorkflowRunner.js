"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActiveWorkflowRunner = void 0;
const typedi_1 = require("typedi");
const n8n_core_1 = require("n8n-core");
const n8n_workflow_1 = require("n8n-workflow");
const Db = __importStar(require("./Db"));
const ResponseHelper = __importStar(require("./ResponseHelper"));
const WebhookHelpers = __importStar(require("./WebhookHelpers"));
const WorkflowHelpers = __importStar(require("./WorkflowHelpers"));
const WorkflowExecuteAdditionalData = __importStar(require("./WorkflowExecuteAdditionalData"));
const config_1 = __importDefault(require("./config"));
const ActiveExecutions_1 = require("./ActiveExecutions");
const GenericHelpers_1 = require("./GenericHelpers");
const constants_1 = require("./constants");
const NodeTypes_1 = require("./NodeTypes");
const WorkflowRunner_1 = require("./WorkflowRunner");
const ExternalHooks_1 = require("./ExternalHooks");
const UserManagementHelper_1 = require("./UserManagement/UserManagementHelper");
const workflows_services_1 = require("./workflows/workflows.services");
const constants_2 = require("./constants");
const utils_1 = require("./utils");
const WEBHOOK_PROD_UNREGISTERED_HINT = "The workflow must be active for a production URL to run successfully. You can activate the workflow using the toggle in the top-right of the editor. Note that unlike test URL calls, production URL calls aren't shown on the canvas (only in the executions list)";
let ActiveWorkflowRunner = class ActiveWorkflowRunner {
    constructor(activeExecutions, externalHooks, nodeTypes) {
        this.activeExecutions = activeExecutions;
        this.externalHooks = externalHooks;
        this.nodeTypes = nodeTypes;
        this.activeWorkflows = new n8n_core_1.ActiveWorkflows();
        this.activationErrors = {};
        this.queuedWorkflowActivations = {};
    }
    async init() {
        const workflowsData = (await Db.collections.Workflow.find({
            where: { active: true },
            relations: ['shared', 'shared.user', 'shared.user.globalRole', 'shared.role'],
        }));
        if (!config_1.default.getEnv('endpoints.skipWebhooksDeregistrationOnShutdown')) {
            await Db.collections.Webhook.clear();
        }
        if (workflowsData.length !== 0) {
            n8n_workflow_1.LoggerProxy.info(' ================================');
            n8n_workflow_1.LoggerProxy.info('   Start Active Workflows:');
            n8n_workflow_1.LoggerProxy.info(' ================================');
            for (const workflowData of workflowsData) {
                n8n_workflow_1.LoggerProxy.info(`   - ${workflowData.name} (ID: ${workflowData.id})`);
                n8n_workflow_1.LoggerProxy.debug(`Initializing active workflow "${workflowData.name}" (startup)`, {
                    workflowName: workflowData.name,
                    workflowId: workflowData.id,
                });
                try {
                    await this.add(workflowData.id, 'init', workflowData);
                    n8n_workflow_1.LoggerProxy.verbose(`Successfully started workflow "${workflowData.name}"`, {
                        workflowName: workflowData.name,
                        workflowId: workflowData.id,
                    });
                    n8n_workflow_1.LoggerProxy.info('     => Started');
                }
                catch (error) {
                    n8n_workflow_1.ErrorReporterProxy.error(error);
                    n8n_workflow_1.LoggerProxy.info('     => ERROR: Workflow could not be activated on first try, keep on trying');
                    n8n_workflow_1.LoggerProxy.info(`               ${error.message}`);
                    n8n_workflow_1.LoggerProxy.error(`Issue on initial workflow activation try "${workflowData.name}" (startup)`, {
                        workflowName: workflowData.name,
                        workflowId: workflowData.id,
                    });
                    this.executeErrorWorkflow(error, workflowData, 'internal');
                    this.addQueuedWorkflowActivation('init', workflowData);
                }
            }
            n8n_workflow_1.LoggerProxy.verbose('Finished initializing active workflows (startup)');
        }
        await this.externalHooks.run('activeWorkflows.initialized', []);
    }
    async removeAll() {
        let activeWorkflowIds = [];
        n8n_workflow_1.LoggerProxy.verbose('Call to remove all active workflows received (removeAll)');
        activeWorkflowIds.push.apply(activeWorkflowIds, this.activeWorkflows.allActiveWorkflows());
        const activeWorkflows = await this.getActiveWorkflows();
        activeWorkflowIds = [
            ...activeWorkflowIds,
            ...activeWorkflows.map((workflow) => workflow.id.toString()),
        ];
        activeWorkflowIds = Array.from(new Set(activeWorkflowIds));
        const removePromises = [];
        for (const workflowId of activeWorkflowIds) {
            removePromises.push(this.remove(workflowId));
        }
        await Promise.all(removePromises);
    }
    async executeWebhook(httpMethod, path, req, res) {
        n8n_workflow_1.LoggerProxy.debug(`Received webhook "${httpMethod}" for path "${path}"`);
        req.params = {};
        if (path.endsWith('/')) {
            path = path.slice(0, -1);
        }
        let webhook = await Db.collections.Webhook.findOneBy({
            webhookPath: path,
            method: httpMethod,
        });
        let webhookId;
        if (webhook === null) {
            const pathElements = path.split('/');
            webhookId = pathElements.shift();
            const dynamicWebhooks = await Db.collections.Webhook.findBy({
                webhookId,
                method: httpMethod,
                pathLength: pathElements.length,
            });
            if (dynamicWebhooks === undefined || dynamicWebhooks.length === 0) {
                throw new ResponseHelper.NotFoundError((0, utils_1.webhookNotFoundErrorMessage)(path, httpMethod), WEBHOOK_PROD_UNREGISTERED_HINT);
            }
            let maxMatches = 0;
            const pathElementsSet = new Set(pathElements);
            dynamicWebhooks.forEach((dynamicWebhook) => {
                const staticElements = dynamicWebhook.webhookPath
                    .split('/')
                    .filter((ele) => !ele.startsWith(':'));
                const allStaticExist = staticElements.every((staticEle) => pathElementsSet.has(staticEle));
                if (allStaticExist && staticElements.length > maxMatches) {
                    maxMatches = staticElements.length;
                    webhook = dynamicWebhook;
                }
                else if (staticElements.length === 0 && !webhook) {
                    webhook = dynamicWebhook;
                }
            });
            if (webhook === null) {
                throw new ResponseHelper.NotFoundError((0, utils_1.webhookNotFoundErrorMessage)(path, httpMethod), WEBHOOK_PROD_UNREGISTERED_HINT);
            }
            path = webhook.webhookPath;
            webhook.webhookPath.split('/').forEach((ele, index) => {
                if (ele.startsWith(':')) {
                    req.params[ele.slice(1)] = pathElements[index];
                }
            });
        }
        const workflowData = await Db.collections.Workflow.findOne({
            where: { id: webhook.workflowId },
            relations: ['shared', 'shared.user', 'shared.user.globalRole'],
        });
        if (workflowData === null) {
            throw new ResponseHelper.NotFoundError(`Could not find workflow with id "${webhook.workflowId}"`);
        }
        const workflow = new n8n_workflow_1.Workflow({
            id: webhook.workflowId,
            name: workflowData.name,
            nodes: workflowData.nodes,
            connections: workflowData.connections,
            active: workflowData.active,
            nodeTypes: this.nodeTypes,
            staticData: workflowData.staticData,
            settings: workflowData.settings,
        });
        const additionalData = await WorkflowExecuteAdditionalData.getBase(workflowData.shared[0].user.id);
        const webhookData = n8n_workflow_1.NodeHelpers.getNodeWebhooks(workflow, workflow.getNode(webhook.node), additionalData).filter((webhook) => {
            return webhook.httpMethod === httpMethod && webhook.path === path;
        })[0];
        const workflowStartNode = workflow.getNode(webhookData.node);
        if (workflowStartNode === null) {
            throw new ResponseHelper.NotFoundError('Could not find node to process webhook.');
        }
        return new Promise((resolve, reject) => {
            const executionMode = 'webhook';
            WebhookHelpers.executeWebhook(workflow, webhookData, workflowData, workflowStartNode, executionMode, undefined, undefined, undefined, req, res, (error, data) => {
                if (error !== null) {
                    return reject(error);
                }
                resolve(data);
            });
        });
    }
    async getWebhookMethods(path) {
        const webhooks = await Db.collections.Webhook.find({
            select: ['method'],
            where: { webhookPath: path },
        });
        return webhooks.map((webhook) => webhook.method);
    }
    async getActiveWorkflows(user) {
        let activeWorkflows = [];
        if (!user || user.globalRole.name === 'owner') {
            activeWorkflows = await Db.collections.Workflow.find({
                select: ['id'],
                where: { active: true },
            });
        }
        else {
            const shared = await Db.collections.SharedWorkflow.find({
                relations: ['workflow'],
                where: (0, UserManagementHelper_1.whereClause)({
                    user,
                    entityType: 'workflow',
                }),
            });
            activeWorkflows = shared.reduce((acc, cur) => {
                if (cur.workflow.active)
                    acc.push(cur.workflow);
                return acc;
            }, []);
        }
        return activeWorkflows.filter((workflow) => this.activationErrors[workflow.id] === undefined);
    }
    async isActive(id) {
        const workflow = await Db.collections.Workflow.findOne({
            select: ['active'],
            where: { id },
        });
        return !!(workflow === null || workflow === void 0 ? void 0 : workflow.active);
    }
    getActivationError(id) {
        if (this.activationErrors[id] === undefined) {
            return undefined;
        }
        return this.activationErrors[id];
    }
    async addWorkflowWebhooks(workflow, additionalData, mode, activation) {
        const webhooks = WebhookHelpers.getWorkflowWebhooks(workflow, additionalData, undefined, true);
        let path = '';
        for (const webhookData of webhooks) {
            const node = workflow.getNode(webhookData.node);
            node.name = webhookData.node;
            path = webhookData.path;
            const webhook = {
                workflowId: webhookData.workflowId,
                webhookPath: path,
                node: node.name,
                method: webhookData.httpMethod,
            };
            if (webhook.webhookPath.startsWith('/')) {
                webhook.webhookPath = webhook.webhookPath.slice(1);
            }
            if (webhook.webhookPath.endsWith('/')) {
                webhook.webhookPath = webhook.webhookPath.slice(0, -1);
            }
            if ((path.startsWith(':') || path.includes('/:')) && node.webhookId) {
                webhook.webhookId = node.webhookId;
                webhook.pathLength = webhook.webhookPath.split('/').length;
            }
            try {
                await Db.collections.Webhook.insert(webhook);
                const webhookExists = await workflow.runWebhookMethod('checkExists', webhookData, n8n_core_1.NodeExecuteFunctions, mode, activation, false);
                if (webhookExists !== true) {
                    await workflow.runWebhookMethod('create', webhookData, n8n_core_1.NodeExecuteFunctions, mode, activation, false);
                }
            }
            catch (error) {
                if (activation === 'init' &&
                    config_1.default.getEnv('endpoints.skipWebhooksDeregistrationOnShutdown') &&
                    error.name === 'QueryFailedError') {
                    continue;
                }
                try {
                    await this.removeWorkflowWebhooks(workflow.id);
                }
                catch (error) {
                    n8n_workflow_1.ErrorReporterProxy.error(error);
                    n8n_workflow_1.LoggerProxy.error(`Could not remove webhooks of workflow "${workflow.id}" because of error: "${error.message}"`);
                }
                if (error.name === 'QueryFailedError') {
                    error = new Error(`The URL path that the "${webhook.node}" node uses is already taken. Please change it to something else.`, { cause: error });
                }
                else if (error.detail) {
                    error.message = error.detail;
                }
                throw error;
            }
        }
        await WorkflowHelpers.saveStaticData(workflow);
    }
    async removeWorkflowWebhooks(workflowId) {
        const workflowData = await Db.collections.Workflow.findOne({
            where: { id: workflowId },
            relations: ['shared', 'shared.user', 'shared.user.globalRole'],
        });
        if (workflowData === null) {
            throw new Error(`Could not find workflow with id "${workflowId}"`);
        }
        const workflow = new n8n_workflow_1.Workflow({
            id: workflowId,
            name: workflowData.name,
            nodes: workflowData.nodes,
            connections: workflowData.connections,
            active: workflowData.active,
            nodeTypes: this.nodeTypes,
            staticData: workflowData.staticData,
            settings: workflowData.settings,
        });
        const mode = 'internal';
        const additionalData = await WorkflowExecuteAdditionalData.getBase(workflowData.shared[0].user.id);
        const webhooks = WebhookHelpers.getWorkflowWebhooks(workflow, additionalData, undefined, true);
        for (const webhookData of webhooks) {
            await workflow.runWebhookMethod('delete', webhookData, n8n_core_1.NodeExecuteFunctions, mode, 'update', false);
        }
        await WorkflowHelpers.saveStaticData(workflow);
        await Db.collections.Webhook.delete({
            workflowId: workflowData.id,
        });
    }
    async runWorkflow(workflowData, node, data, additionalData, mode, responsePromise) {
        const nodeExecutionStack = [
            {
                node,
                data: {
                    main: data,
                },
                source: null,
            },
        ];
        const executionData = {
            startData: {},
            resultData: {
                runData: {},
            },
            executionData: {
                contextData: {},
                nodeExecutionStack,
                waitingExecution: {},
                waitingExecutionSource: {},
            },
        };
        const runData = {
            userId: additionalData.userId,
            executionMode: mode,
            executionData,
            workflowData,
        };
        const workflowRunner = new WorkflowRunner_1.WorkflowRunner();
        return workflowRunner.run(runData, true, undefined, undefined, responsePromise);
    }
    getExecutePollFunctions(workflowData, additionalData, mode, activation) {
        return (workflow, node) => {
            const returnFunctions = n8n_core_1.NodeExecuteFunctions.getExecutePollFunctions(workflow, node, additionalData, mode, activation);
            returnFunctions.__emit = (data, responsePromise, donePromise) => {
                n8n_workflow_1.LoggerProxy.debug(`Received event to trigger execution for workflow "${workflow.name}"`);
                WorkflowHelpers.saveStaticData(workflow);
                const executePromise = this.runWorkflow(workflowData, node, data, additionalData, mode, responsePromise);
                if (donePromise) {
                    executePromise.then((executionId) => {
                        this.activeExecutions
                            .getPostExecutePromise(executionId)
                            .then(donePromise.resolve)
                            .catch(donePromise.reject);
                    });
                }
                else {
                    executePromise.catch(n8n_workflow_1.LoggerProxy.error);
                }
            };
            returnFunctions.__emitError = async (error) => {
                await (0, GenericHelpers_1.createErrorExecution)(error, node, workflowData, workflow, mode);
                this.executeErrorWorkflow(error, workflowData, mode);
            };
            return returnFunctions;
        };
    }
    getExecuteTriggerFunctions(workflowData, additionalData, mode, activation) {
        return (workflow, node) => {
            const returnFunctions = n8n_core_1.NodeExecuteFunctions.getExecuteTriggerFunctions(workflow, node, additionalData, mode, activation);
            returnFunctions.emit = (data, responsePromise, donePromise) => {
                n8n_workflow_1.LoggerProxy.debug(`Received trigger for workflow "${workflow.name}"`);
                WorkflowHelpers.saveStaticData(workflow);
                const executePromise = this.runWorkflow(workflowData, node, data, additionalData, mode, responsePromise);
                if (donePromise) {
                    executePromise.then((executionId) => {
                        this.activeExecutions
                            .getPostExecutePromise(executionId)
                            .then(donePromise.resolve)
                            .catch(donePromise.reject);
                    });
                }
                else {
                    executePromise.catch(n8n_workflow_1.LoggerProxy.error);
                }
            };
            returnFunctions.emitError = async (error) => {
                n8n_workflow_1.LoggerProxy.info(`The trigger node "${node.name}" of workflow "${workflowData.name}" failed with the error: "${error.message}". Will try to reactivate.`, {
                    nodeName: node.name,
                    workflowId: workflowData.id,
                    workflowName: workflowData.name,
                });
                await this.activeWorkflows.remove(workflowData.id);
                this.activationErrors[workflowData.id] = {
                    time: new Date().getTime(),
                    error: {
                        message: error.message,
                    },
                };
                const activationError = new n8n_workflow_1.WorkflowActivationError(`There was a problem with the trigger node "${node.name}", for that reason did the workflow had to be deactivated`, { cause: error, node });
                this.executeErrorWorkflow(activationError, workflowData, mode);
                this.addQueuedWorkflowActivation(activation, workflowData);
            };
            return returnFunctions;
        };
    }
    executeErrorWorkflow(error, workflowData, mode) {
        const fullRunData = {
            data: {
                resultData: {
                    error,
                    runData: {},
                },
            },
            finished: false,
            mode,
            startedAt: new Date(),
            stoppedAt: new Date(),
            status: 'running',
        };
        WorkflowExecuteAdditionalData.executeErrorWorkflow(workflowData, fullRunData, mode);
    }
    async add(workflowId, activation, workflowData) {
        let workflowInstance;
        try {
            if (workflowData === undefined) {
                workflowData = (await Db.collections.Workflow.findOne({
                    where: { id: workflowId },
                    relations: ['shared', 'shared.user', 'shared.user.globalRole', 'shared.role'],
                }));
            }
            if (!workflowData) {
                throw new Error(`Could not find workflow with id "${workflowId}".`);
            }
            workflowInstance = new n8n_workflow_1.Workflow({
                id: workflowId,
                name: workflowData.name,
                nodes: workflowData.nodes,
                connections: workflowData.connections,
                active: workflowData.active,
                nodeTypes: this.nodeTypes,
                staticData: workflowData.staticData,
                settings: workflowData.settings,
            });
            const canBeActivated = workflowInstance.checkIfWorkflowCanBeActivated(constants_2.START_NODES);
            if (!canBeActivated) {
                n8n_workflow_1.LoggerProxy.error(`Unable to activate workflow "${workflowData.name}"`);
                throw new Error('The workflow can not be activated because it does not contain any nodes which could start the workflow. Only workflows which have trigger or webhook nodes can be activated.');
            }
            const mode = 'trigger';
            const workflowOwner = workflowData.shared.find((shared) => shared.role.name === 'owner');
            if (!workflowOwner) {
                throw new Error('Workflow cannot be activated because it has no owner');
            }
            const additionalData = await WorkflowExecuteAdditionalData.getBase(workflowOwner.user.id);
            const getTriggerFunctions = this.getExecuteTriggerFunctions(workflowData, additionalData, mode, activation);
            const getPollFunctions = this.getExecutePollFunctions(workflowData, additionalData, mode, activation);
            await this.addWorkflowWebhooks(workflowInstance, additionalData, mode, activation);
            if (workflowInstance.getTriggerNodes().length !== 0 ||
                workflowInstance.getPollNodes().length !== 0) {
                await this.activeWorkflows.add(workflowId, workflowInstance, additionalData, mode, activation, getTriggerFunctions, getPollFunctions);
                n8n_workflow_1.LoggerProxy.verbose(`Successfully activated workflow "${workflowData.name}"`, {
                    workflowId,
                    workflowName: workflowData.name,
                });
            }
            this.removeQueuedWorkflowActivation(workflowId);
            if (this.activationErrors[workflowId] !== undefined) {
                delete this.activationErrors[workflowId];
            }
            if (workflowInstance.id) {
                const triggerFilter = (nodeType) => !!nodeType.trigger && !nodeType.description.name.includes('manualTrigger');
                const triggerCount = workflowInstance.queryNodes(triggerFilter).length +
                    workflowInstance.getPollNodes().length +
                    WebhookHelpers.getWorkflowWebhooks(workflowInstance, additionalData, undefined, true)
                        .length;
                await workflows_services_1.WorkflowsService.updateWorkflowTriggerCount(workflowInstance.id, triggerCount);
            }
        }
        catch (error) {
            this.activationErrors[workflowId] = {
                time: new Date().getTime(),
                error: {
                    message: error.message,
                },
            };
            throw error;
        }
        await WorkflowHelpers.saveStaticData(workflowInstance);
    }
    addQueuedWorkflowActivation(activationMode, workflowData) {
        const workflowId = workflowData.id;
        const workflowName = workflowData.name;
        const retryFunction = async () => {
            n8n_workflow_1.LoggerProxy.info(`Try to activate workflow "${workflowName}" (${workflowId})`, {
                workflowId,
                workflowName,
            });
            try {
                await this.add(workflowId, activationMode, workflowData);
            }
            catch (error) {
                n8n_workflow_1.ErrorReporterProxy.error(error);
                let lastTimeout = this.queuedWorkflowActivations[workflowId].lastTimeout;
                if (lastTimeout < constants_1.WORKFLOW_REACTIVATE_MAX_TIMEOUT) {
                    lastTimeout = Math.min(lastTimeout * 2, constants_1.WORKFLOW_REACTIVATE_MAX_TIMEOUT);
                }
                n8n_workflow_1.LoggerProxy.info(` -> Activation of workflow "${workflowName}" (${workflowId}) did fail with error: "${error.message}" | retry in ${Math.floor(lastTimeout / 1000)} seconds`, {
                    workflowId,
                    workflowName,
                });
                this.queuedWorkflowActivations[workflowId].lastTimeout = lastTimeout;
                this.queuedWorkflowActivations[workflowId].timeout = setTimeout(retryFunction, lastTimeout);
                return;
            }
            n8n_workflow_1.LoggerProxy.info(` -> Activation of workflow "${workflowName}" (${workflowId}) was successful!`, {
                workflowId,
                workflowName,
            });
        };
        this.removeQueuedWorkflowActivation(workflowId);
        this.queuedWorkflowActivations[workflowId] = {
            activationMode,
            lastTimeout: constants_1.WORKFLOW_REACTIVATE_INITIAL_TIMEOUT,
            timeout: setTimeout(retryFunction, constants_1.WORKFLOW_REACTIVATE_INITIAL_TIMEOUT),
            workflowData,
        };
    }
    removeQueuedWorkflowActivation(workflowId) {
        if (this.queuedWorkflowActivations[workflowId]) {
            clearTimeout(this.queuedWorkflowActivations[workflowId].timeout);
            delete this.queuedWorkflowActivations[workflowId];
        }
    }
    removeAllQueuedWorkflowActivations() {
        for (const workflowId in this.queuedWorkflowActivations) {
            this.removeQueuedWorkflowActivation(workflowId);
        }
    }
    async remove(workflowId) {
        try {
            await this.removeWorkflowWebhooks(workflowId);
        }
        catch (error) {
            n8n_workflow_1.ErrorReporterProxy.error(error);
            n8n_workflow_1.LoggerProxy.error(`Could not remove webhooks of workflow "${workflowId}" because of error: "${error.message}"`);
        }
        if (this.activationErrors[workflowId] !== undefined) {
            delete this.activationErrors[workflowId];
        }
        if (this.queuedWorkflowActivations[workflowId] !== undefined) {
            this.removeQueuedWorkflowActivation(workflowId);
        }
        if (this.activeWorkflows.isActive(workflowId)) {
            await this.activeWorkflows.remove(workflowId);
            n8n_workflow_1.LoggerProxy.verbose(`Successfully deactivated workflow "${workflowId}"`, { workflowId });
        }
    }
};
ActiveWorkflowRunner = __decorate([
    (0, typedi_1.Service)(),
    __metadata("design:paramtypes", [ActiveExecutions_1.ActiveExecutions,
        ExternalHooks_1.ExternalHooks,
        NodeTypes_1.NodeTypes])
], ActiveWorkflowRunner);
exports.ActiveWorkflowRunner = ActiveWorkflowRunner;
//# sourceMappingURL=ActiveWorkflowRunner.js.map