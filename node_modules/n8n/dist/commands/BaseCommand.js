"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseCommand = exports.UM_FIX_INSTRUCTION = void 0;
const command_1 = require("@oclif/command");
const errors_1 = require("@oclif/errors");
const typedi_1 = require("typedi");
const n8n_workflow_1 = require("n8n-workflow");
const n8n_core_1 = require("n8n-core");
const Logger_1 = require("../Logger");
const config_1 = __importDefault(require("../config"));
const Db = __importStar(require("../Db"));
const CrashJournal = __importStar(require("../CrashJournal"));
const constants_1 = require("../constants");
const CredentialTypes_1 = require("../CredentialTypes");
const CredentialsOverwrites_1 = require("../CredentialsOverwrites");
const ErrorReporting_1 = require("../ErrorReporting");
const ExternalHooks_1 = require("../ExternalHooks");
const NodeTypes_1 = require("../NodeTypes");
const LoadNodesAndCredentials_1 = require("../LoadNodesAndCredentials");
const InternalHooks_1 = require("../InternalHooks");
const posthog_1 = require("../posthog");
exports.UM_FIX_INSTRUCTION = 'Please fix the database by running ./packages/cli/bin/n8n user-management:reset';
class BaseCommand extends command_1.Command {
    constructor() {
        super(...arguments);
        this.logger = n8n_workflow_1.LoggerProxy.init((0, Logger_1.getLogger)());
    }
    async init() {
        var _a, _b;
        await (0, ErrorReporting_1.initErrorHandling)();
        process.once('SIGTERM', async () => this.stopProcess());
        process.once('SIGINT', async () => this.stopProcess());
        this.userSettings = await n8n_core_1.UserSettings.prepareUserSettings();
        this.loadNodesAndCredentials = typedi_1.Container.get(LoadNodesAndCredentials_1.LoadNodesAndCredentials);
        await this.loadNodesAndCredentials.init();
        this.nodeTypes = typedi_1.Container.get(NodeTypes_1.NodeTypes);
        this.nodeTypes.init();
        const credentialTypes = typedi_1.Container.get(CredentialTypes_1.CredentialTypes);
        (0, CredentialsOverwrites_1.CredentialsOverwrites)(credentialTypes);
        await Db.init().catch(async (error) => this.exitWithCrash('There was an error initializing DB', error));
        await ((_a = this.server) === null || _a === void 0 ? void 0 : _a.init());
        await Db.migrate().catch(async (error) => this.exitWithCrash('There was an error running database migrations', error));
        if (process.env.WEBHOOK_TUNNEL_URL) {
            n8n_workflow_1.LoggerProxy.warn('You are still using the WEBHOOK_TUNNEL_URL environment variable. It has been deprecated and will be removed in a future version of n8n. Please switch to using WEBHOOK_URL instead.');
        }
        const dbType = config_1.default.getEnv('database.type');
        if (['mysqldb', 'mariadb'].includes(dbType)) {
            n8n_workflow_1.LoggerProxy.warn('Support for MySQL/MariaDB has been deprecated and will be removed with an upcoming version of n8n. Please migrate to PostgreSQL.');
        }
        if (process.env.EXECUTIONS_PROCESS === 'own') {
            n8n_workflow_1.LoggerProxy.warn('Own mode has been deprecated and will be removed in a future version of n8n. If you need the isolation and performance gains, please consider using queue mode.');
        }
        this.instanceId = (_b = this.userSettings.instanceId) !== null && _b !== void 0 ? _b : '';
        await typedi_1.Container.get(posthog_1.PostHogClient).init(this.instanceId);
        await typedi_1.Container.get(InternalHooks_1.InternalHooks).init(this.instanceId);
    }
    async stopProcess() {
    }
    async initCrashJournal() {
        await CrashJournal.init();
    }
    async exitSuccessFully() {
        try {
            await CrashJournal.cleanup();
        }
        finally {
            process.exit();
        }
    }
    async exitWithCrash(message, error) {
        n8n_workflow_1.ErrorReporterProxy.error(new Error(message, { cause: error }), { level: 'fatal' });
        await (0, n8n_workflow_1.sleep)(2000);
        process.exit(1);
    }
    async initBinaryManager() {
        const binaryDataConfig = config_1.default.getEnv('binaryDataManager');
        await n8n_core_1.BinaryDataManager.init(binaryDataConfig, true);
    }
    async initExternalHooks() {
        this.externalHooks = typedi_1.Container.get(ExternalHooks_1.ExternalHooks);
        await this.externalHooks.init();
    }
    async finally(error) {
        if (constants_1.inTest || this.id === 'start')
            return;
        if (Db.connectionState.connected) {
            await (0, n8n_workflow_1.sleep)(100);
            await Db.close();
        }
        const exitCode = error instanceof errors_1.ExitError ? error.oclif.exit : error ? 1 : 0;
        this.exit(exitCode);
    }
}
exports.BaseCommand = BaseCommand;
//# sourceMappingURL=BaseCommand.js.map