"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Start = void 0;
const typedi_1 = require("typedi");
const path_1 = __importDefault(require("path"));
const promises_1 = require("fs/promises");
const fs_1 = require("fs");
const localtunnel_1 = __importDefault(require("localtunnel"));
const n8n_core_1 = require("n8n-core");
const command_1 = require("@oclif/command");
const stream_1 = __importDefault(require("stream"));
const replacestream_1 = __importDefault(require("replacestream"));
const util_1 = require("util");
const fast_glob_1 = __importDefault(require("fast-glob"));
const n8n_workflow_1 = require("n8n-workflow");
const crypto_1 = require("crypto");
const config_1 = __importDefault(require("../config"));
const ActiveExecutions_1 = require("../ActiveExecutions");
const ActiveWorkflowRunner_1 = require("../ActiveWorkflowRunner");
const Db = __importStar(require("../Db"));
const GenericHelpers = __importStar(require("../GenericHelpers"));
const Server_1 = require("../Server");
const TestWebhooks_1 = require("../TestWebhooks");
const packageModel_1 = require("../CommunityNodes/packageModel");
const constants_1 = require("../constants");
const eventbus_1 = require("../eventbus");
const BaseCommand_1 = require("./BaseCommand");
const InternalHooks_1 = require("../InternalHooks");
const License_1 = require("../License");
const open = require('open');
const pipeline = (0, util_1.promisify)(stream_1.default.pipeline);
class Start extends BaseCommand_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.server = new Server_1.Server();
    }
    openBrowser() {
        const editorUrl = GenericHelpers.getBaseUrl();
        open(editorUrl, { wait: true }).catch((error) => {
            console.log(`\nWas not able to open URL in browser. Please open manually by visiting:\n${editorUrl}\n`);
        });
    }
    async stopProcess() {
        this.logger.info('\nStopping n8n...');
        try {
            this.activeWorkflowRunner.removeAllQueuedWorkflowActivations();
            await this.externalHooks.run('n8n.stop', []);
            setTimeout(async () => {
                console.log('process exited after 30s');
                await this.exitSuccessFully();
            }, 30000);
            await typedi_1.Container.get(InternalHooks_1.InternalHooks).onN8nStop();
            const skipWebhookDeregistration = config_1.default.getEnv('endpoints.skipWebhooksDeregistrationOnShutdown');
            const removePromises = [];
            if (!skipWebhookDeregistration) {
                removePromises.push(this.activeWorkflowRunner.removeAll());
            }
            const testWebhooks = typedi_1.Container.get(TestWebhooks_1.TestWebhooks);
            removePromises.push(testWebhooks.removeAll());
            await Promise.all(removePromises);
            const activeExecutionsInstance = typedi_1.Container.get(ActiveExecutions_1.ActiveExecutions);
            let executingWorkflows = activeExecutionsInstance.getActiveExecutions();
            let count = 0;
            while (executingWorkflows.length !== 0) {
                if (count++ % 4 === 0) {
                    console.log(`Waiting for ${executingWorkflows.length} active executions to finish...`);
                    executingWorkflows.map((execution) => {
                        console.log(` - Execution ID ${execution.id}, workflow ID: ${execution.workflowId}`);
                    });
                }
                await (0, n8n_workflow_1.sleep)(500);
                executingWorkflows = activeExecutionsInstance.getActiveExecutions();
            }
            await eventbus_1.eventBus.close();
        }
        catch (error) {
            await this.exitWithCrash('There was an error shutting down n8n.', error);
        }
        await this.exitSuccessFully();
    }
    async generateStaticAssets() {
        const n8nPath = config_1.default.getEnv('path');
        const restEndpoint = config_1.default.getEnv('endpoints.rest');
        const hooksUrls = config_1.default.getEnv('externalFrontendHooksUrls');
        let scriptsString = '';
        if (hooksUrls) {
            scriptsString = hooksUrls.split(';').reduce((acc, curr) => {
                return `${acc}<script src="${curr}"></script>`;
            }, '');
        }
        const closingTitleTag = '</title>';
        const compileFile = async (fileName) => {
            const filePath = path_1.default.join(constants_1.EDITOR_UI_DIST_DIR, fileName);
            if (/(index\.html)|.*\.(js|css)/.test(filePath) && (0, fs_1.existsSync)(filePath)) {
                const destFile = path_1.default.join(constants_1.GENERATED_STATIC_DIR, fileName);
                await (0, promises_1.mkdir)(path_1.default.dirname(destFile), { recursive: true });
                const streams = [
                    (0, fs_1.createReadStream)(filePath, 'utf-8'),
                    (0, replacestream_1.default)('/{{BASE_PATH}}/', n8nPath, { ignoreCase: false }),
                    (0, replacestream_1.default)('/%7B%7BBASE_PATH%7D%7D/', n8nPath, { ignoreCase: false }),
                    (0, replacestream_1.default)('/static/', n8nPath + 'static/', { ignoreCase: false }),
                ];
                if (filePath.endsWith('index.html')) {
                    streams.push((0, replacestream_1.default)('{{REST_ENDPOINT}}', restEndpoint, { ignoreCase: false }), (0, replacestream_1.default)(closingTitleTag, closingTitleTag + scriptsString, {
                        ignoreCase: false,
                    }));
                }
                streams.push((0, fs_1.createWriteStream)(destFile, 'utf-8'));
                return pipeline(streams);
            }
        };
        await compileFile('index.html');
        const files = await (0, fast_glob_1.default)('**/*.{css,js}', { cwd: constants_1.EDITOR_UI_DIST_DIR });
        await Promise.all(files.map(compileFile));
    }
    async initLicense() {
        const license = typedi_1.Container.get(License_1.License);
        await license.init(this.instanceId);
        const activationKey = config_1.default.getEnv('license.activationKey');
        if (activationKey) {
            const hasCert = (await license.loadCertStr()).length > 0;
            if (hasCert) {
                return n8n_workflow_1.LoggerProxy.debug('Skipping license activation');
            }
            try {
                n8n_workflow_1.LoggerProxy.debug('Attempting license activation');
                await license.activate(activationKey);
            }
            catch (e) {
                n8n_workflow_1.LoggerProxy.error('Could not activate license', e);
            }
        }
    }
    async init() {
        await this.initCrashJournal();
        await super.init();
        this.logger.info('Initializing n8n process');
        this.activeWorkflowRunner = typedi_1.Container.get(ActiveWorkflowRunner_1.ActiveWorkflowRunner);
        await this.initLicense();
        await this.initBinaryManager();
        await this.initExternalHooks();
        if (!config_1.default.getEnv('endpoints.disableUi')) {
            await this.generateStaticAssets();
        }
    }
    async run() {
        const { flags } = this.parse(Start);
        if (!config_1.default.getEnv('userManagement.jwtSecret')) {
            const encryptionKey = await n8n_core_1.UserSettings.getEncryptionKey();
            let baseKey = '';
            for (let i = 0; i < encryptionKey.length; i += 2) {
                baseKey += encryptionKey[i];
            }
            config_1.default.set('userManagement.jwtSecret', (0, crypto_1.createHash)('sha256').update(baseKey).digest('hex'));
        }
        await this.loadNodesAndCredentials.generateTypesForFrontend();
        const installedPackages = await (0, packageModel_1.getAllInstalledPackages)();
        const missingPackages = new Set();
        installedPackages.forEach((installedPackage) => {
            installedPackage.installedNodes.forEach((installedNode) => {
                if (!this.loadNodesAndCredentials.known.nodes[installedNode.type]) {
                    missingPackages.add({
                        packageName: installedPackage.packageName,
                        version: installedPackage.installedVersion,
                    });
                }
            });
        });
        await n8n_core_1.UserSettings.getEncryptionKey();
        const databaseSettings = await Db.collections.Settings.findBy({ loadOnStartup: true });
        databaseSettings.forEach((setting) => {
            config_1.default.set(setting.key, (0, n8n_workflow_1.jsonParse)(setting.value, { fallbackValue: setting.value }));
        });
        config_1.default.set('nodes.packagesMissing', '');
        if (missingPackages.size) {
            n8n_workflow_1.LoggerProxy.error('n8n detected that some packages are missing. For more information, visit https://docs.n8n.io/integrations/community-nodes/troubleshooting/');
            if (flags.reinstallMissingPackages || process.env.N8N_REINSTALL_MISSING_PACKAGES) {
                n8n_workflow_1.LoggerProxy.info('Attempting to reinstall missing packages', { missingPackages });
                try {
                    for (const missingPackage of missingPackages) {
                        await this.loadNodesAndCredentials.installNpmModule(missingPackage.packageName, missingPackage.version);
                        missingPackages.delete(missingPackage);
                    }
                    n8n_workflow_1.LoggerProxy.info('Packages reinstalled successfully. Resuming regular initialization.');
                }
                catch (error) {
                    n8n_workflow_1.LoggerProxy.error('n8n was unable to install the missing packages.');
                }
            }
            config_1.default.set('nodes.packagesMissing', Array.from(missingPackages)
                .map((missingPackage) => `${missingPackage.packageName}@${missingPackage.version}`)
                .join(' '));
        }
        const dbType = config_1.default.getEnv('database.type');
        if (dbType === 'sqlite') {
            const shouldRunVacuum = config_1.default.getEnv('database.sqlite.executeVacuumOnStartup');
            if (shouldRunVacuum) {
                await Db.collections.Execution.query('VACUUM;');
            }
        }
        if (flags.tunnel) {
            this.log('\nWaiting for tunnel ...');
            let tunnelSubdomain;
            if (process.env[n8n_core_1.TUNNEL_SUBDOMAIN_ENV] !== undefined &&
                process.env[n8n_core_1.TUNNEL_SUBDOMAIN_ENV] !== '') {
                tunnelSubdomain = process.env[n8n_core_1.TUNNEL_SUBDOMAIN_ENV];
            }
            else if (this.userSettings.tunnelSubdomain !== undefined) {
                tunnelSubdomain = this.userSettings.tunnelSubdomain;
            }
            if (tunnelSubdomain === undefined) {
                const availableCharacters = 'abcdefghijklmnopqrstuvwxyz0123456789';
                this.userSettings.tunnelSubdomain = Array.from({ length: 24 })
                    .map(() => {
                    return availableCharacters.charAt(Math.floor(Math.random() * availableCharacters.length));
                })
                    .join('');
                await n8n_core_1.UserSettings.writeUserSettings(this.userSettings);
            }
            const tunnelSettings = {
                host: 'https://hooks.n8n.cloud',
                subdomain: tunnelSubdomain,
            };
            const port = config_1.default.getEnv('port');
            const webhookTunnel = await (0, localtunnel_1.default)(port, tunnelSettings);
            process.env.WEBHOOK_URL = `${webhookTunnel.url}/`;
            this.log(`Tunnel URL: ${process.env.WEBHOOK_URL}\n`);
            this.log('IMPORTANT! Do not share with anybody as it would give people access to your n8n instance!');
        }
        await this.server.start();
        await this.activeWorkflowRunner.init();
        const editorUrl = GenericHelpers.getBaseUrl();
        this.log(`\nEditor is now accessible via:\n${editorUrl}`);
        const saveManualExecutions = config_1.default.getEnv('executions.saveDataManualExecutions');
        if (saveManualExecutions) {
            this.log('\nManual executions will be visible only for the owner');
        }
        if (Boolean(process.stdout.isTTY) && process.stdin.setRawMode) {
            process.stdin.setRawMode(true);
            process.stdin.resume();
            process.stdin.setEncoding('utf8');
            if (flags.open) {
                this.openBrowser();
            }
            this.log('\nPress "o" to open in Browser.');
            process.stdin.on('data', (key) => {
                if (key === 'o') {
                    this.openBrowser();
                }
                else if (key.charCodeAt(0) === 3) {
                    this.stopProcess();
                }
                else {
                    if (key.charCodeAt(0) === 13) {
                        process.stdout.write('\n');
                    }
                    else {
                        process.stdout.write(key);
                    }
                }
            });
        }
    }
    async catch(error) {
        console.log(error.stack);
        await this.exitWithCrash('Exiting due to an error.', error);
    }
}
Start.description = 'Starts n8n. Makes Web-UI available and starts active workflows';
Start.examples = [
    '$ n8n start',
    '$ n8n start --tunnel',
    '$ n8n start -o',
    '$ n8n start --tunnel -o',
];
Start.flags = {
    help: command_1.flags.help({ char: 'h' }),
    open: command_1.flags.boolean({
        char: 'o',
        description: 'opens the UI automatically in browser',
    }),
    tunnel: command_1.flags.boolean({
        description: 'runs the webhooks via a hooks.n8n.cloud tunnel server. Use only for testing and development!',
    }),
    reinstallMissingPackages: command_1.flags.boolean({
        description: 'Attempts to self heal n8n if packages with nodes are missing. Might drastically increase startup times.',
    }),
};
exports.Start = Start;
//# sourceMappingURL=start.js.map