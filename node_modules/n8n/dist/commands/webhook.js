"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Webhook = void 0;
const command_1 = require("@oclif/command");
const n8n_workflow_1 = require("n8n-workflow");
const config_1 = __importDefault(require("../config"));
const ActiveExecutions_1 = require("../ActiveExecutions");
const WebhookServer_1 = require("../WebhookServer");
const Queue_1 = require("../Queue");
const BaseCommand_1 = require("./BaseCommand");
const typedi_1 = require("typedi");
class Webhook extends BaseCommand_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.server = new WebhookServer_1.WebhookServer();
    }
    async stopProcess() {
        n8n_workflow_1.LoggerProxy.info('\nStopping n8n...');
        try {
            await this.externalHooks.run('n8n.stop', []);
            setTimeout(async () => {
                await this.exitSuccessFully();
            }, 30000);
            const activeExecutionsInstance = typedi_1.Container.get(ActiveExecutions_1.ActiveExecutions);
            let executingWorkflows = activeExecutionsInstance.getActiveExecutions();
            let count = 0;
            while (executingWorkflows.length !== 0) {
                if (count++ % 4 === 0) {
                    n8n_workflow_1.LoggerProxy.info(`Waiting for ${executingWorkflows.length} active executions to finish...`);
                }
                await (0, n8n_workflow_1.sleep)(500);
                executingWorkflows = activeExecutionsInstance.getActiveExecutions();
            }
        }
        catch (error) {
            await this.exitWithCrash('There was an error shutting down n8n.', error);
        }
        await this.exitSuccessFully();
    }
    async init() {
        if (config_1.default.getEnv('executions.mode') !== 'queue') {
            this.error('Webhook processes can only run with execution mode as queue.');
        }
        await this.initCrashJournal();
        await super.init();
        await this.initBinaryManager();
        await this.initExternalHooks();
    }
    async run() {
        await typedi_1.Container.get(Queue_1.Queue).init();
        await this.server.start();
        this.logger.info('Webhook listener waiting for requests.');
        await new Promise(() => { });
    }
    async catch(error) {
        await this.exitWithCrash('Exiting due to an error.', error);
    }
}
Webhook.description = 'Starts n8n webhook process. Intercepts only production URLs.';
Webhook.examples = ['$ n8n webhook'];
Webhook.flags = {
    help: command_1.flags.help({ char: 'h' }),
};
exports.Webhook = Webhook;
//# sourceMappingURL=webhook.js.map