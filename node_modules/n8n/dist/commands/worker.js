"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Worker = void 0;
const express_1 = __importDefault(require("express"));
const http_1 = __importDefault(require("http"));
const typedi_1 = require("typedi");
const command_1 = require("@oclif/command");
const n8n_core_1 = require("n8n-core");
const n8n_workflow_1 = require("n8n-workflow");
const Db = __importStar(require("../Db"));
const ResponseHelper = __importStar(require("../ResponseHelper"));
const WebhookHelpers = __importStar(require("../WebhookHelpers"));
const WorkflowExecuteAdditionalData = __importStar(require("../WorkflowExecuteAdditionalData"));
const PermissionChecker_1 = require("../UserManagement/PermissionChecker");
const config_1 = __importDefault(require("../config"));
const Queue_1 = require("../Queue");
const UserManagementHelper_1 = require("../UserManagement/UserManagementHelper");
const WorkflowHelpers_1 = require("../WorkflowHelpers");
const constants_1 = require("../constants");
const BaseCommand_1 = require("./BaseCommand");
class Worker extends BaseCommand_1.BaseCommand {
    async stopProcess() {
        n8n_workflow_1.LoggerProxy.info('Stopping n8n...');
        Worker.jobQueue.pause(true);
        try {
            await this.externalHooks.run('n8n.stop', []);
            const maxStopTime = config_1.default.getEnv('queue.bull.gracefulShutdownTimeout') * 1000;
            const stopTime = new Date().getTime() + maxStopTime;
            setTimeout(async () => {
                await this.exitSuccessFully();
            }, maxStopTime);
            let count = 0;
            while (Object.keys(Worker.runningJobs).length !== 0) {
                if (count++ % 4 === 0) {
                    const waitLeft = Math.ceil((stopTime - new Date().getTime()) / 1000);
                    n8n_workflow_1.LoggerProxy.info(`Waiting for ${Object.keys(Worker.runningJobs).length} active executions to finish... (wait ${waitLeft} more seconds)`);
                }
                await (0, n8n_workflow_1.sleep)(500);
            }
        }
        catch (error) {
            await this.exitWithCrash('There was an error shutting down n8n.', error);
        }
        await this.exitSuccessFully();
    }
    async runJob(job, nodeTypes) {
        var _a, _b;
        const { executionId, loadStaticData } = job.data;
        const executionDb = await Db.collections.Execution.findOneBy({ id: executionId });
        if (!executionDb) {
            n8n_workflow_1.LoggerProxy.error(`Worker failed to find data of execution "${executionId}" in database. Cannot continue.`, { executionId });
            throw new Error(`Unable to find data of execution "${executionId}" in database. Aborting execution.`);
        }
        const currentExecutionDb = ResponseHelper.unflattenExecutionData(executionDb);
        const workflowId = currentExecutionDb.workflowData.id;
        n8n_workflow_1.LoggerProxy.info(`Start job: ${job.id} (Workflow ID: ${workflowId} | Execution: ${executionId})`);
        const workflowOwner = await (0, UserManagementHelper_1.getWorkflowOwner)(workflowId);
        let { staticData } = currentExecutionDb.workflowData;
        if (loadStaticData) {
            const workflowData = await Db.collections.Workflow.findOne({
                select: ['id', 'staticData'],
                where: {
                    id: workflowId,
                },
            });
            if (workflowData === null) {
                n8n_workflow_1.LoggerProxy.error('Worker execution failed because workflow could not be found in database.', { workflowId, executionId });
                throw new Error(`The workflow with the ID "${workflowId}" could not be found`);
            }
            staticData = workflowData.staticData;
        }
        const workflowSettings = (_a = currentExecutionDb.workflowData.settings) !== null && _a !== void 0 ? _a : {};
        let workflowTimeout = (_b = workflowSettings.executionTimeout) !== null && _b !== void 0 ? _b : config_1.default.getEnv('executions.timeout');
        let executionTimeoutTimestamp;
        if (workflowTimeout > 0) {
            workflowTimeout = Math.min(workflowTimeout, config_1.default.getEnv('executions.maxTimeout'));
            executionTimeoutTimestamp = Date.now() + workflowTimeout * 1000;
        }
        const workflow = new n8n_workflow_1.Workflow({
            id: workflowId,
            name: currentExecutionDb.workflowData.name,
            nodes: currentExecutionDb.workflowData.nodes,
            connections: currentExecutionDb.workflowData.connections,
            active: currentExecutionDb.workflowData.active,
            nodeTypes,
            staticData,
            settings: currentExecutionDb.workflowData.settings,
        });
        const additionalData = await WorkflowExecuteAdditionalData.getBase(workflowOwner.id, undefined, executionTimeoutTimestamp);
        additionalData.hooks = WorkflowExecuteAdditionalData.getWorkflowHooksWorkerExecuter(currentExecutionDb.mode, job.data.executionId, currentExecutionDb.workflowData, { retryOf: currentExecutionDb.retryOf });
        try {
            await PermissionChecker_1.PermissionChecker.check(workflow, workflowOwner.id);
        }
        catch (error) {
            if (error instanceof n8n_workflow_1.NodeOperationError) {
                const failedExecution = (0, WorkflowHelpers_1.generateFailedExecutionFromError)(currentExecutionDb.mode, error, error.node);
                await additionalData.hooks.executeHookFunctions('workflowExecuteAfter', [failedExecution]);
            }
            return { success: true };
        }
        additionalData.hooks.hookFunctions.sendResponse = [
            async (response) => {
                const progress = {
                    executionId,
                    response: WebhookHelpers.encodeWebhookResponse(response),
                };
                await job.progress(progress);
            },
        ];
        additionalData.executionId = executionId;
        additionalData.setExecutionStatus = (status) => {
            n8n_workflow_1.LoggerProxy.debug(`Queued worker execution status for ${executionId} is "${status}"`);
        };
        let workflowExecute;
        let workflowRun;
        if (currentExecutionDb.data !== undefined) {
            workflowExecute = new n8n_core_1.WorkflowExecute(additionalData, currentExecutionDb.mode, currentExecutionDb.data);
            workflowRun = workflowExecute.processRunExecutionData(workflow);
        }
        else {
            workflowExecute = new n8n_core_1.WorkflowExecute(additionalData, currentExecutionDb.mode);
            workflowRun = workflowExecute.run(workflow);
        }
        Worker.runningJobs[job.id] = workflowRun;
        await workflowRun;
        delete Worker.runningJobs[job.id];
        return {
            success: true,
        };
    }
    async init() {
        await this.initCrashJournal();
        await super.init();
        this.logger.debug('Starting n8n worker...');
        await this.initBinaryManager();
        await this.initExternalHooks();
    }
    async run() {
        const { flags } = this.parse(Worker);
        const redisConnectionTimeoutLimit = config_1.default.getEnv('queue.bull.redis.timeoutThreshold');
        const queue = typedi_1.Container.get(Queue_1.Queue);
        await queue.init();
        Worker.jobQueue = queue.getBullObjectInstance();
        Worker.jobQueue.process(flags.concurrency, async (job) => this.runJob(job, this.nodeTypes));
        this.logger.info('\nn8n worker is now ready');
        this.logger.info(` * Version: ${constants_1.N8N_VERSION}`);
        this.logger.info(` * Concurrency: ${flags.concurrency}`);
        this.logger.info('');
        Worker.jobQueue.on('global:progress', (jobId, progress) => {
            if (progress === -1) {
                if (Worker.runningJobs[jobId] !== undefined) {
                    Worker.runningJobs[jobId].cancel();
                    delete Worker.runningJobs[jobId];
                }
            }
        });
        let lastTimer = 0;
        let cumulativeTimeout = 0;
        Worker.jobQueue.on('error', (error) => {
            if (error.toString().includes('ECONNREFUSED')) {
                const now = Date.now();
                if (now - lastTimer > 30000) {
                    lastTimer = now;
                    cumulativeTimeout = 0;
                }
                else {
                    cumulativeTimeout += now - lastTimer;
                    lastTimer = now;
                    if (cumulativeTimeout > redisConnectionTimeoutLimit) {
                        this.logger.error(`Unable to connect to Redis after ${redisConnectionTimeoutLimit}. Exiting process.`);
                        process.exit(1);
                    }
                }
                this.logger.warn('Redis unavailable - trying to reconnect...');
            }
            else if (error.toString().includes('Error initializing Lua scripts')) {
                this.logger.error('Error initializing worker.');
                process.exit(2);
            }
            else {
                this.logger.error('Error from queue: ', error);
                throw error;
            }
        });
        if (config_1.default.getEnv('queue.health.active')) {
            const port = config_1.default.getEnv('queue.health.port');
            const app = (0, express_1.default)();
            app.disable('x-powered-by');
            const server = http_1.default.createServer(app);
            app.get('/healthz', async (req, res) => {
                n8n_workflow_1.LoggerProxy.debug('Health check started!');
                const connection = Db.getConnection();
                try {
                    if (!connection.isInitialized) {
                        throw new Error('No active database connection!');
                    }
                    await connection.query('SELECT 1');
                }
                catch (e) {
                    n8n_workflow_1.LoggerProxy.error('No Database connection!', e);
                    const error = new ResponseHelper.ServiceUnavailableError('No Database connection!');
                    return ResponseHelper.sendErrorResponse(res, error);
                }
                try {
                    await Worker.jobQueue.client.ping();
                }
                catch (e) {
                    n8n_workflow_1.LoggerProxy.error('No Redis connection!', e);
                    const error = new ResponseHelper.ServiceUnavailableError('No Redis connection!');
                    return ResponseHelper.sendErrorResponse(res, error);
                }
                const responseData = {
                    status: 'ok',
                };
                n8n_workflow_1.LoggerProxy.debug('Health check completed successfully!');
                ResponseHelper.sendSuccessResponse(res, responseData, true, 200);
            });
            server.listen(port, () => {
                this.logger.info(`\nn8n worker health check via, port ${port}`);
            });
            server.on('error', (error) => {
                if (error.code === 'EADDRINUSE') {
                    this.logger.error(`n8n's port ${port} is already in use. Do you have the n8n main process running on that port?`);
                    process.exit(1);
                }
            });
        }
        await new Promise(() => { });
    }
    async catch(error) {
        await this.exitWithCrash('Worker exiting due to an error.', error);
    }
}
Worker.description = '\nStarts a n8n worker';
Worker.examples = ['$ n8n worker --concurrency=5'];
Worker.flags = {
    help: command_1.flags.help({ char: 'h' }),
    concurrency: command_1.flags.integer({
        default: 10,
        description: 'How many jobs can run in parallel.',
    }),
};
Worker.runningJobs = {};
exports.Worker = Worker;
//# sourceMappingURL=worker.js.map