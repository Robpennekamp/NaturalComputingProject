"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.close = exports.migrate = exports.init = exports.getConnectionOptions = exports.transaction = exports.connectionState = exports.getConnection = exports.collections = void 0;
const typedi_1 = require("typedi");
const typeorm_1 = require("typeorm");
const n8n_workflow_1 = require("n8n-workflow");
const config_1 = __importDefault(require("./config"));
const entities_1 = require("./databases/entities");
const config_2 = require("./databases/config");
const constants_1 = require("./constants");
const migrationHelpers_1 = require("./databases/utils/migrationHelpers");
const repositories_1 = require("./databases/repositories");
exports.collections = {};
let connection;
const getConnection = () => connection;
exports.getConnection = getConnection;
exports.connectionState = {
    connected: false,
    migrated: false,
};
let pingTimer;
if (!constants_1.inTest) {
    const pingDBFn = async () => {
        if (connection === null || connection === void 0 ? void 0 : connection.isInitialized) {
            try {
                await connection.query('SELECT 1');
                exports.connectionState.connected = true;
                return;
            }
            catch (error) {
                n8n_workflow_1.ErrorReporterProxy.error(error);
            }
            finally {
                pingTimer = setTimeout(pingDBFn, 2000);
            }
        }
        exports.connectionState.connected = false;
    };
    pingTimer = setTimeout(pingDBFn, 2000);
}
async function transaction(fn) {
    return connection.transaction(fn);
}
exports.transaction = transaction;
function getConnectionOptions(dbType) {
    switch (dbType) {
        case 'postgresdb':
            const sslCa = config_1.default.getEnv('database.postgresdb.ssl.ca');
            const sslCert = config_1.default.getEnv('database.postgresdb.ssl.cert');
            const sslKey = config_1.default.getEnv('database.postgresdb.ssl.key');
            const sslRejectUnauthorized = config_1.default.getEnv('database.postgresdb.ssl.rejectUnauthorized');
            let ssl;
            if (sslCa !== '' || sslCert !== '' || sslKey !== '' || !sslRejectUnauthorized) {
                ssl = {
                    ca: sslCa || undefined,
                    cert: sslCert || undefined,
                    key: sslKey || undefined,
                    rejectUnauthorized: sslRejectUnauthorized,
                };
            }
            return {
                ...(0, config_2.getPostgresConnectionOptions)(),
                ...(0, config_2.getOptionOverrides)('postgresdb'),
                ssl,
            };
        case 'mariadb':
        case 'mysqldb':
            return {
                ...(dbType === 'mysqldb' ? (0, config_2.getMysqlConnectionOptions)() : (0, config_2.getMariaDBConnectionOptions)()),
                ...(0, config_2.getOptionOverrides)('mysqldb'),
                timezone: 'Z',
            };
        case 'sqlite':
            return (0, config_2.getSqliteConnectionOptions)();
        default:
            throw new Error(`The database "${dbType}" is currently not supported!`);
    }
}
exports.getConnectionOptions = getConnectionOptions;
async function init(testConnectionOptions) {
    if (exports.connectionState.connected)
        return;
    const dbType = config_1.default.getEnv('database.type');
    const connectionOptions = testConnectionOptions !== null && testConnectionOptions !== void 0 ? testConnectionOptions : getConnectionOptions(dbType);
    let loggingOption = config_1.default.getEnv('database.logging.enabled');
    if (loggingOption) {
        const optionsString = config_1.default.getEnv('database.logging.options').replace(/\s+/g, '');
        if (optionsString === 'all') {
            loggingOption = optionsString;
        }
        else {
            loggingOption = optionsString.split(',');
        }
    }
    const maxQueryExecutionTime = config_1.default.getEnv('database.logging.maxQueryExecutionTime');
    Object.assign(connectionOptions, {
        entities: Object.values(entities_1.entities),
        synchronize: false,
        logging: loggingOption,
        maxQueryExecutionTime,
        migrationsRun: false,
    });
    connection = new typeorm_1.DataSource(connectionOptions);
    typedi_1.Container.set(typeorm_1.DataSource, connection);
    await connection.initialize();
    if (dbType === 'postgresdb') {
        const schema = config_1.default.getEnv('database.postgresdb.schema');
        const searchPath = ['public'];
        if (schema !== 'public') {
            await connection.query(`CREATE SCHEMA IF NOT EXISTS ${schema}`);
            searchPath.unshift(schema);
        }
        await connection.query(`SET search_path TO ${searchPath.join(',')};`);
    }
    exports.connectionState.connected = true;
    exports.collections.AuthIdentity = typedi_1.Container.get(repositories_1.AuthIdentityRepository);
    exports.collections.AuthProviderSyncHistory = typedi_1.Container.get(repositories_1.AuthProviderSyncHistoryRepository);
    exports.collections.Credentials = typedi_1.Container.get(repositories_1.CredentialsRepository);
    exports.collections.EventDestinations = typedi_1.Container.get(repositories_1.EventDestinationsRepository);
    exports.collections.Execution = typedi_1.Container.get(repositories_1.ExecutionRepository);
    exports.collections.ExecutionMetadata = typedi_1.Container.get(repositories_1.ExecutionMetadataRepository);
    exports.collections.InstalledNodes = typedi_1.Container.get(repositories_1.InstalledNodesRepository);
    exports.collections.InstalledPackages = typedi_1.Container.get(repositories_1.InstalledPackagesRepository);
    exports.collections.Role = typedi_1.Container.get(repositories_1.RoleRepository);
    exports.collections.Settings = typedi_1.Container.get(repositories_1.SettingsRepository);
    exports.collections.SharedCredentials = typedi_1.Container.get(repositories_1.SharedCredentialsRepository);
    exports.collections.SharedWorkflow = typedi_1.Container.get(repositories_1.SharedWorkflowRepository);
    exports.collections.Tag = typedi_1.Container.get(repositories_1.TagRepository);
    exports.collections.User = typedi_1.Container.get(repositories_1.UserRepository);
    exports.collections.Variables = typedi_1.Container.get(repositories_1.VariablesRepository);
    exports.collections.Webhook = typedi_1.Container.get(repositories_1.WebhookRepository);
    exports.collections.Workflow = typedi_1.Container.get(repositories_1.WorkflowRepository);
    exports.collections.WorkflowStatistics = typedi_1.Container.get(repositories_1.WorkflowStatisticsRepository);
    exports.collections.WorkflowTagMapping = typedi_1.Container.get(repositories_1.WorkflowTagMappingRepository);
}
exports.init = init;
async function migrate() {
    connection.options.migrations.forEach(migrationHelpers_1.wrapMigration);
    await connection.runMigrations({ transaction: 'each' });
    exports.connectionState.migrated = true;
}
exports.migrate = migrate;
const close = async () => {
    if (pingTimer) {
        clearTimeout(pingTimer);
        pingTimer = undefined;
    }
    if (connection.isInitialized)
        await connection.destroy();
};
exports.close = close;
//# sourceMappingURL=Db.js.map