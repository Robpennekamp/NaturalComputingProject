"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getVariables = exports.validateWorkflowCredentialUsage = exports.getNodesWithInaccessibleCreds = exports.generateFailedExecutionFromError = exports.isBelowOnboardingThreshold = exports.getSharedWorkflowIds = exports.replaceInvalidCredentials = exports.addNodeIds = exports.getStaticDataById = exports.saveStaticDataById = exports.saveStaticData = exports.executeErrorWorkflow = exports.getDataLastExecutedNodeData = void 0;
const typeorm_1 = require("typeorm");
const typedi_1 = require("typedi");
const n8n_workflow_1 = require("n8n-workflow");
const uuid_1 = require("uuid");
const Db = __importStar(require("./Db"));
const NodeTypes_1 = require("./NodeTypes");
const WorkflowRunner_1 = require("./WorkflowRunner");
const config_1 = __importDefault(require("./config"));
const repositories_1 = require("./databases/repositories");
const UserManagementHelper_1 = require("./UserManagement/UserManagementHelper");
const lodash_omit_1 = __importDefault(require("lodash.omit"));
const PermissionChecker_1 = require("./UserManagement/PermissionChecker");
const utils_1 = require("./utils");
const user_service_1 = require("./user/user.service");
const ERROR_TRIGGER_TYPE = config_1.default.getEnv('nodes.errorTriggerType');
function getDataLastExecutedNodeData(inputData) {
    const { runData, pinData = {} } = inputData.data.resultData;
    const { lastNodeExecuted } = inputData.data.resultData;
    if (lastNodeExecuted === undefined) {
        return undefined;
    }
    if (runData[lastNodeExecuted] === undefined) {
        return undefined;
    }
    const lastNodeRunData = runData[lastNodeExecuted][runData[lastNodeExecuted].length - 1];
    let lastNodePinData = pinData[lastNodeExecuted];
    if (lastNodePinData && inputData.mode === 'manual') {
        if (!Array.isArray(lastNodePinData))
            lastNodePinData = [lastNodePinData];
        const itemsPerRun = lastNodePinData.map((item, index) => {
            return { json: item, pairedItem: { item: index } };
        });
        return {
            startTime: 0,
            executionTime: 0,
            data: { main: [itemsPerRun] },
            source: lastNodeRunData.source,
        };
    }
    return lastNodeRunData;
}
exports.getDataLastExecutedNodeData = getDataLastExecutedNodeData;
async function executeErrorWorkflow(workflowId, workflowErrorData, runningUser) {
    try {
        const workflowData = await Db.collections.Workflow.findOneBy({ id: workflowId });
        if (workflowData === null) {
            n8n_workflow_1.LoggerProxy.error(`Calling Error Workflow for "${workflowErrorData.workflow.id}". Could not find error workflow "${workflowId}"`, { workflowId });
            return;
        }
        const executionMode = 'error';
        const nodeTypes = typedi_1.Container.get(NodeTypes_1.NodeTypes);
        const workflowInstance = new n8n_workflow_1.Workflow({
            id: workflowId,
            name: workflowData.name,
            nodeTypes,
            nodes: workflowData.nodes,
            connections: workflowData.connections,
            active: workflowData.active,
            staticData: workflowData.staticData,
            settings: workflowData.settings,
        });
        try {
            await PermissionChecker_1.PermissionChecker.checkSubworkflowExecutePolicy(workflowInstance, runningUser.id, workflowErrorData.workflow.id);
        }
        catch (error) {
            n8n_workflow_1.LoggerProxy.info('Error workflow execution blocked due to subworkflow settings', {
                erroredWorkflowId: workflowErrorData.workflow.id,
                errorWorkflowId: workflowId,
            });
            return;
        }
        let node;
        let workflowStartNode;
        for (const nodeName of Object.keys(workflowInstance.nodes)) {
            node = workflowInstance.nodes[nodeName];
            if (node.type === ERROR_TRIGGER_TYPE) {
                workflowStartNode = node;
            }
        }
        if (workflowStartNode === undefined) {
            n8n_workflow_1.LoggerProxy.error(`Calling Error Workflow for "${workflowErrorData.workflow.id}". Could not find "${ERROR_TRIGGER_TYPE}" in workflow "${workflowId}"`);
            return;
        }
        const nodeExecutionStack = [];
        nodeExecutionStack.push({
            node: workflowStartNode,
            data: {
                main: [
                    [
                        {
                            json: workflowErrorData,
                        },
                    ],
                ],
            },
            source: null,
        });
        const runExecutionData = {
            startData: {},
            resultData: {
                runData: {},
            },
            executionData: {
                contextData: {},
                nodeExecutionStack,
                waitingExecution: {},
                waitingExecutionSource: {},
            },
        };
        const runData = {
            executionMode,
            executionData: runExecutionData,
            workflowData,
            userId: runningUser.id,
        };
        const workflowRunner = new WorkflowRunner_1.WorkflowRunner();
        await workflowRunner.run(runData);
    }
    catch (error) {
        n8n_workflow_1.ErrorReporterProxy.error(error);
        n8n_workflow_1.LoggerProxy.error(`Calling Error Workflow for "${workflowErrorData.workflow.id}": "${error.message}"`, { workflowId: workflowErrorData.workflow.id });
    }
}
exports.executeErrorWorkflow = executeErrorWorkflow;
async function saveStaticData(workflow) {
    if (workflow.staticData.__dataChanged === true) {
        if ((0, utils_1.isWorkflowIdValid)(workflow.id)) {
            try {
                await saveStaticDataById(workflow.id, workflow.staticData);
                workflow.staticData.__dataChanged = false;
            }
            catch (error) {
                n8n_workflow_1.ErrorReporterProxy.error(error);
                n8n_workflow_1.LoggerProxy.error(`There was a problem saving the workflow with id "${workflow.id}" to save changed staticData: "${error.message}"`, { workflowId: workflow.id });
            }
        }
    }
}
exports.saveStaticData = saveStaticData;
async function saveStaticDataById(workflowId, newStaticData) {
    await Db.collections.Workflow.update(workflowId, {
        staticData: newStaticData,
    });
}
exports.saveStaticDataById = saveStaticDataById;
async function getStaticDataById(workflowId) {
    var _a;
    const workflowData = await Db.collections.Workflow.findOne({
        select: ['staticData'],
        where: { id: workflowId },
    });
    return (_a = workflowData === null || workflowData === void 0 ? void 0 : workflowData.staticData) !== null && _a !== void 0 ? _a : {};
}
exports.getStaticDataById = getStaticDataById;
function addNodeIds(workflow) {
    const { nodes } = workflow;
    if (!nodes)
        return;
    nodes.forEach((node) => {
        if (!node.id) {
            node.id = (0, uuid_1.v4)();
        }
    });
}
exports.addNodeIds = addNodeIds;
async function replaceInvalidCredentials(workflow) {
    const { nodes } = workflow;
    if (!nodes)
        return workflow;
    const credentialsByName = {};
    const credentialsById = {};
    for (const node of nodes) {
        if (!node.credentials || node.disabled) {
            continue;
        }
        const allNodeCredentials = Object.entries(node.credentials);
        for (const [nodeCredentialType, nodeCredentials] of allNodeCredentials) {
            if (typeof nodeCredentials === 'string' || nodeCredentials.id === null) {
                const name = typeof nodeCredentials === 'string' ? nodeCredentials : nodeCredentials.name;
                if (!credentialsByName[nodeCredentialType]) {
                    credentialsByName[nodeCredentialType] = {};
                }
                if (credentialsByName[nodeCredentialType][name] === undefined) {
                    const credentials = await Db.collections.Credentials.findBy({
                        name,
                        type: nodeCredentialType,
                    });
                    if ((credentials === null || credentials === void 0 ? void 0 : credentials.length) === 1) {
                        credentialsByName[nodeCredentialType][name] = {
                            id: credentials[0].id,
                            name: credentials[0].name,
                        };
                        node.credentials[nodeCredentialType] = credentialsByName[nodeCredentialType][name];
                        continue;
                    }
                    credentialsByName[nodeCredentialType][name] = {
                        id: null,
                        name,
                    };
                }
                else {
                    node.credentials[nodeCredentialType] = credentialsByName[nodeCredentialType][name];
                }
                continue;
            }
            if (!credentialsById[nodeCredentialType]) {
                credentialsById[nodeCredentialType] = {};
            }
            if (credentialsById[nodeCredentialType][nodeCredentials.id] === undefined) {
                const credentials = await Db.collections.Credentials.findOneBy({
                    id: nodeCredentials.id,
                    type: nodeCredentialType,
                });
                if (credentials) {
                    credentialsById[nodeCredentialType][nodeCredentials.id] = {
                        id: credentials.id,
                        name: credentials.name,
                    };
                    node.credentials[nodeCredentialType] =
                        credentialsById[nodeCredentialType][nodeCredentials.id];
                    continue;
                }
                const credsByName = await Db.collections.Credentials.findBy({
                    name: nodeCredentials.name,
                    type: nodeCredentialType,
                });
                if ((credsByName === null || credsByName === void 0 ? void 0 : credsByName.length) === 1) {
                    credentialsById[nodeCredentialType][credsByName[0].id] = {
                        id: credsByName[0].id,
                        name: credsByName[0].name,
                    };
                    node.credentials[nodeCredentialType] =
                        credentialsById[nodeCredentialType][credsByName[0].id];
                    continue;
                }
                credentialsById[nodeCredentialType][nodeCredentials.id] = nodeCredentials;
                continue;
            }
            node.credentials[nodeCredentialType] =
                credentialsById[nodeCredentialType][nodeCredentials.id];
        }
    }
    return workflow;
}
exports.replaceInvalidCredentials = replaceInvalidCredentials;
async function getSharedWorkflowIds(user, roles) {
    const sharedWorkflows = await Db.collections.SharedWorkflow.find({
        relations: ['workflow', 'role'],
        where: (0, UserManagementHelper_1.whereClause)({ user, entityType: 'workflow', roles }),
        select: ['workflowId'],
    });
    return sharedWorkflows.map(({ workflowId }) => workflowId);
}
exports.getSharedWorkflowIds = getSharedWorkflowIds;
async function isBelowOnboardingThreshold(user) {
    let belowThreshold = true;
    const skippedTypes = ['n8n-nodes-base.start', 'n8n-nodes-base.stickyNote'];
    const workflowOwnerRole = await typedi_1.Container.get(repositories_1.RoleRepository).findWorkflowOwnerRole();
    const ownedWorkflowsIds = await Db.collections.SharedWorkflow.find({
        where: {
            userId: user.id,
            roleId: workflowOwnerRole === null || workflowOwnerRole === void 0 ? void 0 : workflowOwnerRole.id,
        },
        select: ['workflowId'],
    }).then((ownedWorkflows) => ownedWorkflows.map(({ workflowId }) => workflowId));
    if (ownedWorkflowsIds.length > 15) {
        belowThreshold = false;
    }
    else {
        const workflows = await Db.collections.Workflow.find({
            where: { id: (0, typeorm_1.In)(ownedWorkflowsIds) },
            select: ['nodes'],
        });
        const validWorkflowCount = workflows.reduce((counter, workflow) => {
            if (counter <= 2 && workflow.nodes.length > 2) {
                const nodes = workflow.nodes.filter((node) => !skippedTypes.includes(node.type));
                if (nodes.length >= 2) {
                    return counter + 1;
                }
            }
            return counter;
        }, 0);
        belowThreshold = validWorkflowCount <= 2;
    }
    if (!belowThreshold) {
        void user_service_1.UserService.updateUserSettings(user.id, { isOnboarded: true });
    }
    return belowThreshold;
}
exports.isBelowOnboardingThreshold = isBelowOnboardingThreshold;
function generateFailedExecutionFromError(mode, error, node) {
    return {
        data: {
            startData: {
                destinationNode: node.name,
                runNodeFilter: [node.name],
            },
            resultData: {
                error,
                runData: {
                    [node.name]: [
                        {
                            startTime: 0,
                            executionTime: 0,
                            error,
                            source: [],
                        },
                    ],
                },
                lastNodeExecuted: node.name,
            },
            executionData: {
                contextData: {},
                nodeExecutionStack: [
                    {
                        node,
                        data: {},
                        source: null,
                    },
                ],
                waitingExecution: {},
                waitingExecutionSource: {},
            },
        },
        finished: false,
        mode,
        startedAt: new Date(),
        stoppedAt: new Date(),
        status: 'failed',
    };
}
exports.generateFailedExecutionFromError = generateFailedExecutionFromError;
function getNodesWithInaccessibleCreds(workflow, userCredIds) {
    if (!workflow.nodes) {
        return [];
    }
    return workflow.nodes.filter((node) => {
        if (!node.credentials)
            return false;
        const allUsedCredentials = Object.values(node.credentials);
        const allUsedCredentialIds = allUsedCredentials.map((nodeCred) => { var _a; return (_a = nodeCred.id) === null || _a === void 0 ? void 0 : _a.toString(); });
        return allUsedCredentialIds.some((nodeCredId) => nodeCredId && !userCredIds.includes(nodeCredId));
    });
}
exports.getNodesWithInaccessibleCreds = getNodesWithInaccessibleCreds;
function validateWorkflowCredentialUsage(newWorkflowVersion, previousWorkflowVersion, credentialsUserHasAccessTo) {
    const allowedCredentialIds = credentialsUserHasAccessTo.map((cred) => cred.id);
    const nodesWithCredentialsUserDoesNotHaveAccessTo = getNodesWithInaccessibleCreds(newWorkflowVersion, allowedCredentialIds);
    if (nodesWithCredentialsUserDoesNotHaveAccessTo.length === 0) {
        return newWorkflowVersion;
    }
    const previouslyExistingNodeIds = previousWorkflowVersion.nodes.map((node) => node.id);
    const isTamperingAttempt = (inaccessibleCredNodeId) => !previouslyExistingNodeIds.includes(inaccessibleCredNodeId);
    nodesWithCredentialsUserDoesNotHaveAccessTo.forEach((node) => {
        if (isTamperingAttempt(node.id)) {
            n8n_workflow_1.LoggerProxy.verbose('Blocked workflow update due to tampering attempt', {
                nodeType: node.type,
                nodeName: node.name,
                nodeId: node.id,
                nodeCredentials: node.credentials,
            });
            throw new n8n_workflow_1.NodeOperationError(node, `You don't have access to the credentials in the '${node.name}' node. Ask the owner to share them with you.`);
        }
        const nodeIdx = newWorkflowVersion.nodes.findIndex((newWorkflowNode) => newWorkflowNode.id === node.id);
        n8n_workflow_1.LoggerProxy.debug('Replacing node with previous version when saving updated workflow', {
            nodeType: node.type,
            nodeName: node.name,
            nodeId: node.id,
        });
        const previousNodeVersion = previousWorkflowVersion.nodes.find((previousNode) => previousNode.id === node.id);
        Object.assign(newWorkflowVersion.nodes[nodeIdx], (0, lodash_omit_1.default)(previousNodeVersion, ['name', 'position', 'disabled']));
    });
    return newWorkflowVersion;
}
exports.validateWorkflowCredentialUsage = validateWorkflowCredentialUsage;
async function getVariables() {
    return Object.freeze((await Db.collections.Variables.find()).reduce((prev, curr) => {
        prev[curr.key] = curr.value;
        return prev;
    }, {}));
}
exports.getVariables = getVariables;
//# sourceMappingURL=WorkflowHelpers.js.map