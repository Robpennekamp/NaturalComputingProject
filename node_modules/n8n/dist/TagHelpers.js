"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setTagsForImport = exports.sortByRequestOrder = void 0;
const TagEntity_1 = require("./databases/entities/TagEntity");
function sortByRequestOrder(tags, { requestOrder }) {
    const tagMap = tags.reduce((acc, tag) => {
        acc[tag.id] = tag;
        return acc;
    }, {});
    return requestOrder.map((tagId) => tagMap[tagId]);
}
exports.sortByRequestOrder = sortByRequestOrder;
const createTag = async (transactionManager, name) => {
    const tag = new TagEntity_1.TagEntity();
    tag.name = name;
    return transactionManager.save(tag);
};
const findOrCreateTag = async (transactionManager, importTag, tagsEntities) => {
    const identicalMatch = tagsEntities.find((existingTag) => existingTag.id === importTag.id &&
        existingTag.createdAt &&
        importTag.createdAt &&
        existingTag.createdAt.getTime() === new Date(importTag.createdAt).getTime());
    if (identicalMatch) {
        return identicalMatch;
    }
    const nameMatch = tagsEntities.find((existingTag) => existingTag.name === importTag.name);
    if (nameMatch) {
        return nameMatch;
    }
    const created = await createTag(transactionManager, importTag.name);
    tagsEntities.push(created);
    return created;
};
const hasTags = (workflow) => 'tags' in workflow && Array.isArray(workflow.tags) && workflow.tags.length > 0;
async function setTagsForImport(transactionManager, workflow, tags) {
    var _a;
    if (!hasTags(workflow)) {
        return;
    }
    const workflowTags = workflow.tags;
    const tagLookupPromises = [];
    for (let i = 0; i < workflowTags.length; i++) {
        if ((_a = workflowTags[i]) === null || _a === void 0 ? void 0 : _a.name) {
            const lookupPromise = findOrCreateTag(transactionManager, workflowTags[i], tags).then((tag) => {
                workflowTags[i] = {
                    id: tag.id,
                    name: tag.name,
                };
            });
            tagLookupPromises.push(lookupPromise);
        }
    }
    await Promise.all(tagLookupPromises);
}
exports.setTagsForImport = setTagsForImport;
//# sourceMappingURL=TagHelpers.js.map