"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Server = void 0;
const assert_1 = __importDefault(require("assert"));
const child_process_1 = require("child_process");
const promises_1 = require("fs/promises");
const os_1 = __importDefault(require("os"));
const path_1 = require("path");
const crypto_1 = require("crypto");
const util_1 = require("util");
const cookie_parser_1 = __importDefault(require("cookie-parser"));
const express_1 = __importDefault(require("express"));
const express_handlebars_1 = require("express-handlebars");
const typeorm_1 = require("typeorm");
const axios_1 = __importDefault(require("axios"));
const oauth_1_0a_1 = __importDefault(require("oauth-1.0a"));
const n8n_core_1 = require("n8n-core");
const n8n_workflow_1 = require("n8n-workflow");
const google_timezones_json_1 = __importDefault(require("google-timezones-json"));
const connect_history_api_fallback_1 = __importDefault(require("connect-history-api-fallback"));
const config_1 = __importDefault(require("./config"));
const Queue_1 = require("./Queue");
const WorkflowHelpers_1 = require("./WorkflowHelpers");
const workflows_controller_1 = require("./workflows/workflows.controller");
const constants_1 = require("./constants");
const credentials_controller_1 = require("./credentials/credentials.controller");
const oauth2Credential_api_1 = require("./credentials/oauth2Credential.api");
const decorators_1 = require("./decorators");
const controllers_1 = require("./controllers");
const executions_controller_1 = require("./executions/executions.controller");
const workflowStats_api_1 = require("./api/workflowStats.api");
const PublicApi_1 = require("./PublicApi");
const UserManagementHelper_1 = require("./UserManagement/UserManagementHelper");
const email_1 = require("./UserManagement/email");
const Db = __importStar(require("./Db"));
const ActiveExecutions_1 = require("./ActiveExecutions");
const CredentialsHelper_1 = require("./CredentialsHelper");
const CredentialsOverwrites_1 = require("./CredentialsOverwrites");
const CredentialTypes_1 = require("./CredentialTypes");
const LoadNodesAndCredentials_1 = require("./LoadNodesAndCredentials");
const NodeTypes_1 = require("./NodeTypes");
const ResponseHelper = __importStar(require("./ResponseHelper"));
const WaitTracker_1 = require("./WaitTracker");
const WebhookHelpers = __importStar(require("./WebhookHelpers"));
const WorkflowExecuteAdditionalData = __importStar(require("./WorkflowExecuteAdditionalData"));
const CurlConverterHelper_1 = require("./CurlConverterHelper");
const eventBus_controller_1 = require("./eventbus/eventBus.controller");
const MessageEventBusHelper_1 = require("./eventbus/MessageEventBus/MessageEventBusHelper");
const license_controller_1 = require("./license/license.controller");
const push_1 = require("./push");
const middlewares_1 = require("./middlewares");
const events_1 = require("./events");
const helpers_1 = require("./Ldap/helpers");
const AbstractServer_1 = require("./AbstractServer");
const metrics_1 = require("./metrics");
const basicAuth_1 = require("./middlewares/basicAuth");
const externalJWTAuth_1 = require("./middlewares/externalJWTAuth");
const posthog_1 = require("./posthog");
const eventbus_1 = require("./eventbus");
const typedi_1 = require("typedi");
const InternalHooks_1 = require("./InternalHooks");
const executionHelpers_1 = require("./executions/executionHelpers");
const samlHelpers_1 = require("./sso/saml/samlHelpers");
const saml_controller_ee_1 = require("./sso/saml/routes/saml.controller.ee");
const saml_service_ee_1 = require("./sso/saml/saml.service.ee");
const variables_controller_1 = require("./environments/variables/variables.controller");
const LdapManager_ee_1 = require("./Ldap/LdapManager.ee");
const enviromentHelpers_1 = require("./environments/variables/enviromentHelpers");
const ssoHelpers_1 = require("./sso/ssoHelpers");
const versionControlHelper_1 = require("./environments/versionControl/versionControlHelper");
const versionControl_service_ee_1 = require("./environments/versionControl/versionControl.service.ee");
const versionControl_controller_ee_1 = require("./environments/versionControl/versionControl.controller.ee");
const exec = (0, util_1.promisify)(child_process_1.exec);
class Server extends AbstractServer_1.AbstractServer {
    constructor() {
        var _a, _b, _c, _d;
        super();
        this.app.engine('handlebars', (0, express_handlebars_1.engine)({ defaultLayout: false }));
        this.app.set('view engine', 'handlebars');
        this.app.set('views', constants_1.TEMPLATES_DIR);
        const urlBaseWebhook = WebhookHelpers.getWebhookBaseUrl();
        const telemetrySettings = {
            enabled: config_1.default.getEnv('diagnostics.enabled'),
        };
        if (telemetrySettings.enabled) {
            const conf = config_1.default.getEnv('diagnostics.config.frontend');
            const [key, url] = conf.split(';');
            if (!key || !url) {
                n8n_workflow_1.LoggerProxy.warn('Diagnostics frontend config is invalid');
                telemetrySettings.enabled = false;
            }
            telemetrySettings.config = { key, url };
        }
        const instanceBaseUrl = (0, UserManagementHelper_1.getInstanceBaseUrl)();
        this.frontendSettings = {
            endpointWebhook: this.endpointWebhook,
            endpointWebhookTest: this.endpointWebhookTest,
            saveDataErrorExecution: config_1.default.getEnv('executions.saveDataOnError'),
            saveDataSuccessExecution: config_1.default.getEnv('executions.saveDataOnSuccess'),
            saveManualExecutions: config_1.default.getEnv('executions.saveDataManualExecutions'),
            executionTimeout: config_1.default.getEnv('executions.timeout'),
            maxExecutionTimeout: config_1.default.getEnv('executions.maxTimeout'),
            workflowCallerPolicyDefaultOption: config_1.default.getEnv('workflows.callerPolicyDefaultOption'),
            timezone: this.timezone,
            urlBaseWebhook,
            urlBaseEditor: instanceBaseUrl,
            versionCli: '',
            oauthCallbackUrls: {
                oauth1: `${instanceBaseUrl}/${this.restEndpoint}/oauth1-credential/callback`,
                oauth2: `${instanceBaseUrl}/${this.restEndpoint}/oauth2-credential/callback`,
            },
            versionNotifications: {
                enabled: config_1.default.getEnv('versionNotifications.enabled'),
                endpoint: config_1.default.getEnv('versionNotifications.endpoint'),
                infoUrl: config_1.default.getEnv('versionNotifications.infoUrl'),
            },
            instanceId: '',
            telemetry: telemetrySettings,
            posthog: {
                enabled: config_1.default.getEnv('diagnostics.enabled'),
                apiHost: config_1.default.getEnv('diagnostics.config.posthog.apiHost'),
                apiKey: config_1.default.getEnv('diagnostics.config.posthog.apiKey'),
                autocapture: false,
                disableSessionRecording: config_1.default.getEnv('diagnostics.config.posthog.disableSessionRecording'),
                debug: config_1.default.getEnv('logs.level') === 'debug',
            },
            personalizationSurveyEnabled: config_1.default.getEnv('personalization.enabled') && config_1.default.getEnv('diagnostics.enabled'),
            userActivationSurveyEnabled: config_1.default.getEnv('userActivationSurvey.enabled') && config_1.default.getEnv('diagnostics.enabled'),
            defaultLocale: config_1.default.getEnv('defaultLocale'),
            userManagement: {
                enabled: (0, UserManagementHelper_1.isUserManagementEnabled)(),
                showSetupOnFirstLoad: config_1.default.getEnv('userManagement.disabled') === false &&
                    config_1.default.getEnv('userManagement.isInstanceOwnerSetUp') === false &&
                    config_1.default.getEnv('userManagement.skipInstanceOwnerSetup') === false,
                smtpSetup: (0, UserManagementHelper_1.isEmailSetUp)(),
                authenticationMethod: (0, ssoHelpers_1.getCurrentAuthenticationMethod)(),
            },
            sso: {
                saml: {
                    loginEnabled: false,
                    loginLabel: '',
                },
                ldap: {
                    loginEnabled: false,
                    loginLabel: '',
                },
            },
            publicApi: {
                enabled: !config_1.default.getEnv('publicApi.disabled'),
                latestVersion: 1,
                path: config_1.default.getEnv('publicApi.path'),
                swaggerUi: {
                    enabled: !config_1.default.getEnv('publicApi.swaggerUi.disabled'),
                },
            },
            workflowTagsDisabled: config_1.default.getEnv('workflowTagsDisabled'),
            logLevel: config_1.default.getEnv('logs.level'),
            hiringBannerEnabled: config_1.default.getEnv('hiringBanner.enabled'),
            templates: {
                enabled: config_1.default.getEnv('templates.enabled'),
                host: config_1.default.getEnv('templates.host'),
            },
            onboardingCallPromptEnabled: config_1.default.getEnv('onboardingCallPrompt.enabled'),
            executionMode: config_1.default.getEnv('executions.mode'),
            pushBackend: config_1.default.getEnv('push.backend'),
            communityNodesEnabled: config_1.default.getEnv('nodes.communityPackages.enabled'),
            deployment: {
                type: config_1.default.getEnv('deployment.type'),
            },
            isNpmAvailable: false,
            allowedModules: {
                builtIn: (_b = (_a = process.env.NODE_FUNCTION_ALLOW_BUILTIN) === null || _a === void 0 ? void 0 : _a.split(',')) !== null && _b !== void 0 ? _b : undefined,
                external: (_d = (_c = process.env.NODE_FUNCTION_ALLOW_EXTERNAL) === null || _c === void 0 ? void 0 : _c.split(',')) !== null && _d !== void 0 ? _d : undefined,
            },
            enterprise: {
                sharing: false,
                ldap: false,
                saml: false,
                logStreaming: false,
                advancedExecutionFilters: false,
                variables: false,
                versionControl: false,
            },
            hideUsagePage: config_1.default.getEnv('hideUsagePage'),
            license: {
                environment: config_1.default.getEnv('license.tenantId') === 1 ? 'production' : 'staging',
            },
            variables: {
                limit: 0,
            },
        };
    }
    async start() {
        this.loadNodesAndCredentials = typedi_1.Container.get(LoadNodesAndCredentials_1.LoadNodesAndCredentials);
        this.credentialTypes = typedi_1.Container.get(CredentialTypes_1.CredentialTypes);
        this.nodeTypes = typedi_1.Container.get(NodeTypes_1.NodeTypes);
        this.activeExecutionsInstance = typedi_1.Container.get(ActiveExecutions_1.ActiveExecutions);
        this.waitTracker = typedi_1.Container.get(WaitTracker_1.WaitTracker);
        this.postHog = typedi_1.Container.get(posthog_1.PostHogClient);
        this.presetCredentialsLoaded = false;
        this.endpointPresetCredentials = config_1.default.getEnv('credentials.overwrite.endpoint');
        this.push = typedi_1.Container.get(push_1.Push);
        if (process.env.E2E_TESTS === 'true') {
            this.app.use('/e2e', require('./api/e2e.api').e2eController);
        }
        await super.start();
        const cpus = os_1.default.cpus();
        const binaryDataConfig = config_1.default.getEnv('binaryDataManager');
        const diagnosticInfo = {
            basicAuthActive: config_1.default.getEnv('security.basicAuth.active'),
            databaseType: config_1.default.getEnv('database.type'),
            disableProductionWebhooksOnMainProcess: config_1.default.getEnv('endpoints.disableProductionWebhooksOnMainProcess'),
            notificationsEnabled: config_1.default.getEnv('versionNotifications.enabled'),
            versionCli: constants_1.N8N_VERSION,
            systemInfo: {
                os: {
                    type: os_1.default.type(),
                    version: os_1.default.version(),
                },
                memory: os_1.default.totalmem() / 1024,
                cpus: {
                    count: cpus.length,
                    model: cpus[0].model,
                    speed: cpus[0].speed,
                },
            },
            executionVariables: {
                executions_process: config_1.default.getEnv('executions.process'),
                executions_mode: config_1.default.getEnv('executions.mode'),
                executions_timeout: config_1.default.getEnv('executions.timeout'),
                executions_timeout_max: config_1.default.getEnv('executions.maxTimeout'),
                executions_data_save_on_error: config_1.default.getEnv('executions.saveDataOnError'),
                executions_data_save_on_success: config_1.default.getEnv('executions.saveDataOnSuccess'),
                executions_data_save_on_progress: config_1.default.getEnv('executions.saveExecutionProgress'),
                executions_data_save_manual_executions: config_1.default.getEnv('executions.saveDataManualExecutions'),
                executions_data_prune: config_1.default.getEnv('executions.pruneData'),
                executions_data_max_age: config_1.default.getEnv('executions.pruneDataMaxAge'),
                executions_data_prune_timeout: config_1.default.getEnv('executions.pruneDataTimeout'),
            },
            deploymentType: config_1.default.getEnv('deployment.type'),
            binaryDataMode: binaryDataConfig.mode,
            n8n_multi_user_allowed: (0, UserManagementHelper_1.isUserManagementEnabled)(),
            smtp_set_up: config_1.default.getEnv('userManagement.emails.mode') === 'smtp',
            ldap_allowed: (0, ssoHelpers_1.isLdapCurrentAuthenticationMethod)(),
            saml_enabled: (0, ssoHelpers_1.isSamlCurrentAuthenticationMethod)(),
        };
        (0, events_1.initEvents)();
        if (constants_1.inDevelopment && process.env.N8N_DEV_RELOAD === 'true') {
            const { reloadNodesAndCredentials } = await Promise.resolve().then(() => __importStar(require('./ReloadNodesAndCredentials')));
            await reloadNodesAndCredentials(this.loadNodesAndCredentials, this.nodeTypes, this.push);
        }
        void Db.collections.Workflow.findOne({
            select: ['createdAt'],
            order: { createdAt: 'ASC' },
            where: {},
        }).then(async (workflow) => typedi_1.Container.get(InternalHooks_1.InternalHooks).onServerStarted(diagnosticInfo, workflow === null || workflow === void 0 ? void 0 : workflow.createdAt));
    }
    getSettingsForFrontend() {
        Object.assign(this.frontendSettings.userManagement, {
            enabled: (0, UserManagementHelper_1.isUserManagementEnabled)(),
            authenticationMethod: (0, ssoHelpers_1.getCurrentAuthenticationMethod)(),
            showSetupOnFirstLoad: config_1.default.getEnv('userManagement.disabled') === false &&
                config_1.default.getEnv('userManagement.isInstanceOwnerSetUp') === false &&
                config_1.default.getEnv('userManagement.skipInstanceOwnerSetup') === false &&
                config_1.default.getEnv('deployment.type').startsWith('desktop_') === false,
        });
        Object.assign(this.frontendSettings.enterprise, {
            sharing: (0, UserManagementHelper_1.isSharingEnabled)(),
            logStreaming: (0, MessageEventBusHelper_1.isLogStreamingEnabled)(),
            ldap: (0, helpers_1.isLdapEnabled)(),
            saml: (0, samlHelpers_1.isSamlLicensed)(),
            advancedExecutionFilters: (0, executionHelpers_1.isAdvancedExecutionFiltersEnabled)(),
            variables: (0, enviromentHelpers_1.isVariablesEnabled)(),
            versionControl: (0, versionControlHelper_1.isVersionControlLicensed)(),
        });
        if ((0, helpers_1.isLdapEnabled)()) {
            Object.assign(this.frontendSettings.sso.ldap, {
                loginLabel: (0, helpers_1.getLdapLoginLabel)(),
                loginEnabled: (0, helpers_1.isLdapLoginEnabled)(),
            });
        }
        if ((0, samlHelpers_1.isSamlLicensed)()) {
            Object.assign(this.frontendSettings.sso.saml, {
                loginLabel: (0, samlHelpers_1.getSamlLoginLabel)(),
                loginEnabled: (0, samlHelpers_1.isSamlLoginEnabled)(),
            });
        }
        if ((0, enviromentHelpers_1.isVariablesEnabled)()) {
            this.frontendSettings.variables.limit = (0, enviromentHelpers_1.getVariablesLimit)();
        }
        if (config_1.default.get('nodes.packagesMissing').length > 0) {
            this.frontendSettings.missingPackages = true;
        }
        return this.frontendSettings;
    }
    registerControllers(ignoredEndpoints) {
        const { app, externalHooks, activeWorkflowRunner, nodeTypes } = this;
        const repositories = Db.collections;
        (0, middlewares_1.setupAuthMiddlewares)(app, ignoredEndpoints, this.restEndpoint, repositories.User);
        const logger = n8n_workflow_1.LoggerProxy;
        const internalHooks = typedi_1.Container.get(InternalHooks_1.InternalHooks);
        const mailer = typedi_1.Container.get(email_1.UserManagementMailer);
        const postHog = this.postHog;
        const samlService = typedi_1.Container.get(saml_service_ee_1.SamlService);
        const versionControlService = typedi_1.Container.get(versionControl_service_ee_1.VersionControlService);
        const controllers = [
            new eventBus_controller_1.EventBusController(),
            new controllers_1.AuthController({ config: config_1.default, internalHooks, repositories, logger, postHog }),
            new controllers_1.OwnerController({ config: config_1.default, internalHooks, repositories, logger }),
            new controllers_1.MeController({ externalHooks, internalHooks, repositories, logger }),
            new controllers_1.NodeTypesController({ config: config_1.default, nodeTypes }),
            new controllers_1.PasswordResetController({
                config: config_1.default,
                externalHooks,
                internalHooks,
                mailer,
                repositories,
                logger,
            }),
            new controllers_1.TagsController({ config: config_1.default, repositories, externalHooks }),
            new controllers_1.TranslationController(config_1.default, this.credentialTypes),
            new controllers_1.UsersController({
                config: config_1.default,
                mailer,
                externalHooks,
                internalHooks,
                repositories,
                activeWorkflowRunner,
                logger,
                postHog,
            }),
            new saml_controller_ee_1.SamlController(samlService),
            new versionControl_controller_ee_1.VersionControlController(versionControlService),
        ];
        if ((0, helpers_1.isLdapEnabled)()) {
            const { service, sync } = LdapManager_ee_1.LdapManager.getInstance();
            controllers.push(new controllers_1.LdapController(service, sync, internalHooks));
        }
        if (config_1.default.getEnv('nodes.communityPackages.enabled')) {
            controllers.push(new controllers_1.NodesController(config_1.default, this.loadNodesAndCredentials, this.push, internalHooks));
        }
        controllers.forEach((controller) => (0, decorators_1.registerController)(app, config_1.default, controller));
    }
    async configure() {
        (0, metrics_1.configureMetrics)(this.app);
        this.instanceId = await n8n_core_1.UserSettings.getInstanceId();
        this.frontendSettings.isNpmAvailable = await exec('npm --version')
            .then(() => true)
            .catch(() => false);
        this.frontendSettings.versionCli = constants_1.N8N_VERSION;
        this.frontendSettings.instanceId = this.instanceId;
        await this.externalHooks.run('frontend.settings', [this.frontendSettings]);
        await this.postHog.init(this.frontendSettings.instanceId);
        const publicApiEndpoint = config_1.default.getEnv('publicApi.path');
        const excludeEndpoints = config_1.default.getEnv('security.excludeEndpoints');
        const ignoredEndpoints = [
            'assets',
            'healthz',
            'metrics',
            'e2e',
            this.endpointWebhook,
            this.endpointWebhookTest,
            this.endpointPresetCredentials,
            config_1.default.getEnv('publicApi.disabled') ? publicApiEndpoint : '',
            ...excludeEndpoints.split(':'),
        ].filter((u) => !!u);
        (0, assert_1.default)(!ignoredEndpoints.includes(this.restEndpoint), `REST endpoint cannot be set to any of these values: ${ignoredEndpoints.join()} `);
        const authIgnoreRegex = new RegExp(`^\/(${ignoredEndpoints.join('|')})\/?.*$`);
        if (config_1.default.getEnv('security.basicAuth.active')) {
            await (0, basicAuth_1.setupBasicAuth)(this.app, config_1.default, authIgnoreRegex);
        }
        if (config_1.default.getEnv('security.jwtAuth.active')) {
            await (0, externalJWTAuth_1.setupExternalJWTAuth)(this.app, config_1.default, authIgnoreRegex);
        }
        if (!config_1.default.getEnv('publicApi.disabled')) {
            const { apiRouters, apiLatestVersion } = await (0, PublicApi_1.loadPublicApiVersions)(publicApiEndpoint);
            this.app.use(...apiRouters);
            this.frontendSettings.publicApi.latestVersion = apiLatestVersion;
        }
        this.app.use((0, cookie_parser_1.default)());
        const { restEndpoint, app } = this;
        (0, push_1.setupPushHandler)(restEndpoint, app, (0, UserManagementHelper_1.isUserManagementEnabled)());
        this.app.use((0, connect_history_api_fallback_1.default)({
            rewrites: [
                {
                    from: new RegExp(`^/(${[this.restEndpoint, ...ignoredEndpoints].join('|')})/?.*$`),
                    to: (context) => {
                        return context.parsedUrl.pathname.toString();
                    },
                },
            ],
        }));
        if (config_1.default.getEnv('executions.mode') === 'queue') {
            await typedi_1.Container.get(Queue_1.Queue).init();
        }
        await (0, helpers_1.handleLdapInit)();
        this.registerControllers(ignoredEndpoints);
        this.app.use(`/${this.restEndpoint}/credentials`, credentials_controller_1.credentialsController);
        this.app.use(`/${this.restEndpoint}/workflows`, workflows_controller_1.workflowsController);
        this.app.use(`/${this.restEndpoint}/license`, license_controller_1.licenseController);
        this.app.use(`/${this.restEndpoint}/workflow-stats`, workflowStats_api_1.workflowStatsController);
        try {
            await typedi_1.Container.get(saml_service_ee_1.SamlService).init();
        }
        catch (error) {
            n8n_workflow_1.LoggerProxy.warn(`SAML initialization failed: ${error.message}`);
        }
        this.app.use(`/${this.restEndpoint}/variables`, variables_controller_1.variablesController);
        try {
            await typedi_1.Container.get(versionControl_service_ee_1.VersionControlService).init();
        }
        catch (error) {
            n8n_workflow_1.LoggerProxy.warn(`Version Control initialization failed: ${error.message}`);
        }
        this.app.get(`/${this.restEndpoint}/node-parameter-options`, ResponseHelper.send(async (req) => {
            const nodeTypeAndVersion = (0, n8n_workflow_1.jsonParse)(req.query.nodeTypeAndVersion);
            const { path, methodName } = req.query;
            const currentNodeParameters = (0, n8n_workflow_1.jsonParse)(req.query.currentNodeParameters);
            let credentials;
            if (req.query.credentials) {
                credentials = (0, n8n_workflow_1.jsonParse)(req.query.credentials);
            }
            const loadDataInstance = new n8n_core_1.LoadNodeParameterOptions(nodeTypeAndVersion, this.nodeTypes, path, currentNodeParameters, credentials);
            const additionalData = await WorkflowExecuteAdditionalData.getBase(req.user.id, currentNodeParameters);
            if (methodName) {
                return loadDataInstance.getOptionsViaMethodName(methodName, additionalData);
            }
            if (req.query.loadOptions) {
                return loadDataInstance.getOptionsViaRequestProperty((0, n8n_workflow_1.jsonParse)(req.query.loadOptions), additionalData);
            }
            return [];
        }));
        this.app.get(`/${this.restEndpoint}/nodes-list-search`, ResponseHelper.send(async (req, res) => {
            const nodeTypeAndVersion = (0, n8n_workflow_1.jsonParse)(req.query.nodeTypeAndVersion);
            const { path, methodName } = req.query;
            if (!req.query.currentNodeParameters) {
                throw new ResponseHelper.BadRequestError('Parameter currentNodeParameters is required.');
            }
            const currentNodeParameters = (0, n8n_workflow_1.jsonParse)(req.query.currentNodeParameters);
            let credentials;
            if (req.query.credentials) {
                credentials = (0, n8n_workflow_1.jsonParse)(req.query.credentials);
            }
            const listSearchInstance = new n8n_core_1.LoadNodeListSearch(nodeTypeAndVersion, this.nodeTypes, path, currentNodeParameters, credentials);
            const additionalData = await WorkflowExecuteAdditionalData.getBase(req.user.id, currentNodeParameters);
            if (methodName) {
                return listSearchInstance.getOptionsViaMethodName(methodName, additionalData, req.query.filter, req.query.paginationToken);
            }
            throw new ResponseHelper.BadRequestError('Parameter methodName is required.');
        }));
        this.app.get(`/${this.restEndpoint}/active`, ResponseHelper.send(async (req) => {
            const activeWorkflows = await this.activeWorkflowRunner.getActiveWorkflows(req.user);
            return activeWorkflows.map(({ id }) => id);
        }));
        this.app.get(`/${this.restEndpoint}/active/error/:id`, ResponseHelper.send(async (req) => {
            const { id: workflowId } = req.params;
            const shared = await Db.collections.SharedWorkflow.findOne({
                relations: ['workflow'],
                where: (0, UserManagementHelper_1.whereClause)({
                    user: req.user,
                    entityType: 'workflow',
                    entityId: workflowId,
                }),
            });
            if (!shared) {
                n8n_workflow_1.LoggerProxy.verbose('User attempted to access workflow errors without permissions', {
                    workflowId,
                    userId: req.user.id,
                });
                throw new ResponseHelper.BadRequestError(`Workflow with ID "${workflowId}" could not be found.`);
            }
            return this.activeWorkflowRunner.getActivationError(workflowId);
        }));
        this.app.post(`/${this.restEndpoint}/curl-to-json`, ResponseHelper.send(async (req, res) => {
            var _a;
            const curlCommand = (_a = req.body.curlCommand) !== null && _a !== void 0 ? _a : '';
            try {
                const parameters = (0, CurlConverterHelper_1.toHttpNodeParameters)(curlCommand);
                return ResponseHelper.flattenObject(parameters, 'parameters');
            }
            catch (e) {
                throw new ResponseHelper.BadRequestError('Invalid cURL command');
            }
        }));
        this.app.get(`/${this.restEndpoint}/oauth1-credential/auth`, ResponseHelper.send(async (req) => {
            const { id: credentialId } = req.query;
            if (!credentialId) {
                n8n_workflow_1.LoggerProxy.error('OAuth1 credential authorization failed due to missing credential ID');
                throw new ResponseHelper.BadRequestError('Required credential ID is missing');
            }
            const credential = await (0, CredentialsHelper_1.getCredentialForUser)(credentialId, req.user);
            if (!credential) {
                n8n_workflow_1.LoggerProxy.error('OAuth1 credential authorization failed because the current user does not have the correct permissions', { userId: req.user.id });
                throw new ResponseHelper.NotFoundError(constants_1.RESPONSE_ERROR_MESSAGES.NO_CREDENTIAL);
            }
            let encryptionKey;
            try {
                encryptionKey = await n8n_core_1.UserSettings.getEncryptionKey();
            }
            catch (error) {
                throw new ResponseHelper.InternalServerError(error.message);
            }
            const mode = 'internal';
            const timezone = config_1.default.getEnv('generic.timezone');
            const credentialsHelper = new CredentialsHelper_1.CredentialsHelper(encryptionKey);
            const decryptedDataOriginal = await credentialsHelper.getDecrypted(credential, credential.type, mode, timezone, true);
            const oauthCredentials = credentialsHelper.applyDefaultsAndOverwrites(decryptedDataOriginal, credential.type, mode, timezone);
            const signatureMethod = oauthCredentials.signatureMethod;
            const oAuthOptions = {
                consumer: {
                    key: oauthCredentials.consumerKey,
                    secret: oauthCredentials.consumerSecret,
                },
                signature_method: signatureMethod,
                hash_function(base, key) {
                    const algorithm = signatureMethod === 'HMAC-SHA1' ? 'sha1' : 'sha256';
                    return (0, crypto_1.createHmac)(algorithm, key).update(base).digest('base64');
                },
            };
            const oauthRequestData = {
                oauth_callback: `${WebhookHelpers.getWebhookBaseUrl()}${this.restEndpoint}/oauth1-credential/callback?cid=${credentialId}`,
            };
            await this.externalHooks.run('oauth1.authenticate', [oAuthOptions, oauthRequestData]);
            const oauth = new oauth_1_0a_1.default(oAuthOptions);
            const options = {
                method: 'POST',
                url: oauthCredentials.requestTokenUrl,
                data: oauthRequestData,
            };
            const data = oauth.toHeader(oauth.authorize(options));
            options.headers = data;
            const { data: response } = await axios_1.default.request(options);
            const paramsParser = new URLSearchParams(response);
            const responseJson = Object.fromEntries(paramsParser.entries());
            const returnUri = `${oauthCredentials.authUrl}?oauth_token=${responseJson.oauth_token}`;
            const credentials = new n8n_core_1.Credentials(credential, credential.type, credential.nodesAccess);
            credentials.setData(decryptedDataOriginal, encryptionKey);
            const newCredentialsData = credentials.getDataToSave();
            newCredentialsData.updatedAt = new Date();
            await Db.collections.Credentials.update(credentialId, newCredentialsData);
            n8n_workflow_1.LoggerProxy.verbose('OAuth1 authorization successful for new credential', {
                userId: req.user.id,
                credentialId,
            });
            return returnUri;
        }));
        this.app.get(`/${this.restEndpoint}/oauth1-credential/callback`, async (req, res) => {
            var _a, _b, _c, _d, _e;
            try {
                const { oauth_verifier, oauth_token, cid: credentialId } = req.query;
                if (!oauth_verifier || !oauth_token) {
                    const errorResponse = new ResponseHelper.ServiceUnavailableError(`Insufficient parameters for OAuth1 callback. Received following query parameters: ${JSON.stringify(req.query)}`);
                    n8n_workflow_1.LoggerProxy.error('OAuth1 callback failed because of insufficient parameters received', {
                        userId: (_a = req.user) === null || _a === void 0 ? void 0 : _a.id,
                        credentialId,
                    });
                    return ResponseHelper.sendErrorResponse(res, errorResponse);
                }
                const credential = await (0, CredentialsHelper_1.getCredentialWithoutUser)(credentialId);
                if (!credential) {
                    n8n_workflow_1.LoggerProxy.error('OAuth1 callback failed because of insufficient user permissions', {
                        userId: (_b = req.user) === null || _b === void 0 ? void 0 : _b.id,
                        credentialId,
                    });
                    const errorResponse = new ResponseHelper.NotFoundError(constants_1.RESPONSE_ERROR_MESSAGES.NO_CREDENTIAL);
                    return ResponseHelper.sendErrorResponse(res, errorResponse);
                }
                let encryptionKey;
                try {
                    encryptionKey = await n8n_core_1.UserSettings.getEncryptionKey();
                }
                catch (error) {
                    throw new ResponseHelper.InternalServerError(error.message);
                }
                const mode = 'internal';
                const timezone = config_1.default.getEnv('generic.timezone');
                const credentialsHelper = new CredentialsHelper_1.CredentialsHelper(encryptionKey);
                const decryptedDataOriginal = await credentialsHelper.getDecrypted(credential, credential.type, mode, timezone, true);
                const oauthCredentials = credentialsHelper.applyDefaultsAndOverwrites(decryptedDataOriginal, credential.type, mode, timezone);
                const options = {
                    method: 'POST',
                    url: oauthCredentials.accessTokenUrl,
                    params: {
                        oauth_token,
                        oauth_verifier,
                    },
                };
                let oauthToken;
                try {
                    oauthToken = await axios_1.default.request(options);
                }
                catch (error) {
                    n8n_workflow_1.LoggerProxy.error('Unable to fetch tokens for OAuth1 callback', {
                        userId: (_c = req.user) === null || _c === void 0 ? void 0 : _c.id,
                        credentialId,
                    });
                    const errorResponse = new ResponseHelper.NotFoundError('Unable to get access tokens!');
                    return ResponseHelper.sendErrorResponse(res, errorResponse);
                }
                const paramParser = new URLSearchParams(oauthToken.data);
                const oauthTokenJson = Object.fromEntries(paramParser.entries());
                decryptedDataOriginal.oauthTokenData = oauthTokenJson;
                const credentials = new n8n_core_1.Credentials(credential, credential.type, credential.nodesAccess);
                credentials.setData(decryptedDataOriginal, encryptionKey);
                const newCredentialsData = credentials.getDataToSave();
                newCredentialsData.updatedAt = new Date();
                await Db.collections.Credentials.update(credentialId, newCredentialsData);
                n8n_workflow_1.LoggerProxy.verbose('OAuth1 callback successful for new credential', {
                    userId: (_d = req.user) === null || _d === void 0 ? void 0 : _d.id,
                    credentialId,
                });
                res.sendFile((0, path_1.resolve)(constants_1.TEMPLATES_DIR, 'oauth-callback.html'));
            }
            catch (error) {
                n8n_workflow_1.LoggerProxy.error('OAuth1 callback failed because of insufficient user permissions', {
                    userId: (_e = req.user) === null || _e === void 0 ? void 0 : _e.id,
                    credentialId: req.query.cid,
                });
                return ResponseHelper.sendErrorResponse(res, error);
            }
        });
        this.app.use(`/${this.restEndpoint}/oauth2-credential`, oauth2Credential_api_1.oauth2CredentialController);
        this.app.use(`/${this.restEndpoint}/executions`, executions_controller_1.executionsController);
        this.app.get(`/${this.restEndpoint}/executions-current`, ResponseHelper.send(async (req) => {
            if (config_1.default.getEnv('executions.mode') === 'queue') {
                const queue = typedi_1.Container.get(Queue_1.Queue);
                const currentJobs = await queue.getJobs(['active', 'waiting']);
                const currentlyRunningQueueIds = currentJobs.map((job) => job.data.executionId);
                const currentlyRunningManualExecutions = this.activeExecutionsInstance.getActiveExecutions();
                const manualExecutionIds = currentlyRunningManualExecutions.map((execution) => execution.id);
                const currentlyRunningExecutionIds = currentlyRunningQueueIds.concat(manualExecutionIds);
                if (!currentlyRunningExecutionIds.length)
                    return [];
                const findOptions = {
                    select: ['id', 'workflowId', 'mode', 'retryOf', 'startedAt', 'stoppedAt', 'status'],
                    order: { id: 'DESC' },
                    where: {
                        id: (0, typeorm_1.In)(currentlyRunningExecutionIds),
                        status: (0, typeorm_1.Not)((0, typeorm_1.In)(['finished', 'stopped', 'failed', 'crashed'])),
                    },
                };
                const sharedWorkflowIds = await (0, WorkflowHelpers_1.getSharedWorkflowIds)(req.user);
                if (!sharedWorkflowIds.length)
                    return [];
                if (req.query.filter) {
                    const { workflowId, status, finished } = (0, n8n_workflow_1.jsonParse)(req.query.filter);
                    if (workflowId && sharedWorkflowIds.includes(workflowId)) {
                        Object.assign(findOptions.where, { workflowId });
                    }
                    if (status) {
                        Object.assign(findOptions.where, { status: (0, typeorm_1.In)(status) });
                    }
                    if (finished) {
                        Object.assign(findOptions.where, { finished });
                    }
                }
                else {
                    Object.assign(findOptions.where, { workflowId: (0, typeorm_1.In)(sharedWorkflowIds) });
                }
                const executions = await Db.collections.Execution.find(findOptions);
                if (!executions.length)
                    return [];
                return executions.map((execution) => {
                    var _a, _b;
                    if (!execution.status) {
                        execution.status = (0, executionHelpers_1.getStatusUsingPreviousExecutionStatusMethod)(execution);
                    }
                    return {
                        id: execution.id,
                        workflowId: execution.workflowId,
                        mode: execution.mode,
                        retryOf: execution.retryOf !== null ? execution.retryOf : undefined,
                        startedAt: new Date(execution.startedAt),
                        status: (_a = execution.status) !== null && _a !== void 0 ? _a : null,
                        stoppedAt: (_b = execution.stoppedAt) !== null && _b !== void 0 ? _b : null,
                    };
                });
            }
            const executingWorkflows = this.activeExecutionsInstance.getActiveExecutions();
            const returnData = [];
            const filter = req.query.filter ? (0, n8n_workflow_1.jsonParse)(req.query.filter) : {};
            const sharedWorkflowIds = await (0, WorkflowHelpers_1.getSharedWorkflowIds)(req.user);
            for (const data of executingWorkflows) {
                if ((filter.workflowId !== undefined && filter.workflowId !== data.workflowId) ||
                    (data.workflowId !== undefined && !sharedWorkflowIds.includes(data.workflowId))) {
                    continue;
                }
                returnData.push({
                    id: data.id,
                    workflowId: data.workflowId === undefined ? '' : data.workflowId,
                    mode: data.mode,
                    retryOf: data.retryOf,
                    startedAt: new Date(data.startedAt),
                    status: data.status,
                });
            }
            returnData.sort((a, b) => Number(b.id) - Number(a.id));
            return returnData;
        }));
        this.app.post(`/${this.restEndpoint}/executions-current/:id/stop`, ResponseHelper.send(async (req) => {
            const { id: executionId } = req.params;
            const sharedWorkflowIds = await (0, WorkflowHelpers_1.getSharedWorkflowIds)(req.user);
            if (!sharedWorkflowIds.length) {
                throw new ResponseHelper.NotFoundError('Execution not found');
            }
            const execution = await Db.collections.Execution.findOne({
                where: {
                    id: executionId,
                    workflowId: (0, typeorm_1.In)(sharedWorkflowIds),
                },
            });
            if (!execution) {
                throw new ResponseHelper.NotFoundError('Execution not found');
            }
            if (config_1.default.getEnv('executions.mode') === 'queue') {
                const result = await this.activeExecutionsInstance.stopExecution(req.params.id);
                if (result === undefined) {
                    try {
                        return await this.waitTracker.stopExecution(req.params.id);
                    }
                    catch (error) {
                    }
                }
                else {
                    return {
                        mode: result.mode,
                        startedAt: new Date(result.startedAt),
                        stoppedAt: result.stoppedAt ? new Date(result.stoppedAt) : undefined,
                        finished: result.finished,
                        status: result.status,
                    };
                }
                const queue = typedi_1.Container.get(Queue_1.Queue);
                const currentJobs = await queue.getJobs(['active', 'waiting']);
                const job = currentJobs.find((job) => job.data.executionId === req.params.id);
                if (!job) {
                    throw new Error(`Could not stop "${req.params.id}" as it is no longer in queue.`);
                }
                else {
                    await queue.stopJob(job);
                }
                const executionDb = (await Db.collections.Execution.findOneBy({
                    id: req.params.id,
                }));
                const fullExecutionData = ResponseHelper.unflattenExecutionData(executionDb);
                const returnData = {
                    mode: fullExecutionData.mode,
                    startedAt: new Date(fullExecutionData.startedAt),
                    stoppedAt: fullExecutionData.stoppedAt
                        ? new Date(fullExecutionData.stoppedAt)
                        : undefined,
                    finished: fullExecutionData.finished,
                    status: fullExecutionData.status,
                };
                return returnData;
            }
            const result = await this.activeExecutionsInstance.stopExecution(executionId);
            let returnData;
            if (result === undefined) {
                returnData = await this.waitTracker.stopExecution(executionId);
            }
            else {
                returnData = {
                    mode: result.mode,
                    startedAt: new Date(result.startedAt),
                    stoppedAt: result.stoppedAt ? new Date(result.stoppedAt) : undefined,
                    finished: result.finished,
                    status: result.status,
                };
            }
            return returnData;
        }));
        this.app.get(`/${this.restEndpoint}/options/timezones`, ResponseHelper.send(async (req, res) => {
            return google_timezones_json_1.default;
        }));
        this.app.get(`/${this.restEndpoint}/data/:path`, async (req, res) => {
            const identifier = req.params.path;
            const binaryDataManager = n8n_core_1.BinaryDataManager.getInstance();
            try {
                const binaryPath = binaryDataManager.getBinaryPath(identifier);
                let { mode, fileName, mimeType } = req.query;
                if (!fileName || !mimeType) {
                    try {
                        const metadata = await binaryDataManager.getBinaryMetadata(identifier);
                        fileName = metadata.fileName;
                        mimeType = metadata.mimeType;
                        res.setHeader('Content-Length', metadata.fileSize);
                    }
                    catch { }
                }
                if (mimeType)
                    res.setHeader('Content-Type', mimeType);
                if (mode === 'download') {
                    res.setHeader('Content-Disposition', `attachment; filename="${fileName}"`);
                }
                res.sendFile(binaryPath);
            }
            catch (error) {
                if (error instanceof n8n_core_1.FileNotFoundError)
                    res.writeHead(404).end();
                else
                    throw error;
            }
        });
        this.app.get(`/${this.restEndpoint}/settings`, ResponseHelper.send(async (req, res) => {
            void typedi_1.Container.get(InternalHooks_1.InternalHooks).onFrontendSettingsAPI(req.headers.sessionid);
            return this.getSettingsForFrontend();
        }));
        if (!eventbus_1.eventBus.isInitialized) {
            await eventbus_1.eventBus.initialize();
        }
        if (!config_1.default.getEnv('endpoints.disableProductionWebhooksOnMainProcess')) {
            this.setupWebhookEndpoint();
            this.setupWaitingWebhookEndpoint();
        }
        this.setupTestWebhookEndpoint();
        if (this.endpointPresetCredentials !== '') {
            this.app.post(`/${this.endpointPresetCredentials}`, async (req, res) => {
                if (!this.presetCredentialsLoaded) {
                    const body = req.body;
                    if (req.headers['content-type'] !== 'application/json') {
                        ResponseHelper.sendErrorResponse(res, new Error('Body must be a valid JSON, make sure the content-type is application/json'));
                        return;
                    }
                    (0, CredentialsOverwrites_1.CredentialsOverwrites)().setData(body);
                    await this.loadNodesAndCredentials.generateTypesForFrontend();
                    this.presetCredentialsLoaded = true;
                    ResponseHelper.sendSuccessResponse(res, { success: true }, true, 200);
                }
                else {
                    ResponseHelper.sendErrorResponse(res, new Error('Preset credentials can be set once'));
                }
            });
        }
        if (!config_1.default.getEnv('endpoints.disableUi')) {
            const staticOptions = {
                cacheControl: false,
                setHeaders: (res, path) => {
                    const isIndex = path === (0, path_1.join)(constants_1.GENERATED_STATIC_DIR, 'index.html');
                    const cacheControl = isIndex
                        ? 'no-cache, no-store, must-revalidate'
                        : 'max-age=86400, immutable';
                    res.header('Cache-Control', cacheControl);
                },
            };
            const serveIcons = async (req, res) => {
                let { scope, packageName } = req.params;
                if (scope)
                    packageName = `@${scope}/${packageName}`;
                const loader = this.loadNodesAndCredentials.loaders[packageName];
                if (loader) {
                    const pathPrefix = `/icons/${packageName}/`;
                    const filePath = (0, path_1.resolve)(loader.directory, req.originalUrl.substring(pathPrefix.length));
                    try {
                        await (0, promises_1.access)(filePath);
                        return res.sendFile(filePath);
                    }
                    catch { }
                }
                res.sendStatus(404);
            };
            this.app.use('/icons/@:scope/:packageName/*/*.(svg|png)', serveIcons);
            this.app.use('/icons/:packageName/*/*.(svg|png)', serveIcons);
            this.app.use('/', express_1.default.static(constants_1.GENERATED_STATIC_DIR), express_1.default.static(constants_1.EDITOR_UI_DIST_DIR, staticOptions));
            const startTime = new Date().toUTCString();
            this.app.use('/index.html', (req, res, next) => {
                res.setHeader('Last-Modified', startTime);
                next();
            });
        }
        else {
            this.app.use('/', express_1.default.static(constants_1.GENERATED_STATIC_DIR));
        }
    }
    setupPushServer() {
        const { restEndpoint, server, app } = this;
        (0, push_1.setupPushServer)(restEndpoint, server, app);
    }
}
exports.Server = Server;
//# sourceMappingURL=Server.js.map