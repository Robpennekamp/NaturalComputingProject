"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.oauth2CredentialController = void 0;
const client_oauth2_1 = __importDefault(require("client-oauth2"));
const csrf_1 = __importDefault(require("csrf"));
const express_1 = __importDefault(require("express"));
const lodash_get_1 = __importDefault(require("lodash.get"));
const lodash_omit_1 = __importDefault(require("lodash.omit"));
const lodash_set_1 = __importDefault(require("lodash.set"));
const lodash_split_1 = __importDefault(require("lodash.split"));
const lodash_unset_1 = __importDefault(require("lodash.unset"));
const n8n_core_1 = require("n8n-core");
const n8n_workflow_1 = require("n8n-workflow");
const path_1 = require("path");
const Db = __importStar(require("../Db"));
const ResponseHelper = __importStar(require("../ResponseHelper"));
const constants_1 = require("../constants");
const CredentialsHelper_1 = require("../CredentialsHelper");
const Logger_1 = require("../Logger");
const ExternalHooks_1 = require("../ExternalHooks");
const config_1 = __importDefault(require("../config"));
const UserManagementHelper_1 = require("../UserManagement/UserManagementHelper");
const typedi_1 = require("typedi");
exports.oauth2CredentialController = express_1.default.Router();
exports.oauth2CredentialController.use((req, res, next) => {
    try {
        n8n_workflow_1.LoggerProxy.getInstance();
    }
    catch (error) {
        n8n_workflow_1.LoggerProxy.init((0, Logger_1.getLogger)());
    }
    next();
});
const restEndpoint = config_1.default.getEnv('endpoints.rest');
exports.oauth2CredentialController.get('/auth', ResponseHelper.send(async (req) => {
    const { id: credentialId } = req.query;
    if (!credentialId) {
        throw new ResponseHelper.BadRequestError('Required credential ID is missing');
    }
    const credential = await (0, CredentialsHelper_1.getCredentialForUser)(credentialId, req.user);
    if (!credential) {
        n8n_workflow_1.LoggerProxy.error('Failed to authorize OAuth2 due to lack of permissions', {
            userId: req.user.id,
            credentialId,
        });
        throw new ResponseHelper.NotFoundError(constants_1.RESPONSE_ERROR_MESSAGES.NO_CREDENTIAL);
    }
    let encryptionKey;
    try {
        encryptionKey = await n8n_core_1.UserSettings.getEncryptionKey();
    }
    catch (error) {
        throw new ResponseHelper.InternalServerError(error.message);
    }
    const credentialType = credential.type;
    const mode = 'internal';
    const timezone = config_1.default.getEnv('generic.timezone');
    const credentialsHelper = new CredentialsHelper_1.CredentialsHelper(encryptionKey);
    const decryptedDataOriginal = await credentialsHelper.getDecrypted(credential, credentialType, mode, timezone, true);
    const genericOAuth2 = ['oAuth2Api', 'googleOAuth2Api', 'microsoftOAuth2Api'];
    if ((decryptedDataOriginal === null || decryptedDataOriginal === void 0 ? void 0 : decryptedDataOriginal.scope) &&
        credentialType.includes('OAuth2') &&
        !genericOAuth2.includes(credentialType)) {
        delete decryptedDataOriginal.scope;
    }
    const oauthCredentials = credentialsHelper.applyDefaultsAndOverwrites(decryptedDataOriginal, credentialType, mode, timezone);
    const token = new csrf_1.default();
    const csrfSecret = token.secretSync();
    const state = {
        token: token.create(csrfSecret),
        cid: req.query.id,
    };
    const stateEncodedStr = Buffer.from(JSON.stringify(state)).toString('base64');
    const oAuthOptions = {
        clientId: (0, lodash_get_1.default)(oauthCredentials, 'clientId'),
        clientSecret: (0, lodash_get_1.default)(oauthCredentials, 'clientSecret', ''),
        accessTokenUri: (0, lodash_get_1.default)(oauthCredentials, 'accessTokenUrl', ''),
        authorizationUri: (0, lodash_get_1.default)(oauthCredentials, 'authUrl', ''),
        redirectUri: `${(0, UserManagementHelper_1.getInstanceBaseUrl)()}/${restEndpoint}/oauth2-credential/callback`,
        scopes: (0, lodash_split_1.default)((0, lodash_get_1.default)(oauthCredentials, 'scope', 'openid,'), ','),
        state: stateEncodedStr,
    };
    await typedi_1.Container.get(ExternalHooks_1.ExternalHooks).run('oauth2.authenticate', [oAuthOptions]);
    const oAuthObj = new client_oauth2_1.default(oAuthOptions);
    const credentials = new n8n_core_1.Credentials(credential, credentialType, credential.nodesAccess);
    decryptedDataOriginal.csrfSecret = csrfSecret;
    credentials.setData(decryptedDataOriginal, encryptionKey);
    const newCredentialsData = credentials.getDataToSave();
    newCredentialsData.updatedAt = new Date();
    await Db.collections.Credentials.update(req.query.id, newCredentialsData);
    const authQueryParameters = (0, lodash_get_1.default)(oauthCredentials, 'authQueryParameters', '');
    let returnUri = oAuthObj.code.getUri();
    if ((0, lodash_get_1.default)(oauthCredentials, 'scope').includes(',')) {
        const data = returnUri.split('?')[1];
        const scope = (0, lodash_get_1.default)(oauthCredentials, 'scope');
        const percentEncoded = [data, `scope=${encodeURIComponent(scope)}`].join('&');
        returnUri = `${(0, lodash_get_1.default)(oauthCredentials, 'authUrl', '')}?${percentEncoded}`;
    }
    if (authQueryParameters) {
        returnUri += `&${authQueryParameters}`;
    }
    n8n_workflow_1.LoggerProxy.verbose('OAuth2 authentication successful for new credential', {
        userId: req.user.id,
        credentialId,
    });
    return returnUri;
}));
const renderCallbackError = (res, errorMessage) => res.render('oauth-error-callback', { error: { message: errorMessage } });
exports.oauth2CredentialController.get('/callback', async (req, res) => {
    var _a, _b, _c, _d;
    try {
        const { code, state: stateEncoded } = req.query;
        if (!code || !stateEncoded) {
            return renderCallbackError(res, `Insufficient parameters for OAuth2 callback. Received following query parameters: ${JSON.stringify(req.query)}`);
        }
        let state;
        try {
            state = JSON.parse(Buffer.from(stateEncoded, 'base64').toString());
        }
        catch (error) {
            return renderCallbackError(res, 'Invalid state format returned');
        }
        const credential = await (0, CredentialsHelper_1.getCredentialWithoutUser)(state.cid);
        if (!credential) {
            const errorMessage = 'OAuth2 callback failed because of insufficient permissions';
            n8n_workflow_1.LoggerProxy.error(errorMessage, {
                userId: (_a = req.user) === null || _a === void 0 ? void 0 : _a.id,
                credentialId: state.cid,
            });
            return renderCallbackError(res, errorMessage);
        }
        const encryptionKey = await n8n_core_1.UserSettings.getEncryptionKey();
        const mode = 'internal';
        const timezone = config_1.default.getEnv('generic.timezone');
        const credentialsHelper = new CredentialsHelper_1.CredentialsHelper(encryptionKey);
        const decryptedDataOriginal = await credentialsHelper.getDecrypted(credential, credential.type, mode, timezone, true);
        const oauthCredentials = credentialsHelper.applyDefaultsAndOverwrites(decryptedDataOriginal, credential.type, mode, timezone);
        const token = new csrf_1.default();
        if (decryptedDataOriginal.csrfSecret === undefined ||
            !token.verify(decryptedDataOriginal.csrfSecret, state.token)) {
            const errorMessage = 'The OAuth2 callback state is invalid!';
            n8n_workflow_1.LoggerProxy.debug(errorMessage, {
                userId: (_b = req.user) === null || _b === void 0 ? void 0 : _b.id,
                credentialId: state.cid,
            });
            return renderCallbackError(res, errorMessage);
        }
        let options = {};
        const oAuth2Parameters = {
            clientId: (0, lodash_get_1.default)(oauthCredentials, 'clientId'),
            clientSecret: (0, lodash_get_1.default)(oauthCredentials, 'clientSecret', ''),
            accessTokenUri: (0, lodash_get_1.default)(oauthCredentials, 'accessTokenUrl', ''),
            authorizationUri: (0, lodash_get_1.default)(oauthCredentials, 'authUrl', ''),
            redirectUri: `${(0, UserManagementHelper_1.getInstanceBaseUrl)()}/${restEndpoint}/oauth2-credential/callback`,
            scopes: (0, lodash_split_1.default)((0, lodash_get_1.default)(oauthCredentials, 'scope', 'openid,'), ','),
        };
        if ((0, lodash_get_1.default)(oauthCredentials, 'authentication', 'header') === 'body') {
            options = {
                body: {
                    client_id: (0, lodash_get_1.default)(oauthCredentials, 'clientId'),
                    client_secret: (0, lodash_get_1.default)(oauthCredentials, 'clientSecret', ''),
                },
            };
            delete oAuth2Parameters.clientSecret;
        }
        await typedi_1.Container.get(ExternalHooks_1.ExternalHooks).run('oauth2.callback', [oAuth2Parameters]);
        const oAuthObj = new client_oauth2_1.default(oAuth2Parameters);
        const queryParameters = req.originalUrl.split('?').splice(1, 1).join('');
        const oauthToken = await oAuthObj.code.getToken(`${oAuth2Parameters.redirectUri}?${queryParameters}`, options);
        if (Object.keys(req.query).length > 2) {
            (0, lodash_set_1.default)(oauthToken.data, 'callbackQueryString', (0, lodash_omit_1.default)(req.query, 'state', 'code'));
        }
        if (oauthToken === undefined) {
            const errorMessage = 'Unable to get OAuth2 access tokens!';
            n8n_workflow_1.LoggerProxy.error(errorMessage, {
                userId: (_c = req.user) === null || _c === void 0 ? void 0 : _c.id,
                credentialId: state.cid,
            });
            return renderCallbackError(res, errorMessage);
        }
        if (decryptedDataOriginal.oauthTokenData) {
            Object.assign(decryptedDataOriginal.oauthTokenData, oauthToken.data);
        }
        else {
            decryptedDataOriginal.oauthTokenData = oauthToken.data;
        }
        (0, lodash_unset_1.default)(decryptedDataOriginal, 'csrfSecret');
        const credentials = new n8n_core_1.Credentials(credential, credential.type, credential.nodesAccess);
        credentials.setData(decryptedDataOriginal, encryptionKey);
        const newCredentialsData = credentials.getDataToSave();
        newCredentialsData.updatedAt = new Date();
        await Db.collections.Credentials.update(state.cid, newCredentialsData);
        n8n_workflow_1.LoggerProxy.verbose('OAuth2 callback successful for new credential', {
            userId: (_d = req.user) === null || _d === void 0 ? void 0 : _d.id,
            credentialId: state.cid,
        });
        return res.sendFile((0, path_1.resolve)(constants_1.TEMPLATES_DIR, 'oauth-callback.html'));
    }
    catch (error) {
        return renderCallbackError(res, error.message);
    }
});
//# sourceMappingURL=oauth2Credential.api.js.map