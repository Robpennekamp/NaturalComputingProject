"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CredentialsService = void 0;
const n8n_core_1 = require("n8n-core");
const n8n_workflow_1 = require("n8n-workflow");
const typedi_1 = require("typedi");
const typeorm_1 = require("typeorm");
const Db = __importStar(require("../Db"));
const ResponseHelper = __importStar(require("../ResponseHelper"));
const CredentialsHelper_1 = require("../CredentialsHelper");
const constants_1 = require("../constants");
const CredentialsEntity_1 = require("../databases/entities/CredentialsEntity");
const SharedCredentials_1 = require("../databases/entities/SharedCredentials");
const GenericHelpers_1 = require("../GenericHelpers");
const ExternalHooks_1 = require("../ExternalHooks");
const repositories_1 = require("../databases/repositories");
const CredentialTypes_1 = require("../CredentialTypes");
class CredentialsService {
    static async get(where, options) {
        return Db.collections.Credentials.findOne({
            relations: options === null || options === void 0 ? void 0 : options.relations,
            where,
        });
    }
    static async getAll(user, options) {
        var _a, _b;
        const SELECT_FIELDS = [
            'id',
            'name',
            'type',
            'nodesAccess',
            'createdAt',
            'updatedAt',
        ];
        if (user.globalRole.name === 'owner' && (options === null || options === void 0 ? void 0 : options.disableGlobalRole) !== true) {
            return Db.collections.Credentials.find({
                select: SELECT_FIELDS,
                relations: options === null || options === void 0 ? void 0 : options.relations,
            });
        }
        const userSharings = await Db.collections.SharedCredentials.find({
            where: {
                userId: user.id,
                ...(((_a = options === null || options === void 0 ? void 0 : options.roles) === null || _a === void 0 ? void 0 : _a.length) ? { role: { name: (0, typeorm_1.In)(options.roles) } } : {}),
            },
            relations: ((_b = options === null || options === void 0 ? void 0 : options.roles) === null || _b === void 0 ? void 0 : _b.length) ? ['role'] : [],
        });
        return Db.collections.Credentials.find({
            select: SELECT_FIELDS,
            relations: options === null || options === void 0 ? void 0 : options.relations,
            where: {
                id: (0, typeorm_1.In)(userSharings.map((x) => x.credentialsId)),
            },
        });
    }
    static async getMany(filter) {
        return Db.collections.Credentials.find(filter);
    }
    static async getSharing(user, credentialId, relations = ['credentials'], { allowGlobalOwner } = { allowGlobalOwner: true }) {
        const where = { credentialsId: credentialId };
        if (!allowGlobalOwner || user.globalRole.name !== 'owner') {
            Object.assign(where, {
                userId: user.id,
                role: { name: 'owner' },
            });
            if (!relations.includes('role')) {
                relations.push('role');
            }
        }
        return Db.collections.SharedCredentials.findOne({ where, relations });
    }
    static async prepareCreateData(data) {
        const { id, ...rest } = data;
        const newCredentials = Db.collections.Credentials.create(rest);
        await (0, GenericHelpers_1.validateEntity)(newCredentials);
        for (const nodeAccess of newCredentials.nodesAccess) {
            nodeAccess.date = new Date();
        }
        return newCredentials;
    }
    static async prepareUpdateData(data, decryptedData) {
        const mergedData = (0, n8n_workflow_1.deepCopy)(data);
        if (mergedData.data) {
            mergedData.data = this.unredact(mergedData.data, decryptedData);
        }
        const updateData = Db.collections.Credentials.create(mergedData);
        await (0, GenericHelpers_1.validateEntity)(updateData);
        for (const nodeAccess of updateData.nodesAccess) {
            if (!nodeAccess.date) {
                nodeAccess.date = new Date();
            }
        }
        if (decryptedData.oauthTokenData) {
            updateData.data.oauthTokenData = decryptedData.oauthTokenData;
        }
        return updateData;
    }
    static createEncryptedData(encryptionKey, credentialId, data) {
        const credentials = new n8n_core_1.Credentials({ id: credentialId, name: data.name }, data.type, data.nodesAccess);
        credentials.setData(data.data, encryptionKey);
        const newCredentialData = credentials.getDataToSave();
        newCredentialData.updatedAt = new Date();
        return newCredentialData;
    }
    static async getEncryptionKey() {
        try {
            return await n8n_core_1.UserSettings.getEncryptionKey();
        }
        catch (error) {
            throw new ResponseHelper.InternalServerError(constants_1.RESPONSE_ERROR_MESSAGES.NO_ENCRYPTION_KEY);
        }
    }
    static async decrypt(encryptionKey, credential) {
        const coreCredential = (0, CredentialsHelper_1.createCredentialsFromCredentialsEntity)(credential);
        const data = coreCredential.getData(encryptionKey);
        return data;
    }
    static async update(credentialId, newCredentialData) {
        await typedi_1.Container.get(ExternalHooks_1.ExternalHooks).run('credentials.update', [newCredentialData]);
        await Db.collections.Credentials.update(credentialId, newCredentialData);
        return Db.collections.Credentials.findOneBy({ id: credentialId });
    }
    static async save(credential, encryptedData, user) {
        const newCredential = new CredentialsEntity_1.CredentialsEntity();
        Object.assign(newCredential, credential, encryptedData);
        await typedi_1.Container.get(ExternalHooks_1.ExternalHooks).run('credentials.create', [encryptedData]);
        const role = await typedi_1.Container.get(repositories_1.RoleRepository).findCredentialOwnerRoleOrFail();
        const result = await Db.transaction(async (transactionManager) => {
            const savedCredential = await transactionManager.save(newCredential);
            savedCredential.data = newCredential.data;
            const newSharedCredential = new SharedCredentials_1.SharedCredentials();
            Object.assign(newSharedCredential, {
                role,
                user,
                credentials: savedCredential,
            });
            await transactionManager.save(newSharedCredential);
            return savedCredential;
        });
        n8n_workflow_1.LoggerProxy.verbose('New credential created', {
            credentialId: newCredential.id,
            ownerId: user.id,
        });
        return result;
    }
    static async delete(credentials) {
        await typedi_1.Container.get(ExternalHooks_1.ExternalHooks).run('credentials.delete', [credentials.id]);
        await Db.collections.Credentials.remove(credentials);
    }
    static async test(user, encryptionKey, credentials) {
        const helper = new CredentialsHelper_1.CredentialsHelper(encryptionKey);
        return helper.testCredentials(user, credentials.type, credentials);
    }
    static redact(data, credential) {
        var _a;
        const copiedData = (0, n8n_workflow_1.deepCopy)(data);
        const credTypes = typedi_1.Container.get(CredentialTypes_1.CredentialTypes);
        let credType;
        try {
            credType = credTypes.getByName(credential.type);
        }
        catch {
            return data;
        }
        const getExtendedProps = (type) => {
            var _a;
            const props = [];
            for (const e of (_a = type.extends) !== null && _a !== void 0 ? _a : []) {
                const extendsType = credTypes.getByName(e);
                const extendedProps = getExtendedProps(extendsType);
                n8n_workflow_1.NodeHelpers.mergeNodeProperties(props, extendedProps);
            }
            n8n_workflow_1.NodeHelpers.mergeNodeProperties(props, type.properties);
            return props;
        };
        const properties = getExtendedProps(credType);
        for (const dataKey of Object.keys(copiedData)) {
            if (dataKey === 'oauthTokenData') {
                copiedData[dataKey] = constants_1.CREDENTIAL_BLANKING_VALUE;
                continue;
            }
            const prop = properties.find((v) => v.name === dataKey);
            if (!prop) {
                continue;
            }
            if ((_a = prop.typeOptions) === null || _a === void 0 ? void 0 : _a.password) {
                copiedData[dataKey] = constants_1.CREDENTIAL_BLANKING_VALUE;
            }
        }
        return copiedData;
    }
    static unredactRestoreValues(unmerged, replacement) {
        for (const [key, value] of Object.entries(unmerged)) {
            if (value === constants_1.CREDENTIAL_BLANKING_VALUE) {
                unmerged[key] = replacement[key];
            }
            else if (typeof value === 'object' &&
                value !== null &&
                key in replacement &&
                typeof replacement[key] === 'object' &&
                replacement[key] !== null) {
                this.unredactRestoreValues(value, replacement[key]);
            }
        }
    }
    static unredact(redactedData, savedData) {
        const mergedData = (0, n8n_workflow_1.deepCopy)(redactedData);
        this.unredactRestoreValues(mergedData, savedData);
        return mergedData;
    }
}
exports.CredentialsService = CredentialsService;
//# sourceMappingURL=credentials.service.js.map