"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isNpmError = exports.isClientError = exports.removePackageFromMissingList = exports.hasPackageLoaded = exports.checkNpmPackageStatus = exports.matchMissingPackages = exports.matchPackagesWithUpdates = exports.executeCommand = exports.sanitizeNpmPackageName = exports.parseNpmPackageName = void 0;
const util_1 = require("util");
const child_process_1 = require("child_process");
const promises_1 = require("fs/promises");
const axios_1 = __importDefault(require("axios"));
const n8n_core_1 = require("n8n-core");
const n8n_workflow_1 = require("n8n-workflow");
const constants_1 = require("../constants");
const config_1 = __importDefault(require("../config"));
const { PACKAGE_NAME_NOT_PROVIDED, DISK_IS_FULL, PACKAGE_FAILED_TO_INSTALL, PACKAGE_VERSION_NOT_FOUND, PACKAGE_DOES_NOT_CONTAIN_NODES, PACKAGE_NOT_FOUND, } = constants_1.RESPONSE_ERROR_MESSAGES;
const { NPM_PACKAGE_NOT_FOUND_ERROR, NPM_NO_VERSION_AVAILABLE, NPM_DISK_NO_SPACE, NPM_DISK_INSUFFICIENT_SPACE, NPM_PACKAGE_VERSION_NOT_FOUND_ERROR, } = constants_1.NPM_COMMAND_TOKENS;
const execAsync = (0, util_1.promisify)(child_process_1.exec);
const INVALID_OR_SUSPICIOUS_PACKAGE_NAME = /[^0-9a-z@\-./]/;
const parseNpmPackageName = (rawString) => {
    if (!rawString)
        throw new Error(PACKAGE_NAME_NOT_PROVIDED);
    if (INVALID_OR_SUSPICIOUS_PACKAGE_NAME.test(rawString))
        throw new Error('Package name must be a single word');
    const scope = rawString.includes('/') ? rawString.split('/')[0] : undefined;
    const packageNameWithoutScope = scope ? rawString.replace(`${scope}/`, '') : rawString;
    if (!packageNameWithoutScope.startsWith(constants_1.NODE_PACKAGE_PREFIX)) {
        throw new Error(`Package name must start with ${constants_1.NODE_PACKAGE_PREFIX}`);
    }
    const version = packageNameWithoutScope.includes('@')
        ? packageNameWithoutScope.split('@')[1]
        : undefined;
    const packageName = version ? rawString.replace(`@${version}`, '') : rawString;
    return {
        packageName,
        scope,
        version,
        rawString,
    };
};
exports.parseNpmPackageName = parseNpmPackageName;
exports.sanitizeNpmPackageName = exports.parseNpmPackageName;
const executeCommand = async (command, options) => {
    const downloadFolder = n8n_core_1.UserSettings.getUserN8nFolderDownloadedNodesPath();
    const execOptions = {
        cwd: downloadFolder,
        env: {
            NODE_PATH: process.env.NODE_PATH,
            PATH: process.env.PATH,
            APPDATA: process.env.APPDATA,
        },
    };
    try {
        await (0, promises_1.access)(downloadFolder);
    }
    catch {
        await (0, promises_1.mkdir)(downloadFolder);
        await execAsync('npm init -y', execOptions);
    }
    try {
        const commandResult = await execAsync(command, execOptions);
        return commandResult.stdout;
    }
    catch (error) {
        if (options === null || options === void 0 ? void 0 : options.doNotHandleError)
            throw error;
        const errorMessage = error instanceof Error ? error.message : constants_1.UNKNOWN_FAILURE_REASON;
        const map = {
            [NPM_PACKAGE_NOT_FOUND_ERROR]: PACKAGE_NOT_FOUND,
            [NPM_NO_VERSION_AVAILABLE]: PACKAGE_NOT_FOUND,
            [NPM_PACKAGE_VERSION_NOT_FOUND_ERROR]: PACKAGE_VERSION_NOT_FOUND,
            [NPM_DISK_NO_SPACE]: DISK_IS_FULL,
            [NPM_DISK_INSUFFICIENT_SPACE]: DISK_IS_FULL,
        };
        Object.entries(map).forEach(([npmMessage, n8nMessage]) => {
            if (errorMessage.includes(npmMessage))
                throw new Error(n8nMessage);
        });
        n8n_workflow_1.LoggerProxy.warn('npm command failed', { errorMessage });
        throw new Error(PACKAGE_FAILED_TO_INSTALL);
    }
};
exports.executeCommand = executeCommand;
function matchPackagesWithUpdates(packages, updates) {
    if (!updates)
        return packages;
    return packages.reduce((acc, cur) => {
        const publicPackage = { ...cur };
        const update = updates[cur.packageName];
        if (update)
            publicPackage.updateAvailable = update.latest;
        acc.push(publicPackage);
        return acc;
    }, []);
}
exports.matchPackagesWithUpdates = matchPackagesWithUpdates;
function matchMissingPackages(installedPackages, missingPackages) {
    const missingPackageNames = missingPackages.split(' ');
    const missingPackagesList = missingPackageNames.map((missingPackageName) => {
        try {
            const parsedPackageData = (0, exports.parseNpmPackageName)(missingPackageName);
            return parsedPackageData.packageName;
        }
        catch { }
        return undefined;
    });
    const hydratedPackageList = [];
    installedPackages.forEach((installedPackage) => {
        const hydratedInstalledPackage = { ...installedPackage };
        if (missingPackagesList.includes(hydratedInstalledPackage.packageName)) {
            hydratedInstalledPackage.failedLoading = true;
        }
        hydratedPackageList.push(hydratedInstalledPackage);
    });
    return hydratedPackageList;
}
exports.matchMissingPackages = matchMissingPackages;
async function checkNpmPackageStatus(packageName) {
    const N8N_BACKEND_SERVICE_URL = 'https://api.n8n.io/api/package';
    try {
        const response = await axios_1.default.post(N8N_BACKEND_SERVICE_URL, { name: packageName }, { method: 'POST' });
        if (response.data.status !== constants_1.NPM_PACKAGE_STATUS_GOOD)
            return response.data;
    }
    catch (error) {
    }
    return { status: constants_1.NPM_PACKAGE_STATUS_GOOD };
}
exports.checkNpmPackageStatus = checkNpmPackageStatus;
function hasPackageLoaded(packageName) {
    const missingPackages = config_1.default.get('nodes.packagesMissing');
    if (!missingPackages)
        return true;
    return !missingPackages
        .split(' ')
        .some((packageNameAndVersion) => packageNameAndVersion.startsWith(packageName) &&
        packageNameAndVersion.replace(packageName, '').startsWith('@'));
}
exports.hasPackageLoaded = hasPackageLoaded;
function removePackageFromMissingList(packageName) {
    try {
        const failedPackages = config_1.default.get('nodes.packagesMissing').split(' ');
        const packageFailedToLoad = failedPackages.filter((packageNameAndVersion) => !packageNameAndVersion.startsWith(packageName) ||
            !packageNameAndVersion.replace(packageName, '').startsWith('@'));
        config_1.default.set('nodes.packagesMissing', packageFailedToLoad.join(' '));
    }
    catch {
    }
}
exports.removePackageFromMissingList = removePackageFromMissingList;
const isClientError = (error) => {
    const clientErrors = [
        PACKAGE_VERSION_NOT_FOUND,
        PACKAGE_DOES_NOT_CONTAIN_NODES,
        PACKAGE_NOT_FOUND,
    ];
    return clientErrors.some((message) => error.message.includes(message));
};
exports.isClientError = isClientError;
function isNpmError(error) {
    return typeof error === 'object' && error !== null && 'code' in error && 'stdout' in error;
}
exports.isNpmError = isNpmError;
//# sourceMappingURL=helpers.js.map