"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.eventBus = exports.MessageEventBus = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const MessageEventBusLogWriter_1 = require("../MessageEventBusWriter/MessageEventBusLogWriter");
const events_1 = __importDefault(require("events"));
const config_1 = __importDefault(require("../../config"));
const Db = __importStar(require("../../Db"));
const Helpers_ee_1 = require("../MessageEventBusDestination/Helpers.ee");
const lodash_uniqby_1 = __importDefault(require("lodash.uniqby"));
const EventMessageAudit_1 = require("../EventMessageClasses/EventMessageAudit");
const EventMessageWorkflow_1 = require("../EventMessageClasses/EventMessageWorkflow");
const MessageEventBusHelper_1 = require("./MessageEventBusHelper");
const EventMessageNode_1 = require("../EventMessageClasses/EventMessageNode");
const EventMessageGeneric_1 = require("../EventMessageClasses/EventMessageGeneric");
const recoverEvents_1 = require("./recoverEvents");
class MessageEventBus extends events_1.default {
    constructor() {
        super();
        this.destinations = {};
        this.isInitialized = false;
    }
    static getInstance() {
        if (!MessageEventBus.instance) {
            MessageEventBus.instance = new MessageEventBus();
        }
        return MessageEventBus.instance;
    }
    async initialize() {
        var _a, _b, _c;
        if (this.isInitialized) {
            return;
        }
        n8n_workflow_1.LoggerProxy.debug('Initializing event bus...');
        const savedEventDestinations = await Db.collections.EventDestinations.find({});
        if (savedEventDestinations.length > 0) {
            for (const destinationData of savedEventDestinations) {
                try {
                    const destination = (0, Helpers_ee_1.messageEventBusDestinationFromDb)(this, destinationData);
                    if (destination) {
                        await this.addDestination(destination);
                    }
                }
                catch (error) {
                    if (error.message)
                        n8n_workflow_1.LoggerProxy.debug(error.message);
                }
            }
        }
        n8n_workflow_1.LoggerProxy.debug('Initializing event writer');
        this.logWriter = await MessageEventBusLogWriter_1.MessageEventBusLogWriter.getInstance();
        n8n_workflow_1.LoggerProxy.debug('Checking for unsent event messages');
        const unsentAndUnfinished = await this.getUnsentAndUnfinishedExecutions();
        n8n_workflow_1.LoggerProxy.debug(`Start logging into ${(_b = (_a = this.logWriter) === null || _a === void 0 ? void 0 : _a.getLogFileName()) !== null && _b !== void 0 ? _b : 'unknown filename'} `);
        (_c = this.logWriter) === null || _c === void 0 ? void 0 : _c.startLogging();
        await this.send(unsentAndUnfinished.unsentMessages);
        if (Object.keys(unsentAndUnfinished.unfinishedExecutions).length > 0) {
            for (const executionId of Object.keys(unsentAndUnfinished.unfinishedExecutions)) {
                await (0, recoverEvents_1.recoverExecutionDataFromEventLogMessages)(executionId, unsentAndUnfinished.unfinishedExecutions[executionId], true);
            }
        }
        if (config_1.default.getEnv('eventBus.checkUnsentInterval') > 0) {
            if (this.pushIntervalTimer) {
                clearInterval(this.pushIntervalTimer);
            }
            this.pushIntervalTimer = setInterval(async () => {
                await this.trySendingUnsent();
            }, config_1.default.getEnv('eventBus.checkUnsentInterval'));
        }
        n8n_workflow_1.LoggerProxy.debug('MessageEventBus initialized');
        this.isInitialized = true;
    }
    async addDestination(destination) {
        await this.removeDestination(destination.getId());
        this.destinations[destination.getId()] = destination;
        this.destinations[destination.getId()].startListening();
        return destination;
    }
    async findDestination(id) {
        let result;
        if (id && Object.keys(this.destinations).includes(id)) {
            result = [this.destinations[id].serialize()];
        }
        else {
            result = Object.keys(this.destinations).map((e) => this.destinations[e].serialize());
        }
        return result.sort((a, b) => { var _a, _b; return ((_a = a.__type) !== null && _a !== void 0 ? _a : '').localeCompare((_b = b.__type) !== null && _b !== void 0 ? _b : ''); });
    }
    async removeDestination(id) {
        let result;
        if (Object.keys(this.destinations).includes(id)) {
            await this.destinations[id].close();
            result = await this.destinations[id].deleteFromDb();
            delete this.destinations[id];
        }
        return result;
    }
    async trySendingUnsent(msgs) {
        const unsentMessages = msgs !== null && msgs !== void 0 ? msgs : (await this.getEventsUnsent());
        if (unsentMessages.length > 0) {
            n8n_workflow_1.LoggerProxy.debug(`Found unsent event messages: ${unsentMessages.length}`);
            for (const unsentMsg of unsentMessages) {
                n8n_workflow_1.LoggerProxy.debug(`Retrying: ${unsentMsg.id} ${unsentMsg.__type}`);
                await this.emitMessage(unsentMsg);
            }
        }
    }
    async close() {
        var _a;
        n8n_workflow_1.LoggerProxy.debug('Shutting down event writer...');
        await ((_a = this.logWriter) === null || _a === void 0 ? void 0 : _a.close());
        for (const destinationName of Object.keys(this.destinations)) {
            n8n_workflow_1.LoggerProxy.debug(`Shutting down event destination ${this.destinations[destinationName].getId()}...`);
            await this.destinations[destinationName].close();
        }
        n8n_workflow_1.LoggerProxy.debug('EventBus shut down.');
    }
    async send(msgs) {
        var _a;
        if (!Array.isArray(msgs)) {
            msgs = [msgs];
        }
        for (const msg of msgs) {
            (_a = this.logWriter) === null || _a === void 0 ? void 0 : _a.putMessage(msg);
            if (!this.shouldSendMsg(msg)) {
                this.confirmSent(msg, { id: '0', name: 'eventBus' });
            }
            await this.emitMessage(msg);
        }
    }
    async testDestination(destinationId) {
        const msg = new EventMessageGeneric_1.EventMessageGeneric({
            eventName: EventMessageGeneric_1.eventMessageGenericDestinationTestEvent,
        });
        const destination = await this.findDestination(destinationId);
        if (destination.length > 0) {
            const sendResult = await this.destinations[destinationId].receiveFromEventBus({
                msg,
                confirmCallback: () => this.confirmSent(msg, { id: '0', name: 'eventBus' }),
            });
            return sendResult;
        }
        return false;
    }
    confirmSent(msg, source) {
        var _a;
        (_a = this.logWriter) === null || _a === void 0 ? void 0 : _a.confirmMessageSent(msg.id, source);
    }
    hasAnyDestinationSubscribedToEvent(msg) {
        for (const destinationName of Object.keys(this.destinations)) {
            if (this.destinations[destinationName].hasSubscribedToEvent(msg)) {
                return true;
            }
        }
        return false;
    }
    async emitMessage(msg) {
        if (config_1.default.getEnv('endpoints.metrics.enable')) {
            await (0, Helpers_ee_1.incrementPrometheusMetric)(msg);
        }
        this.emitMessageWithCallback('message', msg);
        if (this.shouldSendMsg(msg)) {
            for (const destinationName of Object.keys(this.destinations)) {
                this.emitMessageWithCallback(this.destinations[destinationName].getId(), msg);
            }
        }
    }
    emitMessageWithCallback(eventName, msg) {
        const confirmCallback = (message, src) => this.confirmSent(message, src);
        return this.emit(eventName, msg, confirmCallback);
    }
    shouldSendMsg(msg) {
        return ((0, MessageEventBusHelper_1.isLogStreamingEnabled)() &&
            Object.keys(this.destinations).length > 0 &&
            this.hasAnyDestinationSubscribedToEvent(msg));
    }
    async getEventsFailed(amount = 5) {
        var _a;
        const result = [];
        try {
            const queryResult = await ((_a = this.logWriter) === null || _a === void 0 ? void 0 : _a.getMessagesAll());
            const uniques = (0, lodash_uniqby_1.default)(queryResult, 'id');
            const filteredExecutionIds = uniques
                .filter((e) => ['n8n.workflow.crashed', 'n8n.workflow.failed'].includes(e.eventName))
                .map((e) => ({
                executionId: e.payload.executionId,
                name: e.payload.workflowName,
                timestamp: e.ts,
                event: e.eventName,
            }))
                .filter((e) => e)
                .sort((a, b) => (a.timestamp > b.timestamp ? 1 : -1))
                .slice(-amount);
            for (const execution of filteredExecutionIds) {
                const data = await (0, recoverEvents_1.recoverExecutionDataFromEventLogMessages)(execution.executionId, queryResult, false);
                if (data) {
                    const lastNodeExecuted = data.resultData.lastNodeExecuted;
                    result.push({
                        lastNodeExecuted: lastNodeExecuted !== null && lastNodeExecuted !== void 0 ? lastNodeExecuted : '',
                        executionId: execution.executionId,
                        name: execution.name,
                        event: execution.event,
                        timestamp: execution.timestamp.toISO(),
                    });
                }
            }
        }
        catch { }
        return result;
    }
    async getEventsAll() {
        var _a;
        const queryResult = await ((_a = this.logWriter) === null || _a === void 0 ? void 0 : _a.getMessagesAll());
        const filtered = (0, lodash_uniqby_1.default)(queryResult, 'id');
        return filtered;
    }
    async getEventsSent() {
        var _a;
        const queryResult = await ((_a = this.logWriter) === null || _a === void 0 ? void 0 : _a.getMessagesSent());
        const filtered = (0, lodash_uniqby_1.default)(queryResult, 'id');
        return filtered;
    }
    async getEventsUnsent() {
        var _a;
        const queryResult = await ((_a = this.logWriter) === null || _a === void 0 ? void 0 : _a.getMessagesUnsent());
        const filtered = (0, lodash_uniqby_1.default)(queryResult, 'id');
        return filtered;
    }
    async getUnfinishedExecutions() {
        var _a;
        const queryResult = await ((_a = this.logWriter) === null || _a === void 0 ? void 0 : _a.getUnfinishedExecutions());
        return queryResult;
    }
    async getUnsentAndUnfinishedExecutions() {
        var _a;
        const queryResult = await ((_a = this.logWriter) === null || _a === void 0 ? void 0 : _a.getUnsentAndUnfinishedExecutions());
        return queryResult;
    }
    async getEventsByExecutionId(executionId, logHistory) {
        var _a;
        const result = await ((_a = this.logWriter) === null || _a === void 0 ? void 0 : _a.getMessagesByExecutionId(executionId, logHistory));
        return result;
    }
    async sendAuditEvent(options) {
        await this.send(new EventMessageAudit_1.EventMessageAudit(options));
    }
    async sendWorkflowEvent(options) {
        await this.send(new EventMessageWorkflow_1.EventMessageWorkflow(options));
    }
    async sendNodeEvent(options) {
        await this.send(new EventMessageNode_1.EventMessageNode(options));
    }
}
exports.MessageEventBus = MessageEventBus;
exports.eventBus = MessageEventBus.getInstance();
//# sourceMappingURL=MessageEventBus.js.map