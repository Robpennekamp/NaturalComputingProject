/// <reference types="node" />
import type { MessageEventBusDestinationOptions } from 'n8n-workflow';
import type { DeleteResult } from 'typeorm';
import type { EventMessageTypes, FailedEventSummary } from '../EventMessageClasses/';
import type { MessageEventBusDestination } from '../MessageEventBusDestination/MessageEventBusDestination.ee';
import { MessageEventBusLogWriter } from '../MessageEventBusWriter/MessageEventBusLogWriter';
import EventEmitter from 'events';
import type { EventMessageConfirmSource } from '../EventMessageClasses/EventMessageConfirm';
import type { EventMessageAuditOptions } from '../EventMessageClasses/EventMessageAudit';
import type { EventMessageWorkflowOptions } from '../EventMessageClasses/EventMessageWorkflow';
import type { EventMessageNodeOptions } from '../EventMessageClasses/EventMessageNode';
export type EventMessageReturnMode = 'sent' | 'unsent' | 'all' | 'unfinished';
export interface MessageWithCallback {
    msg: EventMessageTypes;
    confirmCallback: (message: EventMessageTypes, src: EventMessageConfirmSource) => void;
}
export declare class MessageEventBus extends EventEmitter {
    private static instance;
    isInitialized: boolean;
    logWriter: MessageEventBusLogWriter;
    destinations: {
        [key: string]: MessageEventBusDestination;
    };
    private pushIntervalTimer;
    constructor();
    static getInstance(): MessageEventBus;
    initialize(): Promise<void>;
    addDestination(destination: MessageEventBusDestination): Promise<MessageEventBusDestination>;
    findDestination(id?: string): Promise<MessageEventBusDestinationOptions[]>;
    removeDestination(id: string): Promise<DeleteResult | undefined>;
    private trySendingUnsent;
    close(): Promise<void>;
    send(msgs: EventMessageTypes | EventMessageTypes[]): Promise<void>;
    testDestination(destinationId: string): Promise<boolean>;
    confirmSent(msg: EventMessageTypes, source?: EventMessageConfirmSource): void;
    private hasAnyDestinationSubscribedToEvent;
    private emitMessage;
    private emitMessageWithCallback;
    shouldSendMsg(msg: EventMessageTypes): boolean;
    getEventsFailed(amount?: number): Promise<FailedEventSummary[]>;
    getEventsAll(): Promise<EventMessageTypes[]>;
    getEventsSent(): Promise<EventMessageTypes[]>;
    getEventsUnsent(): Promise<EventMessageTypes[]>;
    getUnfinishedExecutions(): Promise<Record<string, EventMessageTypes[]>>;
    getUnsentAndUnfinishedExecutions(): Promise<{
        unsentMessages: EventMessageTypes[];
        unfinishedExecutions: Record<string, EventMessageTypes[]>;
    }>;
    getEventsByExecutionId(executionId: string, logHistory?: number): Promise<EventMessageTypes[]>;
    sendAuditEvent(options: EventMessageAuditOptions): Promise<void>;
    sendWorkflowEvent(options: EventMessageWorkflowOptions): Promise<void>;
    sendNodeEvent(options: EventMessageNodeOptions): Promise<void>;
}
export declare const eventBus: MessageEventBus;
