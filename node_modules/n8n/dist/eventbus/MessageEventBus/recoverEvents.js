"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.recoverExecutionDataFromEventLogMessages = void 0;
const flatted_1 = require("flatted");
const n8n_workflow_1 = require("n8n-workflow");
const Db = __importStar(require("../../Db"));
const push_1 = require("../../push");
const WorkflowStatistics_1 = require("../../events/WorkflowStatistics");
const MessageEventBus_1 = require("./MessageEventBus");
const typedi_1 = require("typedi");
const InternalHooks_1 = require("../../InternalHooks");
const WorkflowExecuteAdditionalData_1 = require("../../WorkflowExecuteAdditionalData");
async function recoverExecutionDataFromEventLogMessages(executionId, messages, applyToDb = true) {
    var _a, _b, _c, _d;
    const executionEntry = await Db.collections.Execution.findOne({
        where: {
            id: executionId,
        },
    });
    if (executionEntry && messages) {
        let executionData;
        let workflowError;
        try {
            executionData = (0, flatted_1.parse)(executionEntry.data);
        }
        catch { }
        if (!executionData) {
            executionData = { resultData: { runData: {} } };
        }
        let nodeNames = [];
        if (((_a = executionData === null || executionData === void 0 ? void 0 : executionData.resultData) === null || _a === void 0 ? void 0 : _a.runData) &&
            Object.keys(executionData.resultData.runData).length > 0) {
        }
        else {
            if (!executionData.resultData) {
                executionData.resultData = {
                    runData: {},
                };
            }
            else {
                if (!executionData.resultData.runData) {
                    executionData.resultData.runData = {};
                }
            }
        }
        nodeNames = executionEntry.workflowData.nodes.map((n) => n.name);
        let lastNodeRunTimestamp = undefined;
        for (const nodeName of nodeNames) {
            const nodeByName = executionEntry === null || executionEntry === void 0 ? void 0 : executionEntry.workflowData.nodes.find((n) => n.name === nodeName);
            if (!nodeByName)
                continue;
            const nodeStartedMessage = messages.find((message) => message.eventName === 'n8n.node.started' && message.payload.nodeName === nodeName);
            const nodeFinishedMessage = messages.find((message) => message.eventName === 'n8n.node.finished' && message.payload.nodeName === nodeName);
            const executionTime = nodeStartedMessage && nodeFinishedMessage
                ? nodeFinishedMessage.ts.diff(nodeStartedMessage.ts).toMillis()
                : 0;
            let taskData;
            if (((_b = executionData.resultData.runData[nodeName]) === null || _b === void 0 ? void 0 : _b.length) > 0) {
                taskData = executionData.resultData.runData[nodeName][0];
            }
            else {
                taskData = {
                    startTime: nodeStartedMessage ? nodeStartedMessage.ts.toUnixInteger() : 0,
                    executionTime,
                    source: [null],
                    executionStatus: 'unknown',
                };
            }
            if (nodeStartedMessage && !nodeFinishedMessage) {
                const nodeError = new n8n_workflow_1.NodeOperationError(nodeByName, 'Node crashed, possible out-of-memory issue', {
                    message: 'Execution stopped at this node',
                    description: "n8n may have run out of memory while executing it. More context and tips on how to avoid this <a href='https://docs.n8n.io/flow-logic/error-handling/memory-errors' target='_blank'>in the docs</a>",
                });
                workflowError = new n8n_workflow_1.WorkflowOperationError('Workflow did not finish, possible out-of-memory issue');
                taskData.error = nodeError;
                taskData.executionStatus = 'crashed';
                executionData.resultData.lastNodeExecuted = nodeName;
                if (nodeStartedMessage)
                    lastNodeRunTimestamp = nodeStartedMessage.ts;
            }
            else if (nodeStartedMessage && nodeFinishedMessage) {
                taskData.executionStatus = 'success';
                if (taskData.data === undefined) {
                    taskData.data = {
                        main: [
                            [
                                {
                                    json: {
                                        isArtificialRecoveredEventItem: true,
                                    },
                                    pairedItem: undefined,
                                },
                            ],
                        ],
                    };
                }
            }
            if (!executionData.resultData.runData[nodeName]) {
                executionData.resultData.runData[nodeName] = [taskData];
            }
        }
        if (!lastNodeRunTimestamp) {
            const workflowEndedMessage = messages.find((message) => [
                'n8n.workflow.success',
                'n8n.workflow.crashed',
                'n8n.workflow.failed',
            ].includes(message.eventName));
            if (workflowEndedMessage) {
                lastNodeRunTimestamp = workflowEndedMessage.ts;
            }
            else {
                if (!workflowError) {
                    workflowError = new n8n_workflow_1.WorkflowOperationError('Workflow did not finish, possible out-of-memory issue');
                }
                const workflowStartedMessage = messages.find((message) => message.eventName === 'n8n.workflow.started');
                if (workflowStartedMessage) {
                    lastNodeRunTimestamp = workflowStartedMessage.ts;
                }
            }
        }
        if (!executionData.resultData.error && workflowError) {
            executionData.resultData.error = workflowError;
        }
        if (applyToDb) {
            const newStatus = executionEntry.status === 'failed' ? 'failed' : 'crashed';
            await Db.collections.Execution.update(executionId, {
                data: (0, flatted_1.stringify)(executionData),
                status: newStatus,
                stoppedAt: lastNodeRunTimestamp === null || lastNodeRunTimestamp === void 0 ? void 0 : lastNodeRunTimestamp.toJSDate(),
            });
            await typedi_1.Container.get(InternalHooks_1.InternalHooks).onWorkflowPostExecute(executionId, executionEntry.workflowData, {
                data: executionData,
                finished: false,
                mode: executionEntry.mode,
                waitTill: (_c = executionEntry.waitTill) !== null && _c !== void 0 ? _c : undefined,
                startedAt: executionEntry.startedAt,
                stoppedAt: lastNodeRunTimestamp === null || lastNodeRunTimestamp === void 0 ? void 0 : lastNodeRunTimestamp.toJSDate(),
                status: newStatus,
            });
            const iRunData = {
                data: executionData,
                finished: false,
                mode: executionEntry.mode,
                waitTill: (_d = executionEntry.waitTill) !== null && _d !== void 0 ? _d : undefined,
                startedAt: executionEntry.startedAt,
                stoppedAt: lastNodeRunTimestamp === null || lastNodeRunTimestamp === void 0 ? void 0 : lastNodeRunTimestamp.toJSDate(),
                status: newStatus,
            };
            const workflowHooks = (0, WorkflowExecuteAdditionalData_1.getWorkflowHooksMain)({
                userId: '',
                workflowData: executionEntry.workflowData,
                executionMode: executionEntry.mode,
                executionData,
                runData: executionData.resultData.runData,
                retryOf: executionEntry.retryOf,
            }, executionId);
            await workflowHooks.executeHookFunctions('workflowExecuteAfter', [iRunData]);
            await (0, WorkflowStatistics_1.workflowExecutionCompleted)(executionEntry.workflowData, iRunData);
            MessageEventBus_1.eventBus.once('editorUiConnected', function handleUiBackUp() {
                setTimeout(() => {
                    typedi_1.Container.get(push_1.Push).send('executionRecovered', {
                        executionId,
                    });
                }, 1000);
            });
        }
        return executionData;
    }
    return;
}
exports.recoverExecutionDataFromEventLogMessages = recoverExecutionDataFromEventLogMessages;
//# sourceMappingURL=recoverEvents.js.map