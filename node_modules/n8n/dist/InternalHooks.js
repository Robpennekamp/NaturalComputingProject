"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InternalHooks = void 0;
const typedi_1 = require("typedi");
const change_case_1 = require("change-case");
const n8n_core_1 = require("n8n-core");
const n8n_workflow_1 = require("n8n-workflow");
const psl_1 = require("psl");
const telemetry_1 = require("./telemetry");
const role_service_1 = require("./role/role.service");
const eventbus_1 = require("./eventbus");
const constants_1 = require("./constants");
const Db = __importStar(require("./Db"));
const NodeTypes_1 = require("./NodeTypes");
function userToPayload(user) {
    var _a;
    return {
        userId: user.id,
        _email: user.email,
        _firstName: user.firstName,
        _lastName: user.lastName,
        globalRole: (_a = user.globalRole) === null || _a === void 0 ? void 0 : _a.name,
    };
}
let InternalHooks = class InternalHooks {
    constructor(telemetry, nodeTypes, roleService) {
        this.telemetry = telemetry;
        this.nodeTypes = nodeTypes;
        this.roleService = roleService;
    }
    async init(instanceId) {
        this.instanceId = instanceId;
        this.telemetry.setInstanceId(instanceId);
        await this.telemetry.init();
    }
    async onServerStarted(diagnosticInfo, earliestWorkflowCreatedAt) {
        const info = {
            version_cli: diagnosticInfo.versionCli,
            db_type: diagnosticInfo.databaseType,
            n8n_version_notifications_enabled: diagnosticInfo.notificationsEnabled,
            n8n_disable_production_main_process: diagnosticInfo.disableProductionWebhooksOnMainProcess,
            n8n_basic_auth_active: diagnosticInfo.basicAuthActive,
            system_info: diagnosticInfo.systemInfo,
            execution_variables: diagnosticInfo.executionVariables,
            n8n_deployment_type: diagnosticInfo.deploymentType,
            n8n_binary_data_mode: diagnosticInfo.binaryDataMode,
            n8n_multi_user_allowed: diagnosticInfo.n8n_multi_user_allowed,
            smtp_set_up: diagnosticInfo.smtp_set_up,
            ldap_allowed: diagnosticInfo.ldap_allowed,
            saml_enabled: diagnosticInfo.saml_enabled,
        };
        return Promise.all([
            this.telemetry.identify(info),
            this.telemetry.track('Instance started', {
                ...info,
                earliest_workflow_created: earliestWorkflowCreatedAt,
            }),
        ]);
    }
    async onFrontendSettingsAPI(sessionId) {
        return this.telemetry.track('Session started', { session_id: sessionId });
    }
    async onPersonalizationSurveySubmitted(userId, answers) {
        const camelCaseKeys = Object.keys(answers);
        const personalizationSurveyData = { user_id: userId };
        camelCaseKeys.forEach((camelCaseKey) => {
            personalizationSurveyData[(0, change_case_1.snakeCase)(camelCaseKey)] = answers[camelCaseKey];
        });
        return this.telemetry.track('User responded to personalization questions', personalizationSurveyData, { withPostHog: true });
    }
    async onWorkflowCreated(user, workflow, publicApi) {
        const { nodeGraph } = n8n_workflow_1.TelemetryHelpers.generateNodesGraph(workflow, this.nodeTypes);
        void Promise.all([
            eventbus_1.eventBus.sendAuditEvent({
                eventName: 'n8n.audit.workflow.created',
                payload: {
                    ...userToPayload(user),
                    workflowId: workflow.id,
                    workflowName: workflow.name,
                },
            }),
            this.telemetry.track('User created workflow', {
                user_id: user.id,
                workflow_id: workflow.id,
                node_graph_string: JSON.stringify(nodeGraph),
                public_api: publicApi,
            }),
        ]);
    }
    async onWorkflowDeleted(user, workflowId, publicApi) {
        void Promise.all([
            eventbus_1.eventBus.sendAuditEvent({
                eventName: 'n8n.audit.workflow.deleted',
                payload: {
                    ...userToPayload(user),
                    workflowId,
                },
            }),
            this.telemetry.track('User deleted workflow', {
                user_id: user.id,
                workflow_id: workflowId,
                public_api: publicApi,
            }),
        ]);
    }
    async onWorkflowSaved(user, workflow, publicApi) {
        var _a, _b;
        const { nodeGraph } = n8n_workflow_1.TelemetryHelpers.generateNodesGraph(workflow, this.nodeTypes);
        const notesCount = Object.keys(nodeGraph.notes).length;
        const overlappingCount = Object.values(nodeGraph.notes).filter((note) => note.overlapping).length;
        let userRole = undefined;
        if (user.id && workflow.id) {
            const role = await this.roleService.getUserRoleForWorkflow(user.id, workflow.id);
            if (role) {
                userRole = role.name === 'owner' ? 'owner' : 'sharee';
            }
        }
        void Promise.all([
            eventbus_1.eventBus.sendAuditEvent({
                eventName: 'n8n.audit.workflow.updated',
                payload: {
                    ...userToPayload(user),
                    workflowId: workflow.id,
                    workflowName: workflow.name,
                },
            }),
            this.telemetry.track('User saved workflow', {
                user_id: user.id,
                workflow_id: workflow.id,
                node_graph_string: JSON.stringify(nodeGraph),
                notes_count_overlapping: overlappingCount,
                notes_count_non_overlapping: notesCount - overlappingCount,
                version_cli: constants_1.N8N_VERSION,
                num_tags: (_b = (_a = workflow.tags) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0,
                public_api: publicApi,
                sharing_role: userRole,
            }, { withPostHog: true }),
        ]);
    }
    async onNodeBeforeExecute(executionId, workflow, nodeName) {
        var _a;
        const nodeInWorkflow = workflow.nodes.find((node) => node.name === nodeName);
        void eventbus_1.eventBus.sendNodeEvent({
            eventName: 'n8n.node.started',
            payload: {
                executionId,
                nodeName,
                workflowId: (_a = workflow.id) === null || _a === void 0 ? void 0 : _a.toString(),
                workflowName: workflow.name,
                nodeType: nodeInWorkflow === null || nodeInWorkflow === void 0 ? void 0 : nodeInWorkflow.type,
            },
        });
    }
    async onNodePostExecute(executionId, workflow, nodeName) {
        var _a;
        const nodeInWorkflow = workflow.nodes.find((node) => node.name === nodeName);
        void eventbus_1.eventBus.sendNodeEvent({
            eventName: 'n8n.node.finished',
            payload: {
                executionId,
                nodeName,
                workflowId: (_a = workflow.id) === null || _a === void 0 ? void 0 : _a.toString(),
                workflowName: workflow.name,
                nodeType: nodeInWorkflow === null || nodeInWorkflow === void 0 ? void 0 : nodeInWorkflow.type,
            },
        });
    }
    async onWorkflowBeforeExecute(executionId, data) {
        var _a;
        void Promise.all([
            Db.collections.Execution.update(executionId, { status: 'running' }),
            eventbus_1.eventBus.sendWorkflowEvent({
                eventName: 'n8n.workflow.started',
                payload: {
                    executionId,
                    userId: data.userId,
                    workflowId: (_a = data.workflowData.id) === null || _a === void 0 ? void 0 : _a.toString(),
                    isManual: data.executionMode === 'manual',
                    workflowName: data.workflowData.name,
                },
            }),
        ]);
    }
    async onWorkflowCrashed(executionId, executionMode, workflowData) {
        var _a;
        void Promise.all([
            eventbus_1.eventBus.sendWorkflowEvent({
                eventName: 'n8n.workflow.crashed',
                payload: {
                    executionId,
                    isManual: executionMode === 'manual',
                    workflowId: (_a = workflowData === null || workflowData === void 0 ? void 0 : workflowData.id) === null || _a === void 0 ? void 0 : _a.toString(),
                    workflowName: workflowData === null || workflowData === void 0 ? void 0 : workflowData.name,
                },
            }),
        ]);
    }
    async onWorkflowPostExecute(executionId, workflow, runData, userId) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        if (!workflow.id) {
            return;
        }
        const promises = [];
        const properties = {
            workflow_id: workflow.id,
            is_manual: false,
            version_cli: constants_1.N8N_VERSION,
            success: false,
        };
        if (userId) {
            properties.user_id = userId;
        }
        if ((_b = (_a = runData === null || runData === void 0 ? void 0 : runData.data.resultData.error) === null || _a === void 0 ? void 0 : _a.message) === null || _b === void 0 ? void 0 : _b.includes('canceled')) {
            runData.status = 'canceled';
        }
        properties.success = !!(runData === null || runData === void 0 ? void 0 : runData.finished);
        let executionStatus;
        if ((runData === null || runData === void 0 ? void 0 : runData.status) === 'crashed') {
            executionStatus = 'crashed';
        }
        else if ((runData === null || runData === void 0 ? void 0 : runData.status) === 'waiting' || ((_c = runData === null || runData === void 0 ? void 0 : runData.data) === null || _c === void 0 ? void 0 : _c.waitTill)) {
            executionStatus = 'waiting';
        }
        else if ((runData === null || runData === void 0 ? void 0 : runData.status) === 'canceled') {
            executionStatus = 'canceled';
        }
        else {
            executionStatus = properties.success ? 'success' : 'failed';
        }
        if (runData !== undefined) {
            properties.execution_mode = runData.mode;
            properties.is_manual = runData.mode === 'manual';
            let nodeGraphResult = null;
            if (!properties.success && (runData === null || runData === void 0 ? void 0 : runData.data.resultData.error)) {
                properties.error_message = runData === null || runData === void 0 ? void 0 : runData.data.resultData.error.message;
                let errorNodeName = 'node' in (runData === null || runData === void 0 ? void 0 : runData.data.resultData.error)
                    ? (_d = runData === null || runData === void 0 ? void 0 : runData.data.resultData.error.node) === null || _d === void 0 ? void 0 : _d.name
                    : undefined;
                properties.error_node_type =
                    'node' in (runData === null || runData === void 0 ? void 0 : runData.data.resultData.error)
                        ? (_e = runData === null || runData === void 0 ? void 0 : runData.data.resultData.error.node) === null || _e === void 0 ? void 0 : _e.type
                        : undefined;
                if (runData.data.resultData.lastNodeExecuted) {
                    const lastNode = n8n_workflow_1.TelemetryHelpers.getNodeTypeForName(workflow, runData.data.resultData.lastNodeExecuted);
                    if (lastNode !== undefined) {
                        properties.error_node_type = lastNode.type;
                        errorNodeName = lastNode.name;
                    }
                }
                if (properties.is_manual) {
                    nodeGraphResult = n8n_workflow_1.TelemetryHelpers.generateNodesGraph(workflow, this.nodeTypes);
                    properties.node_graph = nodeGraphResult.nodeGraph;
                    properties.node_graph_string = JSON.stringify(nodeGraphResult.nodeGraph);
                    if (errorNodeName) {
                        properties.error_node_id = nodeGraphResult.nameIndices[errorNodeName];
                    }
                }
            }
            if (properties.is_manual) {
                if (!nodeGraphResult) {
                    nodeGraphResult = n8n_workflow_1.TelemetryHelpers.generateNodesGraph(workflow, this.nodeTypes);
                }
                let userRole = undefined;
                if (userId) {
                    const role = await this.roleService.getUserRoleForWorkflow(userId, workflow.id);
                    if (role) {
                        userRole = role.name === 'owner' ? 'owner' : 'sharee';
                    }
                }
                const manualExecEventProperties = {
                    user_id: userId,
                    workflow_id: workflow.id,
                    status: executionStatus,
                    executionStatus: (_f = runData === null || runData === void 0 ? void 0 : runData.status) !== null && _f !== void 0 ? _f : 'unknown',
                    error_message: properties.error_message,
                    error_node_type: properties.error_node_type,
                    node_graph_string: properties.node_graph_string,
                    error_node_id: properties.error_node_id,
                    webhook_domain: null,
                    sharing_role: userRole,
                };
                if (!manualExecEventProperties.node_graph_string) {
                    nodeGraphResult = n8n_workflow_1.TelemetryHelpers.generateNodesGraph(workflow, this.nodeTypes);
                    manualExecEventProperties.node_graph_string = JSON.stringify(nodeGraphResult.nodeGraph);
                }
                if ((_g = runData.data.startData) === null || _g === void 0 ? void 0 : _g.destinationNode) {
                    const telemetryPayload = {
                        ...manualExecEventProperties,
                        node_type: (_j = n8n_workflow_1.TelemetryHelpers.getNodeTypeForName(workflow, (_h = runData.data.startData) === null || _h === void 0 ? void 0 : _h.destinationNode)) === null || _j === void 0 ? void 0 : _j.type,
                        node_id: nodeGraphResult.nameIndices[(_k = runData.data.startData) === null || _k === void 0 ? void 0 : _k.destinationNode],
                    };
                    promises.push(this.telemetry.track('Manual node exec finished', telemetryPayload, {
                        withPostHog: true,
                    }));
                }
                else {
                    nodeGraphResult.webhookNodeNames.forEach((name) => {
                        var _a, _b, _c, _d, _e, _f, _g;
                        const execJson = (_f = (_e = (_d = (_c = (_b = (_a = runData.data.resultData.runData[name]) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c.main) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.json;
                        if (((_g = execJson === null || execJson === void 0 ? void 0 : execJson.headers) === null || _g === void 0 ? void 0 : _g.origin) && execJson.headers.origin !== '') {
                            manualExecEventProperties.webhook_domain = (0, psl_1.get)(execJson.headers.origin.replace(/^https?:\/\//, ''));
                        }
                    });
                    promises.push(this.telemetry.track('Manual workflow exec finished', manualExecEventProperties, {
                        withPostHog: true,
                    }));
                }
            }
        }
        promises.push(Db.collections.Execution.update(executionId, {
            status: executionStatus,
        }));
        promises.push(properties.success
            ? eventbus_1.eventBus.sendWorkflowEvent({
                eventName: 'n8n.workflow.success',
                payload: {
                    executionId,
                    success: properties.success,
                    userId: properties.user_id,
                    workflowId: properties.workflow_id,
                    isManual: properties.is_manual,
                    workflowName: workflow.name,
                },
            })
            : eventbus_1.eventBus.sendWorkflowEvent({
                eventName: 'n8n.workflow.failed',
                payload: {
                    executionId,
                    success: properties.success,
                    userId: properties.user_id,
                    workflowId: properties.workflow_id,
                    lastNodeExecuted: runData === null || runData === void 0 ? void 0 : runData.data.resultData.lastNodeExecuted,
                    errorNodeType: properties.error_node_type,
                    errorNodeId: (_l = properties.error_node_id) === null || _l === void 0 ? void 0 : _l.toString(),
                    errorMessage: (_m = properties.error_message) === null || _m === void 0 ? void 0 : _m.toString(),
                    isManual: properties.is_manual,
                    workflowName: workflow.name,
                },
            }));
        await n8n_core_1.BinaryDataManager.getInstance().persistBinaryDataForExecutionId(executionId);
        void Promise.all([...promises, this.telemetry.trackWorkflowExecution(properties)]);
    }
    async onWorkflowSharingUpdate(workflowId, userId, userList) {
        const properties = {
            workflow_id: workflowId,
            user_id_sharer: userId,
            user_id_list: userList,
        };
        return this.telemetry.track('User updated workflow sharing', properties, { withPostHog: true });
    }
    async onN8nStop() {
        const timeoutPromise = new Promise((resolve) => {
            setTimeout(() => {
                resolve();
            }, 3000);
        });
        return Promise.race([timeoutPromise, this.telemetry.trackN8nStop()]);
    }
    async onUserDeletion(userDeletionData) {
        void Promise.all([
            eventbus_1.eventBus.sendAuditEvent({
                eventName: 'n8n.audit.user.deleted',
                payload: {
                    ...userToPayload(userDeletionData.user),
                },
            }),
            this.telemetry.track('User deleted user', {
                ...userDeletionData.telemetryData,
                user_id: userDeletionData.user.id,
                public_api: userDeletionData.publicApi,
            }),
        ]);
    }
    async onUserInvite(userInviteData) {
        void Promise.all([
            eventbus_1.eventBus.sendAuditEvent({
                eventName: 'n8n.audit.user.invited',
                payload: {
                    ...userToPayload(userInviteData.user),
                    targetUserId: userInviteData.target_user_id,
                },
            }),
            this.telemetry.track('User invited new user', {
                user_id: userInviteData.user.id,
                target_user_id: userInviteData.target_user_id,
                public_api: userInviteData.public_api,
                email_sent: userInviteData.email_sent,
            }),
        ]);
    }
    async onUserReinvite(userReinviteData) {
        void Promise.all([
            eventbus_1.eventBus.sendAuditEvent({
                eventName: 'n8n.audit.user.reinvited',
                payload: {
                    ...userToPayload(userReinviteData.user),
                    targetUserId: userReinviteData.target_user_id,
                },
            }),
            this.telemetry.track('User resent new user invite email', {
                user_id: userReinviteData.user.id,
                target_user_id: userReinviteData.target_user_id,
                public_api: userReinviteData.public_api,
            }),
        ]);
    }
    async onUserRetrievedUser(userRetrievedData) {
        return this.telemetry.track('User retrieved user', userRetrievedData);
    }
    async onUserRetrievedAllUsers(userRetrievedData) {
        return this.telemetry.track('User retrieved all users', userRetrievedData);
    }
    async onUserRetrievedExecution(userRetrievedData) {
        return this.telemetry.track('User retrieved execution', userRetrievedData);
    }
    async onUserRetrievedAllExecutions(userRetrievedData) {
        return this.telemetry.track('User retrieved all executions', userRetrievedData);
    }
    async onUserRetrievedWorkflow(userRetrievedData) {
        return this.telemetry.track('User retrieved workflow', userRetrievedData);
    }
    async onUserRetrievedAllWorkflows(userRetrievedData) {
        return this.telemetry.track('User retrieved all workflows', userRetrievedData);
    }
    async onUserUpdate(userUpdateData) {
        void Promise.all([
            eventbus_1.eventBus.sendAuditEvent({
                eventName: 'n8n.audit.user.updated',
                payload: {
                    ...userToPayload(userUpdateData.user),
                    fieldsChanged: userUpdateData.fields_changed,
                },
            }),
            this.telemetry.track('User changed personal settings', {
                user_id: userUpdateData.user.id,
                fields_changed: userUpdateData.fields_changed,
            }),
        ]);
    }
    async onUserInviteEmailClick(userInviteClickData) {
        void Promise.all([
            eventbus_1.eventBus.sendAuditEvent({
                eventName: 'n8n.audit.user.invitation.accepted',
                payload: {
                    invitee: {
                        ...userToPayload(userInviteClickData.invitee),
                    },
                    inviter: {
                        ...userToPayload(userInviteClickData.inviter),
                    },
                },
            }),
            this.telemetry.track('User clicked invite link from email', {
                user_id: userInviteClickData.invitee.id,
            }),
        ]);
    }
    async onUserPasswordResetEmailClick(userPasswordResetData) {
        void Promise.all([
            eventbus_1.eventBus.sendAuditEvent({
                eventName: 'n8n.audit.user.reset',
                payload: {
                    ...userToPayload(userPasswordResetData.user),
                },
            }),
            this.telemetry.track('User clicked password reset link from email', {
                user_id: userPasswordResetData.user.id,
            }),
        ]);
    }
    async onUserTransactionalEmail(userTransactionalEmailData) {
        return this.telemetry.track('Instance sent transactional email to user', userTransactionalEmailData);
    }
    async onUserInvokedApi(userInvokedApiData) {
        return this.telemetry.track('User invoked API', userInvokedApiData);
    }
    async onApiKeyDeleted(apiKeyDeletedData) {
        void Promise.all([
            eventbus_1.eventBus.sendAuditEvent({
                eventName: 'n8n.audit.user.api.deleted',
                payload: {
                    ...userToPayload(apiKeyDeletedData.user),
                },
            }),
            this.telemetry.track('API key deleted', {
                user_id: apiKeyDeletedData.user.id,
                public_api: apiKeyDeletedData.public_api,
            }),
        ]);
    }
    async onApiKeyCreated(apiKeyCreatedData) {
        void Promise.all([
            eventbus_1.eventBus.sendAuditEvent({
                eventName: 'n8n.audit.user.api.created',
                payload: {
                    ...userToPayload(apiKeyCreatedData.user),
                },
            }),
            this.telemetry.track('API key created', {
                user_id: apiKeyCreatedData.user.id,
                public_api: apiKeyCreatedData.public_api,
            }),
        ]);
    }
    async onUserPasswordResetRequestClick(userPasswordResetData) {
        void Promise.all([
            eventbus_1.eventBus.sendAuditEvent({
                eventName: 'n8n.audit.user.reset.requested',
                payload: {
                    ...userToPayload(userPasswordResetData.user),
                },
            }),
            this.telemetry.track('User requested password reset while logged out', {
                user_id: userPasswordResetData.user.id,
            }),
        ]);
    }
    async onInstanceOwnerSetup(instanceOwnerSetupData) {
        return this.telemetry.track('Owner finished instance setup', instanceOwnerSetupData);
    }
    async onUserSignup(user, userSignupData) {
        void Promise.all([
            eventbus_1.eventBus.sendAuditEvent({
                eventName: 'n8n.audit.user.signedup',
                payload: {
                    ...userToPayload(user),
                },
            }),
            this.telemetry.track('User signed up', {
                user_id: user.id,
                ...userSignupData,
            }),
        ]);
    }
    async onEmailFailed(failedEmailData) {
        void Promise.all([
            eventbus_1.eventBus.sendAuditEvent({
                eventName: 'n8n.audit.user.email.failed',
                payload: {
                    messageType: failedEmailData.message_type,
                    ...userToPayload(failedEmailData.user),
                },
            }),
            this.telemetry.track('Instance failed to send transactional email to user', {
                user_id: failedEmailData.user.id,
            }),
        ]);
    }
    async onUserLoginSuccess(userLoginData) {
        void Promise.all([
            eventbus_1.eventBus.sendAuditEvent({
                eventName: 'n8n.audit.user.login.success',
                payload: {
                    authenticationMethod: userLoginData.authenticationMethod,
                    ...userToPayload(userLoginData.user),
                },
            }),
        ]);
    }
    async onUserLoginFailed(userLoginData) {
        void Promise.all([
            eventbus_1.eventBus.sendAuditEvent({
                eventName: 'n8n.audit.user.login.failed',
                payload: {
                    authenticationMethod: userLoginData.authenticationMethod,
                    user: userLoginData.user,
                    reason: userLoginData.reason,
                },
            }),
        ]);
    }
    async onUserCreatedCredentials(userCreatedCredentialsData) {
        void Promise.all([
            eventbus_1.eventBus.sendAuditEvent({
                eventName: 'n8n.audit.user.credentials.created',
                payload: {
                    ...userToPayload(userCreatedCredentialsData.user),
                    credentialName: userCreatedCredentialsData.credential_name,
                    credentialType: userCreatedCredentialsData.credential_type,
                    credentialId: userCreatedCredentialsData.credential_id,
                },
            }),
            this.telemetry.track('User created credentials', {
                user_id: userCreatedCredentialsData.user.id,
                credential_type: userCreatedCredentialsData.credential_type,
                credential_id: userCreatedCredentialsData.credential_id,
                instance_id: this.instanceId,
            }),
        ]);
    }
    async onUserSharedCredentials(userSharedCredentialsData) {
        void Promise.all([
            eventbus_1.eventBus.sendAuditEvent({
                eventName: 'n8n.audit.user.credentials.shared',
                payload: {
                    ...userToPayload(userSharedCredentialsData.user),
                    credentialName: userSharedCredentialsData.credential_name,
                    credentialType: userSharedCredentialsData.credential_type,
                    credentialId: userSharedCredentialsData.credential_id,
                    userIdSharer: userSharedCredentialsData.user_id_sharer,
                    userIdsShareesAdded: userSharedCredentialsData.user_ids_sharees_added,
                    shareesRemoved: userSharedCredentialsData.sharees_removed,
                },
            }),
            this.telemetry.track('User updated cred sharing', {
                user_id: userSharedCredentialsData.user.id,
                credential_type: userSharedCredentialsData.credential_type,
                credential_id: userSharedCredentialsData.credential_id,
                user_id_sharer: userSharedCredentialsData.user_id_sharer,
                user_ids_sharees_added: userSharedCredentialsData.user_ids_sharees_added,
                sharees_removed: userSharedCredentialsData.sharees_removed,
                instance_id: this.instanceId,
            }),
        ]);
    }
    async onCommunityPackageInstallFinished(installationData) {
        void Promise.all([
            eventbus_1.eventBus.sendAuditEvent({
                eventName: 'n8n.audit.package.installed',
                payload: {
                    ...userToPayload(installationData.user),
                    inputString: installationData.input_string,
                    packageName: installationData.package_name,
                    success: installationData.success,
                    packageVersion: installationData.package_version,
                    packageNodeNames: installationData.package_node_names,
                    packageAuthor: installationData.package_author,
                    packageAuthorEmail: installationData.package_author_email,
                    failureReason: installationData.failure_reason,
                },
            }),
            this.telemetry.track('cnr package install finished', {
                user_id: installationData.user.id,
                input_string: installationData.input_string,
                package_name: installationData.package_name,
                success: installationData.success,
                package_version: installationData.package_version,
                package_node_names: installationData.package_node_names,
                package_author: installationData.package_author,
                package_author_email: installationData.package_author_email,
                failure_reason: installationData.failure_reason,
            }),
        ]);
    }
    async onCommunityPackageUpdateFinished(updateData) {
        void Promise.all([
            eventbus_1.eventBus.sendAuditEvent({
                eventName: 'n8n.audit.package.updated',
                payload: {
                    ...userToPayload(updateData.user),
                    packageName: updateData.package_name,
                    packageVersionCurrent: updateData.package_version_current,
                    packageVersionNew: updateData.package_version_new,
                    packageNodeNames: updateData.package_node_names,
                    packageAuthor: updateData.package_author,
                    packageAuthorEmail: updateData.package_author_email,
                },
            }),
            this.telemetry.track('cnr package updated', {
                user_id: updateData.user.id,
                package_name: updateData.package_name,
                package_version_current: updateData.package_version_current,
                package_version_new: updateData.package_version_new,
                package_node_names: updateData.package_node_names,
                package_author: updateData.package_author,
                package_author_email: updateData.package_author_email,
            }),
        ]);
    }
    async onCommunityPackageDeleteFinished(deleteData) {
        void Promise.all([
            eventbus_1.eventBus.sendAuditEvent({
                eventName: 'n8n.audit.package.deleted',
                payload: {
                    ...userToPayload(deleteData.user),
                    packageName: deleteData.package_name,
                    packageVersion: deleteData.package_version,
                    packageNodeNames: deleteData.package_node_names,
                    packageAuthor: deleteData.package_author,
                    packageAuthorEmail: deleteData.package_author_email,
                },
            }),
            this.telemetry.track('cnr package deleted', {
                user_id: deleteData.user.id,
                package_name: deleteData.package_name,
                package_version: deleteData.package_version,
                package_node_names: deleteData.package_node_names,
                package_author: deleteData.package_author,
                package_author_email: deleteData.package_author_email,
            }),
        ]);
    }
    async onLdapSyncFinished(data) {
        return this.telemetry.track('Ldap general sync finished', data);
    }
    async onLdapUsersDisabled(data) {
        return this.telemetry.track('Ldap users disabled', data);
    }
    async onUserUpdatedLdapSettings(data) {
        return this.telemetry.track('Ldap general sync finished', data);
    }
    async onLdapLoginSyncFailed(data) {
        return this.telemetry.track('Ldap login sync failed', data);
    }
    async userLoginFailedDueToLdapDisabled(data) {
        return this.telemetry.track('User login failed since ldap disabled', data);
    }
    async onFirstProductionWorkflowSuccess(data) {
        return this.telemetry.track('Workflow first prod success', data, { withPostHog: true });
    }
    async onFirstWorkflowDataLoad(data) {
        return this.telemetry.track('Workflow first data fetched', data, { withPostHog: true });
    }
    async onLicenseRenewAttempt(data) {
        await this.telemetry.track('Instance attempted to refresh license', data);
    }
    async onAuditGeneratedViaCli() {
        return this.telemetry.track('Instance generated security audit via CLI command');
    }
    async onVariableCreated(createData) {
        return this.telemetry.track('User created variable', createData);
    }
};
InternalHooks = __decorate([
    (0, typedi_1.Service)(),
    __metadata("design:paramtypes", [telemetry_1.Telemetry,
        NodeTypes_1.NodeTypes,
        role_service_1.RoleService])
], InternalHooks);
exports.InternalHooks = InternalHooks;
//# sourceMappingURL=InternalHooks.js.map