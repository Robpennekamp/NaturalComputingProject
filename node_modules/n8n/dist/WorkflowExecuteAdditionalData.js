"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWorkflowHooksMain = exports.getWorkflowHooksWorkerMain = exports.getWorkflowHooksWorkerExecuter = exports.getBase = exports.sendMessageToUI = exports.setExecutionStatus = exports.getWorkflowData = exports.getRunData = exports.hookFunctionsPreExecute = exports.saveExecutionMetadata = exports.executeErrorWorkflow = void 0;
const n8n_core_1 = require("n8n-core");
const n8n_workflow_1 = require("n8n-workflow");
const lodash_pick_1 = __importDefault(require("lodash.pick"));
const typeorm_1 = require("typeorm");
const DateUtils_1 = require("typeorm/util/DateUtils");
const config_1 = __importDefault(require("./config"));
const Db = __importStar(require("./Db"));
const ActiveExecutions_1 = require("./ActiveExecutions");
const CredentialsHelper_1 = require("./CredentialsHelper");
const ExternalHooks_1 = require("./ExternalHooks");
const NodeTypes_1 = require("./NodeTypes");
const push_1 = require("./push");
const ResponseHelper = __importStar(require("./ResponseHelper"));
const WebhookHelpers = __importStar(require("./WebhookHelpers"));
const WorkflowHelpers = __importStar(require("./WorkflowHelpers"));
const UserManagementHelper_1 = require("./UserManagement/UserManagementHelper");
const utils_1 = require("./utils");
const PermissionChecker_1 = require("./UserManagement/PermissionChecker");
const workflows_services_1 = require("./workflows/workflows.services");
const typedi_1 = require("typedi");
const InternalHooks_1 = require("./InternalHooks");
const ERROR_TRIGGER_TYPE = config_1.default.getEnv('nodes.errorTriggerType');
function executeErrorWorkflow(workflowData, fullRunData, mode, executionId, retryOf) {
    var _a;
    let pastExecutionUrl;
    if (executionId !== undefined) {
        pastExecutionUrl = `${WebhookHelpers.getWebhookBaseUrl()}workflow/${workflowData.id}/executions/${executionId}`;
    }
    if (fullRunData.data.resultData.error !== undefined) {
        let workflowErrorData;
        const workflowId = workflowData.id;
        if (executionId) {
            workflowErrorData = {
                execution: {
                    id: executionId,
                    url: pastExecutionUrl,
                    error: fullRunData.data.resultData.error,
                    lastNodeExecuted: fullRunData.data.resultData.lastNodeExecuted,
                    mode,
                    retryOf,
                },
                workflow: {
                    id: workflowId,
                    name: workflowData.name,
                },
            };
        }
        else {
            workflowErrorData = {
                trigger: {
                    error: fullRunData.data.resultData.error,
                    mode,
                },
                workflow: {
                    id: workflowId,
                    name: workflowData.name,
                },
            };
        }
        const { errorWorkflow } = (_a = workflowData.settings) !== null && _a !== void 0 ? _a : {};
        if (errorWorkflow && !(mode === 'error' && workflowId && errorWorkflow === workflowId)) {
            n8n_workflow_1.LoggerProxy.verbose('Start external error workflow', {
                executionId,
                errorWorkflowId: errorWorkflow,
                workflowId,
            });
            if (!workflowId) {
                return;
            }
            (0, UserManagementHelper_1.getWorkflowOwner)(workflowId)
                .then((user) => {
                void WorkflowHelpers.executeErrorWorkflow(errorWorkflow, workflowErrorData, user);
            })
                .catch((error) => {
                n8n_workflow_1.ErrorReporterProxy.error(error);
                n8n_workflow_1.LoggerProxy.error(`Could not execute ErrorWorkflow for execution ID ${this.executionId} because of error querying the workflow owner`, {
                    executionId,
                    errorWorkflowId: errorWorkflow,
                    workflowId,
                    error,
                    workflowErrorData,
                });
            });
        }
        else if (mode !== 'error' &&
            workflowId !== undefined &&
            workflowData.nodes.some((node) => node.type === ERROR_TRIGGER_TYPE)) {
            n8n_workflow_1.LoggerProxy.verbose('Start internal error workflow', { executionId, workflowId });
            void (0, UserManagementHelper_1.getWorkflowOwner)(workflowId).then((user) => {
                void WorkflowHelpers.executeErrorWorkflow(workflowId, workflowErrorData, user);
            });
        }
    }
}
exports.executeErrorWorkflow = executeErrorWorkflow;
let throttling = false;
async function pruneExecutionData() {
    if (!throttling) {
        n8n_workflow_1.LoggerProxy.verbose('Pruning execution data from database');
        throttling = true;
        const timeout = config_1.default.getEnv('executions.pruneDataTimeout');
        const maxAge = config_1.default.getEnv('executions.pruneDataMaxAge');
        const maxCount = config_1.default.getEnv('executions.pruneDataMaxCount');
        const date = new Date();
        date.setHours(date.getHours() - maxAge);
        const utcDate = DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(date);
        const toPrune = [
            { stoppedAt: (0, typeorm_1.LessThanOrEqual)(utcDate) },
        ];
        if (maxCount > 0) {
            const executions = await Db.collections.Execution.find({
                select: ['id'],
                skip: maxCount,
                take: 1,
                order: { id: 'DESC' },
            });
            if (executions[0]) {
                toPrune.push({ id: (0, typeorm_1.LessThanOrEqual)(executions[0].id) });
            }
        }
        const isBinaryModeDefaultMode = config_1.default.getEnv('binaryDataManager.mode') === 'default';
        try {
            setTimeout(() => {
                throttling = false;
            }, timeout * 1000);
            let executionIds;
            do {
                executionIds = (await Db.collections.Execution.find({
                    select: ['id'],
                    where: toPrune,
                    take: 100,
                })).map(({ id }) => id);
                await Db.collections.Execution.delete({ id: (0, typeorm_1.In)(executionIds) });
                if (!isBinaryModeDefaultMode)
                    await n8n_core_1.BinaryDataManager.getInstance().markDataForDeletionByExecutionIds(executionIds);
            } while (executionIds.length > 0);
        }
        catch (error) {
            n8n_workflow_1.ErrorReporterProxy.error(error);
            throttling = false;
            n8n_workflow_1.LoggerProxy.error(`Failed pruning execution data from database for execution ID ${this.executionId} (hookFunctionsSave)`, {
                ...error,
                executionId: this.executionId,
                sessionId: this.sessionId,
                workflowId: this.workflowData.id,
            });
        }
    }
}
async function saveExecutionMetadata(executionId, executionMetadata) {
    const metadataRows = [];
    for (const [key, value] of Object.entries(executionMetadata)) {
        metadataRows.push({
            execution: { id: executionId },
            key,
            value,
        });
    }
    return Db.collections.ExecutionMetadata.save(metadataRows);
}
exports.saveExecutionMetadata = saveExecutionMetadata;
function hookFunctionsPush() {
    return {
        nodeExecuteBefore: [
            async function (nodeName) {
                const { sessionId, executionId } = this;
                if (sessionId === undefined) {
                    return;
                }
                n8n_workflow_1.LoggerProxy.debug(`Executing hook on node "${nodeName}" (hookFunctionsPush)`, {
                    executionId,
                    sessionId,
                    workflowId: this.workflowData.id,
                });
                const pushInstance = typedi_1.Container.get(push_1.Push);
                pushInstance.send('nodeExecuteBefore', { executionId, nodeName }, sessionId);
            },
        ],
        nodeExecuteAfter: [
            async function (nodeName, data) {
                const { sessionId, executionId } = this;
                if (sessionId === undefined) {
                    return;
                }
                n8n_workflow_1.LoggerProxy.debug(`Executing hook on node "${nodeName}" (hookFunctionsPush)`, {
                    executionId,
                    sessionId,
                    workflowId: this.workflowData.id,
                });
                const pushInstance = typedi_1.Container.get(push_1.Push);
                pushInstance.send('nodeExecuteAfter', { executionId, nodeName, data }, sessionId);
            },
        ],
        workflowExecuteBefore: [
            async function () {
                const { sessionId, executionId } = this;
                const { id: workflowId, name: workflowName } = this.workflowData;
                n8n_workflow_1.LoggerProxy.debug('Executing hook (hookFunctionsPush)', {
                    executionId,
                    sessionId,
                    workflowId,
                });
                if (sessionId === undefined) {
                    return;
                }
                const pushInstance = typedi_1.Container.get(push_1.Push);
                pushInstance.send('executionStarted', {
                    executionId,
                    mode: this.mode,
                    startedAt: new Date(),
                    retryOf: this.retryOf,
                    workflowId,
                    sessionId,
                    workflowName,
                }, sessionId);
            },
        ],
        workflowExecuteAfter: [
            async function (fullRunData, newStaticData) {
                const { sessionId, executionId, retryOf } = this;
                const { id: workflowId } = this.workflowData;
                n8n_workflow_1.LoggerProxy.debug('Executing hook (hookFunctionsPush)', {
                    executionId,
                    sessionId,
                    workflowId,
                });
                if (sessionId === undefined) {
                    return;
                }
                let pushRunData;
                if (fullRunData.mode === 'manual') {
                    pushRunData = fullRunData;
                }
                else {
                    pushRunData = {
                        ...fullRunData,
                        data: {
                            ...fullRunData.data,
                            resultData: {
                                ...fullRunData.data.resultData,
                                runData: {},
                            },
                        },
                    };
                }
                n8n_workflow_1.LoggerProxy.debug(`Save execution progress to database for execution ID ${executionId} `, {
                    executionId,
                    workflowId,
                });
                const sendData = {
                    executionId,
                    data: pushRunData,
                    retryOf,
                };
                const pushInstance = typedi_1.Container.get(push_1.Push);
                pushInstance.send('executionFinished', sendData, sessionId);
            },
        ],
    };
}
function hookFunctionsPreExecute(parentProcessMode) {
    const externalHooks = typedi_1.Container.get(ExternalHooks_1.ExternalHooks);
    return {
        workflowExecuteBefore: [
            async function (workflow) {
                await externalHooks.run('workflow.preExecute', [workflow, this.mode]);
            },
        ],
        nodeExecuteAfter: [
            async function (nodeName, data, executionData) {
                const saveExecutionProgress = config_1.default.getEnv('executions.saveExecutionProgress');
                const workflowSettings = this.workflowData.settings;
                if (workflowSettings !== undefined) {
                    if (workflowSettings.saveExecutionProgress === false) {
                        return;
                    }
                    if (workflowSettings.saveExecutionProgress !== true && !saveExecutionProgress) {
                        return;
                    }
                }
                else if (!saveExecutionProgress) {
                    return;
                }
                try {
                    n8n_workflow_1.LoggerProxy.debug(`Save execution progress to database for execution ID ${this.executionId} `, { executionId: this.executionId, nodeName });
                    const execution = await Db.collections.Execution.findOneBy({ id: this.executionId });
                    if (execution === null) {
                        return;
                    }
                    const fullExecutionData = ResponseHelper.unflattenExecutionData(execution);
                    if (fullExecutionData.finished) {
                        return;
                    }
                    if (fullExecutionData.data === undefined) {
                        fullExecutionData.data = {
                            startData: {},
                            resultData: {
                                runData: {},
                            },
                            executionData: {
                                contextData: {},
                                nodeExecutionStack: [],
                                waitingExecution: {},
                                waitingExecutionSource: {},
                            },
                        };
                    }
                    if (Array.isArray(fullExecutionData.data.resultData.runData[nodeName])) {
                        fullExecutionData.data.resultData.runData[nodeName].push(data);
                    }
                    else {
                        fullExecutionData.data.resultData.runData[nodeName] = [data];
                    }
                    fullExecutionData.data.executionData = executionData.executionData;
                    fullExecutionData.data.resultData.lastNodeExecuted = nodeName;
                    fullExecutionData.status = 'running';
                    const flattenedExecutionData = ResponseHelper.flattenExecutionData(fullExecutionData);
                    await Db.collections.Execution.update(this.executionId, flattenedExecutionData);
                }
                catch (err) {
                    n8n_workflow_1.ErrorReporterProxy.error(err);
                    n8n_workflow_1.LoggerProxy.error(`Failed saving execution progress to database for execution ID ${this.executionId} (hookFunctionsPreExecute, nodeExecuteAfter)`, {
                        ...err,
                        executionId: this.executionId,
                        sessionId: this.sessionId,
                        workflowId: this.workflowData.id,
                    });
                }
            },
        ],
    };
}
exports.hookFunctionsPreExecute = hookFunctionsPreExecute;
function hookFunctionsSave(parentProcessMode) {
    return {
        nodeExecuteBefore: [
            async function (nodeName) {
                void typedi_1.Container.get(InternalHooks_1.InternalHooks).onNodeBeforeExecute(this.executionId, this.workflowData, nodeName);
            },
        ],
        nodeExecuteAfter: [
            async function (nodeName) {
                void typedi_1.Container.get(InternalHooks_1.InternalHooks).onNodePostExecute(this.executionId, this.workflowData, nodeName);
            },
        ],
        workflowExecuteBefore: [],
        workflowExecuteAfter: [
            async function (fullRunData, newStaticData) {
                var _a;
                n8n_workflow_1.LoggerProxy.debug('Executing hook (hookFunctionsSave)', {
                    executionId: this.executionId,
                    workflowId: this.workflowData.id,
                });
                if (config_1.default.getEnv('executions.pruneData')) {
                    await pruneExecutionData.call(this);
                }
                const isManualMode = [this.mode, parentProcessMode].includes('manual');
                try {
                    if (!isManualMode && (0, utils_1.isWorkflowIdValid)(this.workflowData.id) && newStaticData) {
                        try {
                            await WorkflowHelpers.saveStaticDataById(this.workflowData.id, newStaticData);
                        }
                        catch (e) {
                            n8n_workflow_1.ErrorReporterProxy.error(e);
                            n8n_workflow_1.LoggerProxy.error(`There was a problem saving the workflow with id "${this.workflowData.id}" to save changed staticData: "${e.message}" (hookFunctionsSave)`, { executionId: this.executionId, workflowId: this.workflowData.id });
                        }
                    }
                    const workflowSettings = this.workflowData.settings;
                    let saveManualExecutions = config_1.default.getEnv('executions.saveDataManualExecutions');
                    if ((workflowSettings === null || workflowSettings === void 0 ? void 0 : workflowSettings.saveManualExecutions) !== undefined) {
                        saveManualExecutions = workflowSettings.saveManualExecutions;
                    }
                    if (isManualMode && !saveManualExecutions && !fullRunData.waitTill) {
                        await Db.collections.Execution.delete(this.executionId);
                        await n8n_core_1.BinaryDataManager.getInstance().markDataForDeletionByExecutionId(this.executionId);
                        return;
                    }
                    let saveDataErrorExecution = config_1.default.getEnv('executions.saveDataOnError');
                    let saveDataSuccessExecution = config_1.default.getEnv('executions.saveDataOnSuccess');
                    if (this.workflowData.settings !== undefined) {
                        saveDataErrorExecution =
                            this.workflowData.settings.saveDataErrorExecution ||
                                saveDataErrorExecution;
                        saveDataSuccessExecution =
                            this.workflowData.settings.saveDataSuccessExecution ||
                                saveDataSuccessExecution;
                    }
                    const workflowHasCrashed = fullRunData.status === 'crashed';
                    const workflowWasCanceled = fullRunData.status === 'canceled';
                    const workflowDidSucceed = !fullRunData.data.resultData.error && !workflowHasCrashed && !workflowWasCanceled;
                    let workflowStatusFinal = workflowDidSucceed ? 'success' : 'failed';
                    if (workflowHasCrashed)
                        workflowStatusFinal = 'crashed';
                    if (workflowWasCanceled)
                        workflowStatusFinal = 'canceled';
                    if ((workflowDidSucceed && saveDataSuccessExecution === 'none') ||
                        (!workflowDidSucceed && saveDataErrorExecution === 'none')) {
                        if (!fullRunData.waitTill) {
                            if (!isManualMode) {
                                executeErrorWorkflow(this.workflowData, fullRunData, this.mode, this.executionId, this.retryOf);
                            }
                            await Db.collections.Execution.delete(this.executionId);
                            await n8n_core_1.BinaryDataManager.getInstance().markDataForDeletionByExecutionId(this.executionId);
                            return;
                        }
                    }
                    const pristineWorkflowData = (0, lodash_pick_1.default)(this.workflowData, [
                        'id',
                        'name',
                        'active',
                        'createdAt',
                        'updatedAt',
                        'nodes',
                        'connections',
                        'settings',
                        'staticData',
                        'pinData',
                    ]);
                    const fullExecutionData = {
                        data: fullRunData.data,
                        mode: fullRunData.mode,
                        finished: fullRunData.finished ? fullRunData.finished : false,
                        startedAt: fullRunData.startedAt,
                        stoppedAt: fullRunData.stoppedAt,
                        workflowData: pristineWorkflowData,
                        waitTill: fullRunData.waitTill,
                        status: workflowStatusFinal,
                    };
                    if (this.retryOf !== undefined) {
                        fullExecutionData.retryOf = (_a = this.retryOf) === null || _a === void 0 ? void 0 : _a.toString();
                    }
                    const workflowId = this.workflowData.id;
                    if ((0, utils_1.isWorkflowIdValid)(workflowId)) {
                        fullExecutionData.workflowId = workflowId;
                    }
                    n8n_workflow_1.LoggerProxy.debug(`Save execution data to database for execution ID ${this.executionId}`, {
                        executionId: this.executionId,
                        workflowId,
                        finished: fullExecutionData.finished,
                        stoppedAt: fullExecutionData.stoppedAt,
                    });
                    const executionData = ResponseHelper.flattenExecutionData(fullExecutionData);
                    await Db.collections.Execution.update(this.executionId, executionData);
                    try {
                        if (fullRunData.data.resultData.metadata) {
                            await saveExecutionMetadata(this.executionId, fullRunData.data.resultData.metadata);
                        }
                    }
                    catch (e) {
                        n8n_workflow_1.LoggerProxy.error(`Failed to save metadata for execution ID ${this.executionId}`, e);
                    }
                    if (fullRunData.finished === true && this.retryOf !== undefined) {
                        await Db.collections.Execution.update(this.retryOf, {
                            retrySuccessId: this.executionId,
                        });
                    }
                    if (!isManualMode) {
                        executeErrorWorkflow(this.workflowData, fullRunData, this.mode, this.executionId, this.retryOf);
                    }
                }
                catch (error) {
                    n8n_workflow_1.ErrorReporterProxy.error(error);
                    n8n_workflow_1.LoggerProxy.error(`Failed saving execution data to DB on execution ID ${this.executionId}`, {
                        executionId: this.executionId,
                        workflowId: this.workflowData.id,
                        error,
                    });
                    if (!isManualMode) {
                        executeErrorWorkflow(this.workflowData, fullRunData, this.mode, this.executionId, this.retryOf);
                    }
                }
                finally {
                    n8n_core_1.eventEmitter.emit(n8n_core_1.eventEmitter.types.workflowExecutionCompleted, this.workflowData, fullRunData);
                }
            },
        ],
        nodeFetchedData: [
            async (workflowId, node) => {
                n8n_core_1.eventEmitter.emit(n8n_core_1.eventEmitter.types.nodeFetchedData, workflowId, node);
            },
        ],
    };
}
function hookFunctionsSaveWorker() {
    return {
        nodeExecuteBefore: [],
        nodeExecuteAfter: [],
        workflowExecuteBefore: [],
        workflowExecuteAfter: [
            async function (fullRunData, newStaticData) {
                try {
                    if ((0, utils_1.isWorkflowIdValid)(this.workflowData.id) && newStaticData) {
                        try {
                            await WorkflowHelpers.saveStaticDataById(this.workflowData.id, newStaticData);
                        }
                        catch (e) {
                            n8n_workflow_1.ErrorReporterProxy.error(e);
                            n8n_workflow_1.LoggerProxy.error(`There was a problem saving the workflow with id "${this.workflowData.id}" to save changed staticData: "${e.message}" (workflowExecuteAfter)`, { sessionId: this.sessionId, workflowId: this.workflowData.id });
                        }
                    }
                    const workflowHasCrashed = fullRunData.status === 'crashed';
                    const workflowWasCanceled = fullRunData.status === 'canceled';
                    const workflowDidSucceed = !fullRunData.data.resultData.error && !workflowHasCrashed && !workflowWasCanceled;
                    let workflowStatusFinal = workflowDidSucceed ? 'success' : 'failed';
                    if (workflowHasCrashed)
                        workflowStatusFinal = 'crashed';
                    if (workflowWasCanceled)
                        workflowStatusFinal = 'canceled';
                    if (!workflowDidSucceed) {
                        executeErrorWorkflow(this.workflowData, fullRunData, this.mode, this.executionId, this.retryOf);
                    }
                    const fullExecutionData = {
                        data: fullRunData.data,
                        mode: fullRunData.mode,
                        finished: fullRunData.finished ? fullRunData.finished : false,
                        startedAt: fullRunData.startedAt,
                        stoppedAt: fullRunData.stoppedAt,
                        workflowData: this.workflowData,
                        waitTill: fullRunData.data.waitTill,
                        status: workflowStatusFinal,
                    };
                    if (this.retryOf !== undefined) {
                        fullExecutionData.retryOf = this.retryOf.toString();
                    }
                    const workflowId = this.workflowData.id;
                    if ((0, utils_1.isWorkflowIdValid)(workflowId)) {
                        fullExecutionData.workflowId = workflowId;
                    }
                    const executionData = ResponseHelper.flattenExecutionData(fullExecutionData);
                    await Db.collections.Execution.update(this.executionId, executionData);
                    await Db.collections.Execution.update(this.executionId, {
                        status: executionData.status,
                    });
                    try {
                        if (fullRunData.data.resultData.metadata) {
                            await saveExecutionMetadata(this.executionId, fullRunData.data.resultData.metadata);
                        }
                    }
                    catch (e) {
                        n8n_workflow_1.LoggerProxy.error(`Failed to save metadata for execution ID ${this.executionId}`, e);
                    }
                    if (fullRunData.finished === true && this.retryOf !== undefined) {
                        await Db.collections.Execution.update(this.retryOf, {
                            retrySuccessId: this.executionId,
                        });
                    }
                }
                catch (error) {
                    executeErrorWorkflow(this.workflowData, fullRunData, this.mode, this.executionId, this.retryOf);
                }
                finally {
                    n8n_core_1.eventEmitter.emit(n8n_core_1.eventEmitter.types.workflowExecutionCompleted, this.workflowData, fullRunData);
                }
            },
        ],
        nodeFetchedData: [
            async (workflowId, node) => {
                n8n_core_1.eventEmitter.emit(n8n_core_1.eventEmitter.types.nodeFetchedData, workflowId, node);
            },
        ],
    };
}
async function getRunData(workflowData, userId, inputData, parentWorkflowId) {
    const mode = 'integrated';
    const startingNode = (0, utils_1.findSubworkflowStart)(workflowData.nodes);
    inputData = inputData || [
        {
            json: {},
        },
    ];
    const nodeExecutionStack = [];
    nodeExecutionStack.push({
        node: startingNode,
        data: {
            main: [inputData],
        },
        source: null,
    });
    const runExecutionData = {
        startData: {},
        resultData: {
            runData: {},
        },
        executionData: {
            contextData: {},
            nodeExecutionStack,
            waitingExecution: {},
            waitingExecutionSource: {},
        },
    };
    const runData = {
        executionMode: mode,
        executionData: runExecutionData,
        workflowData,
        userId,
    };
    return runData;
}
exports.getRunData = getRunData;
async function getWorkflowData(workflowInfo, parentWorkflowId, parentWorkflowSettings) {
    var _a;
    if (workflowInfo.id === undefined && workflowInfo.code === undefined) {
        throw new Error('No information about the workflow to execute found. Please provide either the "id" or "code"!');
    }
    let workflowData;
    if (workflowInfo.id !== undefined) {
        const relations = config_1.default.getEnv('workflowTagsDisabled') ? [] : ['tags'];
        workflowData = await workflows_services_1.WorkflowsService.get({ id: workflowInfo.id }, { relations });
        if (workflowData === undefined) {
            throw new Error(`The workflow with the id "${workflowInfo.id}" does not exist.`);
        }
    }
    else {
        workflowData = (_a = workflowInfo.code) !== null && _a !== void 0 ? _a : null;
        if (workflowData) {
            if (!workflowData.id) {
                workflowData.id = parentWorkflowId;
            }
            if (!workflowData.settings) {
                workflowData.settings = parentWorkflowSettings;
            }
        }
    }
    return workflowData;
}
exports.getWorkflowData = getWorkflowData;
async function executeWorkflow(workflowInfo, additionalData, options) {
    var _a, _b, _c;
    const externalHooks = typedi_1.Container.get(ExternalHooks_1.ExternalHooks);
    await externalHooks.init();
    const nodeTypes = typedi_1.Container.get(NodeTypes_1.NodeTypes);
    const workflowData = (_a = options.loadedWorkflowData) !== null && _a !== void 0 ? _a : (await getWorkflowData(workflowInfo, options.parentWorkflowId, options.parentWorkflowSettings));
    const workflowName = workflowData ? workflowData.name : undefined;
    const workflow = new n8n_workflow_1.Workflow({
        id: (_b = workflowData.id) === null || _b === void 0 ? void 0 : _b.toString(),
        name: workflowName,
        nodes: workflowData.nodes,
        connections: workflowData.connections,
        active: workflowData.active,
        nodeTypes,
        staticData: workflowData.staticData,
        settings: workflowData.settings,
    });
    const runData = (_c = options.loadedRunData) !== null && _c !== void 0 ? _c : (await getRunData(workflowData, additionalData.userId, options.inputData));
    let executionId;
    if (options.parentExecutionId !== undefined) {
        executionId = options.parentExecutionId;
    }
    else {
        executionId =
            options.parentExecutionId !== undefined
                ? options.parentExecutionId
                : await typedi_1.Container.get(ActiveExecutions_1.ActiveExecutions).add(runData);
    }
    void typedi_1.Container.get(InternalHooks_1.InternalHooks).onWorkflowBeforeExecute(executionId || '', runData);
    let data;
    try {
        await PermissionChecker_1.PermissionChecker.check(workflow, additionalData.userId);
        await PermissionChecker_1.PermissionChecker.checkSubworkflowExecutePolicy(workflow, additionalData.userId, options.parentWorkflowId);
        const additionalDataIntegrated = await getBase(additionalData.userId);
        additionalDataIntegrated.hooks = getWorkflowHooksIntegrated(runData.executionMode, executionId, workflowData, { parentProcessMode: additionalData.hooks.mode });
        additionalDataIntegrated.executionId = executionId;
        additionalDataIntegrated.executeWorkflow = additionalData.executeWorkflow;
        let subworkflowTimeout = additionalData.executionTimeoutTimestamp;
        const workflowSettings = workflowData.settings;
        if ((workflowSettings === null || workflowSettings === void 0 ? void 0 : workflowSettings.executionTimeout) !== undefined && workflowSettings.executionTimeout > 0) {
            subworkflowTimeout = Math.min(additionalData.executionTimeoutTimestamp || Number.MAX_SAFE_INTEGER, Date.now() + workflowSettings.executionTimeout * 1000);
        }
        additionalDataIntegrated.executionTimeoutTimestamp = subworkflowTimeout;
        const runExecutionData = runData.executionData;
        const workflowExecute = new n8n_core_1.WorkflowExecute(additionalDataIntegrated, runData.executionMode, runExecutionData);
        if (options.parentExecutionId !== undefined) {
            return {
                startedAt: new Date(),
                workflow,
                workflowExecute,
            };
        }
        data = await workflowExecute.processRunExecutionData(workflow);
    }
    catch (error) {
        const fullRunData = {
            data: {
                resultData: {
                    error,
                    runData: {},
                },
            },
            finished: false,
            mode: 'integrated',
            startedAt: new Date(),
            stoppedAt: new Date(),
            status: 'failed',
        };
        const fullExecutionData = {
            data: fullRunData.data,
            mode: fullRunData.mode,
            finished: fullRunData.finished ? fullRunData.finished : false,
            startedAt: fullRunData.startedAt,
            stoppedAt: fullRunData.stoppedAt,
            status: fullRunData.status,
            workflowData,
        };
        if (workflowData.id) {
            fullExecutionData.workflowId = workflowData.id;
        }
        typedi_1.Container.get(ActiveExecutions_1.ActiveExecutions).remove(executionId, fullRunData);
        const executionData = ResponseHelper.flattenExecutionData(fullExecutionData);
        await Db.collections.Execution.update(executionId, executionData);
        throw {
            ...error,
            stack: error.stack,
            message: error.message,
        };
    }
    await externalHooks.run('workflow.postExecute', [data, workflowData, executionId]);
    void typedi_1.Container.get(InternalHooks_1.InternalHooks).onWorkflowPostExecute(executionId, workflowData, data, additionalData.userId);
    if (data.finished === true) {
        typedi_1.Container.get(ActiveExecutions_1.ActiveExecutions).remove(executionId, data);
        const returnData = WorkflowHelpers.getDataLastExecutedNodeData(data);
        return returnData.data.main;
    }
    typedi_1.Container.get(ActiveExecutions_1.ActiveExecutions).remove(executionId, data);
    const { error } = data.data.resultData;
    throw {
        ...error,
        stack: error.stack,
    };
}
function setExecutionStatus(status) {
    if (this.executionId === undefined) {
        n8n_workflow_1.LoggerProxy.debug(`Setting execution status "${status}" failed because executionId is undefined`);
        return;
    }
    n8n_workflow_1.LoggerProxy.debug(`Setting execution status for ${this.executionId} to "${status}"`);
    typedi_1.Container.get(ActiveExecutions_1.ActiveExecutions)
        .setStatus(this.executionId, status)
        .catch((error) => {
        n8n_workflow_1.LoggerProxy.debug(`Setting execution status "${status}" failed: ${error.message}`);
    });
}
exports.setExecutionStatus = setExecutionStatus;
function sendMessageToUI(source, messages) {
    const { sessionId } = this;
    if (sessionId === undefined) {
        return;
    }
    try {
        const pushInstance = typedi_1.Container.get(push_1.Push);
        pushInstance.send('sendConsoleMessage', {
            source: `[Node: "${source}"]`,
            messages,
        }, sessionId);
    }
    catch (error) {
        n8n_workflow_1.LoggerProxy.warn(`There was a problem sending message to UI: ${error.message}`);
    }
}
exports.sendMessageToUI = sendMessageToUI;
async function getBase(userId, currentNodeParameters, executionTimeoutTimestamp) {
    const urlBaseWebhook = WebhookHelpers.getWebhookBaseUrl();
    const timezone = config_1.default.getEnv('generic.timezone');
    const webhookBaseUrl = urlBaseWebhook + config_1.default.getEnv('endpoints.webhook');
    const webhookWaitingBaseUrl = urlBaseWebhook + config_1.default.getEnv('endpoints.webhookWaiting');
    const webhookTestBaseUrl = urlBaseWebhook + config_1.default.getEnv('endpoints.webhookTest');
    const [encryptionKey, variables] = await Promise.all([
        n8n_core_1.UserSettings.getEncryptionKey(),
        WorkflowHelpers.getVariables(),
    ]);
    return {
        credentialsHelper: new CredentialsHelper_1.CredentialsHelper(encryptionKey),
        encryptionKey,
        executeWorkflow,
        restApiUrl: urlBaseWebhook + config_1.default.getEnv('endpoints.rest'),
        timezone,
        webhookBaseUrl,
        webhookWaitingBaseUrl,
        webhookTestBaseUrl,
        currentNodeParameters,
        executionTimeoutTimestamp,
        userId,
        setExecutionStatus,
        variables,
    };
}
exports.getBase = getBase;
function getWorkflowHooksIntegrated(mode, executionId, workflowData, optionalParameters) {
    optionalParameters = optionalParameters || {};
    const hookFunctions = hookFunctionsSave(optionalParameters.parentProcessMode);
    const preExecuteFunctions = hookFunctionsPreExecute(optionalParameters.parentProcessMode);
    for (const key of Object.keys(preExecuteFunctions)) {
        if (hookFunctions[key] === undefined) {
            hookFunctions[key] = [];
        }
        hookFunctions[key].push.apply(hookFunctions[key], preExecuteFunctions[key]);
    }
    return new n8n_workflow_1.WorkflowHooks(hookFunctions, mode, executionId, workflowData, optionalParameters);
}
function getWorkflowHooksWorkerExecuter(mode, executionId, workflowData, optionalParameters) {
    optionalParameters = optionalParameters || {};
    const hookFunctions = hookFunctionsSaveWorker();
    const preExecuteFunctions = hookFunctionsPreExecute(optionalParameters.parentProcessMode);
    for (const key of Object.keys(preExecuteFunctions)) {
        if (hookFunctions[key] === undefined) {
            hookFunctions[key] = [];
        }
        hookFunctions[key].push.apply(hookFunctions[key], preExecuteFunctions[key]);
    }
    return new n8n_workflow_1.WorkflowHooks(hookFunctions, mode, executionId, workflowData, optionalParameters);
}
exports.getWorkflowHooksWorkerExecuter = getWorkflowHooksWorkerExecuter;
function getWorkflowHooksWorkerMain(mode, executionId, workflowData, optionalParameters) {
    optionalParameters = optionalParameters || {};
    const hookFunctions = hookFunctionsPush();
    const preExecuteFunctions = hookFunctionsPreExecute(optionalParameters.parentProcessMode);
    for (const key of Object.keys(preExecuteFunctions)) {
        if (hookFunctions[key] === undefined) {
            hookFunctions[key] = [];
        }
        hookFunctions[key].push.apply(hookFunctions[key], preExecuteFunctions[key]);
    }
    hookFunctions.nodeExecuteBefore = [];
    hookFunctions.nodeExecuteAfter = [];
    return new n8n_workflow_1.WorkflowHooks(hookFunctions, mode, executionId, workflowData, optionalParameters);
}
exports.getWorkflowHooksWorkerMain = getWorkflowHooksWorkerMain;
function getWorkflowHooksMain(data, executionId, isMainProcess = false) {
    const hookFunctions = hookFunctionsSave();
    const pushFunctions = hookFunctionsPush();
    for (const key of Object.keys(pushFunctions)) {
        if (hookFunctions[key] === undefined) {
            hookFunctions[key] = [];
        }
        hookFunctions[key].push.apply(hookFunctions[key], pushFunctions[key]);
    }
    if (isMainProcess) {
        const preExecuteFunctions = hookFunctionsPreExecute();
        for (const key of Object.keys(preExecuteFunctions)) {
            if (hookFunctions[key] === undefined) {
                hookFunctions[key] = [];
            }
            hookFunctions[key].push.apply(hookFunctions[key], preExecuteFunctions[key]);
        }
    }
    if (!hookFunctions.nodeExecuteBefore)
        hookFunctions.nodeExecuteBefore = [];
    if (!hookFunctions.nodeExecuteAfter)
        hookFunctions.nodeExecuteAfter = [];
    return new n8n_workflow_1.WorkflowHooks(hookFunctions, data.executionMode, executionId, data.workflowData, {
        sessionId: data.sessionId,
        retryOf: data.retryOf,
    });
}
exports.getWorkflowHooksMain = getWorkflowHooksMain;
//# sourceMappingURL=WorkflowExecuteAdditionalData.js.map