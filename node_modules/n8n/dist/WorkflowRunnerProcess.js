"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
require("source-map-support/register");
require("reflect-metadata");
const typedi_1 = require("typedi");
const n8n_core_1 = require("n8n-core");
const n8n_workflow_1 = require("n8n-workflow");
const CredentialTypes_1 = require("./CredentialTypes");
const CredentialsOverwrites_1 = require("./CredentialsOverwrites");
const Db = __importStar(require("./Db"));
const ExternalHooks_1 = require("./ExternalHooks");
const NodeTypes_1 = require("./NodeTypes");
const LoadNodesAndCredentials_1 = require("./LoadNodesAndCredentials");
const WebhookHelpers = __importStar(require("./WebhookHelpers"));
const WorkflowHelpers = __importStar(require("./WorkflowHelpers"));
const WorkflowExecuteAdditionalData = __importStar(require("./WorkflowExecuteAdditionalData"));
const Logger_1 = require("./Logger");
const config_1 = __importDefault(require("./config"));
const WorkflowHelpers_1 = require("./WorkflowHelpers");
const ErrorReporting_1 = require("./ErrorReporting");
const PermissionChecker_1 = require("./UserManagement/PermissionChecker");
const License_1 = require("./License");
const InternalHooks_1 = require("./InternalHooks");
const posthog_1 = require("./posthog");
class WorkflowRunnerProcess {
    constructor() {
        this.startedAt = new Date();
        this.childExecutions = {};
    }
    static async stopProcess() {
        setTimeout(() => {
            process.exit(0);
        }, 30000);
    }
    async runWorkflow(inputData) {
        var _a, _b, _c, _d, _e, _f;
        process.once('SIGTERM', WorkflowRunnerProcess.stopProcess);
        process.once('SIGINT', WorkflowRunnerProcess.stopProcess);
        await (0, ErrorReporting_1.initErrorHandling)();
        const logger = (this.logger = (0, Logger_1.getLogger)());
        n8n_workflow_1.LoggerProxy.init(logger);
        this.data = inputData;
        const { userId } = inputData;
        logger.verbose('Initializing n8n sub-process', {
            pid: process.pid,
            workflowId: this.data.workflowData.id,
        });
        this.startedAt = new Date();
        const userSettings = await n8n_core_1.UserSettings.prepareUserSettings();
        const loadNodesAndCredentials = typedi_1.Container.get(LoadNodesAndCredentials_1.LoadNodesAndCredentials);
        await loadNodesAndCredentials.init();
        const nodeTypes = typedi_1.Container.get(NodeTypes_1.NodeTypes);
        const credentialTypes = typedi_1.Container.get(CredentialTypes_1.CredentialTypes);
        (0, CredentialsOverwrites_1.CredentialsOverwrites)(credentialTypes);
        const externalHooks = typedi_1.Container.get(ExternalHooks_1.ExternalHooks);
        await externalHooks.init();
        await Db.init();
        const instanceId = (_a = userSettings.instanceId) !== null && _a !== void 0 ? _a : '';
        await typedi_1.Container.get(posthog_1.PostHogClient).init(instanceId);
        await typedi_1.Container.get(InternalHooks_1.InternalHooks).init(instanceId);
        const binaryDataConfig = config_1.default.getEnv('binaryDataManager');
        await n8n_core_1.BinaryDataManager.init(binaryDataConfig);
        const license = typedi_1.Container.get(License_1.License);
        await license.init(instanceId);
        const workflowSettings = (_b = this.data.workflowData.settings) !== null && _b !== void 0 ? _b : {};
        let workflowTimeout = (_c = workflowSettings.executionTimeout) !== null && _c !== void 0 ? _c : config_1.default.getEnv('executions.timeout');
        if (workflowTimeout > 0) {
            workflowTimeout = Math.min(workflowTimeout, config_1.default.getEnv('executions.maxTimeout'));
        }
        this.workflow = new n8n_workflow_1.Workflow({
            id: this.data.workflowData.id,
            name: this.data.workflowData.name,
            nodes: this.data.workflowData.nodes,
            connections: this.data.workflowData.connections,
            active: this.data.workflowData.active,
            nodeTypes,
            staticData: this.data.workflowData.staticData,
            settings: this.data.workflowData.settings,
            pinData: this.data.pinData,
        });
        try {
            await PermissionChecker_1.PermissionChecker.check(this.workflow, userId);
        }
        catch (error) {
            const caughtError = error;
            const failedExecutionData = (0, WorkflowHelpers_1.generateFailedExecutionFromError)(this.data.executionMode, caughtError, caughtError.node);
            await this.sendHookToParentProcess('workflowExecuteAfter', [failedExecutionData]);
            return failedExecutionData;
        }
        const additionalData = await WorkflowExecuteAdditionalData.getBase(userId, undefined, workflowTimeout <= 0 ? undefined : Date.now() + workflowTimeout * 1000);
        additionalData.restartExecutionId = this.data.restartExecutionId;
        additionalData.hooks = this.getProcessForwardHooks();
        additionalData.hooks.hookFunctions.sendResponse = [
            async (response) => {
                await sendToParentProcess('sendResponse', {
                    response: WebhookHelpers.encodeWebhookResponse(response),
                });
            },
        ];
        additionalData.executionId = inputData.executionId;
        additionalData.setExecutionStatus = WorkflowExecuteAdditionalData.setExecutionStatus.bind({
            executionId: inputData.executionId,
        });
        additionalData.sendMessageToUI = async (source, message) => {
            if (workflowRunner.data.executionMode !== 'manual') {
                return;
            }
            try {
                await sendToParentProcess('sendMessageToUI', { source, message });
            }
            catch (error) {
                n8n_workflow_1.ErrorReporterProxy.error(error);
                this.logger.error(`There was a problem sending UI data to parent process: "${error.message}"`);
            }
        };
        const executeWorkflowFunction = additionalData.executeWorkflow;
        additionalData.executeWorkflow = async (workflowInfo, additionalData, options) => {
            const workflowData = await WorkflowExecuteAdditionalData.getWorkflowData(workflowInfo, options === null || options === void 0 ? void 0 : options.parentWorkflowId, options === null || options === void 0 ? void 0 : options.parentWorkflowSettings);
            const runData = await WorkflowExecuteAdditionalData.getRunData(workflowData, additionalData.userId, options === null || options === void 0 ? void 0 : options.inputData, options === null || options === void 0 ? void 0 : options.parentWorkflowId);
            await sendToParentProcess('startExecution', { runData });
            const executionId = await new Promise((resolve) => {
                this.executionIdCallback = (executionId) => {
                    resolve(executionId);
                };
            });
            void typedi_1.Container.get(InternalHooks_1.InternalHooks).onWorkflowBeforeExecute(executionId || '', runData);
            let result;
            try {
                const executeWorkflowFunctionOutput = (await executeWorkflowFunction(workflowInfo, additionalData, {
                    parentWorkflowId: options === null || options === void 0 ? void 0 : options.parentWorkflowId,
                    inputData: options === null || options === void 0 ? void 0 : options.inputData,
                    parentExecutionId: executionId,
                    loadedWorkflowData: workflowData,
                    loadedRunData: runData,
                    parentWorkflowSettings: options === null || options === void 0 ? void 0 : options.parentWorkflowSettings,
                }));
                const { workflowExecute } = executeWorkflowFunctionOutput;
                this.childExecutions[executionId] = executeWorkflowFunctionOutput;
                const { workflow } = executeWorkflowFunctionOutput;
                result = await workflowExecute.processRunExecutionData(workflow);
                await externalHooks.run('workflow.postExecute', [result, workflowData, executionId]);
                void typedi_1.Container.get(InternalHooks_1.InternalHooks).onWorkflowPostExecute(executionId, workflowData, result, additionalData.userId);
                await sendToParentProcess('finishExecution', { executionId, result });
                delete this.childExecutions[executionId];
            }
            catch (e) {
                await sendToParentProcess('finishExecution', { executionId });
                delete this.childExecutions[executionId];
                throw e;
            }
            await sendToParentProcess('finishExecution', { executionId, result });
            const returnData = WorkflowHelpers.getDataLastExecutedNodeData(result);
            if (returnData.error) {
                const error = new Error(returnData.error.message);
                error.stack = returnData.error.stack;
                throw error;
            }
            return returnData.data.main;
        };
        if (this.data.executionData !== undefined) {
            this.workflowExecute = new n8n_core_1.WorkflowExecute(additionalData, this.data.executionMode, this.data.executionData);
            return this.workflowExecute.processRunExecutionData(this.workflow);
        }
        if (this.data.runData === undefined ||
            this.data.startNodes === undefined ||
            this.data.startNodes.length === 0 ||
            this.data.destinationNode === undefined) {
            let startNode;
            if (((_d = this.data.startNodes) === null || _d === void 0 ? void 0 : _d.length) === 1 &&
                Object.keys((_e = this.data.pinData) !== null && _e !== void 0 ? _e : {}).includes(this.data.startNodes[0])) {
                startNode = (_f = this.workflow.getNode(this.data.startNodes[0])) !== null && _f !== void 0 ? _f : undefined;
            }
            this.workflowExecute = new n8n_core_1.WorkflowExecute(additionalData, this.data.executionMode);
            return this.workflowExecute.run(this.workflow, startNode, this.data.destinationNode, this.data.pinData);
        }
        this.workflowExecute = new n8n_core_1.WorkflowExecute(additionalData, this.data.executionMode);
        return this.workflowExecute.runPartialWorkflow(this.workflow, this.data.runData, this.data.startNodes, this.data.destinationNode, this.data.pinData);
    }
    async sendHookToParentProcess(hook, parameters) {
        try {
            await sendToParentProcess('processHook', {
                hook,
                parameters,
            });
        }
        catch (error) {
            n8n_workflow_1.ErrorReporterProxy.error(error);
            this.logger.error(`There was a problem sending hook: "${hook}"`, { parameters, error });
        }
    }
    getProcessForwardHooks() {
        const hookFunctions = {
            nodeExecuteBefore: [
                async (nodeName) => {
                    await this.sendHookToParentProcess('nodeExecuteBefore', [nodeName]);
                },
            ],
            nodeExecuteAfter: [
                async (nodeName, data) => {
                    await this.sendHookToParentProcess('nodeExecuteAfter', [nodeName, data]);
                },
            ],
            workflowExecuteBefore: [
                async () => {
                    await this.sendHookToParentProcess('workflowExecuteBefore', []);
                },
            ],
            workflowExecuteAfter: [
                async (fullRunData, newStaticData) => {
                    await this.sendHookToParentProcess('workflowExecuteAfter', [fullRunData, newStaticData]);
                },
            ],
            nodeFetchedData: [
                async (workflowId, node) => {
                    await this.sendHookToParentProcess('nodeFetchedData', [workflowId, node]);
                },
            ],
        };
        const preExecuteFunctions = WorkflowExecuteAdditionalData.hookFunctionsPreExecute();
        for (const key of Object.keys(preExecuteFunctions)) {
            if (hookFunctions[key] === undefined) {
                hookFunctions[key] = [];
            }
            hookFunctions[key].push.apply(hookFunctions[key], preExecuteFunctions[key]);
        }
        return new n8n_workflow_1.WorkflowHooks(hookFunctions, this.data.executionMode, this.data.executionId, this.data.workflowData, { sessionId: this.data.sessionId, retryOf: this.data.retryOf });
    }
}
async function sendToParentProcess(type, data) {
    return new Promise((resolve, reject) => {
        process.send({
            type,
            data,
        }, (error) => {
            if (error) {
                return reject(error);
            }
            resolve();
        });
    });
}
const workflowRunner = new WorkflowRunnerProcess();
process.on('message', async (message) => {
    try {
        if (message.type === 'startWorkflow') {
            await sendToParentProcess('start', {});
            const runData = await workflowRunner.runWorkflow(message.data);
            await sendToParentProcess('end', {
                runData,
            });
            process.exit();
        }
        else if (message.type === 'stopExecution' || message.type === 'timeout') {
            let runData;
            if (workflowRunner.workflowExecute !== undefined) {
                const executionIds = Object.keys(workflowRunner.childExecutions);
                for (const executionId of executionIds) {
                    const childWorkflowExecute = workflowRunner.childExecutions[executionId];
                    runData = childWorkflowExecute.workflowExecute.getFullRunData(workflowRunner.childExecutions[executionId].startedAt);
                    const timeOutError = message.type === 'timeout'
                        ? new n8n_workflow_1.WorkflowOperationError('Workflow execution timed out!')
                        : new n8n_workflow_1.WorkflowOperationError('Workflow-Execution has been canceled!');
                    await childWorkflowExecute.workflowExecute.processSuccessExecution(workflowRunner.childExecutions[executionId].startedAt, childWorkflowExecute.workflow, timeOutError);
                }
                runData = workflowRunner.workflowExecute.getFullRunData(workflowRunner.startedAt);
                const timeOutError = message.type === 'timeout'
                    ? new n8n_workflow_1.WorkflowOperationError('Workflow execution timed out!')
                    : new n8n_workflow_1.WorkflowOperationError('Workflow-Execution has been canceled!');
                runData.status = message.type === 'timeout' ? 'failed' : 'canceled';
                await workflowRunner.workflowExecute.processSuccessExecution(workflowRunner.startedAt, workflowRunner.workflow, timeOutError);
            }
            else {
                runData = {
                    data: {
                        resultData: {
                            runData: {},
                        },
                    },
                    finished: false,
                    mode: workflowRunner.data
                        ? workflowRunner.data.executionMode
                        : 'own',
                    startedAt: workflowRunner.startedAt,
                    stoppedAt: new Date(),
                    status: 'canceled',
                };
                workflowRunner.sendHookToParentProcess('workflowExecuteAfter', [runData]);
            }
            await sendToParentProcess(message.type === 'timeout' ? message.type : 'end', {
                runData,
            });
            process.exit();
        }
        else if (message.type === 'executionId') {
            workflowRunner.executionIdCallback(message.data.executionId);
        }
    }
    catch (error) {
        workflowRunner.logger.error(error.message);
        const executionError = {
            ...error,
            name: error.name || 'Error',
            message: error.message,
            stack: error.stack,
        };
        await sendToParentProcess('processError', {
            executionError,
        });
        process.exit();
    }
});
//# sourceMappingURL=WorkflowRunnerProcess.js.map