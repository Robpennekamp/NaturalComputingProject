"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActiveWebhooks = void 0;
const typedi_1 = require("typedi");
const NodeExecuteFunctions = __importStar(require("n8n-core"));
let ActiveWebhooks = class ActiveWebhooks {
    constructor() {
        this.workflowWebhooks = {};
        this.webhookUrls = {};
        this.testWebhooks = false;
    }
    async add(workflow, webhookData, mode, activation) {
        if (workflow.id === undefined) {
            throw new Error('Webhooks can only be added for saved workflows as an id is needed!');
        }
        if (webhookData.path.endsWith('/')) {
            webhookData.path = webhookData.path.slice(0, -1);
        }
        const webhookKey = this.getWebhookKey(webhookData.httpMethod, webhookData.path, webhookData.webhookId);
        if (this.webhookUrls[webhookKey] && !webhookData.webhookId) {
            throw new Error(`The URL path that the "${webhookData.node}" node uses is already taken. Please change it to something else.`);
        }
        if (this.workflowWebhooks[webhookData.workflowId] === undefined) {
            this.workflowWebhooks[webhookData.workflowId] = [];
        }
        if (!this.webhookUrls[webhookKey]) {
            this.webhookUrls[webhookKey] = [];
        }
        this.webhookUrls[webhookKey].push(webhookData);
        try {
            const webhookExists = await workflow.runWebhookMethod('checkExists', webhookData, NodeExecuteFunctions, mode, activation, this.testWebhooks);
            if (webhookExists !== true) {
                await workflow.runWebhookMethod('create', webhookData, NodeExecuteFunctions, mode, activation, this.testWebhooks);
            }
        }
        catch (error) {
            if (this.webhookUrls[webhookKey].length <= 1) {
                delete this.webhookUrls[webhookKey];
            }
            else {
                this.webhookUrls[webhookKey] = this.webhookUrls[webhookKey].filter((webhook) => webhook.path !== webhookData.path);
            }
            throw error;
        }
        this.workflowWebhooks[webhookData.workflowId].push(webhookData);
    }
    get(httpMethod, path, webhookId) {
        const webhookKey = this.getWebhookKey(httpMethod, path, webhookId);
        if (this.webhookUrls[webhookKey] === undefined) {
            return undefined;
        }
        let webhook;
        let maxMatches = 0;
        const pathElementsSet = new Set(path.split('/'));
        this.webhookUrls[webhookKey].forEach((dynamicWebhook) => {
            const staticElements = dynamicWebhook.path.split('/').filter((ele) => !ele.startsWith(':'));
            const allStaticExist = staticElements.every((staticEle) => pathElementsSet.has(staticEle));
            if (allStaticExist && staticElements.length > maxMatches) {
                maxMatches = staticElements.length;
                webhook = dynamicWebhook;
            }
            else if (staticElements.length === 0 && !webhook) {
                webhook = dynamicWebhook;
            }
        });
        return webhook;
    }
    getWebhookMethods(path) {
        const methods = [];
        Object.keys(this.webhookUrls)
            .filter((key) => key.includes(path))
            .map((key) => {
            methods.push(key.split('|')[0]);
        });
        return methods;
    }
    getWorkflowIds() {
        return Object.keys(this.workflowWebhooks);
    }
    getWebhookKey(httpMethod, path, webhookId) {
        if (webhookId) {
            if (path.startsWith(webhookId)) {
                const cutFromIndex = path.indexOf('/') + 1;
                path = path.slice(cutFromIndex);
            }
            return `${httpMethod}|${webhookId}|${path.split('/').length}`;
        }
        return `${httpMethod}|${path}`;
    }
    async removeWorkflow(workflow) {
        const workflowId = workflow.id.toString();
        if (this.workflowWebhooks[workflowId] === undefined) {
            return false;
        }
        const webhooks = this.workflowWebhooks[workflowId];
        const mode = 'internal';
        for (const webhookData of webhooks) {
            await workflow.runWebhookMethod('delete', webhookData, NodeExecuteFunctions, mode, 'update', this.testWebhooks);
            delete this.webhookUrls[this.getWebhookKey(webhookData.httpMethod, webhookData.path, webhookData.webhookId)];
        }
        delete this.workflowWebhooks[workflowId];
        return true;
    }
    async removeAll(workflows) {
        const removePromises = [];
        for (const workflow of workflows) {
            removePromises.push(this.removeWorkflow(workflow));
        }
        await Promise.all(removePromises);
    }
};
ActiveWebhooks = __decorate([
    (0, typedi_1.Service)()
], ActiveWebhooks);
exports.ActiveWebhooks = ActiveWebhooks;
//# sourceMappingURL=ActiveWebhooks.js.map