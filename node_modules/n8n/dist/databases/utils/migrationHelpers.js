"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.escapeQuery = exports.runInBatches = exports.wrapMigration = exports.logMigrationEnd = exports.logMigrationStart = exports.loadSurveyFromDisk = void 0;
const fs_1 = require("fs");
const n8n_core_1 = require("n8n-core");
const config_1 = __importDefault(require("../../config"));
const Logger_1 = require("../../Logger");
const constants_1 = require("../../constants");
const logger = (0, Logger_1.getLogger)();
const PERSONALIZATION_SURVEY_FILENAME = 'personalizationSurvey.json';
function loadSurveyFromDisk() {
    const userSettingsPath = n8n_core_1.UserSettings.getUserN8nFolderPath();
    try {
        const filename = `${userSettingsPath}/${PERSONALIZATION_SURVEY_FILENAME}`;
        const surveyFile = (0, fs_1.readFileSync)(filename, 'utf-8');
        (0, fs_1.rmSync)(filename);
        const personalizationSurvey = JSON.parse(surveyFile);
        const kvPairs = Object.entries(personalizationSurvey);
        if (!kvPairs.length) {
            throw new Error('personalizationSurvey is empty');
        }
        else {
            const emptyKeys = kvPairs.reduce((acc, [_key, value]) => {
                if (!value || (Array.isArray(value) && !value.length)) {
                    return acc + 1;
                }
                return acc;
            }, 0);
            if (emptyKeys === kvPairs.length) {
                throw new Error('incomplete personalizationSurvey');
            }
        }
        return surveyFile;
    }
    catch (error) {
        return null;
    }
}
exports.loadSurveyFromDisk = loadSurveyFromDisk;
let logFinishTimeout;
function logMigrationStart(migrationName, disableLogging = constants_1.inTest) {
    if (disableLogging)
        return;
    if (!logFinishTimeout) {
        logger.warn('Migrations in progress, please do NOT stop the process.');
    }
    logger.debug(`Starting migration ${migrationName}`);
    clearTimeout(logFinishTimeout);
}
exports.logMigrationStart = logMigrationStart;
function logMigrationEnd(migrationName, disableLogging = constants_1.inTest) {
    if (disableLogging)
        return;
    logger.debug(`Finished migration ${migrationName}`);
    logFinishTimeout = setTimeout(() => {
        logger.warn('Migrations finished.');
    }, 100);
}
exports.logMigrationEnd = logMigrationEnd;
const wrapMigration = (migration) => {
    const dbType = config_1.default.getEnv('database.type');
    const dbName = config_1.default.getEnv(`database.${dbType === 'mariadb' ? 'mysqldb' : dbType}.database`);
    const tablePrefix = config_1.default.getEnv('database.tablePrefix');
    const migrationName = migration.name;
    const context = { tablePrefix, dbType, dbName, migrationName };
    const { up, down } = migration.prototype;
    Object.assign(migration.prototype, {
        up: async (queryRunner) => {
            logMigrationStart(migrationName);
            await up.call(this, { queryRunner, ...context });
            logMigrationEnd(migrationName);
        },
        down: async (queryRunner) => {
            await (down === null || down === void 0 ? void 0 : down.call(this, { queryRunner, ...context }));
        },
    });
};
exports.wrapMigration = wrapMigration;
function batchQuery(query, limit, offset = 0) {
    return `
			${query}
			LIMIT ${limit}
			OFFSET ${offset}
		`;
}
async function runInBatches(queryRunner, query, operation, limit = 100) {
    let offset = 0;
    let batchedQuery;
    let batchedQueryResults;
    if (query.trim().endsWith(';'))
        query = query.trim().slice(0, -1);
    do {
        batchedQuery = batchQuery(query, limit, offset);
        batchedQueryResults = (await queryRunner.query(batchedQuery));
        await operation([...batchedQueryResults]);
        offset += limit;
    } while (batchedQueryResults.length === limit);
}
exports.runInBatches = runInBatches;
const escapeQuery = (queryRunner, query, params) => queryRunner.connection.driver.escapeQueryWithParameters(query, {
    pinData: params.pinData,
    id: params.id,
}, {});
exports.escapeQuery = escapeQuery;
//# sourceMappingURL=migrationHelpers.js.map