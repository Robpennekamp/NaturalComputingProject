"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateWorkflowCredentials1630451444017 = void 0;
const migrationHelpers_1 = require("../../utils/migrationHelpers");
class UpdateWorkflowCredentials1630451444017 {
    async up({ queryRunner, tablePrefix }) {
        const credentialsEntities = (await queryRunner.query(`
			SELECT id, name, type
			FROM ${tablePrefix}credentials_entity
		`));
        const workflowsQuery = `
			SELECT id, nodes
			FROM ${tablePrefix}workflow_entity
		`;
        await (0, migrationHelpers_1.runInBatches)(queryRunner, workflowsQuery, (workflows) => {
            workflows.forEach(async (workflow) => {
                const nodes = workflow.nodes;
                let credentialsUpdated = false;
                nodes.forEach((node) => {
                    if (node.credentials) {
                        const allNodeCredentials = Object.entries(node.credentials);
                        for (const [type, name] of allNodeCredentials) {
                            if (typeof name === 'string') {
                                const matchingCredentials = credentialsEntities.find((credentials) => credentials.name === name && credentials.type === type);
                                node.credentials[type] = { id: (matchingCredentials === null || matchingCredentials === void 0 ? void 0 : matchingCredentials.id) || null, name };
                                credentialsUpdated = true;
                            }
                        }
                    }
                });
                if (credentialsUpdated) {
                    const [updateQuery, updateParams] = queryRunner.connection.driver.escapeQueryWithParameters(`
								UPDATE ${tablePrefix}workflow_entity
								SET nodes = :nodes
								WHERE id = '${workflow.id}'
							`, { nodes: JSON.stringify(nodes) }, {});
                    await queryRunner.query(updateQuery, updateParams);
                }
            });
        });
        const waitingExecutionsQuery = `
			SELECT id, workflowData
			FROM ${tablePrefix}execution_entity
			WHERE waitTill IS NOT NULL AND finished = 0
		`;
        await (0, migrationHelpers_1.runInBatches)(queryRunner, waitingExecutionsQuery, (waitingExecutions) => {
            waitingExecutions.forEach(async (execution) => {
                const data = execution.workflowData;
                let credentialsUpdated = false;
                data.nodes.forEach((node) => {
                    if (node.credentials) {
                        const allNodeCredentials = Object.entries(node.credentials);
                        for (const [type, name] of allNodeCredentials) {
                            if (typeof name === 'string') {
                                const matchingCredentials = credentialsEntities.find((credentials) => credentials.name === name && credentials.type === type);
                                node.credentials[type] = { id: (matchingCredentials === null || matchingCredentials === void 0 ? void 0 : matchingCredentials.id) || null, name };
                                credentialsUpdated = true;
                            }
                        }
                    }
                });
                if (credentialsUpdated) {
                    const [updateQuery, updateParams] = queryRunner.connection.driver.escapeQueryWithParameters(`
								UPDATE ${tablePrefix}execution_entity
								SET workflowData = :data
								WHERE id = '${execution.id}'
							`, { data: JSON.stringify(data) }, {});
                    await queryRunner.query(updateQuery, updateParams);
                }
            });
        });
        const retryableExecutions = await queryRunner.query(`
			SELECT id, workflowData
			FROM ${tablePrefix}execution_entity
			WHERE waitTill IS NULL AND finished = 0 AND mode != 'retry'
			ORDER BY startedAt DESC
			LIMIT 200
		`);
        retryableExecutions.forEach(async (execution) => {
            const data = execution.workflowData;
            let credentialsUpdated = false;
            data.nodes.forEach((node) => {
                if (node.credentials) {
                    const allNodeCredentials = Object.entries(node.credentials);
                    for (const [type, name] of allNodeCredentials) {
                        if (typeof name === 'string') {
                            const matchingCredentials = credentialsEntities.find((credentials) => credentials.name === name && credentials.type === type);
                            node.credentials[type] = { id: (matchingCredentials === null || matchingCredentials === void 0 ? void 0 : matchingCredentials.id) || null, name };
                            credentialsUpdated = true;
                        }
                    }
                }
            });
            if (credentialsUpdated) {
                const [updateQuery, updateParams] = queryRunner.connection.driver.escapeQueryWithParameters(`
						UPDATE ${tablePrefix}execution_entity
						SET workflowData = :data
						WHERE id = '${execution.id}'
					`, { data: JSON.stringify(data) }, {});
                await queryRunner.query(updateQuery, updateParams);
            }
        });
    }
    async down({ queryRunner, tablePrefix }) {
        const credentialsEntities = (await queryRunner.query(`
			SELECT id, name, type
			FROM ${tablePrefix}credentials_entity
		`));
        const workflowsQuery = `
			SELECT id, nodes
			FROM ${tablePrefix}workflow_entity
		`;
        await (0, migrationHelpers_1.runInBatches)(queryRunner, workflowsQuery, (workflows) => {
            workflows.forEach(async (workflow) => {
                const nodes = workflow.nodes;
                let credentialsUpdated = false;
                nodes.forEach((node) => {
                    if (node.credentials) {
                        const allNodeCredentials = Object.entries(node.credentials);
                        for (const [type, creds] of allNodeCredentials) {
                            if (typeof creds === 'object') {
                                const matchingCredentials = credentialsEntities.find((credentials) => credentials.id === creds.id && credentials.type === type);
                                if (matchingCredentials) {
                                    node.credentials[type] = matchingCredentials.name;
                                }
                                else {
                                    node.credentials[type] = creds.name;
                                }
                                credentialsUpdated = true;
                            }
                        }
                    }
                });
                if (credentialsUpdated) {
                    const [updateQuery, updateParams] = queryRunner.connection.driver.escapeQueryWithParameters(`
								UPDATE ${tablePrefix}workflow_entity
								SET nodes = :nodes
								WHERE id = '${workflow.id}'
							`, { nodes: JSON.stringify(nodes) }, {});
                    await queryRunner.query(updateQuery, updateParams);
                }
            });
        });
        const waitingExecutionsQuery = `
			SELECT id, workflowData
			FROM ${tablePrefix}execution_entity
			WHERE waitTill IS NOT NULL AND finished = 0
		`;
        await (0, migrationHelpers_1.runInBatches)(queryRunner, waitingExecutionsQuery, (waitingExecutions) => {
            waitingExecutions.forEach(async (execution) => {
                const data = execution.workflowData;
                let credentialsUpdated = false;
                data.nodes.forEach((node) => {
                    if (node.credentials) {
                        const allNodeCredentials = Object.entries(node.credentials);
                        for (const [type, creds] of allNodeCredentials) {
                            if (typeof creds === 'object') {
                                const matchingCredentials = credentialsEntities.find((credentials) => credentials.id === creds.id && credentials.type === type);
                                if (matchingCredentials) {
                                    node.credentials[type] = matchingCredentials.name;
                                }
                                else {
                                    node.credentials[type] = creds.name;
                                }
                                credentialsUpdated = true;
                            }
                        }
                    }
                });
                if (credentialsUpdated) {
                    const [updateQuery, updateParams] = queryRunner.connection.driver.escapeQueryWithParameters(`
								UPDATE ${tablePrefix}execution_entity
								SET workflowData = :data
								WHERE id = '${execution.id}'
							`, { data: JSON.stringify(data) }, {});
                    await queryRunner.query(updateQuery, updateParams);
                }
            });
        });
        const retryableExecutions = await queryRunner.query(`
			SELECT id, workflowData
			FROM ${tablePrefix}execution_entity
			WHERE waitTill IS NULL AND finished = 0 AND mode != 'retry'
			ORDER BY startedAt DESC
			LIMIT 200
		`);
        retryableExecutions.forEach(async (execution) => {
            const data = execution.workflowData;
            let credentialsUpdated = false;
            data.nodes.forEach((node) => {
                if (node.credentials) {
                    const allNodeCredentials = Object.entries(node.credentials);
                    for (const [type, creds] of allNodeCredentials) {
                        if (typeof creds === 'object') {
                            const matchingCredentials = credentialsEntities.find((credentials) => credentials.id === creds.id && credentials.type === type);
                            if (matchingCredentials) {
                                node.credentials[type] = matchingCredentials.name;
                            }
                            else {
                                node.credentials[type] = creds.name;
                            }
                            credentialsUpdated = true;
                        }
                    }
                }
            });
            if (credentialsUpdated) {
                const [updateQuery, updateParams] = queryRunner.connection.driver.escapeQueryWithParameters(`
						UPDATE ${tablePrefix}execution_entity
						SET workflowData = :data
						WHERE id = '${execution.id}'
					`, { data: JSON.stringify(data) }, {});
                await queryRunner.query(updateQuery, updateParams);
            }
        });
    }
}
exports.UpdateWorkflowCredentials1630451444017 = UpdateWorkflowCredentials1630451444017;
//# sourceMappingURL=1630451444017-UpdateWorkflowCredentials.js.map