"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWebhookBaseUrl = exports.executeWebhook = exports.encodeWebhookResponse = exports.decodeWebhookResponse = exports.getWorkflowWebhooks = exports.WEBHOOK_METHODS = void 0;
const lodash_get_1 = __importDefault(require("lodash.get"));
const n8n_core_1 = require("n8n-core");
const n8n_workflow_1 = require("n8n-workflow");
const GenericHelpers = __importStar(require("./GenericHelpers"));
const ResponseHelper = __importStar(require("./ResponseHelper"));
const WorkflowHelpers = __importStar(require("./WorkflowHelpers"));
const WorkflowRunner_1 = require("./WorkflowRunner");
const WorkflowExecuteAdditionalData = __importStar(require("./WorkflowExecuteAdditionalData"));
const ActiveExecutions_1 = require("./ActiveExecutions");
const UserManagementHelper_1 = require("./UserManagement/UserManagementHelper");
const typedi_1 = require("typedi");
exports.WEBHOOK_METHODS = ['DELETE', 'GET', 'HEAD', 'PATCH', 'POST', 'PUT'];
function getWorkflowWebhooks(workflow, additionalData, destinationNode, ignoreRestartWebhooks = false) {
    const returnData = [];
    let parentNodes;
    if (destinationNode !== undefined) {
        parentNodes = workflow.getParentNodes(destinationNode);
        parentNodes.push(destinationNode);
    }
    for (const node of Object.values(workflow.nodes)) {
        if (parentNodes !== undefined && !parentNodes.includes(node.name)) {
            continue;
        }
        returnData.push.apply(returnData, n8n_workflow_1.NodeHelpers.getNodeWebhooks(workflow, node, additionalData, ignoreRestartWebhooks));
    }
    return returnData;
}
exports.getWorkflowWebhooks = getWorkflowWebhooks;
function decodeWebhookResponse(response) {
    if (typeof response === 'object' &&
        typeof response.body === 'object' &&
        response.body['__@N8nEncodedBuffer@__']) {
        response.body = Buffer.from(response.body['__@N8nEncodedBuffer@__'], n8n_workflow_1.BINARY_ENCODING);
    }
    return response;
}
exports.decodeWebhookResponse = decodeWebhookResponse;
function encodeWebhookResponse(response) {
    if (typeof response === 'object' && Buffer.isBuffer(response.body)) {
        response.body = {
            '__@N8nEncodedBuffer@__': response.body.toString(n8n_workflow_1.BINARY_ENCODING),
        };
    }
    return response;
}
exports.encodeWebhookResponse = encodeWebhookResponse;
async function executeWebhook(workflow, webhookData, workflowData, workflowStartNode, executionMode, sessionId, runExecutionData, executionId, req, res, responseCallback, destinationNode) {
    var _a;
    const nodeType = workflow.nodeTypes.getByNameAndVersion(workflowStartNode.type, workflowStartNode.typeVersion);
    if (nodeType === undefined) {
        const errorMessage = `The type of the webhook node "${workflowStartNode.name}" is not known`;
        responseCallback(new Error(errorMessage), {});
        throw new ResponseHelper.InternalServerError(errorMessage);
    }
    const additionalKeys = {
        $executionId: executionId,
    };
    let user;
    if (((_a = workflowData.shared) === null || _a === void 0 ? void 0 : _a.length) &&
        workflowData.shared[0].user) {
        user = workflowData.shared[0].user;
    }
    else {
        try {
            user = await (0, UserManagementHelper_1.getWorkflowOwner)(workflowData.id);
        }
        catch (error) {
            throw new ResponseHelper.NotFoundError('Cannot find workflow');
        }
    }
    const additionalData = await WorkflowExecuteAdditionalData.getBase(user.id);
    const responseMode = workflow.expression.getSimpleParameterValue(workflowStartNode, webhookData.webhookDescription.responseMode, executionMode, additionalData.timezone, additionalKeys, undefined, 'onReceived');
    const responseCode = workflow.expression.getSimpleParameterValue(workflowStartNode, webhookData.webhookDescription.responseCode, executionMode, additionalData.timezone, additionalKeys, undefined, 200);
    const responseData = workflow.expression.getSimpleParameterValue(workflowStartNode, webhookData.webhookDescription.responseData, executionMode, additionalData.timezone, additionalKeys, undefined, 'firstEntryJson');
    if (!['onReceived', 'lastNode', 'responseNode'].includes(responseMode)) {
        const errorMessage = `The response mode '${responseMode}' is not valid!`;
        responseCallback(new Error(errorMessage), {});
        throw new ResponseHelper.InternalServerError(errorMessage);
    }
    additionalData.httpRequest = req;
    additionalData.httpResponse = res;
    let didSendResponse = false;
    let runExecutionDataMerge = {};
    try {
        let webhookResultData;
        try {
            webhookResultData = await workflow.runWebhook(webhookData, workflowStartNode, additionalData, n8n_core_1.NodeExecuteFunctions, executionMode);
            n8n_core_1.eventEmitter.emit(n8n_core_1.eventEmitter.types.nodeFetchedData, workflow.id, workflowStartNode);
        }
        catch (err) {
            const errorMessage = 'Workflow Webhook Error: Workflow could not be started!';
            responseCallback(new Error(errorMessage), {});
            didSendResponse = true;
            runExecutionDataMerge = {
                resultData: {
                    runData: {},
                    lastNodeExecuted: workflowStartNode.name,
                    error: {
                        ...err,
                        message: err.message,
                        stack: err.stack,
                    },
                },
            };
            webhookResultData = {
                noWebhookResponse: true,
                workflowData: [[{ json: {} }]],
            };
        }
        await WorkflowHelpers.saveStaticData(workflow);
        const additionalKeys = {
            $executionId: executionId,
        };
        if (webhookData.webhookDescription.responseHeaders !== undefined) {
            const responseHeaders = workflow.expression.getComplexParameterValue(workflowStartNode, webhookData.webhookDescription.responseHeaders, executionMode, additionalData.timezone, additionalKeys, undefined, undefined);
            if (responseHeaders !== undefined && responseHeaders.entries !== undefined) {
                for (const item of responseHeaders.entries) {
                    res.setHeader(item.name, item.value);
                }
            }
        }
        if (webhookResultData.noWebhookResponse === true && !didSendResponse) {
            responseCallback(null, {
                noWebhookResponse: true,
            });
            didSendResponse = true;
        }
        if (webhookResultData.workflowData === undefined) {
            if (webhookResultData.webhookResponse !== undefined) {
                if (!didSendResponse) {
                    responseCallback(null, {
                        data: webhookResultData.webhookResponse,
                        responseCode,
                    });
                    didSendResponse = true;
                }
            }
            else {
                if (!didSendResponse) {
                    responseCallback(null, {
                        data: {
                            message: 'Webhook call received',
                        },
                        responseCode,
                    });
                    didSendResponse = true;
                }
            }
            return;
        }
        if (responseMode === 'onReceived' && !didSendResponse) {
            if (responseData === 'noData') {
                responseCallback(null, {
                    responseCode,
                });
            }
            else if (webhookResultData.webhookResponse !== undefined) {
                responseCallback(null, {
                    data: webhookResultData.webhookResponse,
                    responseCode,
                });
            }
            else {
                responseCallback(null, {
                    data: {
                        message: 'Workflow was started',
                    },
                    responseCode,
                });
            }
            didSendResponse = true;
        }
        const nodeExecutionStack = [];
        nodeExecutionStack.push({
            node: workflowStartNode,
            data: {
                main: webhookResultData.workflowData,
            },
            source: null,
        });
        runExecutionData =
            runExecutionData ||
                {
                    startData: {},
                    resultData: {
                        runData: {},
                    },
                    executionData: {
                        contextData: {},
                        nodeExecutionStack,
                        waitingExecution: {},
                    },
                };
        if (destinationNode && runExecutionData.startData) {
            runExecutionData.startData.destinationNode = destinationNode;
        }
        if (executionId !== undefined) {
            runExecutionData.executionData.nodeExecutionStack[0].data.main =
                webhookResultData.workflowData;
        }
        if (Object.keys(runExecutionDataMerge).length !== 0) {
            Object.assign(runExecutionData, runExecutionDataMerge);
        }
        const runData = {
            executionMode,
            executionData: runExecutionData,
            sessionId,
            workflowData,
            userId: user.id,
        };
        let responsePromise;
        if (responseMode === 'responseNode') {
            responsePromise = await (0, n8n_workflow_1.createDeferredPromise)();
            responsePromise
                .promise()
                .then((response) => {
                if (didSendResponse) {
                    return;
                }
                if (Buffer.isBuffer(response.body)) {
                    res.header(response.headers);
                    res.end(response.body);
                    responseCallback(null, {
                        noWebhookResponse: true,
                    });
                }
                else {
                    responseCallback(null, {
                        data: response.body,
                        headers: response.headers,
                        responseCode: response.statusCode,
                    });
                }
                didSendResponse = true;
            })
                .catch(async (error) => {
                n8n_workflow_1.ErrorReporterProxy.error(error);
                n8n_workflow_1.LoggerProxy.error(`Error with Webhook-Response for execution "${executionId}": "${error.message}"`, { executionId, workflowId: workflow.id });
            });
        }
        const workflowRunner = new WorkflowRunner_1.WorkflowRunner();
        executionId = await workflowRunner.run(runData, true, !didSendResponse, executionId, responsePromise);
        n8n_workflow_1.LoggerProxy.verbose(`Started execution of workflow "${workflow.name}" from webhook with execution ID ${executionId}`, { executionId });
        const executePromise = typedi_1.Container.get(ActiveExecutions_1.ActiveExecutions).getPostExecutePromise(executionId);
        executePromise
            .then(async (data) => {
            if (data === undefined) {
                if (!didSendResponse) {
                    responseCallback(null, {
                        data: {
                            message: 'Workflow executed successfully but no data was returned',
                        },
                        responseCode,
                    });
                    didSendResponse = true;
                }
                return undefined;
            }
            if (workflowData.pinData) {
                data.data.resultData.pinData = workflowData.pinData;
            }
            const returnData = WorkflowHelpers.getDataLastExecutedNodeData(data);
            if (data.data.resultData.error || (returnData === null || returnData === void 0 ? void 0 : returnData.error) !== undefined) {
                if (!didSendResponse) {
                    responseCallback(null, {
                        data: {
                            message: 'Error in workflow',
                        },
                        responseCode: 500,
                    });
                }
                didSendResponse = true;
                return data;
            }
            if (responseMode === 'responseNode') {
                if (!didSendResponse) {
                    responseCallback(null, {
                        data: {
                            message: 'Workflow executed successfully',
                        },
                        responseCode,
                    });
                    didSendResponse = true;
                }
                return undefined;
            }
            if (returnData === undefined) {
                if (!didSendResponse) {
                    responseCallback(null, {
                        data: {
                            message: 'Workflow executed successfully but the last node did not return any data',
                        },
                        responseCode,
                    });
                }
                didSendResponse = true;
                return data;
            }
            const additionalKeys = {
                $executionId: executionId,
            };
            if (!didSendResponse) {
                let data;
                if (responseData === 'firstEntryJson') {
                    if (returnData.data.main[0][0] === undefined) {
                        responseCallback(new Error('No item to return got found'), {});
                        didSendResponse = true;
                        return undefined;
                    }
                    data = returnData.data.main[0][0].json;
                    const responsePropertyName = workflow.expression.getSimpleParameterValue(workflowStartNode, webhookData.webhookDescription.responsePropertyName, executionMode, additionalData.timezone, additionalKeys, undefined, undefined);
                    if (responsePropertyName !== undefined) {
                        data = (0, lodash_get_1.default)(data, responsePropertyName);
                    }
                    const responseContentType = workflow.expression.getSimpleParameterValue(workflowStartNode, webhookData.webhookDescription.responseContentType, executionMode, additionalData.timezone, additionalKeys, undefined, undefined);
                    if (responseContentType !== undefined) {
                        res.setHeader('Content-Type', responseContentType);
                        if (data !== null &&
                            data !== undefined &&
                            ['Buffer', 'String'].includes(data.constructor.name)) {
                            res.end(data);
                        }
                        else {
                            res.end(JSON.stringify(data));
                        }
                        responseCallback(null, {
                            noWebhookResponse: true,
                        });
                        didSendResponse = true;
                    }
                }
                else if (responseData === 'firstEntryBinary') {
                    data = returnData.data.main[0][0];
                    if (data === undefined) {
                        responseCallback(new Error('No item was found to return'), {});
                        didSendResponse = true;
                        return undefined;
                    }
                    if (data.binary === undefined) {
                        responseCallback(new Error('No binary data was found to return'), {});
                        didSendResponse = true;
                        return undefined;
                    }
                    const responseBinaryPropertyName = workflow.expression.getSimpleParameterValue(workflowStartNode, webhookData.webhookDescription.responseBinaryPropertyName, executionMode, additionalData.timezone, additionalKeys, undefined, 'data');
                    if (responseBinaryPropertyName === undefined && !didSendResponse) {
                        responseCallback(new Error("No 'responseBinaryPropertyName' is set"), {});
                        didSendResponse = true;
                    }
                    const binaryData = data.binary[responseBinaryPropertyName];
                    if (binaryData === undefined && !didSendResponse) {
                        responseCallback(new Error(`The binary property '${responseBinaryPropertyName}' which should be returned does not exist`), {});
                        didSendResponse = true;
                    }
                    if (!didSendResponse) {
                        res.setHeader('Content-Type', binaryData.mimeType);
                        const binaryDataBuffer = await n8n_core_1.BinaryDataManager.getInstance().retrieveBinaryData(binaryData);
                        res.end(binaryDataBuffer);
                        responseCallback(null, {
                            noWebhookResponse: true,
                        });
                    }
                }
                else if (responseData === 'noData') {
                    data = undefined;
                }
                else {
                    data = [];
                    for (const entry of returnData.data.main[0]) {
                        data.push(entry.json);
                    }
                }
                if (!didSendResponse) {
                    responseCallback(null, {
                        data,
                        responseCode,
                    });
                }
            }
            didSendResponse = true;
            return data;
        })
            .catch((e) => {
            if (!didSendResponse) {
                responseCallback(new Error('There was a problem executing the workflow'), {});
            }
            throw new ResponseHelper.InternalServerError(e.message);
        });
        return executionId;
    }
    catch (e) {
        if (!didSendResponse) {
            responseCallback(new Error('There was a problem executing the workflow'), {});
        }
        throw new ResponseHelper.InternalServerError(e.message);
    }
}
exports.executeWebhook = executeWebhook;
function getWebhookBaseUrl() {
    let urlBaseWebhook = GenericHelpers.getBaseUrl();
    if (process.env.WEBHOOK_TUNNEL_URL !== undefined || process.env.WEBHOOK_URL !== undefined) {
        urlBaseWebhook = process.env.WEBHOOK_TUNNEL_URL || process.env.WEBHOOK_URL;
    }
    if (!urlBaseWebhook.endsWith('/')) {
        urlBaseWebhook += '/';
    }
    return urlBaseWebhook;
}
exports.getWebhookBaseUrl = getWebhookBaseUrl;
//# sourceMappingURL=WebhookHelpers.js.map