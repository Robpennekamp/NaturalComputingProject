"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodesController = void 0;
const constants_1 = require("../constants");
const decorators_1 = require("../decorators");
const ResponseHelper_1 = require("../ResponseHelper");
const helpers_1 = require("../CommunityNodes/helpers");
const packageModel_1 = require("../CommunityNodes/packageModel");
const LoadNodesAndCredentials_1 = require("../LoadNodesAndCredentials");
const InternalHooks_1 = require("../InternalHooks");
const push_1 = require("../push");
const { PACKAGE_NOT_INSTALLED, PACKAGE_NAME_NOT_PROVIDED } = constants_1.RESPONSE_ERROR_MESSAGES;
let NodesController = class NodesController {
    constructor(config, loadNodesAndCredentials, push, internalHooks) {
        this.config = config;
        this.loadNodesAndCredentials = loadNodesAndCredentials;
        this.push = push;
        this.internalHooks = internalHooks;
    }
    checkIfCommunityNodesEnabled(req, res, next) {
        if (this.config.getEnv('executions.mode') === 'queue' && req.method !== 'GET')
            res.status(400).json({
                status: 'error',
                message: 'Package management is disabled when running in "queue" mode',
            });
        else
            next();
    }
    async installPackage(req) {
        const { name } = req.body;
        if (!name) {
            throw new ResponseHelper_1.BadRequestError(PACKAGE_NAME_NOT_PROVIDED);
        }
        let parsed;
        try {
            parsed = (0, helpers_1.parseNpmPackageName)(name);
        }
        catch (error) {
            throw new ResponseHelper_1.BadRequestError(error instanceof Error ? error.message : 'Failed to parse package name');
        }
        if (parsed.packageName === constants_1.STARTER_TEMPLATE_NAME) {
            throw new ResponseHelper_1.BadRequestError([
                `Package "${parsed.packageName}" is only a template`,
                'Please enter an actual package to install',
            ].join('.'));
        }
        const isInstalled = await (0, packageModel_1.isPackageInstalled)(parsed.packageName);
        const hasLoaded = (0, helpers_1.hasPackageLoaded)(name);
        if (isInstalled && hasLoaded) {
            throw new ResponseHelper_1.BadRequestError([
                `Package "${parsed.packageName}" is already installed`,
                'To update it, click the corresponding button in the UI',
            ].join('.'));
        }
        const packageStatus = await (0, helpers_1.checkNpmPackageStatus)(name);
        if (packageStatus.status !== 'OK') {
            throw new ResponseHelper_1.BadRequestError(`Package "${name}" is banned so it cannot be installed`);
        }
        let installedPackage;
        try {
            installedPackage = await this.loadNodesAndCredentials.installNpmModule(parsed.packageName, parsed.version);
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : constants_1.UNKNOWN_FAILURE_REASON;
            void this.internalHooks.onCommunityPackageInstallFinished({
                user: req.user,
                input_string: name,
                package_name: parsed.packageName,
                success: false,
                package_version: parsed.version,
                failure_reason: errorMessage,
            });
            let message = [`Error loading package "${name}" `, errorMessage].join(':');
            if (error instanceof Error && error.cause instanceof Error) {
                message += `\nCause: ${error.cause.message}`;
            }
            const clientError = error instanceof Error ? (0, helpers_1.isClientError)(error) : false;
            throw new (clientError ? ResponseHelper_1.BadRequestError : ResponseHelper_1.InternalServerError)(message);
        }
        if (!hasLoaded)
            (0, helpers_1.removePackageFromMissingList)(name);
        installedPackage.installedNodes.forEach((node) => {
            this.push.send('reloadNodeType', {
                name: node.type,
                version: node.latestVersion,
            });
        });
        void this.internalHooks.onCommunityPackageInstallFinished({
            user: req.user,
            input_string: name,
            package_name: parsed.packageName,
            success: true,
            package_version: parsed.version,
            package_node_names: installedPackage.installedNodes.map((node) => node.name),
            package_author: installedPackage.authorName,
            package_author_email: installedPackage.authorEmail,
        });
        return installedPackage;
    }
    async getInstalledPackages() {
        const installedPackages = await (0, packageModel_1.getAllInstalledPackages)();
        if (installedPackages.length === 0)
            return [];
        let pendingUpdates;
        try {
            const command = ['npm', 'outdated', '--json'].join(' ');
            await (0, helpers_1.executeCommand)(command, { doNotHandleError: true });
        }
        catch (error) {
            if ((0, helpers_1.isNpmError)(error) && error.code === 1) {
                pendingUpdates = JSON.parse(error.stdout);
            }
        }
        let hydratedPackages = (0, helpers_1.matchPackagesWithUpdates)(installedPackages, pendingUpdates);
        try {
            const missingPackages = this.config.get('nodes.packagesMissing');
            if (missingPackages) {
                hydratedPackages = (0, helpers_1.matchMissingPackages)(hydratedPackages, missingPackages);
            }
        }
        catch { }
        return hydratedPackages;
    }
    async uninstallPackage(req) {
        const { name } = req.query;
        if (!name) {
            throw new ResponseHelper_1.BadRequestError(PACKAGE_NAME_NOT_PROVIDED);
        }
        try {
            (0, helpers_1.sanitizeNpmPackageName)(name);
        }
        catch (error) {
            const message = error instanceof Error ? error.message : constants_1.UNKNOWN_FAILURE_REASON;
            throw new ResponseHelper_1.BadRequestError(message);
        }
        const installedPackage = await (0, packageModel_1.findInstalledPackage)(name);
        if (!installedPackage) {
            throw new ResponseHelper_1.BadRequestError(PACKAGE_NOT_INSTALLED);
        }
        try {
            await this.loadNodesAndCredentials.removeNpmModule(name, installedPackage);
        }
        catch (error) {
            const message = [
                `Error removing package "${name}"`,
                error instanceof Error ? error.message : constants_1.UNKNOWN_FAILURE_REASON,
            ].join(':');
            throw new ResponseHelper_1.InternalServerError(message);
        }
        installedPackage.installedNodes.forEach((node) => {
            this.push.send('removeNodeType', {
                name: node.type,
                version: node.latestVersion,
            });
        });
        void this.internalHooks.onCommunityPackageDeleteFinished({
            user: req.user,
            package_name: name,
            package_version: installedPackage.installedVersion,
            package_node_names: installedPackage.installedNodes.map((node) => node.name),
            package_author: installedPackage.authorName,
            package_author_email: installedPackage.authorEmail,
        });
    }
    async updatePackage(req) {
        const { name } = req.body;
        if (!name) {
            throw new ResponseHelper_1.BadRequestError(PACKAGE_NAME_NOT_PROVIDED);
        }
        const previouslyInstalledPackage = await (0, packageModel_1.findInstalledPackage)(name);
        if (!previouslyInstalledPackage) {
            throw new ResponseHelper_1.BadRequestError(PACKAGE_NOT_INSTALLED);
        }
        try {
            const newInstalledPackage = await this.loadNodesAndCredentials.updateNpmModule((0, helpers_1.parseNpmPackageName)(name).packageName, previouslyInstalledPackage);
            previouslyInstalledPackage.installedNodes.forEach((node) => {
                this.push.send('removeNodeType', {
                    name: node.type,
                    version: node.latestVersion,
                });
            });
            newInstalledPackage.installedNodes.forEach((node) => {
                this.push.send('reloadNodeType', {
                    name: node.name,
                    version: node.latestVersion,
                });
            });
            void this.internalHooks.onCommunityPackageUpdateFinished({
                user: req.user,
                package_name: name,
                package_version_current: previouslyInstalledPackage.installedVersion,
                package_version_new: newInstalledPackage.installedVersion,
                package_node_names: newInstalledPackage.installedNodes.map((node) => node.name),
                package_author: newInstalledPackage.authorName,
                package_author_email: newInstalledPackage.authorEmail,
            });
            return newInstalledPackage;
        }
        catch (error) {
            previouslyInstalledPackage.installedNodes.forEach((node) => {
                this.push.send('removeNodeType', {
                    name: node.type,
                    version: node.latestVersion,
                });
            });
            const message = [
                `Error removing package "${name}"`,
                error instanceof Error ? error.message : constants_1.UNKNOWN_FAILURE_REASON,
            ].join(':');
            throw new ResponseHelper_1.InternalServerError(message);
        }
    }
};
__decorate([
    (0, decorators_1.Middleware)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Function]),
    __metadata("design:returntype", void 0)
], NodesController.prototype, "checkIfCommunityNodesEnabled", null);
__decorate([
    (0, decorators_1.Post)('/'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], NodesController.prototype, "installPackage", null);
__decorate([
    (0, decorators_1.Get)('/'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], NodesController.prototype, "getInstalledPackages", null);
__decorate([
    (0, decorators_1.Delete)('/'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], NodesController.prototype, "uninstallPackage", null);
__decorate([
    (0, decorators_1.Patch)('/'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], NodesController.prototype, "updatePackage", null);
NodesController = __decorate([
    (0, decorators_1.Authorized)(['global', 'owner']),
    (0, decorators_1.RestController)('/nodes'),
    __metadata("design:paramtypes", [Object, LoadNodesAndCredentials_1.LoadNodesAndCredentials,
        push_1.Push,
        InternalHooks_1.InternalHooks])
], NodesController);
exports.NodesController = NodesController;
//# sourceMappingURL=nodes.controller.js.map