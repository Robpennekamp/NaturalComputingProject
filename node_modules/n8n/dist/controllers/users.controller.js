"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UsersController = void 0;
const validator_1 = __importDefault(require("validator"));
const typeorm_1 = require("typeorm");
const n8n_workflow_1 = require("n8n-workflow");
const User_1 = require("../databases/entities/User");
const SharedCredentials_1 = require("../databases/entities/SharedCredentials");
const SharedWorkflow_1 = require("../databases/entities/SharedWorkflow");
const decorators_1 = require("../decorators");
const UserManagementHelper_1 = require("../UserManagement/UserManagementHelper");
const jwt_1 = require("../auth/jwt");
const ResponseHelper_1 = require("../ResponseHelper");
const AuthIdentity_1 = require("../databases/entities/AuthIdentity");
const userManagementEnabled_1 = require("../middlewares/userManagementEnabled");
const samlHelpers_1 = require("../sso/saml/samlHelpers");
let UsersController = class UsersController {
    constructor({ config, logger, externalHooks, internalHooks, repositories, activeWorkflowRunner, mailer, postHog, }) {
        this.config = config;
        this.logger = logger;
        this.externalHooks = externalHooks;
        this.internalHooks = internalHooks;
        this.userRepository = repositories.User;
        this.roleRepository = repositories.Role;
        this.sharedCredentialsRepository = repositories.SharedCredentials;
        this.sharedWorkflowRepository = repositories.SharedWorkflow;
        this.activeWorkflowRunner = activeWorkflowRunner;
        this.mailer = mailer;
        this.postHog = postHog;
    }
    async sendEmailInvites(req) {
        if ((0, samlHelpers_1.isSamlLicensedAndEnabled)()) {
            this.logger.debug('SAML is enabled, so users are managed by the Identity Provider and cannot be added through invites');
            throw new ResponseHelper_1.BadRequestError('SAML is enabled, so users are managed by the Identity Provider and cannot be added through invites');
        }
        if (!this.config.getEnv('userManagement.isInstanceOwnerSetUp')) {
            this.logger.debug('Request to send email invite(s) to user(s) failed because the owner account is not set up');
            throw new ResponseHelper_1.BadRequestError('You must set up your own account before inviting others');
        }
        if (!Array.isArray(req.body)) {
            this.logger.debug('Request to send email invite(s) to user(s) failed because the payload is not an array', {
                payload: req.body,
            });
            throw new ResponseHelper_1.BadRequestError('Invalid payload');
        }
        if (!req.body.length)
            return [];
        const createUsers = {};
        req.body.forEach((invite) => {
            if (typeof invite !== 'object' || !invite.email) {
                throw new ResponseHelper_1.BadRequestError('Request to send email invite(s) to user(s) failed because the payload is not an array shaped Array<{ email: string }>');
            }
            if (!validator_1.default.isEmail(invite.email)) {
                this.logger.debug('Invalid email in payload', { invalidEmail: invite.email });
                throw new ResponseHelper_1.BadRequestError(`Request to send email invite(s) to user(s) failed because of an invalid email address: ${invite.email}`);
            }
            createUsers[invite.email.toLowerCase()] = null;
        });
        const role = await this.roleRepository.findGlobalMemberRole();
        if (!role) {
            this.logger.error('Request to send email invite(s) to user(s) failed because no global member role was found in database');
            throw new ResponseHelper_1.InternalServerError('Members role not found in database - inconsistent state');
        }
        const existingUsers = await this.userRepository.find({
            where: { email: (0, typeorm_1.In)(Object.keys(createUsers)) },
        });
        existingUsers.forEach((user) => {
            if (user.password) {
                delete createUsers[user.email];
                return;
            }
            createUsers[user.email] = user.id;
        });
        const usersToSetUp = Object.keys(createUsers).filter((email) => createUsers[email] === null);
        const total = usersToSetUp.length;
        this.logger.debug(total > 1 ? `Creating ${total} user shells...` : 'Creating 1 user shell...');
        try {
            await this.userRepository.manager.transaction(async (transactionManager) => Promise.all(usersToSetUp.map(async (email) => {
                const newUser = Object.assign(new User_1.User(), {
                    email,
                    globalRole: role,
                });
                const savedUser = await transactionManager.save(newUser);
                createUsers[savedUser.email] = savedUser.id;
                return savedUser;
            })));
        }
        catch (error) {
            n8n_workflow_1.ErrorReporterProxy.error(error);
            this.logger.error('Failed to create user shells', { userShells: createUsers });
            throw new ResponseHelper_1.InternalServerError('An error occurred during user creation');
        }
        this.logger.debug('Created user shell(s) successfully', { userId: req.user.id });
        this.logger.verbose(total > 1 ? `${total} user shells created` : '1 user shell created', {
            userShells: createUsers,
        });
        const baseUrl = (0, UserManagementHelper_1.getInstanceBaseUrl)();
        const usersPendingSetup = Object.entries(createUsers).filter(([email, id]) => id && email);
        const emailingResults = await Promise.all(usersPendingSetup.map(async ([email, id]) => {
            if (!id) {
                throw new ResponseHelper_1.InternalServerError('User ID is missing for user with email address');
            }
            const inviteAcceptUrl = (0, UserManagementHelper_1.generateUserInviteUrl)(req.user.id, id);
            const resp = {
                user: {
                    id,
                    email,
                    inviteAcceptUrl,
                    emailSent: false,
                },
            };
            try {
                const result = await this.mailer.invite({
                    email,
                    inviteAcceptUrl,
                    domain: baseUrl,
                });
                if (result.emailSent) {
                    resp.user.emailSent = true;
                    void this.internalHooks.onUserTransactionalEmail({
                        user_id: id,
                        message_type: 'New user invite',
                        public_api: false,
                    });
                }
                void this.internalHooks.onUserInvite({
                    user: req.user,
                    target_user_id: Object.values(createUsers),
                    public_api: false,
                    email_sent: result.emailSent,
                });
            }
            catch (error) {
                if (error instanceof Error) {
                    void this.internalHooks.onEmailFailed({
                        user: req.user,
                        message_type: 'New user invite',
                        public_api: false,
                    });
                    this.logger.error('Failed to send email', {
                        userId: req.user.id,
                        inviteAcceptUrl,
                        domain: baseUrl,
                        email,
                    });
                    resp.error = error.message;
                }
            }
            return resp;
        }));
        await this.externalHooks.run('user.invited', [usersToSetUp]);
        this.logger.debug(usersPendingSetup.length > 1
            ? `Sent ${usersPendingSetup.length} invite emails successfully`
            : 'Sent 1 invite email successfully', { userShells: createUsers });
        return emailingResults;
    }
    async updateUser(req, res) {
        const { id: inviteeId } = req.params;
        const { inviterId, firstName, lastName, password } = req.body;
        if (!inviterId || !inviteeId || !firstName || !lastName || !password) {
            this.logger.debug('Request to fill out a user shell failed because of missing properties in payload', { payload: req.body });
            throw new ResponseHelper_1.BadRequestError('Invalid payload');
        }
        const validPassword = (0, UserManagementHelper_1.validatePassword)(password);
        const users = await this.userRepository.find({
            where: { id: (0, typeorm_1.In)([inviterId, inviteeId]) },
            relations: ['globalRole'],
        });
        if (users.length !== 2) {
            this.logger.debug('Request to fill out a user shell failed because the inviter ID and/or invitee ID were not found in database', {
                inviterId,
                inviteeId,
            });
            throw new ResponseHelper_1.BadRequestError('Invalid payload or URL');
        }
        const invitee = users.find((user) => user.id === inviteeId);
        if (invitee.password) {
            this.logger.debug('Request to fill out a user shell failed because the invite had already been accepted', { inviteeId });
            throw new ResponseHelper_1.BadRequestError('This invite has been accepted already');
        }
        invitee.firstName = firstName;
        invitee.lastName = lastName;
        invitee.password = await (0, UserManagementHelper_1.hashPassword)(validPassword);
        const updatedUser = await this.userRepository.save(invitee);
        await (0, jwt_1.issueCookie)(res, updatedUser);
        void this.internalHooks.onUserSignup(updatedUser, {
            user_type: 'email',
            was_disabled_ldap_user: false,
        });
        await this.externalHooks.run('user.profile.update', [invitee.email, (0, UserManagementHelper_1.sanitizeUser)(invitee)]);
        await this.externalHooks.run('user.password.update', [invitee.email, invitee.password]);
        return (0, UserManagementHelper_1.withFeatureFlags)(this.postHog, (0, UserManagementHelper_1.sanitizeUser)(updatedUser));
    }
    async listUsers(req) {
        const users = await this.userRepository.find({ relations: ['globalRole', 'authIdentities'] });
        return users.map((user) => (0, UserManagementHelper_1.addInviteLinkToUser)((0, UserManagementHelper_1.sanitizeUser)(user, ['personalizationAnswers']), req.user.id));
    }
    async deleteUser(req) {
        const { id: idToDelete } = req.params;
        if (req.user.id === idToDelete) {
            this.logger.debug('Request to delete a user failed because it attempted to delete the requesting user', { userId: req.user.id });
            throw new ResponseHelper_1.BadRequestError('Cannot delete your own user');
        }
        const { transferId } = req.query;
        if (transferId === idToDelete) {
            throw new ResponseHelper_1.BadRequestError('Request to delete a user failed because the user to delete and the transferee are the same user');
        }
        const users = await this.userRepository.find({
            where: { id: (0, typeorm_1.In)([transferId, idToDelete]) },
        });
        if (!users.length || (transferId && users.length !== 2)) {
            throw new ResponseHelper_1.NotFoundError('Request to delete a user failed because the ID of the user to delete and/or the ID of the transferee were not found in DB');
        }
        const userToDelete = users.find((user) => user.id === req.params.id);
        const telemetryData = {
            user_id: req.user.id,
            target_user_old_status: userToDelete.isPending ? 'invited' : 'active',
            target_user_id: idToDelete,
        };
        telemetryData.migration_strategy = transferId ? 'transfer_data' : 'delete_data';
        if (transferId) {
            telemetryData.migration_user_id = transferId;
        }
        const [workflowOwnerRole, credentialOwnerRole] = await Promise.all([
            this.roleRepository.findWorkflowOwnerRole(),
            this.roleRepository.findCredentialOwnerRole(),
        ]);
        if (transferId) {
            const transferee = users.find((user) => user.id === transferId);
            await this.userRepository.manager.transaction(async (transactionManager) => {
                const sharedWorkflowIds = await transactionManager
                    .getRepository(SharedWorkflow_1.SharedWorkflow)
                    .find({
                    select: ['workflowId'],
                    where: { userId: userToDelete.id, roleId: workflowOwnerRole === null || workflowOwnerRole === void 0 ? void 0 : workflowOwnerRole.id },
                })
                    .then((sharedWorkflows) => sharedWorkflows.map(({ workflowId }) => workflowId));
                await transactionManager.delete(SharedWorkflow_1.SharedWorkflow, {
                    user: transferee,
                    workflowId: (0, typeorm_1.In)(sharedWorkflowIds),
                });
                await transactionManager.update(SharedWorkflow_1.SharedWorkflow, { user: userToDelete, role: workflowOwnerRole }, { user: transferee });
                const sharedCredentialIds = await transactionManager
                    .getRepository(SharedCredentials_1.SharedCredentials)
                    .find({
                    select: ['credentialsId'],
                    where: { userId: userToDelete.id, roleId: credentialOwnerRole === null || credentialOwnerRole === void 0 ? void 0 : credentialOwnerRole.id },
                })
                    .then((sharedCredentials) => sharedCredentials.map(({ credentialsId }) => credentialsId));
                await transactionManager.delete(SharedCredentials_1.SharedCredentials, {
                    user: transferee,
                    credentialsId: (0, typeorm_1.In)(sharedCredentialIds),
                });
                await transactionManager.update(SharedCredentials_1.SharedCredentials, { user: userToDelete, role: credentialOwnerRole }, { user: transferee });
                await transactionManager.delete(AuthIdentity_1.AuthIdentity, { userId: userToDelete.id });
                await transactionManager.delete(User_1.User, { id: userToDelete.id });
            });
            void this.internalHooks.onUserDeletion({
                user: req.user,
                telemetryData,
                publicApi: false,
            });
            await this.externalHooks.run('user.deleted', [(0, UserManagementHelper_1.sanitizeUser)(userToDelete)]);
            return { success: true };
        }
        const [ownedSharedWorkflows, ownedSharedCredentials] = await Promise.all([
            this.sharedWorkflowRepository.find({
                relations: ['workflow'],
                where: { userId: userToDelete.id, roleId: workflowOwnerRole === null || workflowOwnerRole === void 0 ? void 0 : workflowOwnerRole.id },
            }),
            this.sharedCredentialsRepository.find({
                relations: ['credentials'],
                where: { userId: userToDelete.id, roleId: credentialOwnerRole === null || credentialOwnerRole === void 0 ? void 0 : credentialOwnerRole.id },
            }),
        ]);
        await this.userRepository.manager.transaction(async (transactionManager) => {
            const ownedWorkflows = await Promise.all(ownedSharedWorkflows.map(async ({ workflow }) => {
                if (workflow.active) {
                    await this.activeWorkflowRunner.remove(workflow.id);
                }
                return workflow;
            }));
            await transactionManager.remove(ownedWorkflows);
            await transactionManager.remove(ownedSharedCredentials.map(({ credentials }) => credentials));
            await transactionManager.delete(AuthIdentity_1.AuthIdentity, { userId: userToDelete.id });
            await transactionManager.delete(User_1.User, { id: userToDelete.id });
        });
        void this.internalHooks.onUserDeletion({
            user: req.user,
            telemetryData,
            publicApi: false,
        });
        await this.externalHooks.run('user.deleted', [(0, UserManagementHelper_1.sanitizeUser)(userToDelete)]);
        return { success: true };
    }
    async reinviteUser(req) {
        const { id: idToReinvite } = req.params;
        if (!(0, UserManagementHelper_1.isEmailSetUp)()) {
            this.logger.error('Request to reinvite a user failed because email sending was not set up');
            throw new ResponseHelper_1.InternalServerError('Email sending must be set up in order to invite other users');
        }
        const reinvitee = await this.userRepository.findOneBy({ id: idToReinvite });
        if (!reinvitee) {
            this.logger.debug('Request to reinvite a user failed because the ID of the reinvitee was not found in database');
            throw new ResponseHelper_1.NotFoundError('Could not find user');
        }
        if (reinvitee.password) {
            this.logger.debug('Request to reinvite a user failed because the invite had already been accepted', { userId: reinvitee.id });
            throw new ResponseHelper_1.BadRequestError('User has already accepted the invite');
        }
        const baseUrl = (0, UserManagementHelper_1.getInstanceBaseUrl)();
        const inviteAcceptUrl = `${baseUrl}/signup?inviterId=${req.user.id}&inviteeId=${reinvitee.id}`;
        try {
            const result = await this.mailer.invite({
                email: reinvitee.email,
                inviteAcceptUrl,
                domain: baseUrl,
            });
            if (result.emailSent) {
                void this.internalHooks.onUserReinvite({
                    user: req.user,
                    target_user_id: reinvitee.id,
                    public_api: false,
                });
                void this.internalHooks.onUserTransactionalEmail({
                    user_id: reinvitee.id,
                    message_type: 'Resend invite',
                    public_api: false,
                });
            }
        }
        catch (error) {
            void this.internalHooks.onEmailFailed({
                user: reinvitee,
                message_type: 'Resend invite',
                public_api: false,
            });
            this.logger.error('Failed to send email', {
                email: reinvitee.email,
                inviteAcceptUrl,
                domain: baseUrl,
            });
            throw new ResponseHelper_1.InternalServerError(`Failed to send email to ${reinvitee.email}`);
        }
        return { success: true };
    }
};
__decorate([
    (0, decorators_1.Post)('/', { middlewares: [userManagementEnabled_1.userManagementEnabledMiddleware] }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "sendEmailInvites", null);
__decorate([
    (0, decorators_1.NoAuthRequired)(),
    (0, decorators_1.Post)('/:id'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "updateUser", null);
__decorate([
    (0, decorators_1.Authorized)('any'),
    (0, decorators_1.Get)('/'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "listUsers", null);
__decorate([
    (0, decorators_1.Delete)('/:id'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "deleteUser", null);
__decorate([
    (0, decorators_1.Post)('/:id/reinvite'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "reinviteUser", null);
UsersController = __decorate([
    (0, decorators_1.Authorized)(['global', 'owner']),
    (0, decorators_1.RestController)('/users'),
    __metadata("design:paramtypes", [Object])
], UsersController);
exports.UsersController = UsersController;
//# sourceMappingURL=users.controller.js.map