"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PasswordResetController = void 0;
const typeorm_1 = require("typeorm");
const uuid_1 = require("uuid");
const validator_1 = __importDefault(require("validator"));
const decorators_1 = require("../decorators");
const ResponseHelper_1 = require("../ResponseHelper");
const UserManagementHelper_1 = require("../UserManagement/UserManagementHelper");
const jwt_1 = require("../auth/jwt");
const helpers_1 = require("../Ldap/helpers");
const ssoHelpers_1 = require("../sso/ssoHelpers");
let PasswordResetController = class PasswordResetController {
    constructor({ config, logger, externalHooks, internalHooks, mailer, repositories, }) {
        this.config = config;
        this.logger = logger;
        this.externalHooks = externalHooks;
        this.internalHooks = internalHooks;
        this.mailer = mailer;
        this.userRepository = repositories.User;
    }
    async forgotPassword(req) {
        var _a;
        if (this.config.getEnv('userManagement.emails.mode') === '') {
            this.logger.debug('Request to send password reset email failed because emailing was not set up');
            throw new ResponseHelper_1.InternalServerError('Email sending must be set up in order to request a password reset email');
        }
        const { email } = req.body;
        if (!email) {
            this.logger.debug('Request to send password reset email failed because of missing email in payload', { payload: req.body });
            throw new ResponseHelper_1.BadRequestError('Email is mandatory');
        }
        if (!validator_1.default.isEmail(email)) {
            this.logger.debug('Request to send password reset email failed because of invalid email in payload', { invalidEmail: email });
            throw new ResponseHelper_1.BadRequestError('Invalid email address');
        }
        const user = await this.userRepository.findOne({
            where: {
                email,
                password: (0, typeorm_1.Not)((0, typeorm_1.IsNull)()),
            },
            relations: ['authIdentities', 'globalRole'],
        });
        if ((0, ssoHelpers_1.isSamlCurrentAuthenticationMethod)() && (user === null || user === void 0 ? void 0 : user.globalRole.name) !== 'owner') {
            this.logger.debug('Request to send password reset email failed because login is handled by SAML');
            throw new ResponseHelper_1.UnauthorizedError('Login is handled by SAML. Please contact your Identity Provider to reset your password.');
        }
        const ldapIdentity = (_a = user === null || user === void 0 ? void 0 : user.authIdentities) === null || _a === void 0 ? void 0 : _a.find((i) => i.providerType === 'ldap');
        if (!(user === null || user === void 0 ? void 0 : user.password) || (ldapIdentity && user.disabled)) {
            this.logger.debug('Request to send password reset email failed because no user was found for the provided email', { invalidEmail: email });
            return;
        }
        if ((0, helpers_1.isLdapEnabled)() && ldapIdentity) {
            throw new ResponseHelper_1.UnprocessableRequestError('forgotPassword.ldapUserPasswordResetUnavailable');
        }
        user.resetPasswordToken = (0, uuid_1.v4)();
        const { id, firstName, lastName, resetPasswordToken } = user;
        const resetPasswordTokenExpiration = Math.floor(Date.now() / 1000) + 7200;
        await this.userRepository.update(id, { resetPasswordToken, resetPasswordTokenExpiration });
        const baseUrl = (0, UserManagementHelper_1.getInstanceBaseUrl)();
        const url = new URL(`${baseUrl}/change-password`);
        url.searchParams.append('userId', id);
        url.searchParams.append('token', resetPasswordToken);
        try {
            await this.mailer.passwordReset({
                email,
                firstName,
                lastName,
                passwordResetUrl: url.toString(),
                domain: baseUrl,
            });
        }
        catch (error) {
            void this.internalHooks.onEmailFailed({
                user,
                message_type: 'Reset password',
                public_api: false,
            });
            if (error instanceof Error) {
                throw new ResponseHelper_1.InternalServerError(`Please contact your administrator: ${error.message}`);
            }
        }
        this.logger.info('Sent password reset email successfully', { userId: user.id, email });
        void this.internalHooks.onUserTransactionalEmail({
            user_id: id,
            message_type: 'Reset password',
            public_api: false,
        });
        void this.internalHooks.onUserPasswordResetRequestClick({ user });
    }
    async resolvePasswordToken(req) {
        const { token: resetPasswordToken, userId: id } = req.query;
        if (!resetPasswordToken || !id) {
            this.logger.debug('Request to resolve password token failed because of missing password reset token or user ID in query string', {
                queryString: req.query,
            });
            throw new ResponseHelper_1.BadRequestError('');
        }
        const currentTimestamp = Math.floor(Date.now() / 1000);
        const user = await this.userRepository.findOneBy({
            id,
            resetPasswordToken,
            resetPasswordTokenExpiration: (0, typeorm_1.MoreThanOrEqual)(currentTimestamp),
        });
        if (!user) {
            this.logger.debug('Request to resolve password token failed because no user was found for the provided user ID and reset password token', {
                userId: id,
                resetPasswordToken,
            });
            throw new ResponseHelper_1.NotFoundError('');
        }
        this.logger.info('Reset-password token resolved successfully', { userId: id });
        void this.internalHooks.onUserPasswordResetEmailClick({ user });
    }
    async changePassword(req, res) {
        var _a;
        const { token: resetPasswordToken, userId, password } = req.body;
        if (!resetPasswordToken || !userId || !password) {
            this.logger.debug('Request to change password failed because of missing user ID or password or reset password token in payload', {
                payload: req.body,
            });
            throw new ResponseHelper_1.BadRequestError('Missing user ID or password or reset password token');
        }
        const validPassword = (0, UserManagementHelper_1.validatePassword)(password);
        const currentTimestamp = Math.floor(Date.now() / 1000);
        const user = await this.userRepository.findOne({
            where: {
                id: userId,
                resetPasswordToken,
                resetPasswordTokenExpiration: (0, typeorm_1.MoreThanOrEqual)(currentTimestamp),
            },
            relations: ['authIdentities'],
        });
        if (!user) {
            this.logger.debug('Request to resolve password token failed because no user was found for the provided user ID and reset password token', {
                userId,
                resetPasswordToken,
            });
            throw new ResponseHelper_1.NotFoundError('');
        }
        const passwordHash = await (0, UserManagementHelper_1.hashPassword)(validPassword);
        await this.userRepository.update(userId, {
            password: passwordHash,
            resetPasswordToken: null,
            resetPasswordTokenExpiration: null,
        });
        this.logger.info('User password updated successfully', { userId });
        await (0, jwt_1.issueCookie)(res, user);
        void this.internalHooks.onUserUpdate({
            user,
            fields_changed: ['password'],
        });
        const ldapIdentity = (_a = user === null || user === void 0 ? void 0 : user.authIdentities) === null || _a === void 0 ? void 0 : _a.find((i) => i.providerType === 'ldap');
        if (ldapIdentity) {
            void this.internalHooks.onUserSignup(user, {
                user_type: 'email',
                was_disabled_ldap_user: true,
            });
        }
        await this.externalHooks.run('user.password.update', [user.email, passwordHash]);
    }
};
__decorate([
    (0, decorators_1.Post)('/forgot-password'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], PasswordResetController.prototype, "forgotPassword", null);
__decorate([
    (0, decorators_1.Get)('/resolve-password-token'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], PasswordResetController.prototype, "resolvePasswordToken", null);
__decorate([
    (0, decorators_1.Post)('/change-password'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], PasswordResetController.prototype, "changePassword", null);
PasswordResetController = __decorate([
    (0, decorators_1.RestController)(),
    __metadata("design:paramtypes", [Object])
], PasswordResetController);
exports.PasswordResetController = PasswordResetController;
//# sourceMappingURL=passwordReset.controller.js.map