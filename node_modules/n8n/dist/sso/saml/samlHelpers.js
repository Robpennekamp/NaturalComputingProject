"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isConnectionTestRequest = exports.getMappedSamlAttributesFromFlowResult = exports.updateUserFromSamlAttributes = exports.createUserFromSamlAttributes = exports.generatePassword = exports.isSamlPreferences = exports.isSamlLicensedAndEnabled = exports.isSamlLicensed = exports.setSamlLoginLabel = exports.setSamlLoginEnabled = exports.getSamlLoginLabel = exports.isSamlLoginEnabled = void 0;
const typedi_1 = require("typedi");
const config_1 = __importDefault(require("../../config"));
const Db = __importStar(require("../../Db"));
const AuthIdentity_1 = require("../../databases/entities/AuthIdentity");
const User_1 = require("../../databases/entities/User");
const repositories_1 = require("../../databases/repositories");
const License_1 = require("../../License");
const ResponseHelper_1 = require("../../ResponseHelper");
const UserManagementHelper_1 = require("../../UserManagement/UserManagementHelper");
const constants_1 = require("./constants");
const ssoHelpers_1 = require("../ssoHelpers");
const serviceProvider_ee_1 = require("./serviceProvider.ee");
function isSamlLoginEnabled() {
    return config_1.default.getEnv(constants_1.SAML_LOGIN_ENABLED);
}
exports.isSamlLoginEnabled = isSamlLoginEnabled;
function getSamlLoginLabel() {
    return config_1.default.getEnv(constants_1.SAML_LOGIN_LABEL);
}
exports.getSamlLoginLabel = getSamlLoginLabel;
async function setSamlLoginEnabled(enabled) {
    if ((0, ssoHelpers_1.isEmailCurrentAuthenticationMethod)() || (0, ssoHelpers_1.isSamlCurrentAuthenticationMethod)()) {
        if (enabled) {
            config_1.default.set(constants_1.SAML_LOGIN_ENABLED, true);
            await (0, ssoHelpers_1.setCurrentAuthenticationMethod)('saml');
        }
        else if (!enabled) {
            config_1.default.set(constants_1.SAML_LOGIN_ENABLED, false);
            await (0, ssoHelpers_1.setCurrentAuthenticationMethod)('email');
        }
    }
    else {
        throw new ResponseHelper_1.InternalServerError(`Cannot switch SAML login enabled state when an authentication method other than email or saml is active (current: ${(0, ssoHelpers_1.getCurrentAuthenticationMethod)()})`);
    }
}
exports.setSamlLoginEnabled = setSamlLoginEnabled;
function setSamlLoginLabel(label) {
    config_1.default.set(constants_1.SAML_LOGIN_LABEL, label);
}
exports.setSamlLoginLabel = setSamlLoginLabel;
function isSamlLicensed() {
    const license = typedi_1.Container.get(License_1.License);
    return (0, UserManagementHelper_1.isUserManagementEnabled)() && license.isSamlEnabled();
}
exports.isSamlLicensed = isSamlLicensed;
function isSamlLicensedAndEnabled() {
    return isSamlLoginEnabled() && isSamlLicensed() && (0, ssoHelpers_1.isSamlCurrentAuthenticationMethod)();
}
exports.isSamlLicensedAndEnabled = isSamlLicensedAndEnabled;
const isSamlPreferences = (candidate) => {
    const o = candidate;
    return (typeof o === 'object' &&
        typeof o.metadata === 'string' &&
        typeof o.mapping === 'object' &&
        o.mapping !== null &&
        o.loginEnabled !== undefined);
};
exports.isSamlPreferences = isSamlPreferences;
function generatePassword() {
    const length = 18;
    const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    const charsetNoNumbers = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const randomNumber = Math.floor(Math.random() * 10);
    const randomUpper = charset.charAt(Math.floor(Math.random() * charsetNoNumbers.length));
    const randomNumberPosition = Math.floor(Math.random() * length);
    const randomUpperPosition = Math.floor(Math.random() * length);
    let password = '';
    for (let i = 0, n = charset.length; i < length; ++i) {
        password += charset.charAt(Math.floor(Math.random() * n));
    }
    password =
        password.substring(0, randomNumberPosition) +
            randomNumber.toString() +
            password.substring(randomNumberPosition);
    password =
        password.substring(0, randomUpperPosition) +
            randomUpper +
            password.substring(randomUpperPosition);
    return password;
}
exports.generatePassword = generatePassword;
async function createUserFromSamlAttributes(attributes) {
    const user = new User_1.User();
    const authIdentity = new AuthIdentity_1.AuthIdentity();
    user.email = attributes.email;
    user.firstName = attributes.firstName;
    user.lastName = attributes.lastName;
    user.globalRole = await typedi_1.Container.get(repositories_1.RoleRepository).findGlobalMemberRoleOrFail();
    user.password = await (0, UserManagementHelper_1.hashPassword)(generatePassword());
    authIdentity.providerId = attributes.userPrincipalName;
    authIdentity.providerType = 'saml';
    authIdentity.user = user;
    const resultAuthIdentity = await Db.collections.AuthIdentity.save(authIdentity);
    if (!resultAuthIdentity)
        throw new ResponseHelper_1.AuthError('Could not create AuthIdentity');
    user.authIdentities = [authIdentity];
    const resultUser = await Db.collections.User.save(user);
    if (!resultUser)
        throw new ResponseHelper_1.AuthError('Could not create User');
    return resultUser;
}
exports.createUserFromSamlAttributes = createUserFromSamlAttributes;
async function updateUserFromSamlAttributes(user, attributes) {
    if (!attributes.email)
        throw new ResponseHelper_1.AuthError('Email is required to update user');
    if (!user)
        throw new ResponseHelper_1.AuthError('User not found');
    let samlAuthIdentity = user === null || user === void 0 ? void 0 : user.authIdentities.find((e) => e.providerType === 'saml');
    if (!samlAuthIdentity) {
        samlAuthIdentity = new AuthIdentity_1.AuthIdentity();
        samlAuthIdentity.providerId = attributes.userPrincipalName;
        samlAuthIdentity.providerType = 'saml';
        samlAuthIdentity.user = user;
        user.authIdentities.push(samlAuthIdentity);
    }
    else {
        samlAuthIdentity.providerId = attributes.userPrincipalName;
    }
    await Db.collections.AuthIdentity.save(samlAuthIdentity);
    user.firstName = attributes.firstName;
    user.lastName = attributes.lastName;
    const resultUser = await Db.collections.User.save(user);
    if (!resultUser)
        throw new ResponseHelper_1.AuthError('Could not create User');
    return resultUser;
}
exports.updateUserFromSamlAttributes = updateUserFromSamlAttributes;
function getMappedSamlAttributesFromFlowResult(flowResult, attributeMapping) {
    var _a;
    const result = {
        attributes: undefined,
        missingAttributes: [],
    };
    if ((_a = flowResult === null || flowResult === void 0 ? void 0 : flowResult.extract) === null || _a === void 0 ? void 0 : _a.attributes) {
        const attributes = flowResult.extract.attributes;
        const email = attributes[attributeMapping.email];
        const firstName = attributes[attributeMapping.firstName];
        const lastName = attributes[attributeMapping.lastName];
        const userPrincipalName = attributes[attributeMapping.userPrincipalName];
        result.attributes = {
            email,
            firstName,
            lastName,
            userPrincipalName,
        };
        if (!email)
            result.missingAttributes.push(attributeMapping.email);
        if (!userPrincipalName)
            result.missingAttributes.push(attributeMapping.userPrincipalName);
        if (!firstName)
            result.missingAttributes.push(attributeMapping.firstName);
        if (!lastName)
            result.missingAttributes.push(attributeMapping.lastName);
    }
    return result;
}
exports.getMappedSamlAttributesFromFlowResult = getMappedSamlAttributesFromFlowResult;
function isConnectionTestRequest(req) {
    return req.body.RelayState === (0, serviceProvider_ee_1.getServiceProviderConfigTestReturnUrl)();
}
exports.isConnectionTestRequest = isConnectionTestRequest;
//# sourceMappingURL=samlHelpers.js.map