"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EEWorkflowController = void 0;
const express_1 = __importDefault(require("express"));
const uuid_1 = require("uuid");
const Db = __importStar(require("../Db"));
const ResponseHelper = __importStar(require("../ResponseHelper"));
const WorkflowHelpers = __importStar(require("../WorkflowHelpers"));
const config_1 = __importDefault(require("../config"));
const WorkflowEntity_1 = require("../databases/entities/WorkflowEntity");
const GenericHelpers_1 = require("../GenericHelpers");
const UserManagementHelper_1 = require("../UserManagement/UserManagementHelper");
const workflows_services_ee_1 = require("./workflows.services.ee");
const ExternalHooks_1 = require("../ExternalHooks");
const SharedWorkflow_1 = require("../databases/entities/SharedWorkflow");
const repositories_1 = require("../databases/repositories");
const n8n_workflow_1 = require("n8n-workflow");
const TagHelpers = __importStar(require("../TagHelpers"));
const credentials_service_ee_1 = require("../credentials/credentials.service.ee");
const GenericHelpers = __importStar(require("../GenericHelpers"));
const typeorm_1 = require("typeorm");
const typedi_1 = require("typedi");
const InternalHooks_1 = require("../InternalHooks");
exports.EEWorkflowController = express_1.default.Router();
exports.EEWorkflowController.use((req, res, next) => {
    if (!(0, UserManagementHelper_1.isSharingEnabled)()) {
        next('router');
        return;
    }
    next();
});
exports.EEWorkflowController.put('/:workflowId/share', ResponseHelper.send(async (req) => {
    const { workflowId } = req.params;
    const { shareWithIds } = req.body;
    if (!Array.isArray(shareWithIds) ||
        !shareWithIds.every((userId) => typeof userId === 'string')) {
        throw new ResponseHelper.BadRequestError('Bad request');
    }
    const { ownsWorkflow, workflow } = await workflows_services_ee_1.EEWorkflowsService.isOwned(req.user, workflowId);
    if (!ownsWorkflow || !workflow) {
        throw new ResponseHelper.UnauthorizedError('Forbidden');
    }
    let newShareeIds = [];
    await Db.transaction(async (trx) => {
        await workflows_services_ee_1.EEWorkflowsService.pruneSharings(trx, workflowId, [req.user.id, ...shareWithIds]);
        const sharings = await workflows_services_ee_1.EEWorkflowsService.getSharings(trx, workflowId);
        newShareeIds = (0, UserManagementHelper_1.rightDiff)([sharings, (sharing) => sharing.userId], [shareWithIds, (shareeId) => shareeId]);
        if (newShareeIds.length) {
            await workflows_services_ee_1.EEWorkflowsService.share(trx, workflow, newShareeIds);
        }
    });
    void typedi_1.Container.get(InternalHooks_1.InternalHooks).onWorkflowSharingUpdate(workflowId, req.user.id, shareWithIds);
}));
exports.EEWorkflowController.get('/:id(\\d+)', ResponseHelper.send(async (req) => {
    var _a;
    const { id: workflowId } = req.params;
    const relations = ['shared', 'shared.user', 'shared.role'];
    if (!config_1.default.getEnv('workflowTagsDisabled')) {
        relations.push('tags');
    }
    const workflow = await workflows_services_ee_1.EEWorkflowsService.get({ id: workflowId }, { relations });
    if (!workflow) {
        throw new ResponseHelper.NotFoundError(`Workflow with ID "${workflowId}" does not exist`);
    }
    const userSharing = (_a = workflow.shared) === null || _a === void 0 ? void 0 : _a.find((shared) => shared.user.id === req.user.id);
    if (!userSharing && req.user.globalRole.name !== 'owner') {
        throw new ResponseHelper.UnauthorizedError('You do not have permission to access this workflow. Ask the owner to share it with you');
    }
    workflows_services_ee_1.EEWorkflowsService.addOwnerAndSharings(workflow);
    await workflows_services_ee_1.EEWorkflowsService.addCredentialsToWorkflow(workflow, req.user);
    return workflow;
}));
exports.EEWorkflowController.post('/', ResponseHelper.send(async (req) => {
    delete req.body.id;
    const newWorkflow = new WorkflowEntity_1.WorkflowEntity();
    Object.assign(newWorkflow, req.body);
    newWorkflow.versionId = (0, uuid_1.v4)();
    await (0, GenericHelpers_1.validateEntity)(newWorkflow);
    await typedi_1.Container.get(ExternalHooks_1.ExternalHooks).run('workflow.create', [newWorkflow]);
    const { tags: tagIds } = req.body;
    if ((tagIds === null || tagIds === void 0 ? void 0 : tagIds.length) && !config_1.default.getEnv('workflowTagsDisabled')) {
        newWorkflow.tags = await Db.collections.Tag.find({
            select: ['id', 'name'],
            where: {
                id: (0, typeorm_1.In)(tagIds),
            },
        });
    }
    await WorkflowHelpers.replaceInvalidCredentials(newWorkflow);
    WorkflowHelpers.addNodeIds(newWorkflow);
    const allCredentials = await credentials_service_ee_1.EECredentialsService.getAll(req.user);
    try {
        workflows_services_ee_1.EEWorkflowsService.validateCredentialPermissionsToUser(newWorkflow, allCredentials);
    }
    catch (error) {
        throw new ResponseHelper.BadRequestError('The workflow you are trying to save contains credentials that are not shared with you');
    }
    let savedWorkflow;
    await Db.transaction(async (transactionManager) => {
        savedWorkflow = await transactionManager.save(newWorkflow);
        const role = await typedi_1.Container.get(repositories_1.RoleRepository).findWorkflowOwnerRoleOrFail();
        const newSharedWorkflow = new SharedWorkflow_1.SharedWorkflow();
        Object.assign(newSharedWorkflow, {
            role,
            user: req.user,
            workflow: savedWorkflow,
        });
        await transactionManager.save(newSharedWorkflow);
    });
    if (!savedWorkflow) {
        n8n_workflow_1.LoggerProxy.error('Failed to create workflow', { userId: req.user.id });
        throw new ResponseHelper.InternalServerError('An error occurred while saving your workflow. Please try again.');
    }
    if (tagIds && !config_1.default.getEnv('workflowTagsDisabled') && savedWorkflow.tags) {
        savedWorkflow.tags = TagHelpers.sortByRequestOrder(savedWorkflow.tags, {
            requestOrder: tagIds,
        });
    }
    await typedi_1.Container.get(ExternalHooks_1.ExternalHooks).run('workflow.afterCreate', [savedWorkflow]);
    void typedi_1.Container.get(InternalHooks_1.InternalHooks).onWorkflowCreated(req.user, newWorkflow, false);
    return savedWorkflow;
}));
exports.EEWorkflowController.get('/', ResponseHelper.send(async (req) => {
    const [workflows, workflowOwnerRole] = await Promise.all([
        workflows_services_ee_1.EEWorkflowsService.getMany(req.user, req.query.filter),
        typedi_1.Container.get(repositories_1.RoleRepository).findWorkflowOwnerRoleOrFail(),
    ]);
    return workflows.map((workflow) => {
        workflows_services_ee_1.EEWorkflowsService.addOwnerId(workflow, workflowOwnerRole);
        return workflow;
    });
}));
exports.EEWorkflowController.patch('/:id(\\d+)', ResponseHelper.send(async (req) => {
    const { id: workflowId } = req.params;
    const forceSave = req.query.forceSave === 'true';
    const updateData = new WorkflowEntity_1.WorkflowEntity();
    const { tags, ...rest } = req.body;
    Object.assign(updateData, rest);
    const safeWorkflow = await workflows_services_ee_1.EEWorkflowsService.preventTampering(updateData, workflowId, req.user);
    const updatedWorkflow = await workflows_services_ee_1.EEWorkflowsService.update(req.user, safeWorkflow, workflowId, tags, forceSave);
    return updatedWorkflow;
}));
exports.EEWorkflowController.post('/run', ResponseHelper.send(async (req) => {
    const workflow = new WorkflowEntity_1.WorkflowEntity();
    Object.assign(workflow, req.body.workflowData);
    if (workflow.id !== undefined) {
        const safeWorkflow = await workflows_services_ee_1.EEWorkflowsService.preventTampering(workflow, workflow.id, req.user);
        req.body.workflowData.nodes = safeWorkflow.nodes;
    }
    return workflows_services_ee_1.EEWorkflowsService.runManually(req.body, req.user, GenericHelpers.getSessionId(req));
}));
//# sourceMappingURL=workflows.controller.ee.js.map