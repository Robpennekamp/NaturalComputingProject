"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EEWorkflowsService = void 0;
const typeorm_1 = require("typeorm");
const Db = __importStar(require("../Db"));
const ResponseHelper = __importStar(require("../ResponseHelper"));
const WorkflowHelpers = __importStar(require("../WorkflowHelpers"));
const SharedWorkflow_1 = require("../databases/entities/SharedWorkflow");
const WorkflowEntity_1 = require("../databases/entities/WorkflowEntity");
const role_service_1 = require("../role/role.service");
const user_service_1 = require("../user/user.service");
const workflows_services_1 = require("./workflows.services");
const credentials_service_ee_1 = require("../credentials/credentials.service.ee");
const WorkflowHelpers_1 = require("../WorkflowHelpers");
const n8n_workflow_1 = require("n8n-workflow");
class EEWorkflowsService extends workflows_services_1.WorkflowsService {
    static async getWorkflowIdsForUser(user) {
        return (0, WorkflowHelpers_1.getSharedWorkflowIds)(user);
    }
    static async isOwned(user, workflowId) {
        const sharing = await this.getSharing(user, workflowId, ['workflow', 'role'], {
            allowGlobalOwner: false,
        });
        if (!sharing || sharing.role.name !== 'owner')
            return { ownsWorkflow: false };
        const { workflow } = sharing;
        return { ownsWorkflow: true, workflow };
    }
    static async getSharings(transaction, workflowId) {
        var _a;
        const workflow = await transaction.findOne(WorkflowEntity_1.WorkflowEntity, {
            where: { id: workflowId },
            relations: ['shared'],
        });
        return (_a = workflow === null || workflow === void 0 ? void 0 : workflow.shared) !== null && _a !== void 0 ? _a : [];
    }
    static async pruneSharings(transaction, workflowId, userIds) {
        return transaction.delete(SharedWorkflow_1.SharedWorkflow, {
            workflowId,
            userId: (0, typeorm_1.Not)((0, typeorm_1.In)(userIds)),
        });
    }
    static async share(transaction, workflow, shareWithIds) {
        const [users, role] = await Promise.all([
            user_service_1.UserService.getByIds(transaction, shareWithIds),
            role_service_1.RoleService.trxGet(transaction, { scope: 'workflow', name: 'editor' }),
        ]);
        const newSharedWorkflows = users.reduce((acc, user) => {
            if (user.isPending) {
                return acc;
            }
            const entity = {
                workflowId: workflow.id,
                userId: user.id,
                roleId: role === null || role === void 0 ? void 0 : role.id,
            };
            acc.push(Db.collections.SharedWorkflow.create(entity));
            return acc;
        }, []);
        return transaction.save(newSharedWorkflows);
    }
    static addOwnerId(workflow, workflowOwnerRole) {
        var _a, _b;
        const ownerId = (_b = (_a = workflow.shared) === null || _a === void 0 ? void 0 : _a.find(({ roleId }) => String(roleId) === workflowOwnerRole.id)) === null || _b === void 0 ? void 0 : _b.userId;
        workflow.ownedBy = ownerId ? { id: ownerId } : null;
        delete workflow.shared;
    }
    static addOwnerAndSharings(workflow) {
        var _a;
        workflow.ownedBy = null;
        workflow.sharedWith = [];
        if (!workflow.usedCredentials) {
            workflow.usedCredentials = [];
        }
        (_a = workflow.shared) === null || _a === void 0 ? void 0 : _a.forEach(({ user, role }) => {
            var _a;
            const { id, email, firstName, lastName } = user;
            if (role.name === 'owner') {
                workflow.ownedBy = { id, email, firstName, lastName };
                return;
            }
            (_a = workflow.sharedWith) === null || _a === void 0 ? void 0 : _a.push({ id, email, firstName, lastName });
        });
        delete workflow.shared;
    }
    static async addCredentialsToWorkflow(workflow, currentUser) {
        workflow.usedCredentials = [];
        const userCredentials = await credentials_service_ee_1.EECredentialsService.getAll(currentUser, { disableGlobalRole: true });
        const credentialIdsUsedByWorkflow = new Set();
        workflow.nodes.forEach((node) => {
            if (!node.credentials) {
                return;
            }
            Object.keys(node.credentials).forEach((credentialType) => {
                var _a;
                const credential = (_a = node.credentials) === null || _a === void 0 ? void 0 : _a[credentialType];
                if (!(credential === null || credential === void 0 ? void 0 : credential.id)) {
                    return;
                }
                credentialIdsUsedByWorkflow.add(credential.id);
            });
        });
        const workflowCredentials = await credentials_service_ee_1.EECredentialsService.getMany({
            where: {
                id: (0, typeorm_1.In)(Array.from(credentialIdsUsedByWorkflow)),
            },
            relations: ['shared', 'shared.user', 'shared.role'],
        });
        const userCredentialIds = userCredentials.map((credential) => credential.id);
        workflowCredentials.forEach((credential) => {
            var _a, _b;
            const credentialId = credential.id;
            const workflowCredential = {
                id: credentialId,
                name: credential.name,
                type: credential.type,
                currentUserHasAccess: userCredentialIds.includes(credentialId),
                sharedWith: [],
                ownedBy: null,
            };
            (_a = credential.shared) === null || _a === void 0 ? void 0 : _a.forEach(({ user, role }) => {
                var _a;
                const { id, email, firstName, lastName } = user;
                if (role.name === 'owner') {
                    workflowCredential.ownedBy = { id, email, firstName, lastName };
                }
                else {
                    (_a = workflowCredential.sharedWith) === null || _a === void 0 ? void 0 : _a.push({ id, email, firstName, lastName });
                }
            });
            (_b = workflow.usedCredentials) === null || _b === void 0 ? void 0 : _b.push(workflowCredential);
        });
    }
    static validateCredentialPermissionsToUser(workflow, allowedCredentials) {
        workflow.nodes.forEach((node) => {
            if (!node.credentials) {
                return;
            }
            Object.keys(node.credentials).forEach((credentialType) => {
                var _a;
                const credentialId = (_a = node.credentials) === null || _a === void 0 ? void 0 : _a[credentialType].id;
                if (credentialId === undefined)
                    return;
                const matchedCredential = allowedCredentials.find(({ id }) => id === credentialId);
                if (!matchedCredential) {
                    throw new Error('The workflow contains credentials that you do not have access to');
                }
            });
        });
    }
    static async preventTampering(workflow, workflowId, user) {
        const previousVersion = await EEWorkflowsService.get({ id: workflowId });
        if (!previousVersion) {
            throw new ResponseHelper.NotFoundError('Workflow not found');
        }
        const allCredentials = await credentials_service_ee_1.EECredentialsService.getAll(user);
        try {
            return WorkflowHelpers.validateWorkflowCredentialUsage(workflow, previousVersion, allCredentials);
        }
        catch (error) {
            if (error instanceof n8n_workflow_1.NodeOperationError) {
                throw new ResponseHelper.BadRequestError(error.message);
            }
            throw new ResponseHelper.BadRequestError('Invalid workflow credentials - make sure you have access to all credentials and try again.');
        }
    }
}
exports.EEWorkflowsService = EEWorkflowsService;
//# sourceMappingURL=workflows.services.ee.js.map