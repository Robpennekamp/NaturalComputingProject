"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkflowsService = void 0;
const typedi_1 = require("typedi");
const jsonschema_1 = require("jsonschema");
const n8n_workflow_1 = require("n8n-workflow");
const typeorm_1 = require("typeorm");
const lodash_pick_1 = __importDefault(require("lodash.pick"));
const uuid_1 = require("uuid");
const ActiveWorkflowRunner_1 = require("../ActiveWorkflowRunner");
const Db = __importStar(require("../Db"));
const ResponseHelper = __importStar(require("../ResponseHelper"));
const WorkflowHelpers = __importStar(require("../WorkflowHelpers"));
const config_1 = __importDefault(require("../config"));
const GenericHelpers_1 = require("../GenericHelpers");
const ExternalHooks_1 = require("../ExternalHooks");
const TagHelpers = __importStar(require("../TagHelpers"));
const NodeTypes_1 = require("../NodeTypes");
const WorkflowRunner_1 = require("../WorkflowRunner");
const WorkflowExecuteAdditionalData = __importStar(require("../WorkflowExecuteAdditionalData"));
const TestWebhooks_1 = require("../TestWebhooks");
const WorkflowHelpers_1 = require("../WorkflowHelpers");
const UserManagementHelper_1 = require("../UserManagement/UserManagementHelper");
const InternalHooks_1 = require("../InternalHooks");
const schemaGetWorkflowsQueryFilter = {
    $id: '/IGetWorkflowsQueryFilter',
    type: 'object',
    properties: {
        id: { anyOf: [{ type: 'integer' }, { type: 'string' }] },
        name: { type: 'string' },
        active: { type: 'boolean' },
    },
};
const allowedWorkflowsQueryFilterFields = Object.keys(schemaGetWorkflowsQueryFilter.properties);
class WorkflowsService {
    static async getSharing(user, workflowId, relations = ['workflow'], { allowGlobalOwner } = { allowGlobalOwner: true }) {
        const where = { workflowId };
        if (!allowGlobalOwner || user.globalRole.name !== 'owner') {
            where.userId = user.id;
        }
        return Db.collections.SharedWorkflow.findOne({ where, relations });
    }
    static findPinnedTrigger(workflow, startNodes, pinData) {
        var _a;
        if (!pinData || !startNodes)
            return null;
        const isTrigger = (nodeTypeName) => ['trigger', 'webhook'].some((suffix) => nodeTypeName.toLowerCase().includes(suffix));
        const pinnedTriggers = workflow.nodes.filter((node) => !node.disabled && pinData[node.name] && isTrigger(node.type));
        if (pinnedTriggers.length === 0)
            return null;
        if ((startNodes === null || startNodes === void 0 ? void 0 : startNodes.length) === 0)
            return pinnedTriggers[0];
        const [startNodeName] = startNodes;
        const parentNames = new n8n_workflow_1.Workflow({
            nodes: workflow.nodes,
            connections: workflow.connections,
            active: workflow.active,
            nodeTypes: typedi_1.Container.get(NodeTypes_1.NodeTypes),
        }).getParentNodes(startNodeName);
        let checkNodeName = '';
        if (parentNames.length === 0) {
            checkNodeName = startNodeName;
        }
        else {
            checkNodeName = parentNames.find((pn) => pn === pinnedTriggers[0].name);
        }
        return (_a = pinnedTriggers.find((pt) => pt.name === checkNodeName)) !== null && _a !== void 0 ? _a : null;
    }
    static async get(workflow, options) {
        return Db.collections.Workflow.findOne({ where: workflow, relations: options === null || options === void 0 ? void 0 : options.relations });
    }
    static async getWorkflowIdsForUser(user, roles) {
        return (0, WorkflowHelpers_1.getSharedWorkflowIds)(user, roles);
    }
    static async getMany(user, rawFilter) {
        var _a;
        const sharedWorkflowIds = await this.getWorkflowIdsForUser(user, ['owner']);
        if (sharedWorkflowIds.length === 0) {
            return [];
        }
        let filter = {};
        if (rawFilter) {
            try {
                const filterJson = (0, n8n_workflow_1.jsonParse)(rawFilter);
                if (filterJson) {
                    Object.keys(filterJson).map((key) => {
                        if (!allowedWorkflowsQueryFilterFields.includes(key))
                            delete filterJson[key];
                    });
                    if ((0, jsonschema_1.validate)(filterJson, schemaGetWorkflowsQueryFilter).valid) {
                        filter = filterJson;
                    }
                }
            }
            catch (error) {
                n8n_workflow_1.LoggerProxy.error('Failed to parse filter', {
                    userId: user.id,
                    filter,
                });
                throw new ResponseHelper.InternalServerError('Parameter "filter" contained invalid JSON string.');
            }
        }
        const workflowId = (_a = filter === null || filter === void 0 ? void 0 : filter.id) === null || _a === void 0 ? void 0 : _a.toString();
        if (workflowId !== undefined && !sharedWorkflowIds.includes(workflowId)) {
            n8n_workflow_1.LoggerProxy.verbose(`User ${user.id} attempted to query non-shared workflow ${workflowId}`);
            return [];
        }
        const select = {
            id: true,
            name: true,
            active: true,
            createdAt: true,
            updatedAt: true,
        };
        const relations = [];
        if (!config_1.default.getEnv('workflowTagsDisabled')) {
            relations.push('tags');
            select.tags = { id: true, name: true };
        }
        if ((0, UserManagementHelper_1.isSharingEnabled)()) {
            relations.push('shared');
            select.shared = { userId: true, roleId: true };
            select.versionId = true;
        }
        filter.id = (0, typeorm_1.In)(sharedWorkflowIds);
        return Db.collections.Workflow.find({
            select,
            relations,
            where: filter,
            order: { updatedAt: 'DESC' },
        });
    }
    static async update(user, workflow, workflowId, tagIds, forceSave, roles) {
        var _a, _b;
        const shared = await Db.collections.SharedWorkflow.findOne({
            relations: ['workflow', 'role'],
            where: (0, UserManagementHelper_1.whereClause)({
                user,
                entityType: 'workflow',
                entityId: workflowId,
                roles,
            }),
        });
        if (!shared) {
            n8n_workflow_1.LoggerProxy.verbose('User attempted to update a workflow without permissions', {
                workflowId,
                userId: user.id,
            });
            throw new ResponseHelper.NotFoundError('You do not have permission to update this workflow. Ask the owner to share it with you.');
        }
        if (!forceSave &&
            workflow.versionId !== '' &&
            workflow.versionId !== shared.workflow.versionId) {
            throw new ResponseHelper.BadRequestError('Your most recent changes may be lost, because someone else just updated this workflow. Open this workflow in a new tab to see those new updates.', 100);
        }
        workflow.versionId = (0, uuid_1.v4)();
        n8n_workflow_1.LoggerProxy.verbose(`Updating versionId for workflow ${workflowId} for user ${user.id} after saving`, {
            previousVersionId: shared.workflow.versionId,
            newVersionId: workflow.versionId,
        });
        await WorkflowHelpers.replaceInvalidCredentials(workflow);
        WorkflowHelpers.addNodeIds(workflow);
        await typedi_1.Container.get(ExternalHooks_1.ExternalHooks).run('workflow.update', [workflow]);
        if (shared.workflow.active) {
            await typedi_1.Container.get(ActiveWorkflowRunner_1.ActiveWorkflowRunner).remove(workflowId);
        }
        const workflowSettings = (_a = workflow.settings) !== null && _a !== void 0 ? _a : {};
        const keysAllowingDefault = [
            'timezone',
            'saveDataErrorExecution',
            'saveDataSuccessExecution',
            'saveManualExecutions',
            'saveExecutionProgress',
        ];
        for (const key of keysAllowingDefault) {
            if (workflowSettings[key] === 'DEFAULT') {
                delete workflowSettings[key];
            }
        }
        if (workflowSettings.executionTimeout === config_1.default.get('executions.timeout')) {
            delete workflowSettings.executionTimeout;
        }
        if (workflow.name) {
            workflow.updatedAt = new Date();
            await (0, GenericHelpers_1.validateEntity)(workflow);
        }
        await Db.collections.Workflow.update(workflowId, (0, lodash_pick_1.default)(workflow, [
            'name',
            'active',
            'nodes',
            'connections',
            'settings',
            'staticData',
            'pinData',
            'versionId',
        ]));
        if (tagIds && !config_1.default.getEnv('workflowTagsDisabled')) {
            await Db.collections.WorkflowTagMapping.delete({ workflowId });
            await Db.collections.WorkflowTagMapping.insert(tagIds.map((tagId) => ({ tagId, workflowId })));
        }
        const relations = config_1.default.getEnv('workflowTagsDisabled') ? [] : ['tags'];
        const updatedWorkflow = await Db.collections.Workflow.findOne({
            where: { id: workflowId },
            relations,
        });
        if (updatedWorkflow === null) {
            throw new ResponseHelper.BadRequestError(`Workflow with ID "${workflowId}" could not be found to be updated.`);
        }
        if (((_b = updatedWorkflow.tags) === null || _b === void 0 ? void 0 : _b.length) && (tagIds === null || tagIds === void 0 ? void 0 : tagIds.length)) {
            updatedWorkflow.tags = TagHelpers.sortByRequestOrder(updatedWorkflow.tags, {
                requestOrder: tagIds,
            });
        }
        await typedi_1.Container.get(ExternalHooks_1.ExternalHooks).run('workflow.afterUpdate', [updatedWorkflow]);
        void typedi_1.Container.get(InternalHooks_1.InternalHooks).onWorkflowSaved(user, updatedWorkflow, false);
        if (updatedWorkflow.active) {
            try {
                await typedi_1.Container.get(ExternalHooks_1.ExternalHooks).run('workflow.activate', [updatedWorkflow]);
                await typedi_1.Container.get(ActiveWorkflowRunner_1.ActiveWorkflowRunner).add(workflowId, shared.workflow.active ? 'update' : 'activate');
            }
            catch (error) {
                await Db.collections.Workflow.update(workflowId, {
                    active: false,
                    versionId: shared.workflow.versionId,
                });
                updatedWorkflow.active = false;
                let message;
                if (error instanceof n8n_workflow_1.NodeApiError)
                    message = error.description;
                message = message !== null && message !== void 0 ? message : error.message;
                throw new ResponseHelper.BadRequestError(message);
            }
        }
        return updatedWorkflow;
    }
    static async runManually({ workflowData, runData, pinData, startNodes, destinationNode, }, user, sessionId) {
        var _a;
        const EXECUTION_MODE = 'manual';
        const ACTIVATION_MODE = 'manual';
        const pinnedTrigger = WorkflowsService.findPinnedTrigger(workflowData, startNodes, pinData);
        if (pinnedTrigger === null &&
            (runData === undefined ||
                startNodes === undefined ||
                startNodes.length === 0 ||
                destinationNode === undefined)) {
            const workflow = new n8n_workflow_1.Workflow({
                id: (_a = workflowData.id) === null || _a === void 0 ? void 0 : _a.toString(),
                name: workflowData.name,
                nodes: workflowData.nodes,
                connections: workflowData.connections,
                active: false,
                nodeTypes: typedi_1.Container.get(NodeTypes_1.NodeTypes),
                staticData: undefined,
                settings: workflowData.settings,
            });
            const additionalData = await WorkflowExecuteAdditionalData.getBase(user.id);
            const needsWebhook = await typedi_1.Container.get(TestWebhooks_1.TestWebhooks).needsWebhookData(workflowData, workflow, additionalData, EXECUTION_MODE, ACTIVATION_MODE, sessionId, destinationNode);
            if (needsWebhook) {
                return {
                    waitingForWebhook: true,
                };
            }
        }
        workflowData.active = false;
        const data = {
            destinationNode,
            executionMode: EXECUTION_MODE,
            runData,
            pinData,
            sessionId,
            startNodes,
            workflowData,
            userId: user.id,
        };
        const hasRunData = (node) => runData !== undefined && !!runData[node.name];
        if (pinnedTrigger && !hasRunData(pinnedTrigger)) {
            data.startNodes = [pinnedTrigger.name];
        }
        const workflowRunner = new WorkflowRunner_1.WorkflowRunner();
        const executionId = await workflowRunner.run(data);
        return {
            executionId,
        };
    }
    static async delete(user, workflowId) {
        await typedi_1.Container.get(ExternalHooks_1.ExternalHooks).run('workflow.delete', [workflowId]);
        const sharedWorkflow = await Db.collections.SharedWorkflow.findOne({
            relations: ['workflow', 'role'],
            where: (0, UserManagementHelper_1.whereClause)({
                user,
                entityType: 'workflow',
                entityId: workflowId,
                roles: ['owner'],
            }),
        });
        if (!sharedWorkflow) {
            return;
        }
        if (sharedWorkflow.workflow.active) {
            await typedi_1.Container.get(ActiveWorkflowRunner_1.ActiveWorkflowRunner).remove(workflowId);
        }
        await Db.collections.Workflow.delete(workflowId);
        void typedi_1.Container.get(InternalHooks_1.InternalHooks).onWorkflowDeleted(user, workflowId, false);
        await typedi_1.Container.get(ExternalHooks_1.ExternalHooks).run('workflow.afterDelete', [workflowId]);
        return sharedWorkflow.workflow;
    }
    static async updateWorkflowTriggerCount(id, triggerCount) {
        const qb = Db.collections.Workflow.createQueryBuilder('workflow');
        return qb
            .update()
            .set({
            triggerCount,
            updatedAt: () => {
                if (['mysqldb', 'mariadb'].includes(config_1.default.getEnv('database.type'))) {
                    return 'updatedAt';
                }
                return '"updatedAt"';
            },
        })
            .where('id = :id', { id })
            .execute();
    }
}
exports.WorkflowsService = WorkflowsService;
//# sourceMappingURL=workflows.services.js.map