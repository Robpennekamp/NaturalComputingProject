"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.reportInstanceRisk = exports.getOutdatedState = void 0;
const axios_1 = __importDefault(require("axios"));
const n8n_core_1 = require("n8n-core");
const config_1 = __importDefault(require("../../config"));
const utils_1 = require("../../audit/utils");
const utils_2 = require("../../utils");
const constants_1 = require("../../audit/constants");
const constants_2 = require("../../constants");
function getSecuritySettings() {
    var _a, _b;
    if (config_1.default.getEnv('deployment.type') === 'cloud')
        return null;
    const userManagementEnabled = !config_1.default.getEnv('userManagement.disabled');
    const basicAuthActive = config_1.default.getEnv('security.basicAuth.active');
    const jwtAuthActive = config_1.default.getEnv('security.jwtAuth.active');
    const isInstancePubliclyAccessible = !userManagementEnabled && !basicAuthActive && !jwtAuthActive;
    const settings = {};
    if (isInstancePubliclyAccessible) {
        settings.publiclyAccessibleInstance =
            'Important! Your n8n instance is publicly accessible. Any third party who knows your instance URL can access your data.'.toUpperCase();
    }
    settings.features = {
        communityPackagesEnabled: config_1.default.getEnv('nodes.communityPackages.enabled'),
        versionNotificationsEnabled: config_1.default.getEnv('versionNotifications.enabled'),
        templatesEnabled: config_1.default.getEnv('templates.enabled'),
        publicApiEnabled: !config_1.default.getEnv('publicApi.disabled'),
        userManagementEnabled,
    };
    settings.auth = {
        authExcludeEndpoints: config_1.default.getEnv('security.excludeEndpoints') || 'none',
        basicAuthActive,
        jwtAuthActive,
    };
    settings.nodes = {
        nodesExclude: (_a = config_1.default.getEnv('nodes.exclude')) !== null && _a !== void 0 ? _a : 'none',
        nodesInclude: (_b = config_1.default.getEnv('nodes.include')) !== null && _b !== void 0 ? _b : 'none',
    };
    settings.telemetry = {
        diagnosticsEnabled: config_1.default.getEnv('diagnostics.enabled'),
    };
    return settings;
}
function hasValidatorChild({ node, workflow, }) {
    var _a;
    const childNodeNames = (_a = workflow.connections[node.name]) === null || _a === void 0 ? void 0 : _a.main[0].map((i) => i.node);
    if (!childNodeNames)
        return false;
    return childNodeNames.some((name) => workflow.nodes.find((n) => n.name === name && constants_1.WEBHOOK_VALIDATOR_NODE_TYPES.has(n.type)));
}
function getUnprotectedWebhookNodes(workflows) {
    return workflows.reduce((acc, workflow) => {
        if (!workflow.active)
            return acc;
        workflow.nodes.forEach((node) => {
            if (node.type === constants_1.WEBHOOK_NODE_TYPE &&
                node.parameters.authentication === undefined &&
                !hasValidatorChild({ node, workflow })) {
                acc.push((0, utils_1.toFlaggedNode)({ node, workflow }));
            }
        });
        return acc;
    }, []);
}
async function getNextVersions(currentVersionName) {
    const BASE_URL = config_1.default.getEnv('versionNotifications.endpoint');
    const instanceId = await n8n_core_1.UserSettings.getInstanceId();
    const response = await axios_1.default.get(BASE_URL + currentVersionName, {
        headers: { 'n8n-instance-id': instanceId },
    });
    return response.data;
}
function removeIconData(versions) {
    return versions.map((version) => {
        if (version.nodes.length === 0)
            return version;
        version.nodes.forEach((node) => delete node.iconData);
        return version;
    });
}
function classify(versions, currentVersionName) {
    const [pass, fail] = (0, utils_2.separate)(versions, (v) => v.name === currentVersionName);
    return { currentVersion: pass[0], nextVersions: fail };
}
async function getOutdatedState() {
    let versions = [];
    const localVersion = (0, constants_2.getN8nPackageJson)().version;
    try {
        versions = await getNextVersions(localVersion).then(removeIconData);
    }
    catch (error) {
        if (constants_2.inDevelopment) {
            console.error('Failed to fetch n8n versions. Skipping outdated instance report...');
        }
        return null;
    }
    const { currentVersion, nextVersions } = classify(versions, localVersion);
    const nextVersionsNumber = nextVersions.length;
    if (nextVersionsNumber === 0)
        return null;
    const description = [
        `This n8n instance is outdated. Currently at version ${currentVersion.name}, missing ${nextVersionsNumber} ${nextVersionsNumber > 1 ? 'updates' : 'update'}.`,
    ];
    const upcomingSecurityUpdates = nextVersions.some((v) => v.hasSecurityIssue || v.hasSecurityFix);
    if (upcomingSecurityUpdates)
        description.push('Newer versions contain security updates.');
    return {
        description: description.join(' '),
        nextVersions,
    };
}
exports.getOutdatedState = getOutdatedState;
async function reportInstanceRisk(workflows) {
    const unprotectedWebhooks = getUnprotectedWebhookNodes(workflows);
    const outdatedState = await getOutdatedState();
    const securitySettings = getSecuritySettings();
    if (unprotectedWebhooks.length === 0 && outdatedState === null && securitySettings === null) {
        return null;
    }
    const report = {
        risk: constants_1.INSTANCE_REPORT.RISK,
        sections: [],
    };
    if (unprotectedWebhooks.length > 0) {
        const sentenceStart = ({ length }) => length > 1 ? 'These webhook nodes have' : 'This webhook node has';
        const recommendedValidators = [...constants_1.WEBHOOK_VALIDATOR_NODE_TYPES]
            .filter((nodeType) => !nodeType.endsWith('function') || !nodeType.endsWith('functionItem'))
            .join(',');
        report.sections.push({
            title: constants_1.INSTANCE_REPORT.SECTIONS.UNPROTECTED_WEBHOOKS,
            description: [
                sentenceStart(unprotectedWebhooks),
                `the "Authentication" field set to "None" and ${unprotectedWebhooks.length > 1 ? 'are' : 'is'} not directly connected to a node to validate the payload. Every unprotected webhook allows your workflow to be called by any third party who knows the webhook URL.`,
            ].join(' '),
            recommendation: `Consider setting the "Authentication" field to an option other than "None", or validating the payload with one of the following nodes: ${recommendedValidators}.`,
            location: unprotectedWebhooks,
        });
    }
    if (outdatedState !== null) {
        report.sections.push({
            title: constants_1.INSTANCE_REPORT.SECTIONS.OUTDATED_INSTANCE,
            description: outdatedState.description,
            recommendation: 'Consider updating this n8n instance to the latest version to prevent security vulnerabilities.',
            nextVersions: outdatedState.nextVersions,
        });
    }
    if (securitySettings !== null) {
        report.sections.push({
            title: constants_1.INSTANCE_REPORT.SECTIONS.SECURITY_SETTINGS,
            description: 'This n8n instance has the following security settings.',
            recommendation: securitySettings.publiclyAccessibleInstance
                ? [
                    'Important! Your n8n instance is publicly accessible. Set up user management or basic/JWT auth to protect access to your n8n instance.'.toUpperCase(),
                    `See: ${constants_1.SELF_HOSTED_AUTH_DOCS_URL}`,
                ].join(' ')
                : `Consider adjusting the security settings for your n8n instance based on your needs. See: ${constants_1.ENV_VARS_DOCS_URL}`,
            settings: securitySettings,
        });
    }
    return report;
}
exports.reportInstanceRisk = reportInstanceRisk;
//# sourceMappingURL=instance.risk.js.map