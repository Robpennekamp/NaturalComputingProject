"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.reportCredentialsRisk = void 0;
const typeorm_1 = require("typeorm");
const DateUtils_1 = require("typeorm/util/DateUtils");
const Db = __importStar(require("../../Db"));
const config_1 = __importDefault(require("../../config"));
const constants_1 = require("../../audit/constants");
async function getAllCredsInUse(workflows) {
    const credsInAnyUse = new Set();
    const credsInActiveUse = new Set();
    workflows.forEach((workflow) => {
        workflow.nodes.forEach((node) => {
            if (!node.credentials)
                return;
            Object.values(node.credentials).forEach((cred) => {
                if (!(cred === null || cred === void 0 ? void 0 : cred.id))
                    return;
                credsInAnyUse.add(cred.id);
                if (workflow.active)
                    credsInActiveUse.add(cred.id);
            });
        });
    });
    return {
        credsInAnyUse,
        credsInActiveUse,
    };
}
async function getAllExistingCreds() {
    const credentials = await Db.collections.Credentials.find({ select: ['id', 'name'] });
    return credentials.map(({ id, name }) => ({ kind: 'credential', id, name }));
}
async function getExecutionsInPastDays(days) {
    const date = new Date();
    date.setDate(date.getDate() - days);
    const utcDate = DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(date);
    return Db.collections.Execution.find({
        select: ['workflowData'],
        where: {
            startedAt: (0, typeorm_1.MoreThanOrEqual)(utcDate),
        },
    });
}
async function getCredsInRecentlyExecutedWorkflows(days) {
    const recentExecutions = await getExecutionsInPastDays(days);
    return recentExecutions.reduce((acc, execution) => {
        var _a;
        (_a = execution.workflowData) === null || _a === void 0 ? void 0 : _a.nodes.forEach((node) => {
            if (node.credentials) {
                Object.values(node.credentials).forEach((c) => {
                    if (c.id)
                        acc.add(c.id);
                });
            }
        });
        return acc;
    }, new Set());
}
async function reportCredentialsRisk(workflows) {
    const days = config_1.default.getEnv('security.audit.daysAbandonedWorkflow');
    const allExistingCreds = await getAllExistingCreds();
    const { credsInAnyUse, credsInActiveUse } = await getAllCredsInUse(workflows);
    const recentlyExecutedCreds = await getCredsInRecentlyExecutedWorkflows(days);
    const credsNotInAnyUse = allExistingCreds.filter((c) => !credsInAnyUse.has(c.id));
    const credsNotInActiveUse = allExistingCreds.filter((c) => !credsInActiveUse.has(c.id));
    const credsNotRecentlyExecuted = allExistingCreds.filter((c) => !recentlyExecutedCreds.has(c.id));
    const issues = [credsNotInAnyUse, credsNotInActiveUse, credsNotRecentlyExecuted];
    if (issues.every((i) => i.length === 0))
        return null;
    const report = {
        risk: constants_1.CREDENTIALS_REPORT.RISK,
        sections: [],
    };
    const hint = 'Keeping unused credentials in your instance is an unneeded security risk.';
    const recommendation = 'Consider deleting these credentials if you no longer need them.';
    const sentenceStart = ({ length }) => length > 1 ? 'These credentials are' : 'This credential is';
    if (credsNotInAnyUse.length > 0) {
        report.sections.push({
            title: constants_1.CREDENTIALS_REPORT.SECTIONS.CREDS_NOT_IN_ANY_USE,
            description: [sentenceStart(credsNotInAnyUse), 'not used in any workflow.', hint].join(' '),
            recommendation,
            location: credsNotInAnyUse,
        });
    }
    if (credsNotInActiveUse.length > 0) {
        report.sections.push({
            title: constants_1.CREDENTIALS_REPORT.SECTIONS.CREDS_NOT_IN_ACTIVE_USE,
            description: [sentenceStart(credsNotInActiveUse), 'not used in active workflows.', hint].join(' '),
            recommendation,
            location: credsNotInActiveUse,
        });
    }
    if (credsNotRecentlyExecuted.length > 0) {
        report.sections.push({
            title: constants_1.CREDENTIALS_REPORT.SECTIONS.CREDS_NOT_RECENTLY_EXECUTED,
            description: [
                sentenceStart(credsNotRecentlyExecuted),
                `not used in recently executed workflows, i.e. workflows executed in the past ${days} days.`,
                hint,
            ].join(' '),
            recommendation,
            location: credsNotRecentlyExecuted,
        });
    }
    return report;
}
exports.reportCredentialsRisk = reportCredentialsRisk;
//# sourceMappingURL=credentials.risk.js.map