"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongoDb = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const MongoDbDescription_1 = require("./MongoDbDescription");
const GenericFunctions_1 = require("./GenericFunctions");
const mongodb_1 = require("mongodb");
class MongoDb {
    constructor() {
        this.description = MongoDbDescription_1.nodeDescription;
        this.methods = {
            credentialTest: {
                async mongoDbCredentialTest(credential) {
                    const credentials = credential.data;
                    try {
                        const database = (credentials.database || '').trim();
                        let connectionString = '';
                        if (credentials.configurationType === 'connectionString') {
                            connectionString = (credentials.connectionString || '').trim();
                        }
                        else {
                            connectionString = (0, GenericFunctions_1.buildParameterizedConnString)(credentials);
                        }
                        const client = await mongodb_1.MongoClient.connect(connectionString);
                        const { databases } = await client.db().admin().listDatabases();
                        if (!databases.map((db) => db.name).includes(database)) {
                            throw new Error(`Database "${database}" does not exist`);
                        }
                        await client.close();
                    }
                    catch (error) {
                        return {
                            status: 'Error',
                            message: error.message,
                        };
                    }
                    return {
                        status: 'OK',
                        message: 'Connection successful!',
                    };
                },
            },
        };
    }
    async execute() {
        const { database, connectionString } = (0, GenericFunctions_1.validateAndResolveMongoCredentials)(this, await this.getCredentials('mongoDb'));
        const client = await mongodb_1.MongoClient.connect(connectionString);
        const mdb = client.db(database);
        const returnItems = [];
        let responseData = [];
        const items = this.getInputData();
        const operation = this.getNodeParameter('operation', 0);
        if (operation === 'aggregate') {
            try {
                const queryParameter = JSON.parse(this.getNodeParameter('query', 0));
                if (queryParameter._id && typeof queryParameter._id === 'string') {
                    queryParameter._id = new mongodb_1.ObjectId(queryParameter._id);
                }
                const query = mdb
                    .collection(this.getNodeParameter('collection', 0))
                    .aggregate(queryParameter);
                responseData = await query.toArray();
            }
            catch (error) {
                if (this.continueOnFail()) {
                    responseData = [{ error: error.message }];
                }
                else {
                    throw error;
                }
            }
        }
        else if (operation === 'delete') {
            try {
                const { deletedCount } = await mdb
                    .collection(this.getNodeParameter('collection', 0))
                    .deleteMany(JSON.parse(this.getNodeParameter('query', 0)));
                responseData = [{ deletedCount }];
            }
            catch (error) {
                if (this.continueOnFail()) {
                    responseData = [{ error: error.message }];
                }
                else {
                    throw error;
                }
            }
        }
        else if (operation === 'find') {
            try {
                const queryParameter = JSON.parse(this.getNodeParameter('query', 0));
                if (queryParameter._id && typeof queryParameter._id === 'string') {
                    queryParameter._id = new mongodb_1.ObjectId(queryParameter._id);
                }
                let query = mdb
                    .collection(this.getNodeParameter('collection', 0))
                    .find(queryParameter);
                const options = this.getNodeParameter('options', 0);
                const limit = options.limit;
                const skip = options.skip;
                const sort = options.sort && JSON.parse(options.sort);
                if (skip > 0) {
                    query = query.skip(skip);
                }
                if (limit > 0) {
                    query = query.limit(limit);
                }
                if (sort && Object.keys(sort).length !== 0 && sort.constructor === Object) {
                    query = query.sort(sort);
                }
                const queryResult = await query.toArray();
                responseData = queryResult;
            }
            catch (error) {
                if (this.continueOnFail()) {
                    responseData = [{ error: error.message }];
                }
                else {
                    throw error;
                }
            }
        }
        else if (operation === 'findOneAndReplace') {
            const fields = (0, GenericFunctions_1.prepareFields)(this.getNodeParameter('fields', 0));
            const useDotNotation = this.getNodeParameter('options.useDotNotation', 0, false);
            const dateFields = (0, GenericFunctions_1.prepareFields)(this.getNodeParameter('options.dateFields', 0, ''));
            const updateKey = (this.getNodeParameter('updateKey', 0) || '').trim();
            const updateOptions = this.getNodeParameter('upsert', 0)
                ? { upsert: true }
                : undefined;
            const updateItems = (0, GenericFunctions_1.prepareItems)(items, fields, updateKey, useDotNotation, dateFields);
            for (const item of updateItems) {
                try {
                    const filter = { [updateKey]: item[updateKey] };
                    if (updateKey === '_id') {
                        filter[updateKey] = new mongodb_1.ObjectId(item[updateKey]);
                        delete item._id;
                    }
                    await mdb
                        .collection(this.getNodeParameter('collection', 0))
                        .findOneAndReplace(filter, item, updateOptions);
                }
                catch (error) {
                    if (this.continueOnFail()) {
                        item.json = { error: error.message };
                        continue;
                    }
                    throw error;
                }
            }
            responseData = updateItems;
        }
        else if (operation === 'findOneAndUpdate') {
            const fields = (0, GenericFunctions_1.prepareFields)(this.getNodeParameter('fields', 0));
            const useDotNotation = this.getNodeParameter('options.useDotNotation', 0, false);
            const dateFields = (0, GenericFunctions_1.prepareFields)(this.getNodeParameter('options.dateFields', 0, ''));
            const updateKey = (this.getNodeParameter('updateKey', 0) || '').trim();
            const updateOptions = this.getNodeParameter('upsert', 0)
                ? { upsert: true }
                : undefined;
            const updateItems = (0, GenericFunctions_1.prepareItems)(items, fields, updateKey, useDotNotation, dateFields);
            for (const item of updateItems) {
                try {
                    const filter = { [updateKey]: item[updateKey] };
                    if (updateKey === '_id') {
                        filter[updateKey] = new mongodb_1.ObjectId(item[updateKey]);
                        delete item._id;
                    }
                    await mdb
                        .collection(this.getNodeParameter('collection', 0))
                        .findOneAndUpdate(filter, { $set: item }, updateOptions);
                }
                catch (error) {
                    if (this.continueOnFail()) {
                        item.json = { error: error.message };
                        continue;
                    }
                    throw error;
                }
            }
            responseData = updateItems;
        }
        else if (operation === 'insert') {
            try {
                const fields = (0, GenericFunctions_1.prepareFields)(this.getNodeParameter('fields', 0));
                const useDotNotation = this.getNodeParameter('options.useDotNotation', 0, false);
                const dateFields = (0, GenericFunctions_1.prepareFields)(this.getNodeParameter('options.dateFields', 0, ''));
                const insertItems = (0, GenericFunctions_1.prepareItems)(items, fields, '', useDotNotation, dateFields);
                const { insertedIds } = await mdb
                    .collection(this.getNodeParameter('collection', 0))
                    .insertMany(insertItems);
                for (const i of Object.keys(insertedIds)) {
                    responseData.push({
                        ...insertItems[parseInt(i, 10)],
                        id: insertedIds[parseInt(i, 10)],
                    });
                }
            }
            catch (error) {
                if (this.continueOnFail()) {
                    responseData = [{ error: error.message }];
                }
                else {
                    throw error;
                }
            }
        }
        else if (operation === 'update') {
            const fields = (0, GenericFunctions_1.prepareFields)(this.getNodeParameter('fields', 0));
            const useDotNotation = this.getNodeParameter('options.useDotNotation', 0, false);
            const dateFields = (0, GenericFunctions_1.prepareFields)(this.getNodeParameter('options.dateFields', 0, ''));
            const updateKey = (this.getNodeParameter('updateKey', 0) || '').trim();
            const updateOptions = this.getNodeParameter('upsert', 0)
                ? { upsert: true }
                : undefined;
            const updateItems = (0, GenericFunctions_1.prepareItems)(items, fields, updateKey, useDotNotation, dateFields);
            for (const item of updateItems) {
                try {
                    const filter = { [updateKey]: item[updateKey] };
                    if (updateKey === '_id') {
                        filter[updateKey] = new mongodb_1.ObjectId(item[updateKey]);
                        delete item._id;
                    }
                    await mdb
                        .collection(this.getNodeParameter('collection', 0))
                        .updateOne(filter, { $set: item }, updateOptions);
                }
                catch (error) {
                    if (this.continueOnFail()) {
                        item.json = { error: error.message };
                        continue;
                    }
                    throw error;
                }
            }
            responseData = updateItems;
        }
        else {
            if (this.continueOnFail()) {
                responseData = [{ error: `The operation "${operation}" is not supported!` }];
            }
            else {
                throw new n8n_workflow_1.NodeOperationError(this.getNode(), `The operation "${operation}" is not supported!`, { itemIndex: 0 });
            }
        }
        await client.close();
        const executionData = this.helpers.constructExecutionMetaData(this.helpers.returnJsonArray(responseData), { itemData: { item: 0 } });
        returnItems.push(...executionData);
        return this.prepareOutputData(returnItems);
    }
}
exports.MongoDb = MongoDb;
//# sourceMappingURL=MongoDb.node.js.map