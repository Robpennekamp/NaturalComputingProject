"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertDateTime = exports.compareOperationFunctions = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const moment_1 = __importDefault(require("moment"));
const isDateObject = (value) => Object.prototype.toString.call(value) === '[object Date]';
const isDateInvalid = (value) => (value === null || value === void 0 ? void 0 : value.toString()) === 'Invalid Date';
exports.compareOperationFunctions = {
    after: (value1, value2) => (value1 || 0) > (value2 || 0),
    before: (value1, value2) => (value1 || 0) < (value2 || 0),
    contains: (value1, value2) => (value1 || '').toString().includes((value2 || '').toString()),
    notContains: (value1, value2) => !(value1 || '').toString().includes((value2 || '').toString()),
    endsWith: (value1, value2) => value1.endsWith(value2),
    notEndsWith: (value1, value2) => !value1.endsWith(value2),
    equal: (value1, value2) => value1 === value2,
    notEqual: (value1, value2) => value1 !== value2,
    larger: (value1, value2) => (value1 || 0) > (value2 || 0),
    largerEqual: (value1, value2) => (value1 || 0) >= (value2 || 0),
    smaller: (value1, value2) => (value1 || 0) < (value2 || 0),
    smallerEqual: (value1, value2) => (value1 || 0) <= (value2 || 0),
    startsWith: (value1, value2) => value1.startsWith(value2),
    notStartsWith: (value1, value2) => !value1.startsWith(value2),
    isEmpty: (value1) => [undefined, null, '', NaN].includes(value1) ||
        (typeof value1 === 'object' && value1 !== null && !isDateObject(value1)
            ? Object.entries(value1).length === 0
            : false) ||
        (isDateObject(value1) && isDateInvalid(value1)),
    isNotEmpty: (value1) => !([undefined, null, '', NaN].includes(value1) ||
        (typeof value1 === 'object' && value1 !== null && !isDateObject(value1)
            ? Object.entries(value1).length === 0
            : false) ||
        (isDateObject(value1) && isDateInvalid(value1))),
    regex: (value1, value2) => {
        const regexMatch = (value2 || '').toString().match(new RegExp('^/(.*?)/([gimusy]*)$'));
        let regex;
        if (!regexMatch) {
            regex = new RegExp((value2 || '').toString());
        }
        else if (regexMatch.length === 1) {
            regex = new RegExp(regexMatch[1]);
        }
        else {
            regex = new RegExp(regexMatch[1], regexMatch[2]);
        }
        return !!(value1 || '').toString().match(regex);
    },
    notRegex: (value1, value2) => {
        const regexMatch = (value2 || '').toString().match(new RegExp('^/(.*?)/([gimusy]*)$'));
        let regex;
        if (!regexMatch) {
            regex = new RegExp((value2 || '').toString());
        }
        else if (regexMatch.length === 1) {
            regex = new RegExp(regexMatch[1]);
        }
        else {
            regex = new RegExp(regexMatch[1], regexMatch[2]);
        }
        return !(value1 || '').toString().match(regex);
    },
};
const convertDateTime = (node, value) => {
    let returnValue = undefined;
    if (typeof value === 'string') {
        returnValue = new Date(value).getTime();
    }
    else if (typeof value === 'number') {
        returnValue = value;
    }
    if (moment_1.default.isMoment(value)) {
        returnValue = value.unix();
    }
    if (value instanceof Date) {
        returnValue = value.getTime();
    }
    if (returnValue === undefined || isNaN(returnValue)) {
        throw new n8n_workflow_1.NodeOperationError(node, `The value "${value}" is not a valid DateTime.`);
    }
    return returnValue;
};
exports.convertDateTime = convertDateTime;
//# sourceMappingURL=GenericFunctions.js.map