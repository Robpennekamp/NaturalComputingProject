"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GoogleSheet = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const GenericFunctions_1 = require("./GenericFunctions");
const xlsx_1 = require("xlsx");
const lodash_get_1 = __importDefault(require("lodash.get"));
class GoogleSheet {
    constructor(spreadsheetId, executeFunctions, options) {
        if (!options) {
            options = {};
        }
        this.executeFunctions = executeFunctions;
        this.id = spreadsheetId;
    }
    encodeRange(range) {
        if (range.includes('!')) {
            const [sheet, ranges] = range.split('!');
            range = `${encodeURIComponent(sheet)}!${ranges}`;
        }
        return range;
    }
    async clearData(range) {
        const body = {
            spreadsheetId: this.id,
            range,
        };
        const response = await GenericFunctions_1.googleApiRequest.call(this.executeFunctions, 'POST', `/v4/spreadsheets/${this.id}/values/${range}:clear`, body);
        return response;
    }
    async getData(range, valueRenderMode) {
        const query = {
            valueRenderOption: valueRenderMode,
        };
        const response = await GenericFunctions_1.googleApiRequest.call(this.executeFunctions, 'GET', `/v4/spreadsheets/${this.id}/values/${range}`, {}, query);
        return response.values;
    }
    async spreadsheetGetSheets() {
        const query = {
            fields: 'sheets.properties',
        };
        const response = await GenericFunctions_1.googleApiRequest.call(this.executeFunctions, 'GET', `/v4/spreadsheets/${this.id}`, {}, query);
        return response;
    }
    async spreadsheetBatchUpdate(requests) {
        const body = {
            requests,
        };
        const response = await GenericFunctions_1.googleApiRequest.call(this.executeFunctions, 'POST', `/v4/spreadsheets/${this.id}:batchUpdate`, body);
        return response;
    }
    async batchUpdate(updateData, valueInputMode) {
        const body = {
            data: updateData,
            valueInputOption: valueInputMode,
        };
        const response = await GenericFunctions_1.googleApiRequest.call(this.executeFunctions, 'POST', `/v4/spreadsheets/${this.id}/values:batchUpdate`, body);
        return response;
    }
    async setData(range, data, valueInputMode) {
        const body = {
            valueInputOption: valueInputMode,
            values: data,
        };
        const response = await GenericFunctions_1.googleApiRequest.call(this.executeFunctions, 'POST', `/v4/spreadsheets/${this.id}/values/${range}`, body);
        return response;
    }
    async appendData(range, data, valueInputMode) {
        const body = {
            range: decodeURIComponent(range),
            values: data,
        };
        const query = {
            valueInputOption: valueInputMode,
        };
        const response = await GenericFunctions_1.googleApiRequest.call(this.executeFunctions, 'POST', `/v4/spreadsheets/${this.id}/values/${range}:append`, body, query);
        return response;
    }
    structureData(inputData, startRow, keys, addEmpty) {
        const returnData = [];
        let tempEntry, rowIndex, columnIndex, key;
        for (rowIndex = startRow; rowIndex < inputData.length; rowIndex++) {
            tempEntry = {};
            for (columnIndex = 0; columnIndex < inputData[rowIndex].length; columnIndex++) {
                key = keys[columnIndex];
                if (key) {
                    tempEntry[key] = inputData[rowIndex][columnIndex];
                }
            }
            if (Object.keys(tempEntry).length || addEmpty === true) {
                returnData.push(tempEntry);
            }
        }
        return returnData;
    }
    structureArrayDataByColumn(inputData, keyRow, dataStartRow) {
        const keys = [];
        if (keyRow < 0 || dataStartRow < keyRow || keyRow >= inputData.length) {
            return [];
        }
        for (let columnIndex = 0; columnIndex < inputData[keyRow].length; columnIndex++) {
            keys.push(inputData[keyRow][columnIndex]);
        }
        return this.structureData(inputData, dataStartRow, keys);
    }
    async appendSheetData(inputData, range, keyRowIndex, valueInputMode, usePathForKeyRow) {
        const data = await this.convertStructuredDataToArray(inputData, range, keyRowIndex, usePathForKeyRow);
        return this.appendData(range, data, valueInputMode);
    }
    getColumnWithOffset(startColumn, offset) {
        const columnIndex = xlsx_1.utils.decode_col(startColumn) + offset;
        return xlsx_1.utils.encode_col(columnIndex);
    }
    async updateSheetData(inputData, indexKey, range, keyRowIndex, dataStartRowIndex, valueInputMode, valueRenderMode, upsert = false) {
        let rangeFull;
        let sheet = undefined;
        if (range.includes('!')) {
            [sheet, rangeFull] = range.split('!');
        }
        else {
            rangeFull = range;
        }
        const [rangeStart, rangeEnd] = rangeFull.split(':');
        const rangeStartSplit = rangeStart.match(/([a-zA-Z]{1,10})([0-9]{0,10})/);
        const rangeEndSplit = rangeEnd.match(/([a-zA-Z]{1,10})([0-9]{0,10})/);
        if (rangeStartSplit === null ||
            rangeStartSplit.length !== 3 ||
            rangeEndSplit === null ||
            rangeEndSplit.length !== 3) {
            throw new n8n_workflow_1.NodeOperationError(this.executeFunctions.getNode(), `The range "${range}" is not valid.`);
        }
        const keyRowRange = `${sheet ? sheet + '!' : ''}${rangeStartSplit[1]}${keyRowIndex + 1}:${rangeEndSplit[1]}${keyRowIndex + 1}`;
        const sheetDatakeyRow = await this.getData(this.encodeRange(keyRowRange), valueRenderMode);
        if (sheetDatakeyRow === undefined) {
            throw new n8n_workflow_1.NodeOperationError(this.executeFunctions.getNode(), 'Could not retrieve the key row!');
        }
        const keyColumnOrder = sheetDatakeyRow[0];
        const keyIndex = keyColumnOrder.indexOf(indexKey);
        if (keyIndex === -1) {
            throw new n8n_workflow_1.NodeOperationError(this.executeFunctions.getNode(), `Could not find column for key "${indexKey}"!`);
        }
        const startRowIndex = rangeStartSplit[2] || dataStartRowIndex;
        const endRowIndex = rangeEndSplit[2] || '';
        const keyColumn = this.getColumnWithOffset(rangeStartSplit[1], keyIndex);
        const keyColumnRange = `${sheet ? sheet + '!' : ''}${keyColumn}${startRowIndex}:${keyColumn}${endRowIndex}`;
        const sheetDataKeyColumn = await this.getData(this.encodeRange(keyColumnRange), valueRenderMode);
        if (sheetDataKeyColumn === undefined) {
            throw new n8n_workflow_1.NodeOperationError(this.executeFunctions.getNode(), 'Could not retrieve the key column!');
        }
        sheetDataKeyColumn.shift();
        const keyColumnIndexLookup = sheetDataKeyColumn.map((rowContent) => rowContent[0]);
        const updateData = [];
        let itemKey;
        let propertyName;
        let itemKeyIndex;
        let updateRowIndex;
        let updateColumnName;
        for (const inputItem of inputData) {
            itemKey = inputItem[indexKey];
            if (itemKey === undefined || itemKey === null) {
                if (upsert) {
                    const _data = await this.appendSheetData([inputItem], this.encodeRange(range), keyRowIndex, valueInputMode, false);
                }
                continue;
            }
            itemKeyIndex = keyColumnIndexLookup.indexOf(itemKey);
            if (itemKeyIndex === -1) {
                if (upsert) {
                    const _data = await this.appendSheetData([inputItem], this.encodeRange(range), keyRowIndex, valueInputMode, false);
                }
                continue;
            }
            updateRowIndex = keyColumnIndexLookup.indexOf(itemKey) + dataStartRowIndex + 1;
            for (propertyName of keyColumnOrder) {
                if (propertyName === indexKey) {
                    continue;
                }
                if (inputItem[propertyName] === undefined || inputItem[propertyName] === null) {
                    continue;
                }
                updateColumnName = this.getColumnWithOffset(rangeStartSplit[1], keyColumnOrder.indexOf(propertyName));
                updateData.push({
                    range: `${sheet ? sheet + '!' : ''}${updateColumnName}${updateRowIndex}`,
                    values: [[inputItem[propertyName]]],
                });
            }
        }
        return this.batchUpdate(updateData, valueInputMode);
    }
    async lookupValues(inputData, keyRowIndex, dataStartRowIndex, lookupValues, returnAllMatches) {
        var _a;
        const keys = [];
        if (keyRowIndex < 0 || dataStartRowIndex < keyRowIndex || keyRowIndex >= inputData.length) {
            throw new n8n_workflow_1.NodeOperationError(this.executeFunctions.getNode(), 'The key row does not exist!');
        }
        for (let columnIndex = 0; columnIndex < inputData[keyRowIndex].length; columnIndex++) {
            keys.push(inputData[keyRowIndex][columnIndex]);
        }
        const returnData = [inputData[keyRowIndex]];
        for (let rowIndex = 0; rowIndex < (inputData === null || inputData === void 0 ? void 0 : inputData.length); rowIndex++) {
            if (inputData[rowIndex].length === 0) {
                for (let i = 0; i < keys.length; i++) {
                    inputData[rowIndex][i] = '';
                }
            }
            else if (inputData[rowIndex].length < keys.length) {
                for (let i = 0; i < keys.length; i++) {
                    if (inputData[rowIndex][i] === undefined) {
                        inputData[rowIndex].push('');
                    }
                }
            }
        }
        let rowIndex;
        let returnColumnIndex;
        lookupLoop: for (const lookupValue of lookupValues) {
            returnColumnIndex = keys.indexOf(lookupValue.lookupColumn);
            if (returnColumnIndex === -1) {
                throw new n8n_workflow_1.NodeOperationError(this.executeFunctions.getNode(), `The column "${lookupValue.lookupColumn}" could not be found!`);
            }
            for (rowIndex = dataStartRowIndex; rowIndex < inputData.length; rowIndex++) {
                if (((_a = inputData[rowIndex][returnColumnIndex]) === null || _a === void 0 ? void 0 : _a.toString()) === lookupValue.lookupValue.toString()) {
                    returnData.push(inputData[rowIndex]);
                    if (returnAllMatches !== true) {
                        continue lookupLoop;
                    }
                }
            }
            if (returnAllMatches !== true) {
                returnData.push([]);
            }
        }
        return this.structureData(returnData, 1, keys, true);
    }
    async convertStructuredDataToArray(inputData, range, keyRowIndex, usePathForKeyRow) {
        let sheet = undefined;
        if (range.includes('!')) {
            [sheet, range] = range.split('!');
        }
        const [startColumn, endColumn] = range.split(':');
        let getRange = `${startColumn}${keyRowIndex + 1}:${endColumn}${keyRowIndex + 1}`;
        if (sheet !== undefined) {
            getRange = `${sheet}!${getRange}`;
        }
        const keyColumnData = await this.getData(getRange, 'UNFORMATTED_VALUE');
        if (keyColumnData === undefined) {
            throw new n8n_workflow_1.NodeOperationError(this.executeFunctions.getNode(), 'Could not retrieve the column data!');
        }
        const keyColumnOrder = keyColumnData[0];
        const setData = [];
        let rowData = [];
        inputData.forEach((item) => {
            rowData = [];
            keyColumnOrder.forEach((key) => {
                const value = (0, lodash_get_1.default)(item, key);
                if (usePathForKeyRow && value !== undefined && value !== null) {
                    rowData.push(value.toString());
                }
                else if (!usePathForKeyRow &&
                    item.hasOwnProperty(key) &&
                    item[key] !== null &&
                    item[key] !== undefined) {
                    rowData.push(item[key].toString());
                }
                else {
                    rowData.push('');
                }
            });
            setData.push(rowData);
        });
        return setData;
    }
}
exports.GoogleSheet = GoogleSheet;
//# sourceMappingURL=GoogleSheet.js.map