"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sortLoadOptions = exports.autoMapInputData = exports.mapFields = exports.getExistingSheetNames = exports.getRangeString = exports.prepareSheetData = exports.removeEmptyColumns = exports.trimLeadingEmptyRows = exports.removeEmptyRows = exports.trimToFirstEmptyRow = exports.addRowNumber = exports.hexToRgb = exports.getColumnNumber = exports.getColumnName = exports.getSpreadsheetId = exports.untilSheetSelected = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const GoogleSheets_types_1 = require("./GoogleSheets.types");
exports.untilSheetSelected = { sheetName: [''] };
function getSpreadsheetId(documentIdType, value) {
    if (!value) {
        throw new Error(`Can not get sheet '${GoogleSheets_types_1.ResourceLocatorUiNames[documentIdType]}' with a value of '${value}'`);
    }
    if (documentIdType === 'url') {
        const regex = /([-\w]{25,})/;
        const parts = value.match(regex);
        if (parts == null || parts.length < 2) {
            return '';
        }
        else {
            return parts[0];
        }
    }
    return value;
}
exports.getSpreadsheetId = getSpreadsheetId;
function getColumnName(colNumber) {
    const baseChar = 'A'.charCodeAt(0);
    let letters = '';
    do {
        colNumber -= 1;
        letters = String.fromCharCode(baseChar + (colNumber % 26)) + letters;
        colNumber = (colNumber / 26) >> 0;
    } while (colNumber > 0);
    return letters;
}
exports.getColumnName = getColumnName;
function getColumnNumber(colPosition) {
    let colNum = 0;
    for (let i = 0; i < colPosition.length; i++) {
        colNum *= 26;
        colNum += colPosition[i].charCodeAt(0) - 'A'.charCodeAt(0) + 1;
    }
    return colNum;
}
exports.getColumnNumber = getColumnNumber;
function hexToRgb(hex) {
    const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, (m, r, g, b) => {
        return r + r + g + g + b + b;
    });
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (result) {
        return {
            red: parseInt(result[1], 16),
            green: parseInt(result[2], 16),
            blue: parseInt(result[3], 16),
        };
    }
    else {
        return null;
    }
}
exports.hexToRgb = hexToRgb;
function addRowNumber(data, headerRow) {
    if (data.length === 0)
        return data;
    const sheetData = data.map((row, i) => [i + 1, ...row]);
    sheetData[headerRow][0] = GoogleSheets_types_1.ROW_NUMBER;
    return sheetData;
}
exports.addRowNumber = addRowNumber;
function trimToFirstEmptyRow(data, includesRowNumber = true) {
    const baseLength = includesRowNumber ? 1 : 0;
    const emtyRowIndex = data.findIndex((row) => row.slice(baseLength).every((cell) => cell === ''));
    if (emtyRowIndex === -1) {
        return data;
    }
    return data.slice(0, emtyRowIndex);
}
exports.trimToFirstEmptyRow = trimToFirstEmptyRow;
function removeEmptyRows(data, includesRowNumber = true) {
    const baseLength = includesRowNumber ? 1 : 0;
    const notEmptyRows = data.filter((row) => row.slice(baseLength).some((cell) => cell || typeof cell === 'number'));
    if (includesRowNumber) {
        notEmptyRows[0][0] = GoogleSheets_types_1.ROW_NUMBER;
    }
    return notEmptyRows;
}
exports.removeEmptyRows = removeEmptyRows;
function trimLeadingEmptyRows(data, includesRowNumber = true, rowNumbersColumnName = GoogleSheets_types_1.ROW_NUMBER) {
    const baseLength = includesRowNumber ? 1 : 0;
    const firstNotEmptyRowIndex = data.findIndex((row) => row.slice(baseLength).some((cell) => cell || typeof cell === 'number'));
    const returnData = data.slice(firstNotEmptyRowIndex);
    if (includesRowNumber) {
        returnData[0][0] = rowNumbersColumnName;
    }
    return returnData;
}
exports.trimLeadingEmptyRows = trimLeadingEmptyRows;
function removeEmptyColumns(data) {
    if (!data || data.length === 0)
        return [];
    const returnData = [];
    const longestRow = data.reduce((a, b) => (a.length > b.length ? a : b), []).length;
    for (let col = 0; col < longestRow; col++) {
        const column = data.map((row) => row[col]);
        if (column[0] !== '') {
            returnData.push(column);
            continue;
        }
        const hasData = column.slice(1).some((cell) => cell || typeof cell === 'number');
        if (hasData) {
            returnData.push(column);
        }
    }
    return (returnData[0] || []).map((_, i) => returnData.map((row) => row[i] || ''));
}
exports.removeEmptyColumns = removeEmptyColumns;
function prepareSheetData(data, options, addRowNumbersToData = true) {
    let returnData = [...(data || [])];
    let headerRow = 0;
    let firstDataRow = 1;
    if (options.rangeDefinition === 'specifyRange') {
        headerRow = parseInt(options.headerRow, 10) - 1;
        firstDataRow = parseInt(options.firstDataRow, 10) - 1;
    }
    if (addRowNumbersToData) {
        returnData = addRowNumber(returnData, headerRow);
    }
    if (options.rangeDefinition === 'detectAutomatically') {
        returnData = removeEmptyColumns(returnData);
        returnData = trimLeadingEmptyRows(returnData, addRowNumbersToData);
        if (options.readRowsUntil === 'firstEmptyRow') {
            returnData = trimToFirstEmptyRow(returnData, addRowNumbersToData);
        }
        else {
            returnData = removeEmptyRows(returnData, addRowNumbersToData);
        }
    }
    return { data: returnData, headerRow, firstDataRow };
}
exports.prepareSheetData = prepareSheetData;
function getRangeString(sheetName, options) {
    if (options.rangeDefinition === 'specifyRangeA1') {
        return options.range ? `${sheetName}!${options.range}` : sheetName;
    }
    return sheetName;
}
exports.getRangeString = getRangeString;
async function getExistingSheetNames(sheet) {
    const { sheets } = await sheet.spreadsheetGetSheets();
    return (sheets || []).map((entry) => { var _a; return (_a = entry.properties) === null || _a === void 0 ? void 0 : _a.title; });
}
exports.getExistingSheetNames = getExistingSheetNames;
function mapFields(inputSize) {
    const returnData = [];
    for (let i = 0; i < inputSize; i++) {
        const fields = this.getNodeParameter('fieldsUi.fieldValues', i, []);
        let dataToSend = {};
        for (const field of fields) {
            dataToSend = { ...dataToSend, [field.fieldId]: field.fieldValue };
        }
        returnData.push(dataToSend);
    }
    return returnData;
}
exports.mapFields = mapFields;
async function autoMapInputData(sheetNameWithRange, sheet, items, options) {
    var _a;
    const returnData = [];
    const [sheetName, _sheetRange] = sheetNameWithRange.split('!');
    const locationDefine = (_a = options.locationDefine) === null || _a === void 0 ? void 0 : _a.values;
    const handlingExtraData = options.handlingExtraData || 'insertInNewColumn';
    let headerRow = 1;
    if (locationDefine) {
        headerRow = parseInt(locationDefine.headerRow, 10);
    }
    let columnNames = [];
    const response = await sheet.getData(`${sheetName}!${headerRow}:${headerRow}`, 'FORMATTED_VALUE');
    columnNames = response ? response[0] : [];
    if (handlingExtraData === 'insertInNewColumn') {
        if (!columnNames.length) {
            await sheet.updateRows(sheetName, [Object.keys(items[0].json).filter((key) => key !== GoogleSheets_types_1.ROW_NUMBER)], options.cellFormat || 'RAW', headerRow);
            columnNames = Object.keys(items[0].json);
        }
        const newColumns = new Set();
        items.forEach((item) => {
            Object.keys(item.json).forEach((key) => {
                if (key !== GoogleSheets_types_1.ROW_NUMBER && !columnNames.includes(key)) {
                    newColumns.add(key);
                }
            });
            if (item.json[GoogleSheets_types_1.ROW_NUMBER]) {
                delete item.json[GoogleSheets_types_1.ROW_NUMBER];
            }
            returnData.push(item.json);
        });
        if (newColumns.size) {
            await sheet.updateRows(sheetName, [columnNames.concat([...newColumns])], options.cellFormat || 'RAW', headerRow);
        }
    }
    if (handlingExtraData === 'ignoreIt') {
        items.forEach((item) => {
            returnData.push(item.json);
        });
    }
    if (handlingExtraData === 'error') {
        items.forEach((item, itemIndex) => {
            Object.keys(item.json).forEach((key) => {
                if (!columnNames.includes(key)) {
                    throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Unexpected fields in node input', {
                        itemIndex,
                        description: `The input field '${key}' doesn't match any column in the Sheet. You can ignore this by changing the 'Handling extra data' field, which you can find under 'Options'.`,
                    });
                }
            });
            returnData.push(item.json);
        });
    }
    return returnData;
}
exports.autoMapInputData = autoMapInputData;
function sortLoadOptions(data) {
    const returnData = [...data];
    returnData.sort((a, b) => {
        const aName = a.name.toLowerCase();
        const bName = b.name.toLowerCase();
        if (aName < bName) {
            return -1;
        }
        if (aName > bName) {
            return 1;
        }
        return 0;
    });
    return returnData;
}
exports.sortLoadOptions = sortLoadOptions;
//# sourceMappingURL=GoogleSheets.utils.js.map