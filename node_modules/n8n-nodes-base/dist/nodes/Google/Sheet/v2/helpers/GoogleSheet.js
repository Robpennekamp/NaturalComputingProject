"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GoogleSheet = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const transport_1 = require("../transport");
const xlsx_1 = require("xlsx");
const lodash_get_1 = __importDefault(require("lodash.get"));
const GoogleSheets_utils_1 = require("./GoogleSheets.utils");
class GoogleSheet {
    constructor(spreadsheetId, executeFunctions) {
        this.executeFunctions = executeFunctions;
        this.id = spreadsheetId;
    }
    encodeRange(range) {
        if (range.includes('!')) {
            const [sheet, ranges] = range.split('!');
            return `${encodeURIComponent(sheet)}!${ranges}`;
        }
        return encodeURIComponent(range);
    }
    async clearData(range) {
        const body = {
            spreadsheetId: this.id,
            range,
        };
        const response = await transport_1.apiRequest.call(this.executeFunctions, 'POST', `/v4/spreadsheets/${this.id}/values/${this.encodeRange(range)}:clear`, body);
        return response;
    }
    async getData(range, valueRenderMode, dateTimeRenderOption) {
        const query = {
            valueRenderOption: valueRenderMode,
            dateTimeRenderOption: 'FORMATTED_STRING',
        };
        if (dateTimeRenderOption) {
            query.dateTimeRenderOption = dateTimeRenderOption;
        }
        const response = await transport_1.apiRequest.call(this.executeFunctions, 'GET', `/v4/spreadsheets/${this.id}/values/${this.encodeRange(range)}`, {}, query);
        return response.values;
    }
    async spreadsheetGetSheets() {
        const query = {
            fields: 'sheets.properties',
        };
        const response = await transport_1.apiRequest.call(this.executeFunctions, 'GET', `/v4/spreadsheets/${this.id}`, {}, query);
        return response;
    }
    async spreadsheetGetSheetNameById(sheetId) {
        var _a;
        const query = {
            fields: 'sheets.properties',
        };
        const response = await transport_1.apiRequest.call(this.executeFunctions, 'GET', `/v4/spreadsheets/${this.id}`, {}, query);
        const foundItem = response.sheets.find((item) => item.properties.sheetId === +sheetId);
        if (!((_a = foundItem === null || foundItem === void 0 ? void 0 : foundItem.properties) === null || _a === void 0 ? void 0 : _a.title)) {
            throw new Error(`Sheet with id ${sheetId} not found`);
        }
        return foundItem.properties.title;
    }
    async getDataRange(sheetId) {
        const query = {
            fields: 'sheets.properties',
        };
        const response = await transport_1.apiRequest.call(this.executeFunctions, 'GET', `/v4/spreadsheets/${this.id}`, {}, query);
        const foundItem = response.sheets.find((item) => item.properties.sheetId === sheetId);
        return foundItem.properties.gridProperties;
    }
    async spreadsheetBatchUpdate(requests) {
        const body = {
            requests,
        };
        const response = await transport_1.apiRequest.call(this.executeFunctions, 'POST', `/v4/spreadsheets/${this.id}:batchUpdate`, body);
        return response;
    }
    async batchUpdate(updateData, valueInputMode) {
        const body = {
            data: updateData,
            valueInputOption: valueInputMode,
        };
        const response = await transport_1.apiRequest.call(this.executeFunctions, 'POST', `/v4/spreadsheets/${this.id}/values:batchUpdate`, body);
        return response;
    }
    async appendEmptyRowsOrColumns(sheetId, rowsToAdd = 1, columnsToAdd = 1) {
        const requests = [];
        if (rowsToAdd > 0) {
            requests.push({
                appendDimension: {
                    sheetId,
                    dimension: 'ROWS',
                    length: rowsToAdd,
                },
            });
        }
        if (columnsToAdd > 0) {
            requests.push({
                appendDimension: {
                    sheetId,
                    dimension: 'COLUMNS',
                    length: columnsToAdd,
                },
            });
        }
        if (requests.length === 0) {
            throw new Error('Must specify at least one column or row to add');
        }
        const response = await transport_1.apiRequest.call(this.executeFunctions, 'POST', `/v4/spreadsheets/${this.id}:batchUpdate`, { requests });
        return response;
    }
    async appendData(range, data, valueInputMode, lastRow) {
        const lastRowWithData = lastRow ||
            ((await this.getData(range, 'UNFORMATTED_VALUE')) || []).length + 1;
        const response = await this.updateRows(range, data, valueInputMode, lastRowWithData, data.length);
        return response;
    }
    async updateRows(sheetName, data, valueInputMode, row, rowsLength) {
        const [name, _sheetRange] = sheetName.split('!');
        const range = `${name}!${row}:${rowsLength ? row + rowsLength - 1 : row}`;
        const body = {
            range,
            values: data,
        };
        const query = {
            valueInputOption: valueInputMode,
        };
        const response = await transport_1.apiRequest.call(this.executeFunctions, 'PUT', `/v4/spreadsheets/${this.id}/values/${this.encodeRange(range)}`, body, query);
        return response;
    }
    convertSheetDataArrayToObjectArray(data, startRow, columnKeys, addEmpty) {
        const returnData = [];
        for (let rowIndex = startRow; rowIndex < data.length; rowIndex++) {
            const item = {};
            for (let columnIndex = 0; columnIndex < data[rowIndex].length; columnIndex++) {
                const key = columnKeys[columnIndex];
                if (key) {
                    item[key] = data[rowIndex][columnIndex];
                }
            }
            if (Object.keys(item).length || addEmpty === true) {
                returnData.push(item);
            }
        }
        return returnData;
    }
    structureArrayDataByColumn(inputData, keyRow, dataStartRow) {
        const keys = [];
        if (keyRow < 0 || dataStartRow < keyRow || keyRow >= inputData.length) {
            return [];
        }
        const longestRow = inputData.reduce((a, b) => (a.length > b.length ? a : b), []).length;
        for (let columnIndex = 0; columnIndex < longestRow; columnIndex++) {
            keys.push(inputData[keyRow][columnIndex] || `col_${columnIndex}`);
        }
        return this.convertSheetDataArrayToObjectArray(inputData, dataStartRow, keys);
    }
    testFilter(inputData, keyRow, dataStartRow) {
        const keys = [];
        if (keyRow < 0 || dataStartRow < keyRow || keyRow >= inputData.length) {
            return [];
        }
        for (let columnIndex = 0; columnIndex < inputData[keyRow].length; columnIndex++) {
            keys.push(inputData[keyRow][columnIndex]);
        }
        return keys;
    }
    async appendSheetData(inputData, range, keyRowIndex, valueInputMode, usePathForKeyRow, columnNamesList, lastRow) {
        const data = await this.convertObjectArrayToSheetDataArray(inputData, range, keyRowIndex, usePathForKeyRow, columnNamesList);
        return this.appendData(range, data, valueInputMode, lastRow);
    }
    getColumnWithOffset(startColumn, offset) {
        const columnIndex = xlsx_1.utils.decode_col(startColumn) + offset;
        return xlsx_1.utils.encode_col(columnIndex);
    }
    async getColumnValues(range, keyIndex, dataStartRowIndex, valueRenderMode, sheetData) {
        var _a, _b, _c;
        let columnValuesList;
        if (sheetData) {
            columnValuesList = sheetData.slice(dataStartRowIndex - 1).map((row) => row[keyIndex]);
        }
        else {
            const decodedRange = this.getDecodedSheetRange(range);
            const startRowIndex = ((_a = decodedRange.start) === null || _a === void 0 ? void 0 : _a.row) || dataStartRowIndex;
            const endRowIndex = ((_b = decodedRange.end) === null || _b === void 0 ? void 0 : _b.row) || '';
            const keyColumn = this.getColumnWithOffset(((_c = decodedRange.start) === null || _c === void 0 ? void 0 : _c.column) || 'A', keyIndex);
            const keyColumnRange = `${decodedRange.name}!${keyColumn}${startRowIndex}:${keyColumn}${endRowIndex}`;
            columnValuesList = await this.getData(keyColumnRange, valueRenderMode);
        }
        if (columnValuesList === undefined) {
            throw new n8n_workflow_1.NodeOperationError(this.executeFunctions.getNode(), 'Could not retrieve the data from key column');
        }
        return columnValuesList.splice(1).flatMap((value) => value);
    }
    async prepareDataForUpdateOrUpsert(inputData, indexKey, range, keyRowIndex, dataStartRowIndex, valueRenderMode, upsert = false, columnNamesList, columnValuesList) {
        var _a, _b, _c;
        const decodedRange = this.getDecodedSheetRange(range);
        const keyRowRange = `${decodedRange.name}!${((_a = decodedRange.start) === null || _a === void 0 ? void 0 : _a.column) || ''}${keyRowIndex + 1}:${((_b = decodedRange.end) === null || _b === void 0 ? void 0 : _b.column) || ''}${keyRowIndex + 1}`;
        const sheetDatakeyRow = columnNamesList || (await this.getData(keyRowRange, valueRenderMode));
        if (sheetDatakeyRow === undefined) {
            throw new n8n_workflow_1.NodeOperationError(this.executeFunctions.getNode(), 'Could not retrieve the key row');
        }
        const columnNames = sheetDatakeyRow[0];
        const keyIndex = columnNames.indexOf(indexKey);
        if (keyIndex === -1) {
            throw new n8n_workflow_1.NodeOperationError(this.executeFunctions.getNode(), `Could not find column for key "${indexKey}"`);
        }
        const columnValues = columnValuesList ||
            (await this.getColumnValues(range, keyIndex, dataStartRowIndex, valueRenderMode));
        const updateData = [];
        const appendData = [];
        const getKeyIndex = (key, data) => {
            var _a;
            let index = -1;
            for (let i = 0; i < data.length; i++) {
                if (((_a = data[i]) === null || _a === void 0 ? void 0 : _a.toString()) === key.toString()) {
                    index = i;
                    break;
                }
            }
            return index;
        };
        for (const item of inputData) {
            const inputIndexKey = item[indexKey];
            if (inputIndexKey === undefined || inputIndexKey === null) {
                if (upsert) {
                    appendData.push(item);
                }
                continue;
            }
            const indexOfIndexKeyInSheet = getKeyIndex(inputIndexKey, columnValues);
            if (indexOfIndexKeyInSheet === -1) {
                if (upsert) {
                    appendData.push(item);
                }
                continue;
            }
            const updateRowIndex = indexOfIndexKeyInSheet + dataStartRowIndex + 1;
            for (const name of columnNames) {
                if (name === indexKey) {
                    continue;
                }
                if (item[name] === undefined || item[name] === null) {
                    continue;
                }
                const columnToUpdate = this.getColumnWithOffset(((_c = decodedRange.start) === null || _c === void 0 ? void 0 : _c.column) || 'A', columnNames.indexOf(name));
                let updateValue = item[name];
                if (typeof updateValue === 'object') {
                    try {
                        updateValue = JSON.stringify(updateValue);
                    }
                    catch (error) { }
                }
                updateData.push({
                    range: `${decodedRange.name}!${columnToUpdate}${updateRowIndex}`,
                    values: [[updateValue]],
                });
            }
        }
        return { updateData, appendData };
    }
    async lookupValues(inputData, keyRowIndex, dataStartRowIndex, lookupValues, returnAllMatches) {
        var _a;
        const keys = [];
        if (keyRowIndex < 0 || dataStartRowIndex < keyRowIndex || keyRowIndex >= inputData.length) {
            throw new n8n_workflow_1.NodeOperationError(this.executeFunctions.getNode(), 'The key row does not exist');
        }
        for (let columnIndex = 0; columnIndex < inputData[keyRowIndex].length; columnIndex++) {
            keys.push(inputData[keyRowIndex][columnIndex] || `col_${columnIndex}`);
        }
        for (let rowIndex = 0; rowIndex < (inputData === null || inputData === void 0 ? void 0 : inputData.length); rowIndex++) {
            if (inputData[rowIndex].length === 0) {
                for (let i = 0; i < keys.length; i++) {
                    inputData[rowIndex][i] = '';
                }
            }
            else if (inputData[rowIndex].length < keys.length) {
                for (let i = 0; i < keys.length; i++) {
                    if (inputData[rowIndex][i] === undefined) {
                        inputData[rowIndex].push('');
                    }
                }
            }
        }
        let rowIndex;
        let returnColumnIndex;
        const addedRows = [];
        const returnData = [keys];
        lookupLoop: for (const lookupValue of lookupValues) {
            returnColumnIndex = keys.indexOf(lookupValue.lookupColumn);
            if (returnColumnIndex === -1) {
                throw new n8n_workflow_1.NodeOperationError(this.executeFunctions.getNode(), `The column "${lookupValue.lookupColumn}" could not be found`);
            }
            for (rowIndex = dataStartRowIndex; rowIndex < inputData.length; rowIndex++) {
                if (((_a = inputData[rowIndex][returnColumnIndex]) === null || _a === void 0 ? void 0 : _a.toString()) === lookupValue.lookupValue.toString()) {
                    if (addedRows.indexOf(rowIndex) === -1) {
                        returnData.push(inputData[rowIndex]);
                        addedRows.push(rowIndex);
                    }
                    if (returnAllMatches !== true) {
                        continue lookupLoop;
                    }
                }
            }
        }
        const dataWithoutEmptyColumns = (0, GoogleSheets_utils_1.removeEmptyColumns)(returnData);
        return this.convertSheetDataArrayToObjectArray(dataWithoutEmptyColumns, 1, dataWithoutEmptyColumns[0], true);
    }
    async convertObjectArrayToSheetDataArray(inputData, range, keyRowIndex, usePathForKeyRow, columnNamesList) {
        const decodedRange = this.getDecodedSheetRange(range);
        const columnNamesRow = columnNamesList ||
            (await this.getData(`${decodedRange.name}!${keyRowIndex}:${keyRowIndex}`, 'UNFORMATTED_VALUE'));
        if (columnNamesRow === undefined) {
            throw new n8n_workflow_1.NodeOperationError(this.executeFunctions.getNode(), 'Could not retrieve the column data');
        }
        const columnNames = columnNamesRow ? columnNamesRow[0] : [];
        const setData = [];
        inputData.forEach((item) => {
            const rowData = [];
            columnNames.forEach((key) => {
                let value;
                if (usePathForKeyRow) {
                    value = (0, lodash_get_1.default)(item, key);
                }
                else {
                    value = item[key];
                }
                if (value === undefined || value === null) {
                    rowData.push('');
                    return;
                }
                if (typeof value === 'object') {
                    rowData.push(JSON.stringify(value));
                }
                else {
                    rowData.push(value);
                }
            });
            setData.push(rowData);
        });
        return setData;
    }
    getDecodedSheetRange(stringToDecode) {
        const decodedRange = {};
        const [name, range] = stringToDecode.split('!');
        decodedRange.nameWithRange = stringToDecode;
        decodedRange.name = name;
        decodedRange.range = range || '';
        decodedRange.start = {};
        decodedRange.end = {};
        if (range) {
            const [startCell, endCell] = range.split(':');
            if (startCell) {
                decodedRange.start = this.splitCellRange(startCell, range);
            }
            if (endCell) {
                decodedRange.end = this.splitCellRange(endCell, range);
            }
        }
        return decodedRange;
    }
    splitCellRange(cell, range) {
        const cellData = cell.match(/([a-zA-Z]{1,10})([0-9]{0,10})/) || [];
        if (cellData === null || cellData.length !== 3) {
            throw new n8n_workflow_1.NodeOperationError(this.executeFunctions.getNode(), `The range "${range}" is not valid`);
        }
        return { cell: cellData[0], column: cellData[1], row: +cellData[2] };
    }
}
exports.GoogleSheet = GoogleSheet;
//# sourceMappingURL=GoogleSheet.js.map