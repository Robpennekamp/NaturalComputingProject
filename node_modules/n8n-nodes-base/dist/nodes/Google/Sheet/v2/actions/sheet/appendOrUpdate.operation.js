"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = exports.description = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const GoogleSheets_utils_1 = require("../../helpers/GoogleSheets.utils");
const commonDescription_1 = require("./commonDescription");
exports.description = [
    {
        displayName: 'Data Mode',
        name: 'dataMode',
        type: 'options',
        options: [
            {
                name: 'Auto-Map Input Data to Columns',
                value: 'autoMapInputData',
                description: 'Use when node input properties match destination column names',
            },
            {
                name: 'Map Each Column Below',
                value: 'defineBelow',
                description: 'Set the value for each destination column',
            },
            {
                name: 'Nothing',
                value: 'nothing',
                description: 'Do not send anything',
            },
        ],
        displayOptions: {
            show: {
                resource: ['sheet'],
                operation: ['appendOrUpdate'],
            },
            hide: {
                ...GoogleSheets_utils_1.untilSheetSelected,
            },
        },
        default: 'defineBelow',
        description: 'Whether to insert the input data this node receives in the new row',
    },
    {
        displayName: 'Column to match on',
        name: 'columnToMatchOn',
        type: 'options',
        description: 'Choose from the list, or specify an ID using an <a href="https://docs.n8n.io/code-examples/expressions/">expression</a>',
        typeOptions: {
            loadOptionsDependsOn: ['sheetName.value'],
            loadOptionsMethod: 'getSheetHeaderRowAndSkipEmpty',
        },
        default: '',
        hint: "Used to find the correct row to update. Doesn't get changed.",
        displayOptions: {
            show: {
                resource: ['sheet'],
                operation: ['appendOrUpdate'],
            },
            hide: {
                ...GoogleSheets_utils_1.untilSheetSelected,
            },
        },
    },
    {
        displayName: 'Value of Column to Match On',
        name: 'valueToMatchOn',
        type: 'string',
        default: '',
        displayOptions: {
            show: {
                resource: ['sheet'],
                operation: ['appendOrUpdate'],
                dataMode: ['defineBelow'],
            },
            hide: {
                ...GoogleSheets_utils_1.untilSheetSelected,
            },
        },
    },
    {
        displayName: 'Values to Send',
        name: 'fieldsUi',
        placeholder: 'Add Field',
        type: 'fixedCollection',
        typeOptions: {
            multipleValues: true,
        },
        displayOptions: {
            show: {
                resource: ['sheet'],
                operation: ['appendOrUpdate'],
                dataMode: ['defineBelow'],
            },
            hide: {
                ...GoogleSheets_utils_1.untilSheetSelected,
            },
        },
        default: {},
        options: [
            {
                displayName: 'Field',
                name: 'values',
                values: [
                    {
                        displayName: 'Column',
                        name: 'column',
                        type: 'options',
                        description: 'Choose from the list, or specify an ID using an <a href="https://docs.n8n.io/code-examples/expressions/">expression</a>',
                        typeOptions: {
                            loadOptionsDependsOn: ['sheetName.value', 'columnToMatchOn'],
                            loadOptionsMethod: 'getSheetHeaderRowAndAddColumn',
                        },
                        default: '',
                    },
                    {
                        displayName: 'Column Name',
                        name: 'columnName',
                        type: 'string',
                        default: '',
                        displayOptions: {
                            show: {
                                column: ['newColumn'],
                            },
                        },
                    },
                    {
                        displayName: 'Value',
                        name: 'fieldValue',
                        type: 'string',
                        default: '',
                    },
                ],
            },
        ],
    },
    {
        displayName: 'Options',
        name: 'options',
        type: 'collection',
        placeholder: 'Add Option',
        default: {},
        displayOptions: {
            show: {
                resource: ['sheet'],
                operation: ['appendOrUpdate'],
            },
            hide: {
                ...GoogleSheets_utils_1.untilSheetSelected,
            },
        },
        options: [...commonDescription_1.cellFormat, ...commonDescription_1.locationDefine, ...commonDescription_1.handlingExtraData],
    },
];
async function execute(sheet, sheetName, sheetId) {
    var _a;
    const items = this.getInputData();
    const valueInputMode = this.getNodeParameter('options.cellFormat', 0, 'RAW');
    const range = `${sheetName}!A:Z`;
    const options = this.getNodeParameter('options', 0, {});
    const valueRenderMode = (options.valueRenderMode || 'UNFORMATTED_VALUE');
    const locationDefineOption = (_a = options.locationDefine) === null || _a === void 0 ? void 0 : _a.values;
    let headerRow = 0;
    let firstDataRow = 1;
    if (locationDefineOption) {
        if (locationDefineOption.headerRow) {
            headerRow = parseInt(locationDefineOption.headerRow, 10) - 1;
        }
        if (locationDefineOption.firstDataRow) {
            firstDataRow = parseInt(locationDefineOption.firstDataRow, 10) - 1;
        }
    }
    let columnNames = [];
    const sheetData = await sheet.getData(sheetName, 'FORMATTED_VALUE');
    if (sheetData === undefined || sheetData[headerRow] === undefined) {
        throw new n8n_workflow_1.NodeOperationError(this.getNode(), `Could not retrieve the column names from row ${headerRow + 1}`);
    }
    columnNames = sheetData[headerRow];
    const newColumns = new Set();
    const columnToMatchOn = this.getNodeParameter('columnToMatchOn', 0);
    const keyIndex = columnNames.indexOf(columnToMatchOn);
    const columnValues = await sheet.getColumnValues(range, keyIndex, firstDataRow, valueRenderMode, sheetData);
    const updateData = [];
    const appendData = [];
    for (let i = 0; i < items.length; i++) {
        const dataMode = this.getNodeParameter('dataMode', i);
        if (dataMode === 'nothing')
            continue;
        const data = [];
        if (dataMode === 'autoMapInputData') {
            const handlingExtraDataOption = options.handlingExtraData || 'insertInNewColumn';
            if (handlingExtraDataOption === 'ignoreIt') {
                data.push(items[i].json);
            }
            if (handlingExtraDataOption === 'error') {
                Object.keys(items[i].json).forEach((key) => {
                    if (!columnNames.includes(key)) {
                        throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Unexpected fields in node input', {
                            itemIndex: i,
                            description: `The input field '${key}' doesn't match any column in the Sheet. You can ignore this by changing the 'Handling extra data' field, which you can find under 'Options'.`,
                        });
                    }
                });
                data.push(items[i].json);
            }
            if (handlingExtraDataOption === 'insertInNewColumn') {
                Object.keys(items[i].json).forEach((key) => {
                    if (!columnNames.includes(key)) {
                        newColumns.add(key);
                    }
                });
                data.push(items[i].json);
            }
        }
        else {
            const valueToMatchOn = this.getNodeParameter('valueToMatchOn', i);
            const valuesToSend = this.getNodeParameter('fieldsUi.values', i, []);
            if (!(valuesToSend === null || valuesToSend === void 0 ? void 0 : valuesToSend.length)) {
                throw new n8n_workflow_1.NodeOperationError(this.getNode(), "At least one value has to be added under 'Values to Send'");
            }
            const fields = valuesToSend.reduce((acc, entry) => {
                if (entry.column === 'newColumn') {
                    const columnName = entry.columnName;
                    if (!columnNames.includes(columnName)) {
                        newColumns.add(columnName);
                    }
                    acc[columnName] = entry.fieldValue;
                }
                else {
                    acc[entry.column] = entry.fieldValue;
                }
                return acc;
            }, {});
            fields[columnToMatchOn] = valueToMatchOn;
            data.push(fields);
        }
        if (newColumns.size) {
            await sheet.updateRows(sheetName, [columnNames.concat([...newColumns])], options.cellFormat || 'RAW', headerRow + 1);
        }
        const preparedData = await sheet.prepareDataForUpdateOrUpsert(data, columnToMatchOn, range, headerRow, firstDataRow, valueRenderMode, true, [columnNames.concat([...newColumns])], columnValues);
        updateData.push(...preparedData.updateData);
        appendData.push(...preparedData.appendData);
    }
    if (updateData.length) {
        await sheet.batchUpdate(updateData, valueInputMode);
    }
    if (appendData.length) {
        await sheet.appendEmptyRowsOrColumns(sheetId, 1, 0);
        const lastRow = sheetData.length + 1;
        await sheet.appendSheetData(appendData, range, headerRow + 1, valueInputMode, false, [columnNames.concat([...newColumns])], lastRow);
    }
    return items;
}
exports.execute = execute;
//# sourceMappingURL=appendOrUpdate.operation.js.map