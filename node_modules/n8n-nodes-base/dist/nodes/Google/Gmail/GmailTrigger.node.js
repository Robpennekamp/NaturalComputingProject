"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GmailTrigger = void 0;
const GenericFunctions_1 = require("./GenericFunctions");
const luxon_1 = require("luxon");
class GmailTrigger {
    constructor() {
        this.description = {
            displayName: 'Gmail Trigger',
            name: 'gmailTrigger',
            icon: 'file:gmail.svg',
            group: ['trigger'],
            version: 1,
            description: 'Fetches emails from Gmail and starts the workflow on specified polling intervals.',
            subtitle: '={{"Gmail Trigger"}}',
            defaults: {
                name: 'Gmail Trigger',
            },
            credentials: [
                {
                    name: 'googleApi',
                    required: true,
                    displayOptions: {
                        show: {
                            authentication: ['serviceAccount'],
                        },
                    },
                },
                {
                    name: 'gmailOAuth2',
                    required: true,
                    displayOptions: {
                        show: {
                            authentication: ['oAuth2'],
                        },
                    },
                },
            ],
            polling: true,
            inputs: [],
            outputs: ['main'],
            properties: [
                {
                    displayName: 'Authentication',
                    name: 'authentication',
                    type: 'options',
                    options: [
                        {
                            name: 'OAuth2 (recommended)',
                            value: 'oAuth2',
                        },
                        {
                            name: 'Service Account',
                            value: 'serviceAccount',
                        },
                    ],
                    default: 'oAuth2',
                },
                {
                    displayName: 'Event',
                    name: 'event',
                    type: 'options',
                    default: 'messageReceived',
                    options: [
                        {
                            name: 'Message Received',
                            value: 'messageReceived',
                        },
                    ],
                },
                {
                    displayName: 'Simplify',
                    name: 'simple',
                    type: 'boolean',
                    default: true,
                    description: 'Whether to return a simplified version of the response instead of the raw data',
                },
                {
                    displayName: 'Filters',
                    name: 'filters',
                    type: 'collection',
                    placeholder: 'Add Filter',
                    default: {},
                    options: [
                        {
                            displayName: 'Include Spam and Trash',
                            name: 'includeSpamTrash',
                            type: 'boolean',
                            default: false,
                            description: 'Whether to include messages from SPAM and TRASH in the results',
                        },
                        {
                            displayName: 'Label Names or IDs',
                            name: 'labelIds',
                            type: 'multiOptions',
                            typeOptions: {
                                loadOptionsMethod: 'getLabels',
                            },
                            default: [],
                            description: 'Only return messages with labels that match all of the specified label IDs. Choose from the list, or specify IDs using an <a href="https://docs.n8n.io/code-examples/expressions/">expression</a>.',
                        },
                        {
                            displayName: 'Search',
                            name: 'q',
                            type: 'string',
                            default: '',
                            placeholder: 'has:attachment',
                            hint: 'Use the same format as in the Gmail search box. <a href="https://support.google.com/mail/answer/7190?hl=en">More info</a>.',
                            description: 'Only return messages matching the specified query',
                        },
                        {
                            displayName: 'Read Status',
                            name: 'readStatus',
                            type: 'options',
                            default: 'unread',
                            hint: 'Filter emails by whether they have been read or not',
                            options: [
                                {
                                    name: 'Unread and read emails',
                                    value: 'both',
                                },
                                {
                                    name: 'Unread emails only',
                                    value: 'unread',
                                },
                                {
                                    name: 'Read emails only',
                                    value: 'read',
                                },
                            ],
                        },
                        {
                            displayName: 'Sender',
                            name: 'sender',
                            type: 'string',
                            default: '',
                            description: 'Sender name or email to filter by',
                            hint: 'Enter an email or part of a sender name',
                        },
                    ],
                },
                {
                    displayName: 'Options',
                    name: 'options',
                    type: 'collection',
                    placeholder: 'Add Option',
                    default: {},
                    displayOptions: {
                        hide: {
                            simple: [true],
                        },
                    },
                    options: [
                        {
                            displayName: 'Attachment Prefix',
                            name: 'dataPropertyAttachmentsPrefixName',
                            type: 'string',
                            default: 'attachment_',
                            description: "Prefix for name of the binary property to which to write the attachment. An index starting with 0 will be added. So if name is 'attachment_' the first attachment is saved to 'attachment_0'.",
                        },
                        {
                            displayName: 'Download Attachments',
                            name: 'downloadAttachments',
                            type: 'boolean',
                            default: false,
                            description: "Whether the emaail's attachments will be downloaded",
                        },
                    ],
                },
            ],
        };
        this.methods = {
            loadOptions: {
                async getLabels() {
                    const returnData = [];
                    const labels = await GenericFunctions_1.googleApiRequestAllItems.call(this, 'labels', 'GET', '/gmail/v1/users/me/labels');
                    for (const label of labels) {
                        returnData.push({
                            name: label.name,
                            value: label.id,
                        });
                    }
                    return returnData.sort((a, b) => {
                        if (a.name < b.name) {
                            return -1;
                        }
                        if (a.name > b.name) {
                            return 1;
                        }
                        return 0;
                    });
                },
            },
        };
    }
    async poll() {
        const webhookData = this.getWorkflowStaticData('node');
        let responseData;
        const now = Math.floor(luxon_1.DateTime.now().toSeconds()).toString();
        const startDate = webhookData.lastTimeChecked || +now;
        const endDate = +now;
        const options = this.getNodeParameter('options', {});
        const filters = this.getNodeParameter('filters', {});
        try {
            const qs = {};
            filters.receivedAfter = startDate;
            if (this.getMode() === 'manual') {
                qs.maxResults = 1;
                delete filters.receivedAfter;
            }
            Object.assign(qs, GenericFunctions_1.prepareQuery.call(this, filters, 0), options);
            responseData = await GenericFunctions_1.googleApiRequest.call(this, 'GET', '/gmail/v1/users/me/messages', {}, qs);
            responseData = responseData.messages;
            if (responseData === undefined) {
                responseData = [];
            }
            const simple = this.getNodeParameter('simple');
            if (simple) {
                qs.format = 'metadata';
                qs.metadataHeaders = ['From', 'To', 'Cc', 'Bcc', 'Subject'];
            }
            else {
                qs.format = 'raw';
            }
            for (let i = 0; i < responseData.length; i++) {
                responseData[i] = await GenericFunctions_1.googleApiRequest.call(this, 'GET', `/gmail/v1/users/me/messages/${responseData[i].id}`, {}, qs);
                if (!simple) {
                    const dataPropertyNameDownload = options.dataPropertyAttachmentsPrefixName || 'attachment_';
                    responseData[i] = await GenericFunctions_1.parseRawEmail.call(this, responseData[i], dataPropertyNameDownload);
                }
            }
            if (simple) {
                responseData = this.helpers.returnJsonArray(await GenericFunctions_1.simplifyOutput.call(this, responseData));
            }
        }
        catch (error) {
            if (this.getMode() === 'manual' || !webhookData.lastTimeChecked) {
                throw error;
            }
            const workflow = this.getWorkflow();
            const node = this.getNode();
            this.logger.error(`There was a problem in '${node.name}' node in workflow '${workflow.id}': '${error.description}'`, {
                node: node.name,
                workflowId: workflow.id,
                error,
            });
        }
        const getEmailDateAsSeconds = (email) => {
            const { internalDate, date } = email;
            return internalDate
                ? +internalDate / 1000
                : +luxon_1.DateTime.fromJSDate(new Date(date)).toSeconds();
        };
        const lastEmailDate = responseData.reduce((lastDate, { json }) => {
            const emailDate = getEmailDateAsSeconds(json);
            return emailDate > lastDate ? emailDate : lastDate;
        }, 0);
        const nextPollPossibleDuplicates = responseData.reduce((duplicates, { json }) => {
            const emailDate = getEmailDateAsSeconds(json);
            return emailDate === lastEmailDate
                ? duplicates.concat(json.id)
                : duplicates;
        }, []);
        const possibleDuplicates = webhookData.possibleDuplicates || [];
        if (possibleDuplicates.length) {
            responseData = responseData.filter(({ json }) => {
                const { id } = json;
                return !possibleDuplicates.includes(id);
            });
        }
        webhookData.possibleDuplicates = nextPollPossibleDuplicates;
        webhookData.lastTimeChecked = lastEmailDate || endDate;
        if (Array.isArray(responseData) && responseData.length) {
            return [responseData];
        }
        return null;
    }
}
exports.GmailTrigger = GmailTrigger;
//# sourceMappingURL=GmailTrigger.node.js.map