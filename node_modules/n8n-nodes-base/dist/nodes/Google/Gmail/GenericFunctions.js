"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.simplifyOutput = exports.replayToEmail = exports.unescapeSnippets = exports.prepareEmailAttachments = exports.prepareEmailBody = exports.prepareEmailsInput = exports.prepareQuery = exports.prepareTimestamp = exports.extractEmail = exports.googleApiRequestAllItems = exports.encodeEmail = exports.parseRawEmail = exports.googleApiRequest = void 0;
const mailparser_1 = require("mailparser");
const n8n_workflow_1 = require("n8n-workflow");
const moment_timezone_1 = __importDefault(require("moment-timezone"));
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const luxon_1 = require("luxon");
const lodash_isempty_1 = __importDefault(require("lodash.isempty"));
const mail_composer_1 = __importDefault(require("nodemailer/lib/mail-composer"));
async function getAccessToken(credentials) {
    const scopes = [
        'https://www.googleapis.com/auth/gmail.labels',
        'https://www.googleapis.com/auth/gmail.addons.current.action.compose',
        'https://www.googleapis.com/auth/gmail.addons.current.message.action',
        'https://mail.google.com/',
        'https://www.googleapis.com/auth/gmail.modify',
        'https://www.googleapis.com/auth/gmail.compose',
    ];
    const now = (0, moment_timezone_1.default)().unix();
    credentials.email = credentials.email.trim();
    const privateKey = credentials.privateKey.replace(/\\n/g, '\n').trim();
    const signature = jsonwebtoken_1.default.sign({
        iss: credentials.email,
        sub: credentials.delegatedEmail || credentials.email,
        scope: scopes.join(' '),
        aud: 'https://oauth2.googleapis.com/token',
        iat: now,
        exp: now + 3600,
    }, privateKey, {
        algorithm: 'RS256',
        header: {
            kid: privateKey,
            typ: 'JWT',
            alg: 'RS256',
        },
    });
    const options = {
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        method: 'POST',
        form: {
            grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
            assertion: signature,
        },
        uri: 'https://oauth2.googleapis.com/token',
        json: true,
    };
    return this.helpers.request(options);
}
async function googleApiRequest(method, endpoint, body = {}, qs = {}, uri, option = {}) {
    var _a;
    let options = {
        headers: {
            Accept: 'application/json',
            'Content-Type': 'application/json',
        },
        method,
        body,
        qs,
        uri: uri || `https://www.googleapis.com${endpoint}`,
        qsStringifyOptions: {
            arrayFormat: 'repeat',
        },
        json: true,
    };
    options = Object.assign({}, options, option);
    try {
        if (Object.keys(body).length === 0) {
            delete options.body;
        }
        let credentialType = 'gmailOAuth2';
        const authentication = this.getNodeParameter('authentication', 0);
        if (authentication === 'serviceAccount') {
            const credentials = await this.getCredentials('googleApi');
            credentialType = 'googleApi';
            const { access_token } = await getAccessToken.call(this, credentials);
            options.headers.Authorization = `Bearer ${access_token}`;
        }
        const response = await this.helpers.requestWithAuthentication.call(this, credentialType, options);
        return response;
    }
    catch (error) {
        if (error.code === 'ERR_OSSL_PEM_NO_START_LINE') {
            error.statusCode = '401';
        }
        if (error.httpCode === '400') {
            if (error.cause && (error.cause.message || '').includes('Invalid id value')) {
                const resource = this.getNodeParameter('resource', 0);
                const errorOptions = {
                    message: `Invalid ${resource} ID`,
                    description: `${resource.charAt(0).toUpperCase() + resource.slice(1)} IDs should look something like this: 182b676d244938bd`,
                };
                throw new n8n_workflow_1.NodeApiError(this.getNode(), error, errorOptions);
            }
        }
        if (error.httpCode === '404') {
            let resource = this.getNodeParameter('resource', 0);
            if (resource === 'label') {
                resource = 'label ID';
            }
            const errorOptions = {
                message: `${resource.charAt(0).toUpperCase() + resource.slice(1)} not found`,
                description: '',
            };
            throw new n8n_workflow_1.NodeApiError(this.getNode(), error, errorOptions);
        }
        if (error.httpCode === '409') {
            const resource = this.getNodeParameter('resource', 0);
            if (resource === 'label') {
                const errorOptions = {
                    message: 'Label name exists already',
                    description: '',
                };
                throw new n8n_workflow_1.NodeApiError(this.getNode(), error, errorOptions);
            }
        }
        if (error.code === 'EAUTH') {
            const errorOptions = {
                message: ((_a = error === null || error === void 0 ? void 0 : error.body) === null || _a === void 0 ? void 0 : _a.error_description) || 'Authorization error',
                description: error.message,
            };
            throw new n8n_workflow_1.NodeApiError(this.getNode(), error, errorOptions);
        }
        if ((error.message || '').includes('Bad request - please check your parameters') &&
            error.description) {
            const errorOptions = {
                message: error.description,
                description: '',
            };
            throw new n8n_workflow_1.NodeApiError(this.getNode(), error, errorOptions);
        }
        throw new n8n_workflow_1.NodeApiError(this.getNode(), error, {
            message: error.message,
            description: error.description,
        });
    }
}
exports.googleApiRequest = googleApiRequest;
async function parseRawEmail(messageData, dataPropertyNameDownload) {
    const messageEncoded = Buffer.from(messageData.raw, 'base64').toString('utf8');
    const responseData = await (0, mailparser_1.simpleParser)(messageEncoded);
    const headers = {};
    for (const header of responseData.headerLines) {
        headers[header.key] = header.line;
    }
    const binaryData = {};
    if (responseData.attachments) {
        const downloadAttachments = this.getNodeParameter('options.downloadAttachments', 0, false);
        if (downloadAttachments) {
            for (let i = 0; i < responseData.attachments.length; i++) {
                const attachment = responseData.attachments[i];
                binaryData[`${dataPropertyNameDownload}${i}`] = await this.helpers.prepareBinaryData(attachment.content, attachment.filename, attachment.contentType);
            }
        }
    }
    const mailBaseData = {};
    const resolvedModeAddProperties = ['id', 'threadId', 'labelIds', 'sizeEstimate'];
    for (const key of resolvedModeAddProperties) {
        mailBaseData[key] = messageData[key];
    }
    const json = Object.assign({}, mailBaseData, responseData, {
        headers,
        headerLines: undefined,
        attachments: undefined,
    });
    return {
        json,
        binary: Object.keys(binaryData).length ? binaryData : undefined,
    };
}
exports.parseRawEmail = parseRawEmail;
async function encodeEmail(email) {
    const mailOptions = {
        from: email.from,
        to: email.to,
        cc: email.cc,
        bcc: email.bcc,
        inReplyTo: email.inReplyTo,
        references: email.reference,
        subject: email.subject,
        text: email.body,
        keepBcc: true,
    };
    if (email.htmlBody) {
        mailOptions.html = email.htmlBody;
    }
    if (email.attachments !== undefined &&
        Array.isArray(email.attachments) &&
        email.attachments.length > 0) {
        const attachments = email.attachments.map((attachment) => ({
            filename: attachment.name,
            content: attachment.content,
            contentType: attachment.type,
            encoding: 'base64',
        }));
        mailOptions.attachments = attachments;
    }
    const mail = new mail_composer_1.default(mailOptions).compile();
    mail.keepBcc = true;
    const mailBody = await mail.build();
    return mailBody.toString('base64').replace(/\+/g, '-').replace(/\//g, '_');
}
exports.encodeEmail = encodeEmail;
async function googleApiRequestAllItems(propertyName, method, endpoint, body = {}, query = {}) {
    const returnData = [];
    let responseData;
    query.maxResults = 100;
    do {
        responseData = await googleApiRequest.call(this, method, endpoint, body, query);
        query.pageToken = responseData.nextPageToken;
        returnData.push.apply(returnData, responseData[propertyName]);
    } while (responseData.nextPageToken !== undefined && responseData.nextPageToken !== '');
    return returnData;
}
exports.googleApiRequestAllItems = googleApiRequestAllItems;
function extractEmail(s) {
    if (s.includes('<')) {
        const data = s.split('<')[1];
        return data.substring(0, data.length - 1);
    }
    return s;
}
exports.extractEmail = extractEmail;
const prepareTimestamp = (node, itemIndex, query, dateValue, label) => {
    if (dateValue instanceof luxon_1.DateTime) {
        dateValue = dateValue.toISO();
    }
    let timestamp = luxon_1.DateTime.fromISO(dateValue).toSeconds();
    const timestampLengthInMilliseconds1990 = 12;
    if (typeof timestamp === 'number') {
        timestamp = Math.round(timestamp);
    }
    if (!timestamp &&
        typeof dateValue === 'number' &&
        dateValue.toString().length < timestampLengthInMilliseconds1990) {
        timestamp = dateValue;
    }
    if (!timestamp && dateValue.length < timestampLengthInMilliseconds1990) {
        timestamp = parseInt(dateValue, 10);
    }
    if (!timestamp) {
        timestamp = Math.floor(luxon_1.DateTime.fromMillis(parseInt(dateValue, 10)).toSeconds());
    }
    if (!timestamp) {
        const description = `'${dateValue}' isn't a valid date and time. If you're using an expression, be sure to set an ISO date string or a timestamp.`;
        throw new n8n_workflow_1.NodeOperationError(node, `Invalid date/time in 'Received ${label[0].toUpperCase() + label.slice(1)}' field`, {
            description,
            itemIndex,
        });
    }
    if (query) {
        query += ` ${label}:${timestamp}`;
    }
    else {
        query = `${label}:${timestamp}`;
    }
    return query;
};
exports.prepareTimestamp = prepareTimestamp;
function prepareQuery(fields, itemIndex) {
    const qs = { ...fields };
    if (qs.labelIds) {
        if (qs.labelIds === '') {
            delete qs.labelIds;
        }
        else {
            qs.labelIds = qs.labelIds;
        }
    }
    if (qs.sender) {
        if (qs.q) {
            qs.q += ` from:${qs.sender}`;
        }
        else {
            qs.q = `from:${qs.sender}`;
        }
        delete qs.sender;
    }
    if (qs.readStatus && qs.readStatus !== 'both') {
        if (qs.q) {
            qs.q += ` is:${qs.readStatus}`;
        }
        else {
            qs.q = `is:${qs.readStatus}`;
        }
        delete qs.readStatus;
    }
    if (qs.receivedAfter) {
        qs.q = (0, exports.prepareTimestamp)(this.getNode(), itemIndex, qs.q, qs.receivedAfter, 'after');
        delete qs.receivedAfter;
    }
    if (qs.receivedBefore) {
        qs.q = (0, exports.prepareTimestamp)(this.getNode(), itemIndex, qs.q, qs.receivedBefore, 'before');
        delete qs.receivedBefore;
    }
    return qs;
}
exports.prepareQuery = prepareQuery;
function prepareEmailsInput(input, fieldName, itemIndex) {
    let emails = '';
    input.split(',').forEach((entry) => {
        const email = entry.trim();
        if (email.indexOf('@') === -1) {
            const description = `The email address '${email}' in the '${fieldName}' field isn't valid`;
            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Invalid email address', {
                description,
                itemIndex,
            });
        }
        if (email.includes('<') && email.includes('>')) {
            emails += `${email},`;
        }
        else {
            emails += `<${email}>, `;
        }
    });
    return emails;
}
exports.prepareEmailsInput = prepareEmailsInput;
function prepareEmailBody(itemIndex) {
    const emailType = this.getNodeParameter('emailType', itemIndex);
    let body = '';
    let htmlBody = '';
    if (emailType === 'html') {
        htmlBody = this.getNodeParameter('message', itemIndex, '').trim();
    }
    else {
        body = this.getNodeParameter('message', itemIndex, '').trim();
    }
    return { body, htmlBody };
}
exports.prepareEmailBody = prepareEmailBody;
async function prepareEmailAttachments(options, items, itemIndex) {
    const attachmentsList = [];
    const attachments = options.attachmentsBinary;
    if (attachments && !(0, lodash_isempty_1.default)(attachments)) {
        for (const { property } of attachments) {
            for (const name of property.split(',')) {
                const binaryData = this.helpers.assertBinaryData(itemIndex, name);
                const binaryDataBuffer = await this.helpers.getBinaryDataBuffer(itemIndex, name);
                if (!Buffer.isBuffer(binaryDataBuffer)) {
                    const description = `The input field '${name}' doesn't contain an attachment. Please make sure you specify a field containing binary data`;
                    throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Attachment not found', {
                        description,
                        itemIndex,
                    });
                }
                attachmentsList.push({
                    name: binaryData.fileName || 'unknown',
                    content: binaryDataBuffer,
                    type: binaryData.mimeType,
                });
            }
        }
    }
    return attachmentsList;
}
exports.prepareEmailAttachments = prepareEmailAttachments;
function unescapeSnippets(items) {
    const result = items.map((item) => {
        const snippet = item.json.snippet;
        if (snippet) {
            item.json.snippet = snippet.replace(/&amp;|&lt;|&gt;|&#39;|&quot;/g, (match) => {
                switch (match) {
                    case '&amp;':
                        return '&';
                    case '&lt;':
                        return '<';
                    case '&gt;':
                        return '>';
                    case '&#39;':
                        return "'";
                    case '&quot;':
                        return '"';
                    default:
                        return match;
                }
            });
        }
        return item;
    });
    return result;
}
exports.unescapeSnippets = unescapeSnippets;
async function replayToEmail(items, gmailId, options, itemIndex) {
    var _a, _b;
    let qs = {};
    let cc = '';
    let bcc = '';
    if (options.ccList) {
        cc = prepareEmailsInput.call(this, options.ccList, 'CC', itemIndex);
    }
    if (options.bccList) {
        bcc = prepareEmailsInput.call(this, options.bccList, 'BCC', itemIndex);
    }
    let attachments = [];
    if (options.attachmentsUi) {
        attachments = await prepareEmailAttachments.call(this, options.attachmentsUi, items, itemIndex);
        if (attachments.length) {
            qs = {
                userId: 'me',
                uploadType: 'media',
            };
        }
    }
    const endpoint = `/gmail/v1/users/me/messages/${gmailId}`;
    qs.format = 'metadata';
    const { payload, threadId } = await googleApiRequest.call(this, 'GET', endpoint, {}, qs);
    const subject = ((_a = payload.headers.filter((data) => data.name.toLowerCase() === 'subject')[0]) === null || _a === void 0 ? void 0 : _a.value) || '';
    const messageIdGlobal = ((_b = payload.headers.filter((data) => data.name.toLowerCase() === 'message-id')[0]) === null || _b === void 0 ? void 0 : _b.value) || '';
    const { emailAddress } = await googleApiRequest.call(this, 'GET', '/gmail/v1/users/me/profile');
    let to = '';
    const replyToSenderOnly = options.replyToSenderOnly === undefined ? false : options.replyToSenderOnly;
    const prepareEmailString = (email) => {
        if (email.includes(emailAddress))
            return;
        if (email.includes('<') && email.includes('>')) {
            to += `${email}, `;
        }
        else {
            to += `<${email}>, `;
        }
    };
    for (const header of payload.headers) {
        if ((header.name || '').toLowerCase() === 'from') {
            const from = header.value;
            if (from.includes('<') && from.includes('>')) {
                to += `${from}, `;
            }
            else {
                to += `<${from}>, `;
            }
        }
        if ((header.name || '').toLowerCase() === 'to' && !replyToSenderOnly) {
            const toEmails = header.value;
            toEmails.split(',').forEach(prepareEmailString);
        }
    }
    let from = '';
    if (options.senderName) {
        from = `${options.senderName} <${emailAddress}>`;
    }
    const email = {
        from,
        to,
        cc,
        bcc,
        subject,
        attachments,
        inReplyTo: messageIdGlobal,
        reference: messageIdGlobal,
        ...prepareEmailBody.call(this, itemIndex),
    };
    const body = {
        raw: await encodeEmail(email),
        threadId,
    };
    return googleApiRequest.call(this, 'POST', '/gmail/v1/users/me/messages/send', body, qs);
}
exports.replayToEmail = replayToEmail;
async function simplifyOutput(data) {
    const labelsData = await googleApiRequest.call(this, 'GET', '/gmail/v1/users/me/labels');
    const labels = (labelsData.labels || []).map(({ id, name }) => ({
        id,
        name,
    }));
    return (data || []).map((item) => {
        if (item.labelIds) {
            item.labels = labels.filter((label) => item.labelIds.includes(label.id));
            delete item.labelIds;
        }
        if (item.payload && item.payload.headers) {
            const { headers } = item.payload;
            (headers || []).forEach((header) => {
                item[header.name] = header.value;
            });
            delete item.payload.headers;
        }
        return item;
    });
}
exports.simplifyOutput = simplifyOutput;
//# sourceMappingURL=GenericFunctions.js.map