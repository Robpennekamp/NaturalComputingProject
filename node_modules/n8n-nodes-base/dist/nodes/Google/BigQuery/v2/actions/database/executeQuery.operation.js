"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = exports.description = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const utilities_1 = require("../../../../../../utils/utilities");
const utils_1 = require("../../helpers/utils");
const transport_1 = require("../../transport");
const properties = [
    {
        displayName: 'SQL Query',
        name: 'sqlQuery',
        type: 'string',
        typeOptions: {
            editor: 'sqlEditor',
        },
        displayOptions: {
            hide: {
                '/options.useLegacySql': [true],
            },
        },
        default: '',
        placeholder: 'SELECT * FROM dataset.table LIMIT 100',
        description: 'SQL query to execute, you can find more information <a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax" target="_blank">here</a>. Standard SQL syntax used by default, but you can also use Legacy SQL syntax by using optinon \'Use Legacy SQL\'.',
    },
    {
        displayName: 'SQL Query',
        name: 'sqlQuery',
        type: 'string',
        typeOptions: {
            editor: 'sqlEditor',
        },
        displayOptions: {
            show: {
                '/options.useLegacySql': [true],
            },
        },
        default: '',
        placeholder: 'SELECT * FROM [project:dataset.table] LIMIT 100;',
        hint: 'Legacy SQL syntax',
        description: 'SQL query to execute, you can find more information about Legacy SQL syntax <a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax" target="_blank">here</a>',
    },
    {
        displayName: 'Options',
        name: 'options',
        type: 'collection',
        placeholder: 'Add Options',
        default: {},
        options: [
            {
                displayName: 'Default Dataset Name or ID',
                name: 'defaultDataset',
                type: 'options',
                typeOptions: {
                    loadOptionsMethod: 'getDatasets',
                    loadOptionsDependsOn: ['projectId.value'],
                },
                default: '',
                description: 'If not set, all table names in the query string must be qualified in the format \'datasetId.tableId\'. Choose from the list, or specify an ID using an <a href="https://docs.n8n.io/code-examples/expressions/">expression</a>.',
            },
            {
                displayName: 'Dry Run',
                name: 'dryRun',
                type: 'boolean',
                default: false,
                description: "Whether set to true BigQuery doesn't run the job. Instead, if the query is valid, BigQuery returns statistics about the job such as how many bytes would be processed. If the query is invalid, an error returns.",
            },
            {
                displayName: 'Include Schema in Output',
                name: 'includeSchema',
                type: 'boolean',
                default: false,
                description: "Whether to include the schema in the output. If set to true, the output will contain key '_schema' with the schema of the table.",
                displayOptions: {
                    hide: {
                        rawOutput: [true],
                    },
                },
            },
            {
                displayName: 'Location',
                name: 'location',
                type: 'string',
                default: '',
                placeholder: 'e.g. europe-west3',
                description: 'Location or the region where data would be stored and processed. Pricing for storage and analysis is also defined by location of data and reservations, more information <a href="https://cloud.google.com/bigquery/docs/locations" target="_blank">here</a>.',
            },
            {
                displayName: 'Maximum Bytes Billed',
                name: 'maximumBytesBilled',
                type: 'string',
                default: '',
                description: 'Limits the bytes billed for this query. Queries with bytes billed above this limit will fail (without incurring a charge). String in <a href="https://developers.google.com/discovery/v1/type-format?utm_source=cloud.google.com&utm_medium=referral" target="_blank">Int64Value</a> format',
            },
            {
                displayName: 'Max Results',
                name: 'maxResults',
                type: 'number',
                default: 1000,
                description: 'The maximum number of rows of data to return',
            },
            {
                displayName: 'Timeout',
                name: 'timeoutMs',
                type: 'number',
                default: 10000,
                description: 'How long to wait for the query to complete, in milliseconds',
            },
            {
                displayName: 'Raw Output',
                name: 'rawOutput',
                type: 'boolean',
                default: false,
                displayOptions: {
                    hide: {
                        dryRun: [true],
                    },
                },
            },
            {
                displayName: 'Use Legacy SQL',
                name: 'useLegacySql',
                type: 'boolean',
                default: false,
                description: "Whether to use BigQuery's legacy SQL dialect for this query. If set to false, the query will use BigQuery's standard SQL.",
            },
        ],
    },
];
const displayOptions = {
    show: {
        resource: ['database'],
        operation: ['executeQuery'],
    },
};
exports.description = (0, utilities_1.updateDisplayOptions)(displayOptions, properties);
async function execute() {
    var _a, _b, _c, _d;
    const items = this.getInputData();
    const length = items.length;
    const returnData = [];
    let jobs = [];
    for (let i = 0; i < length; i++) {
        try {
            const sqlQuery = this.getNodeParameter('sqlQuery', i);
            const options = this.getNodeParameter('options', i);
            const projectId = this.getNodeParameter('projectId', i, undefined, {
                extractValue: true,
            });
            let rawOutput = false;
            let includeSchema = false;
            if (options.rawOutput !== undefined) {
                rawOutput = options.rawOutput;
                delete options.rawOutput;
            }
            if (options.includeSchema !== undefined) {
                includeSchema = options.includeSchema;
                delete options.includeSchema;
            }
            const body = { ...options };
            body.query = sqlQuery;
            if (body.defaultDataset) {
                body.defaultDataset = {
                    datasetId: options.defaultDataset,
                    projectId,
                };
            }
            if (body.useLegacySql === undefined) {
                body.useLegacySql = false;
            }
            const response = await transport_1.googleApiRequest.call(this, 'POST', `/v2/projects/${projectId}/jobs`, {
                configuration: {
                    query: body,
                },
            });
            if (!((_a = response === null || response === void 0 ? void 0 : response.jobReference) === null || _a === void 0 ? void 0 : _a.jobId)) {
                throw new n8n_workflow_1.NodeOperationError(this.getNode(), `No job ID returned, item ${i}`, {
                    description: `sql: ${sqlQuery}`,
                    itemIndex: i,
                });
            }
            const jobId = (_b = response === null || response === void 0 ? void 0 : response.jobReference) === null || _b === void 0 ? void 0 : _b.jobId;
            const raw = rawOutput || options.dryRun || false;
            if (((_c = response.status) === null || _c === void 0 ? void 0 : _c.state) === 'DONE') {
                const qs = options.location ? { location: options.location } : {};
                const queryResponse = await transport_1.googleApiRequest.call(this, 'GET', `/v2/projects/${projectId}/queries/${jobId}`, undefined, qs);
                returnData.push(...(0, utils_1.prepareOutput)(queryResponse, i, raw, includeSchema));
            }
            else {
                jobs.push({ jobId, projectId, i, raw, includeSchema, location: options.location });
            }
        }
        catch (error) {
            if (this.continueOnFail()) {
                const executionErrorData = this.helpers.constructExecutionMetaData(this.helpers.returnJsonArray({ error: error.message }), { itemData: { item: i } });
                returnData.push(...executionErrorData);
                continue;
            }
            throw new n8n_workflow_1.NodeOperationError(this.getNode(), error.message, {
                itemIndex: i,
                description: error === null || error === void 0 ? void 0 : error.description,
            });
        }
    }
    let waitTime = 1000;
    while (jobs.length > 0) {
        const completedJobs = [];
        for (const job of jobs) {
            try {
                const qs = job.location ? { location: job.location } : {};
                const response = await transport_1.googleApiRequest.call(this, 'GET', `/v2/projects/${job.projectId}/queries/${job.jobId}`, undefined, qs);
                if (response.jobComplete) {
                    completedJobs.push(job.jobId);
                    returnData.push(...(0, utils_1.prepareOutput)(response, job.i, job.raw, job.includeSchema));
                }
                if ((_d = response === null || response === void 0 ? void 0 : response.errors) === null || _d === void 0 ? void 0 : _d.length) {
                    const errorMessages = response.errors.map((error) => error.message);
                    throw new Error(`Error(s) ocurring while executing query from item ${job.i.toString()}: ${errorMessages.join(', ')}`);
                }
            }
            catch (error) {
                if (this.continueOnFail()) {
                    const executionErrorData = this.helpers.constructExecutionMetaData(this.helpers.returnJsonArray({ error: error.message }), { itemData: { item: job.i } });
                    returnData.push(...executionErrorData);
                    continue;
                }
                throw new n8n_workflow_1.NodeOperationError(this.getNode(), error.message, {
                    itemIndex: job.i,
                    description: error === null || error === void 0 ? void 0 : error.description,
                });
            }
        }
        jobs = jobs.filter((job) => !completedJobs.includes(job.jobId));
        if (jobs.length > 0) {
            await (0, n8n_workflow_1.sleep)(waitTime);
            if (waitTime < 30000) {
                waitTime = waitTime * 2;
            }
        }
    }
    return returnData;
}
exports.execute = execute;
//# sourceMappingURL=executeQuery.operation.js.map