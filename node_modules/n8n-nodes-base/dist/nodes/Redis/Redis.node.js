"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Redis = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const lodash_set_1 = __importDefault(require("lodash.set"));
const redis_1 = __importDefault(require("redis"));
const util_1 = __importDefault(require("util"));
class Redis {
    constructor() {
        this.description = {
            displayName: 'Redis',
            name: 'redis',
            icon: 'file:redis.svg',
            group: ['input'],
            version: 1,
            description: 'Get, send and update data in Redis',
            defaults: {
                name: 'Redis',
            },
            inputs: ['main'],
            outputs: ['main'],
            credentials: [
                {
                    name: 'redis',
                    required: true,
                    testedBy: 'redisConnectionTest',
                },
            ],
            properties: [
                {
                    displayName: 'Operation',
                    name: 'operation',
                    type: 'options',
                    noDataExpression: true,
                    options: [
                        {
                            name: 'Delete',
                            value: 'delete',
                            description: 'Delete a key from Redis',
                            action: 'Delete a key from Redis',
                        },
                        {
                            name: 'Get',
                            value: 'get',
                            description: 'Get the value of a key from Redis',
                            action: 'Get the value of a key from Redis',
                        },
                        {
                            name: 'Increment',
                            value: 'incr',
                            description: 'Atomically increments a key by 1. Creates the key if it does not exist.',
                            action: 'Atomically increment a key by 1. Creates the key if it does not exist.',
                        },
                        {
                            name: 'Info',
                            value: 'info',
                            description: 'Returns generic information about the Redis instance',
                            action: 'Return generic information about the Redis instance',
                        },
                        {
                            name: 'Keys',
                            value: 'keys',
                            description: 'Returns all the keys matching a pattern',
                            action: 'Return all keys matching a pattern',
                        },
                        {
                            name: 'Pop',
                            value: 'pop',
                            description: 'Pop data from a redis list',
                            action: 'Pop data from a redis list',
                        },
                        {
                            name: 'Publish',
                            value: 'publish',
                            description: 'Publish message to redis channel',
                            action: 'Publish message to redis channel',
                        },
                        {
                            name: 'Push',
                            value: 'push',
                            description: 'Push data to a redis list',
                            action: 'Push data to a redis list',
                        },
                        {
                            name: 'Set',
                            value: 'set',
                            description: 'Set the value of a key in redis',
                            action: 'Set the value of a key in redis',
                        },
                    ],
                    default: 'info',
                },
                {
                    displayName: 'Name',
                    name: 'propertyName',
                    type: 'string',
                    displayOptions: {
                        show: {
                            operation: ['get'],
                        },
                    },
                    default: 'propertyName',
                    required: true,
                    description: 'Name of the property to write received data to. Supports dot-notation. Example: "data.person[0].name".',
                },
                {
                    displayName: 'Key',
                    name: 'key',
                    type: 'string',
                    displayOptions: {
                        show: {
                            operation: ['delete'],
                        },
                    },
                    default: '',
                    required: true,
                    description: 'Name of the key to delete from Redis',
                },
                {
                    displayName: 'Key',
                    name: 'key',
                    type: 'string',
                    displayOptions: {
                        show: {
                            operation: ['get'],
                        },
                    },
                    default: '',
                    required: true,
                    description: 'Name of the key to get from Redis',
                },
                {
                    displayName: 'Key Type',
                    name: 'keyType',
                    type: 'options',
                    displayOptions: {
                        show: {
                            operation: ['get'],
                        },
                    },
                    options: [
                        {
                            name: 'Automatic',
                            value: 'automatic',
                            description: 'Requests the type before requesting the data (slower)',
                        },
                        {
                            name: 'Hash',
                            value: 'hash',
                            description: "Data in key is of type 'hash'",
                        },
                        {
                            name: 'List',
                            value: 'list',
                            description: "Data in key is of type 'lists'",
                        },
                        {
                            name: 'Sets',
                            value: 'sets',
                            description: "Data in key is of type 'sets'",
                        },
                        {
                            name: 'String',
                            value: 'string',
                            description: "Data in key is of type 'string'",
                        },
                    ],
                    default: 'automatic',
                    description: 'The type of the key to get',
                },
                {
                    displayName: 'Options',
                    name: 'options',
                    type: 'collection',
                    displayOptions: {
                        show: {
                            operation: ['get'],
                        },
                    },
                    placeholder: 'Add Option',
                    default: {},
                    options: [
                        {
                            displayName: 'Dot Notation',
                            name: 'dotNotation',
                            type: 'boolean',
                            default: true,
                            description: '<p>By default, dot-notation is used in property names. This means that "a.b" will set the property "b" underneath "a" so { "a": { "b": value} }.<p></p>If that is not intended this can be deactivated, it will then set { "a.b": value } instead.</p>.',
                        },
                    ],
                },
                {
                    displayName: 'Key',
                    name: 'key',
                    type: 'string',
                    displayOptions: {
                        show: {
                            operation: ['incr'],
                        },
                    },
                    default: '',
                    required: true,
                    description: 'Name of the key to increment',
                },
                {
                    displayName: 'Expire',
                    name: 'expire',
                    type: 'boolean',
                    displayOptions: {
                        show: {
                            operation: ['incr'],
                        },
                    },
                    default: false,
                    description: 'Whether to set a timeout on key',
                },
                {
                    displayName: 'TTL',
                    name: 'ttl',
                    type: 'number',
                    typeOptions: {
                        minValue: 1,
                    },
                    displayOptions: {
                        show: {
                            operation: ['incr'],
                            expire: [true],
                        },
                    },
                    default: 60,
                    description: 'Number of seconds before key expiration',
                },
                {
                    displayName: 'Key Pattern',
                    name: 'keyPattern',
                    type: 'string',
                    displayOptions: {
                        show: {
                            operation: ['keys'],
                        },
                    },
                    default: '',
                    required: true,
                    description: 'The key pattern for the keys to return',
                },
                {
                    displayName: 'Get Values',
                    name: 'getValues',
                    type: 'boolean',
                    displayOptions: {
                        show: {
                            operation: ['keys'],
                        },
                    },
                    default: true,
                    description: 'Whether to get the value of matching keys',
                },
                {
                    displayName: 'Key',
                    name: 'key',
                    type: 'string',
                    displayOptions: {
                        show: {
                            operation: ['set'],
                        },
                    },
                    default: '',
                    required: true,
                    description: 'Name of the key to set in Redis',
                },
                {
                    displayName: 'Value',
                    name: 'value',
                    type: 'string',
                    displayOptions: {
                        show: {
                            operation: ['set'],
                        },
                    },
                    default: '',
                    description: 'The value to write in Redis',
                },
                {
                    displayName: 'Key Type',
                    name: 'keyType',
                    type: 'options',
                    displayOptions: {
                        show: {
                            operation: ['set'],
                        },
                    },
                    options: [
                        {
                            name: 'Automatic',
                            value: 'automatic',
                            description: 'Tries to figure out the type automatically depending on the data',
                        },
                        {
                            name: 'Hash',
                            value: 'hash',
                            description: "Data in key is of type 'hash'",
                        },
                        {
                            name: 'List',
                            value: 'list',
                            description: "Data in key is of type 'lists'",
                        },
                        {
                            name: 'Sets',
                            value: 'sets',
                            description: "Data in key is of type 'sets'",
                        },
                        {
                            name: 'String',
                            value: 'string',
                            description: "Data in key is of type 'string'",
                        },
                    ],
                    default: 'automatic',
                    description: 'The type of the key to set',
                },
                {
                    displayName: 'Value Is JSON',
                    name: 'valueIsJSON',
                    type: 'boolean',
                    displayOptions: {
                        show: {
                            keyType: ['hash'],
                        },
                    },
                    default: true,
                    description: 'Whether the value is JSON or key value pairs',
                },
                {
                    displayName: 'Expire',
                    name: 'expire',
                    type: 'boolean',
                    displayOptions: {
                        show: {
                            operation: ['set'],
                        },
                    },
                    default: false,
                    description: 'Whether to set a timeout on key',
                },
                {
                    displayName: 'TTL',
                    name: 'ttl',
                    type: 'number',
                    typeOptions: {
                        minValue: 1,
                    },
                    displayOptions: {
                        show: {
                            operation: ['set'],
                            expire: [true],
                        },
                    },
                    default: 60,
                    description: 'Number of seconds before key expiration',
                },
                {
                    displayName: 'Channel',
                    name: 'channel',
                    type: 'string',
                    displayOptions: {
                        show: {
                            operation: ['publish'],
                        },
                    },
                    default: '',
                    required: true,
                    description: 'Channel name',
                },
                {
                    displayName: 'Data',
                    name: 'messageData',
                    type: 'string',
                    displayOptions: {
                        show: {
                            operation: ['publish'],
                        },
                    },
                    default: '',
                    required: true,
                    description: 'Data to publish',
                },
                {
                    displayName: 'List',
                    name: 'list',
                    type: 'string',
                    displayOptions: {
                        show: {
                            operation: ['push', 'pop'],
                        },
                    },
                    default: '',
                    required: true,
                    description: 'Name of the list in Redis',
                },
                {
                    displayName: 'Data',
                    name: 'messageData',
                    type: 'string',
                    displayOptions: {
                        show: {
                            operation: ['push'],
                        },
                    },
                    default: '',
                    required: true,
                    description: 'Data to push',
                },
                {
                    displayName: 'Tail',
                    name: 'tail',
                    type: 'boolean',
                    displayOptions: {
                        show: {
                            operation: ['push', 'pop'],
                        },
                    },
                    default: false,
                    description: 'Whether to push or pop data from the end of the list',
                },
                {
                    displayName: 'Name',
                    name: 'propertyName',
                    type: 'string',
                    displayOptions: {
                        show: {
                            operation: ['pop'],
                        },
                    },
                    default: 'propertyName',
                    description: 'Optional name of the property to write received data to. Supports dot-notation. Example: "data.person[0].name".',
                },
                {
                    displayName: 'Options',
                    name: 'options',
                    type: 'collection',
                    displayOptions: {
                        show: {
                            operation: ['pop'],
                        },
                    },
                    placeholder: 'Add Option',
                    default: {},
                    options: [
                        {
                            displayName: 'Dot Notation',
                            name: 'dotNotation',
                            type: 'boolean',
                            default: true,
                            description: '<p>By default, dot-notation is used in property names. This means that "a.b" will set the property "b" underneath "a" so { "a": { "b": value} }.<p></p>If that is not intended this can be deactivated, it will then set { "a.b": value } instead.</p>.',
                        },
                    ],
                },
            ],
        };
        this.methods = {
            credentialTest: {
                async redisConnectionTest(credential) {
                    const credentials = credential.data;
                    const redisOptions = {
                        host: credentials.host,
                        port: credentials.port,
                        db: credentials.database,
                    };
                    if (credentials.password) {
                        redisOptions.password = credentials.password;
                    }
                    try {
                        const client = redis_1.default.createClient(redisOptions);
                        await new Promise((resolve, reject) => {
                            client.on('connect', async () => {
                                client.ping('ping', (error, pong) => {
                                    if (error)
                                        reject(error);
                                    resolve(pong);
                                    client.quit();
                                });
                            });
                            client.on('error', async (err) => {
                                client.quit();
                                reject(err);
                            });
                        });
                    }
                    catch (error) {
                        return {
                            status: 'Error',
                            message: error.message,
                        };
                    }
                    return {
                        status: 'OK',
                        message: 'Connection successful!',
                    };
                },
            },
        };
    }
    async execute() {
        function getParsedValue(value) {
            if (value.match(/^[\d\.]+$/) === null) {
                return value;
            }
            else {
                return parseFloat(value);
            }
        }
        function convertInfoToObject(stringData) {
            const returnData = {};
            let key, value;
            for (const line of stringData.split('\n')) {
                if (['#', ''].includes(line.charAt(0))) {
                    continue;
                }
                [key, value] = line.split(':');
                if (key === undefined || value === undefined) {
                    continue;
                }
                value = value.trim();
                if (value.includes('=')) {
                    returnData[key] = {};
                    let key2, value2;
                    for (const keyValuePair of value.split(',')) {
                        [key2, value2] = keyValuePair.split('=');
                        returnData[key][key2] = getParsedValue(value2);
                    }
                }
                else {
                    returnData[key] = getParsedValue(value);
                }
            }
            return returnData;
        }
        async function getValue(client, keyName, type) {
            if (type === undefined || type === 'automatic') {
                const clientType = util_1.default.promisify(client.type).bind(client);
                type = await clientType(keyName);
            }
            if (type === 'string') {
                const clientGet = util_1.default.promisify(client.get).bind(client);
                return clientGet(keyName);
            }
            else if (type === 'hash') {
                const clientHGetAll = util_1.default.promisify(client.hgetall).bind(client);
                return clientHGetAll(keyName);
            }
            else if (type === 'list') {
                const clientLRange = util_1.default.promisify(client.lrange).bind(client);
                return clientLRange(keyName, 0, -1);
            }
            else if (type === 'sets') {
                const clientSMembers = util_1.default.promisify(client.smembers).bind(client);
                return clientSMembers(keyName);
            }
        }
        const setValue = async (client, keyName, value, expire, ttl, type, valueIsJSON) => {
            if (type === undefined || type === 'automatic') {
                if (typeof value === 'string') {
                    type = 'string';
                }
                else if (Array.isArray(value)) {
                    type = 'list';
                }
                else if (typeof value === 'object') {
                    type = 'hash';
                }
                else {
                    throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Could not identify the type to set. Please set it manually!');
                }
            }
            if (type === 'string') {
                const clientSet = util_1.default.promisify(client.set).bind(client);
                await clientSet(keyName, value.toString());
            }
            else if (type === 'hash') {
                const clientHset = util_1.default.promisify(client.hset).bind(client);
                if (valueIsJSON) {
                    let values;
                    if (typeof value === 'string') {
                        try {
                            values = JSON.parse(value);
                        }
                        catch {
                            values = value;
                        }
                    }
                    else {
                        values = value;
                    }
                    for (const key of Object.keys(values)) {
                        await clientHset(keyName, key, values[key].toString());
                    }
                }
                else {
                    const values = value.toString().split(' ');
                    await clientHset(keyName, values);
                }
            }
            else if (type === 'list') {
                const clientLset = util_1.default.promisify(client.lset).bind(client);
                for (let index = 0; index < value.length; index++) {
                    await clientLset(keyName, index, value[index].toString());
                }
            }
            if (expire) {
                const clientExpire = util_1.default.promisify(client.expire).bind(client);
                await clientExpire(keyName, ttl);
            }
            return;
        };
        return new Promise(async (resolve, reject) => {
            const credentials = await this.getCredentials('redis');
            const redisOptions = {
                host: credentials.host,
                port: credentials.port,
                db: credentials.database,
            };
            if (credentials.password) {
                redisOptions.password = credentials.password;
            }
            const client = redis_1.default.createClient(redisOptions);
            const operation = this.getNodeParameter('operation', 0);
            client.on('error', (err) => {
                client.quit();
                reject(err);
            });
            client.on('ready', async (_err) => {
                client.select(credentials.database);
                try {
                    if (operation === 'info') {
                        const clientInfo = util_1.default.promisify(client.info).bind(client);
                        const result = await clientInfo();
                        resolve(this.prepareOutputData([{ json: convertInfoToObject(result) }]));
                        client.quit();
                    }
                    else if (['delete', 'get', 'keys', 'set', 'incr', 'publish', 'push', 'pop'].includes(operation)) {
                        const items = this.getInputData();
                        const returnItems = [];
                        let item;
                        for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
                            item = { json: {} };
                            if (operation === 'delete') {
                                const keyDelete = this.getNodeParameter('key', itemIndex);
                                const clientDel = util_1.default.promisify(client.del).bind(client);
                                await clientDel(keyDelete);
                                returnItems.push(items[itemIndex]);
                            }
                            else if (operation === 'get') {
                                const propertyName = this.getNodeParameter('propertyName', itemIndex);
                                const keyGet = this.getNodeParameter('key', itemIndex);
                                const keyType = this.getNodeParameter('keyType', itemIndex);
                                const value = (await getValue(client, keyGet, keyType)) || null;
                                const options = this.getNodeParameter('options', itemIndex, {});
                                if (options.dotNotation === false) {
                                    item.json[propertyName] = value;
                                }
                                else {
                                    (0, lodash_set_1.default)(item.json, propertyName, value);
                                }
                                returnItems.push(item);
                            }
                            else if (operation === 'keys') {
                                const keyPattern = this.getNodeParameter('keyPattern', itemIndex);
                                const getValues = this.getNodeParameter('getValues', itemIndex, true);
                                const clientKeys = util_1.default.promisify(client.keys).bind(client);
                                const keys = await clientKeys(keyPattern);
                                if (!getValues) {
                                    returnItems.push({ json: { keys } });
                                    continue;
                                }
                                const promises = {};
                                for (const keyName of keys) {
                                    promises[keyName] = await getValue(client, keyName);
                                }
                                for (const keyName of keys) {
                                    item.json[keyName] = await promises[keyName];
                                }
                                returnItems.push(item);
                            }
                            else if (operation === 'set') {
                                const keySet = this.getNodeParameter('key', itemIndex);
                                const value = this.getNodeParameter('value', itemIndex);
                                const keyType = this.getNodeParameter('keyType', itemIndex);
                                const valueIsJSON = this.getNodeParameter('valueIsJSON', itemIndex, true);
                                const expire = this.getNodeParameter('expire', itemIndex, false);
                                const ttl = this.getNodeParameter('ttl', itemIndex, -1);
                                await setValue(client, keySet, value, expire, ttl, keyType, valueIsJSON);
                                returnItems.push(items[itemIndex]);
                            }
                            else if (operation === 'incr') {
                                const keyIncr = this.getNodeParameter('key', itemIndex);
                                const expire = this.getNodeParameter('expire', itemIndex, false);
                                const ttl = this.getNodeParameter('ttl', itemIndex, -1);
                                const clientIncr = util_1.default.promisify(client.incr).bind(client);
                                const incrementVal = await clientIncr(keyIncr);
                                if (expire && ttl > 0) {
                                    const clientExpire = util_1.default.promisify(client.expire).bind(client);
                                    await clientExpire(keyIncr, ttl);
                                }
                                returnItems.push({ json: { [keyIncr]: incrementVal } });
                            }
                            else if (operation === 'publish') {
                                const channel = this.getNodeParameter('channel', itemIndex);
                                const messageData = this.getNodeParameter('messageData', itemIndex);
                                const clientPublish = util_1.default.promisify(client.publish).bind(client);
                                await clientPublish(channel, messageData);
                                returnItems.push(items[itemIndex]);
                            }
                            else if (operation === 'push') {
                                const redisList = this.getNodeParameter('list', itemIndex);
                                const messageData = this.getNodeParameter('messageData', itemIndex);
                                const tail = this.getNodeParameter('tail', itemIndex, false);
                                const action = tail ? client.RPUSH : client.LPUSH;
                                const clientPush = util_1.default.promisify(action).bind(client);
                                await clientPush(redisList, messageData);
                                returnItems.push(items[itemIndex]);
                            }
                            else if (operation === 'pop') {
                                const redisList = this.getNodeParameter('list', itemIndex);
                                const tail = this.getNodeParameter('tail', itemIndex, false);
                                const propertyName = this.getNodeParameter('propertyName', itemIndex, 'propertyName');
                                const action = tail ? client.rpop : client.lpop;
                                const clientPop = util_1.default.promisify(action).bind(client);
                                const value = await clientPop(redisList);
                                let outputValue;
                                try {
                                    outputValue = JSON.parse(value);
                                }
                                catch {
                                    outputValue = value;
                                }
                                const options = this.getNodeParameter('options', itemIndex, {});
                                if (options.dotNotation === false) {
                                    item.json[propertyName] = outputValue;
                                }
                                else {
                                    (0, lodash_set_1.default)(item.json, propertyName, outputValue);
                                }
                                returnItems.push(item);
                            }
                        }
                        client.quit();
                        resolve(this.prepareOutputData(returnItems));
                    }
                }
                catch (error) {
                    reject(error);
                }
            });
        });
    }
}
exports.Redis = Redis;
//# sourceMappingURL=Redis.node.js.map