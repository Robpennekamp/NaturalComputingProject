"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DateTimeV2 = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const CurrentDateDescription_1 = require("./CurrentDateDescription");
const AddToDateDescription_1 = require("./AddToDateDescription");
const SubtractFromDateDescription_1 = require("./SubtractFromDateDescription");
const FormatDateDescription_1 = require("./FormatDateDescription");
const RoundDateDescription_1 = require("./RoundDateDescription");
const GetTimeBetweenDates_1 = require("./GetTimeBetweenDates");
const luxon_1 = require("luxon");
const ExtractDateDescription_1 = require("./ExtractDateDescription");
const GenericFunctions_1 = require("./GenericFunctions");
class DateTimeV2 {
    constructor(baseDescription) {
        this.description = {
            ...baseDescription,
            version: 2,
            defaults: {
                name: 'Date & Time',
                color: '#408000',
            },
            inputs: ['main'],
            outputs: ['main'],
            properties: [
                {
                    displayName: 'Operation',
                    name: 'operation',
                    type: 'options',
                    noDataExpression: true,
                    options: [
                        {
                            name: 'Add to a Date',
                            value: 'addToDate',
                        },
                        {
                            name: 'Extract Part of a Date',
                            value: 'extractDate',
                        },
                        {
                            name: 'Format a Date',
                            value: 'formatDate',
                        },
                        {
                            name: 'Get Current Date',
                            value: 'getCurrentDate',
                        },
                        {
                            name: 'Get Time Between Dates',
                            value: 'getTimeBetweenDates',
                        },
                        {
                            name: 'Round a Date',
                            value: 'roundDate',
                        },
                        {
                            name: 'Subtract From a Date',
                            value: 'subtractFromDate',
                        },
                    ],
                    default: 'getCurrentDate',
                },
                ...CurrentDateDescription_1.CurrentDateDescription,
                ...AddToDateDescription_1.AddToDateDescription,
                ...SubtractFromDateDescription_1.SubtractFromDateDescription,
                ...FormatDateDescription_1.FormatDateDescription,
                ...RoundDateDescription_1.RoundDateDescription,
                ...GetTimeBetweenDates_1.GetTimeBetweenDatesDescription,
                ...ExtractDateDescription_1.ExtractDateDescription,
            ],
        };
    }
    async execute() {
        const items = this.getInputData();
        const returnData = [];
        const responseData = [];
        const operation = this.getNodeParameter('operation', 0);
        const workflowTimezone = this.getTimezone();
        for (let i = 0; i < items.length; i++) {
            if (operation === 'getCurrentDate') {
                const includeTime = this.getNodeParameter('includeTime', i);
                const outputFieldName = this.getNodeParameter('outputFieldName', i);
                const { timezone } = this.getNodeParameter('options', i);
                const newLocal = timezone ? timezone : workflowTimezone;
                if (luxon_1.DateTime.now().setZone(newLocal).invalidReason === 'unsupported zone') {
                    throw new n8n_workflow_1.NodeOperationError(this.getNode(), `The timezone ${newLocal} is not valid. Please check the timezone.`);
                }
                responseData.push(includeTime
                    ? { [outputFieldName]: luxon_1.DateTime.now().setZone(newLocal).toString() }
                    : {
                        [outputFieldName]: luxon_1.DateTime.now().setZone(newLocal).startOf('day').toString(),
                    });
            }
            else if (operation === 'addToDate') {
                const addToDate = this.getNodeParameter('magnitude', i);
                const timeUnit = this.getNodeParameter('timeUnit', i);
                const duration = this.getNodeParameter('duration', i);
                const outputFieldName = this.getNodeParameter('outputFieldName', i);
                const dateToAdd = GenericFunctions_1.parseDate.call(this, addToDate, workflowTimezone);
                const returnedDate = dateToAdd.plus({ [timeUnit]: duration });
                responseData.push({ [outputFieldName]: returnedDate.toString() });
            }
            else if (operation === 'subtractFromDate') {
                const subtractFromDate = this.getNodeParameter('magnitude', i);
                const timeUnit = this.getNodeParameter('timeUnit', i);
                const duration = this.getNodeParameter('duration', i);
                const outputFieldName = this.getNodeParameter('outputFieldName', i);
                const dateToAdd = GenericFunctions_1.parseDate.call(this, subtractFromDate, workflowTimezone);
                const returnedDate = dateToAdd.minus({ [timeUnit]: duration });
                responseData.push({ [outputFieldName]: returnedDate.toString() });
            }
            else if (operation === 'formatDate') {
                const date = this.getNodeParameter('date', i);
                const format = this.getNodeParameter('format', i);
                const outputFieldName = this.getNodeParameter('outputFieldName', i);
                const { timezone } = this.getNodeParameter('options', i);
                const dateLuxon = timezone
                    ? GenericFunctions_1.parseDate.call(this, date, workflowTimezone)
                    : GenericFunctions_1.parseDate.call(this, date);
                if (format === 'custom') {
                    const customFormat = this.getNodeParameter('customFormat', i);
                    responseData.push({
                        [outputFieldName]: dateLuxon.toFormat(customFormat),
                    });
                }
                else {
                    responseData.push({
                        [outputFieldName]: dateLuxon.toFormat(format),
                    });
                }
            }
            else if (operation === 'roundDate') {
                const date = this.getNodeParameter('date', i);
                const mode = this.getNodeParameter('mode', i);
                const outputFieldName = this.getNodeParameter('outputFieldName', i);
                const dateLuxon = GenericFunctions_1.parseDate.call(this, date, workflowTimezone);
                if (mode === 'roundDown') {
                    const toNearest = this.getNodeParameter('toNearest', i);
                    responseData.push({
                        [outputFieldName]: dateLuxon.startOf(toNearest).toString(),
                    });
                }
                else if (mode === 'roundUp') {
                    const to = this.getNodeParameter('to', i);
                    responseData.push({
                        [outputFieldName]: dateLuxon
                            .plus({ [to]: 1 })
                            .startOf(to)
                            .toString(),
                    });
                }
            }
            else if (operation === 'getTimeBetweenDates') {
                const startDate = this.getNodeParameter('startDate', i);
                const endDate = this.getNodeParameter('endDate', i);
                const unit = this.getNodeParameter('units', i);
                const outputFieldName = this.getNodeParameter('outputFieldName', i);
                const { isoString } = this.getNodeParameter('options', i);
                const luxonStartDate = GenericFunctions_1.parseDate.call(this, startDate, workflowTimezone);
                const luxonEndDate = GenericFunctions_1.parseDate.call(this, endDate, workflowTimezone);
                const duration = luxonEndDate.diff(luxonStartDate, unit);
                isoString
                    ? responseData.push({
                        [outputFieldName]: duration.toString(),
                    })
                    : responseData.push({
                        [outputFieldName]: duration.toObject(),
                    });
            }
            else if (operation === 'extractDate') {
                const date = this.getNodeParameter('date', i);
                const outputFieldName = this.getNodeParameter('outputFieldName', i);
                const part = this.getNodeParameter('part', i);
                const parsedDate = GenericFunctions_1.parseDate.call(this, date, workflowTimezone);
                const selectedPart = part === 'week' ? parsedDate.weekNumber : parsedDate.get(part);
                responseData.push({ [outputFieldName]: selectedPart });
            }
            const executionData = this.helpers.constructExecutionMetaData(this.helpers.returnJsonArray(responseData), {
                itemData: { item: i },
            });
            returnData.push(...executionData);
        }
        return this.prepareOutputData(returnData);
    }
}
exports.DateTimeV2 = DateTimeV2;
//# sourceMappingURL=DateTimeV2.node.js.map