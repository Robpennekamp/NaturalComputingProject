"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Git = void 0;
const descriptions_1 = require("./descriptions");
const simple_git_1 = __importDefault(require("simple-git"));
const promises_1 = require("fs/promises");
const url_1 = require("url");
class Git {
    constructor() {
        this.description = {
            displayName: 'Git',
            name: 'git',
            icon: 'file:git.svg',
            group: ['transform'],
            version: 1,
            description: 'Control git.',
            defaults: {
                name: 'Git',
            },
            inputs: ['main'],
            outputs: ['main'],
            credentials: [
                {
                    name: 'gitPassword',
                    required: true,
                    displayOptions: {
                        show: {
                            authentication: ['gitPassword'],
                        },
                    },
                },
            ],
            properties: [
                {
                    displayName: 'Authentication',
                    name: 'authentication',
                    type: 'options',
                    options: [
                        {
                            name: 'Authenticate',
                            value: 'gitPassword',
                        },
                        {
                            name: 'None',
                            value: 'none',
                        },
                    ],
                    displayOptions: {
                        show: {
                            operation: ['clone', 'push'],
                        },
                    },
                    default: 'none',
                    description: 'The way to authenticate',
                },
                {
                    displayName: 'Operation',
                    name: 'operation',
                    type: 'options',
                    noDataExpression: true,
                    default: 'log',
                    options: [
                        {
                            name: 'Add',
                            value: 'add',
                            description: 'Add a file or folder to commit',
                            action: 'Add a file or folder to commit',
                        },
                        {
                            name: 'Add Config',
                            value: 'addConfig',
                            description: 'Add configuration property',
                            action: 'Add configuration property',
                        },
                        {
                            name: 'Clone',
                            value: 'clone',
                            description: 'Clone a repository',
                            action: 'Clone a repository',
                        },
                        {
                            name: 'Commit',
                            value: 'commit',
                            description: 'Commit files or folders to git',
                            action: 'Commit files or folders to git',
                        },
                        {
                            name: 'Fetch',
                            value: 'fetch',
                            description: 'Fetch from remote repository',
                            action: 'Fetch from remote repository',
                        },
                        {
                            name: 'List Config',
                            value: 'listConfig',
                            description: 'Return current configuration',
                            action: 'Return current configuration',
                        },
                        {
                            name: 'Log',
                            value: 'log',
                            description: 'Return git commit history',
                            action: 'Return git commit history',
                        },
                        {
                            name: 'Pull',
                            value: 'pull',
                            description: 'Pull from remote repository',
                            action: 'Pull from remote repository',
                        },
                        {
                            name: 'Push',
                            value: 'push',
                            description: 'Push to remote repository',
                            action: 'Push to remote repository',
                        },
                        {
                            name: 'Push Tags',
                            value: 'pushTags',
                            description: 'Push Tags to remote repository',
                            action: 'Push tags to remote repository',
                        },
                        {
                            name: 'Status',
                            value: 'status',
                            description: 'Return status of current repository',
                            action: 'Return status of current repository',
                        },
                        {
                            name: 'Tag',
                            value: 'tag',
                            description: 'Create a new tag',
                            action: 'Create a new tag',
                        },
                        {
                            name: 'User Setup',
                            value: 'userSetup',
                            description: 'Set the user',
                            action: 'Set up a user',
                        },
                    ],
                },
                {
                    displayName: 'Repository Path',
                    name: 'repositoryPath',
                    type: 'string',
                    displayOptions: {
                        hide: {
                            operation: ['clone'],
                        },
                    },
                    default: '',
                    placeholder: '/tmp/repository',
                    required: true,
                    description: 'Local path of the git repository to operate on',
                },
                {
                    displayName: 'New Repository Path',
                    name: 'repositoryPath',
                    type: 'string',
                    displayOptions: {
                        show: {
                            operation: ['clone'],
                        },
                    },
                    default: '',
                    placeholder: '/tmp/repository',
                    required: true,
                    description: 'Local path to which the git repository should be cloned into',
                },
                ...descriptions_1.addFields,
                ...descriptions_1.addConfigFields,
                ...descriptions_1.cloneFields,
                ...descriptions_1.commitFields,
                ...descriptions_1.logFields,
                ...descriptions_1.pushFields,
                ...descriptions_1.tagFields,
            ],
        };
    }
    async execute() {
        const items = this.getInputData();
        const prepareRepository = async (repositoryPath) => {
            const authentication = this.getNodeParameter('authentication', 0);
            if (authentication === 'gitPassword') {
                const gitCredentials = await this.getCredentials('gitPassword');
                const url = new url_1.URL(repositoryPath);
                url.username = gitCredentials.username;
                url.password = gitCredentials.password;
                return url.toString();
            }
            return repositoryPath;
        };
        const operation = this.getNodeParameter('operation', 0);
        let _item;
        const returnItems = [];
        for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
            try {
                _item = items[itemIndex];
                const repositoryPath = this.getNodeParameter('repositoryPath', itemIndex, '');
                const options = this.getNodeParameter('options', itemIndex, {});
                if (operation === 'clone') {
                    try {
                        await (0, promises_1.access)(repositoryPath);
                    }
                    catch (error) {
                        await (0, promises_1.mkdir)(repositoryPath);
                    }
                }
                const gitOptions = {
                    baseDir: repositoryPath,
                };
                const git = (0, simple_git_1.default)(gitOptions)
                    .env('GIT_TERMINAL_PROMPT', '0');
                if (operation === 'add') {
                    const pathsToAdd = this.getNodeParameter('pathsToAdd', itemIndex, '');
                    await git.add(pathsToAdd.split(','));
                    returnItems.push({
                        json: {
                            success: true,
                        },
                        pairedItem: {
                            item: itemIndex,
                        },
                    });
                }
                else if (operation === 'addConfig') {
                    const key = this.getNodeParameter('key', itemIndex, '');
                    const value = this.getNodeParameter('value', itemIndex, '');
                    let append = false;
                    if (options.mode === 'append') {
                        append = true;
                    }
                    await git.addConfig(key, value, append);
                    returnItems.push({
                        json: {
                            success: true,
                        },
                        pairedItem: {
                            item: itemIndex,
                        },
                    });
                }
                else if (operation === 'clone') {
                    let sourceRepository = this.getNodeParameter('sourceRepository', itemIndex, '');
                    sourceRepository = await prepareRepository(sourceRepository);
                    await git.clone(sourceRepository, '.');
                    returnItems.push({
                        json: {
                            success: true,
                        },
                        pairedItem: {
                            item: itemIndex,
                        },
                    });
                }
                else if (operation === 'commit') {
                    const message = this.getNodeParameter('message', itemIndex, '');
                    let pathsToAdd = undefined;
                    if (options.files !== undefined) {
                        pathsToAdd = options.pathsToAdd.split(',');
                    }
                    await git.commit(message, pathsToAdd);
                    returnItems.push({
                        json: {
                            success: true,
                        },
                        pairedItem: {
                            item: itemIndex,
                        },
                    });
                }
                else if (operation === 'fetch') {
                    await git.fetch();
                    returnItems.push({
                        json: {
                            success: true,
                        },
                        pairedItem: {
                            item: itemIndex,
                        },
                    });
                }
                else if (operation === 'log') {
                    const logOptions = {};
                    const returnAll = this.getNodeParameter('returnAll', itemIndex, false);
                    if (!returnAll) {
                        logOptions.maxCount = this.getNodeParameter('limit', itemIndex, 100);
                    }
                    if (options.file) {
                        logOptions.file = options.file;
                    }
                    const log = await git.log(logOptions);
                    returnItems.push(...this.helpers.returnJsonArray(log.all).map((item) => {
                        return {
                            ...item,
                            pairedItem: { item: itemIndex },
                        };
                    }));
                }
                else if (operation === 'pull') {
                    await git.pull();
                    returnItems.push({
                        json: {
                            success: true,
                        },
                        pairedItem: {
                            item: itemIndex,
                        },
                    });
                }
                else if (operation === 'push') {
                    if (options.repository) {
                        const targetRepository = await prepareRepository(options.targetRepository);
                        await git.push(targetRepository);
                    }
                    else {
                        const authentication = this.getNodeParameter('authentication', 0);
                        if (authentication === 'gitPassword') {
                            const config = await git.listConfig();
                            let targetRepository;
                            for (const fileName of Object.keys(config.values)) {
                                if (config.values[fileName]['remote.origin.url']) {
                                    targetRepository = config.values[fileName]['remote.origin.url'];
                                    break;
                                }
                            }
                            targetRepository = await prepareRepository(targetRepository);
                            await git.push(targetRepository);
                        }
                        else {
                            await git.push();
                        }
                    }
                    returnItems.push({
                        json: {
                            success: true,
                        },
                        pairedItem: {
                            item: itemIndex,
                        },
                    });
                }
                else if (operation === 'pushTags') {
                    await git.pushTags();
                    returnItems.push({
                        json: {
                            success: true,
                        },
                        pairedItem: {
                            item: itemIndex,
                        },
                    });
                }
                else if (operation === 'listConfig') {
                    const config = await git.listConfig();
                    const data = [];
                    for (const fileName of Object.keys(config.values)) {
                        data.push({
                            _file: fileName,
                            ...config.values[fileName],
                        });
                    }
                    returnItems.push(...this.helpers.returnJsonArray(data).map((item) => {
                        return {
                            ...item,
                            pairedItem: { item: itemIndex },
                        };
                    }));
                }
                else if (operation === 'status') {
                    const status = await git.status();
                    returnItems.push(...this.helpers.returnJsonArray([status]).map((item) => {
                        return {
                            ...item,
                            pairedItem: { item: itemIndex },
                        };
                    }));
                }
                else if (operation === 'tag') {
                    const name = this.getNodeParameter('name', itemIndex, '');
                    await git.addTag(name);
                    returnItems.push({
                        json: {
                            success: true,
                        },
                        pairedItem: {
                            item: itemIndex,
                        },
                    });
                }
            }
            catch (error) {
                if (this.continueOnFail()) {
                    returnItems.push({
                        json: {
                            error: error.toString(),
                        },
                        pairedItem: {
                            item: itemIndex,
                        },
                    });
                    continue;
                }
                throw error;
            }
        }
        return this.prepareOutputData(returnItems);
    }
}
exports.Git = Git;
//# sourceMappingURL=Git.node.js.map