"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SlackV2 = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const ChannelDescription_1 = require("./ChannelDescription");
const MessageDescription_1 = require("./MessageDescription");
const StarDescription_1 = require("./StarDescription");
const FileDescription_1 = require("./FileDescription");
const ReactionDescription_1 = require("./ReactionDescription");
const UserGroupDescription_1 = require("./UserGroupDescription");
const UserDescription_1 = require("./UserDescription");
const GenericFunctions_1 = require("./GenericFunctions");
const moment_1 = __importDefault(require("moment"));
class SlackV2 {
    constructor(baseDescription) {
        this.methods = {
            listSearch: {
                async getChannels(filter) {
                    const qs = { types: 'public_channel,private_channel', limit: 1000 };
                    const channels = (await GenericFunctions_1.slackApiRequestAllItems.call(this, 'channels', 'GET', '/conversations.list', {}, qs));
                    const results = channels
                        .map((c) => ({
                        name: c.name,
                        value: c.id,
                    }))
                        .filter((c) => {
                        var _a;
                        return !filter ||
                            c.name.toLowerCase().includes(filter.toLowerCase()) ||
                            ((_a = c.value) === null || _a === void 0 ? void 0 : _a.toString()) === filter;
                    })
                        .sort((a, b) => {
                        if (a.name.toLowerCase() < b.name.toLowerCase())
                            return -1;
                        if (a.name.toLowerCase() > b.name.toLowerCase())
                            return 1;
                        return 0;
                    });
                    return { results };
                },
                async getUsers(filter) {
                    const users = (await GenericFunctions_1.slackApiRequestAllItems.call(this, 'members', 'GET', '/users.list'));
                    const results = users
                        .map((c) => ({
                        name: c.name,
                        value: c.id,
                    }))
                        .filter((c) => {
                        var _a;
                        return !filter ||
                            c.name.toLowerCase().includes(filter.toLowerCase()) ||
                            ((_a = c.value) === null || _a === void 0 ? void 0 : _a.toString()) === filter;
                    })
                        .sort((a, b) => {
                        if (a.name.toLowerCase() < b.name.toLowerCase())
                            return -1;
                        if (a.name.toLowerCase() > b.name.toLowerCase())
                            return 1;
                        return 0;
                    });
                    return { results };
                },
            },
            loadOptions: {
                async getUsers() {
                    const returnData = [];
                    const users = await GenericFunctions_1.slackApiRequestAllItems.call(this, 'members', 'GET', '/users.list');
                    for (const user of users) {
                        const userName = user.name;
                        const userId = user.id;
                        returnData.push({
                            name: userName,
                            value: userId,
                        });
                    }
                    returnData.sort((a, b) => {
                        if (a.name < b.name) {
                            return -1;
                        }
                        if (a.name > b.name) {
                            return 1;
                        }
                        return 0;
                    });
                    return returnData;
                },
                async getChannels() {
                    const returnData = [];
                    const qs = { types: 'public_channel,private_channel', limit: 1000 };
                    const channels = await GenericFunctions_1.slackApiRequestAllItems.call(this, 'channels', 'GET', '/conversations.list', {}, qs);
                    for (const channel of channels) {
                        const channelName = channel.name;
                        const channelId = channel.id;
                        returnData.push({
                            name: channelName,
                            value: channelId,
                        });
                    }
                    returnData.sort((a, b) => {
                        if (a.name < b.name) {
                            return -1;
                        }
                        if (a.name > b.name) {
                            return 1;
                        }
                        return 0;
                    });
                    return returnData;
                },
                async getChannelsName() {
                    const returnData = [];
                    const qs = { types: 'public_channel,private_channel', limit: 1000 };
                    const channels = await GenericFunctions_1.slackApiRequestAllItems.call(this, 'channels', 'GET', '/conversations.list', {}, qs);
                    for (const channel of channels) {
                        const channelName = channel.name;
                        returnData.push({
                            name: channelName,
                            value: channelName,
                        });
                    }
                    returnData.sort((a, b) => {
                        if (a.name < b.name) {
                            return -1;
                        }
                        if (a.name > b.name) {
                            return 1;
                        }
                        return 0;
                    });
                    return returnData;
                },
                async getTeamFields() {
                    const returnData = [];
                    const { profile: { fields }, } = await GenericFunctions_1.slackApiRequest.call(this, 'GET', '/team.profile.get');
                    for (const field of fields) {
                        const fieldName = field.label;
                        const fieldId = field.id;
                        returnData.push({
                            name: fieldName,
                            value: fieldId,
                        });
                    }
                    return returnData;
                },
            },
        };
        this.description = {
            ...baseDescription,
            version: 2,
            defaults: {
                name: 'Slack',
            },
            inputs: ['main'],
            outputs: ['main'],
            credentials: [
                {
                    name: 'slackApi',
                    required: true,
                    displayOptions: {
                        show: {
                            authentication: ['accessToken'],
                        },
                    },
                },
                {
                    name: 'slackOAuth2Api',
                    required: true,
                    displayOptions: {
                        show: {
                            authentication: ['oAuth2'],
                        },
                    },
                },
            ],
            properties: [
                {
                    displayName: 'Authentication',
                    name: 'authentication',
                    type: 'options',
                    options: [
                        {
                            name: 'Access Token',
                            value: 'accessToken',
                        },
                        {
                            name: 'OAuth2',
                            value: 'oAuth2',
                        },
                    ],
                    default: 'accessToken',
                },
                {
                    displayName: 'Resource',
                    name: 'resource',
                    type: 'options',
                    noDataExpression: true,
                    options: [
                        {
                            name: 'Channel',
                            value: 'channel',
                        },
                        {
                            name: 'File',
                            value: 'file',
                        },
                        {
                            name: 'Message',
                            value: 'message',
                        },
                        {
                            name: 'Reaction',
                            value: 'reaction',
                        },
                        {
                            name: 'Star',
                            value: 'star',
                        },
                        {
                            name: 'User',
                            value: 'user',
                        },
                        {
                            name: 'User Group',
                            value: 'userGroup',
                        },
                    ],
                    default: 'message',
                },
                ...ChannelDescription_1.channelOperations,
                ...ChannelDescription_1.channelFields,
                ...MessageDescription_1.messageOperations,
                ...MessageDescription_1.messageFields,
                ...StarDescription_1.starOperations,
                ...StarDescription_1.starFields,
                ...FileDescription_1.fileOperations,
                ...FileDescription_1.fileFields,
                ...ReactionDescription_1.reactionOperations,
                ...ReactionDescription_1.reactionFields,
                ...UserDescription_1.userOperations,
                ...UserDescription_1.userFields,
                ...UserGroupDescription_1.userGroupOperations,
                ...UserGroupDescription_1.userGroupFields,
            ],
        };
    }
    async execute() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const items = this.getInputData();
        const returnData = [];
        const length = items.length;
        let qs;
        let responseData;
        const authentication = this.getNodeParameter('authentication', 0);
        const resource = this.getNodeParameter('resource', 0);
        const operation = this.getNodeParameter('operation', 0);
        for (let i = 0; i < length; i++) {
            try {
                responseData = {
                    error: 'Resource ' + resource + ' / operation ' + operation + ' not found!',
                };
                qs = {};
                if (resource === 'channel') {
                    if (operation === 'archive') {
                        const channel = this.getNodeParameter('channelId', i, {}, { extractValue: true });
                        const body = {
                            channel,
                        };
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'POST', '/conversations.archive', body, qs);
                    }
                    if (operation === 'close') {
                        const channel = this.getNodeParameter('channelId', i, {}, { extractValue: true });
                        const body = {
                            channel,
                        };
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'POST', '/conversations.close', body, qs);
                    }
                    if (operation === 'create') {
                        let channel = this.getNodeParameter('channelId', i, {}, { extractValue: true });
                        channel = channel[0] === '#' ? channel.slice(1) : channel;
                        const channelVisibility = this.getNodeParameter('channelVisibility', i);
                        const body = {
                            name: channel,
                            is_private: channelVisibility === 'private' ? true : false,
                        };
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'POST', '/conversations.create', body, qs);
                        responseData = responseData.channel;
                    }
                    if (operation === 'kick') {
                        const channel = this.getNodeParameter('channelId', i, {}, { extractValue: true });
                        const userId = this.getNodeParameter('userId', i);
                        const body = {
                            channel,
                            user: userId,
                        };
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'POST', '/conversations.kick', body, qs);
                    }
                    if (operation === 'join') {
                        const channel = this.getNodeParameter('channelId', i, {}, { extractValue: true });
                        const body = {
                            channel,
                        };
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'POST', '/conversations.join', body, qs);
                        responseData = responseData.channel;
                    }
                    if (operation === 'get') {
                        const channel = this.getNodeParameter('channelId', i, {}, { extractValue: true });
                        qs.channel = channel;
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'POST', '/conversations.info', {}, qs);
                        responseData = responseData.channel;
                    }
                    if (operation === 'getAll') {
                        const returnAll = this.getNodeParameter('returnAll', i);
                        const filters = this.getNodeParameter('filters', i);
                        if (filters.types) {
                            qs.types = filters.types.join(',');
                        }
                        if (filters.excludeArchived) {
                            qs.exclude_archived = filters.excludeArchived;
                        }
                        if (returnAll) {
                            responseData = await GenericFunctions_1.slackApiRequestAllItems.call(this, 'channels', 'GET', '/conversations.list', {}, qs);
                        }
                        else {
                            qs.limit = this.getNodeParameter('limit', i);
                            responseData = await GenericFunctions_1.slackApiRequest.call(this, 'GET', '/conversations.list', {}, qs);
                            responseData = responseData.channels;
                        }
                    }
                    if (operation === 'history') {
                        const channel = this.getNodeParameter('channelId', i, {}, { extractValue: true });
                        const returnAll = this.getNodeParameter('returnAll', i);
                        const filters = this.getNodeParameter('filters', i);
                        qs.channel = channel;
                        if (filters.inclusive) {
                            qs.inclusive = filters.inclusive;
                        }
                        if (filters.latest) {
                            qs.latest = new Date(filters.latest).getTime() / 1000;
                        }
                        if (filters.oldest) {
                            qs.oldest = new Date(filters.oldest).getTime() / 1000;
                        }
                        if (returnAll) {
                            responseData = await GenericFunctions_1.slackApiRequestAllItems.call(this, 'messages', 'GET', '/conversations.history', {}, qs);
                        }
                        else {
                            qs.limit = this.getNodeParameter('limit', i);
                            responseData = await GenericFunctions_1.slackApiRequest.call(this, 'GET', '/conversations.history', {}, qs);
                            responseData = responseData.messages;
                        }
                    }
                    if (operation === 'invite') {
                        const channel = this.getNodeParameter('channelId', i, {}, { extractValue: true });
                        const userIds = this.getNodeParameter('userIds', i).join(',');
                        const body = {
                            channel,
                            users: userIds,
                        };
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'POST', '/conversations.invite', body, qs);
                        responseData = responseData.channel;
                    }
                    if (operation === 'leave') {
                        const channel = this.getNodeParameter('channelId', i, {}, { extractValue: true });
                        const body = {
                            channel,
                        };
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'POST', '/conversations.leave', body, qs);
                    }
                    if (operation === 'member') {
                        const returnAll = this.getNodeParameter('returnAll', 0);
                        const resolveData = this.getNodeParameter('resolveData', 0);
                        qs.channel = this.getNodeParameter('channelId', i, {}, { extractValue: true });
                        if (returnAll) {
                            responseData = await GenericFunctions_1.slackApiRequestAllItems.call(this, 'members', 'GET', '/conversations.members', {}, qs);
                            responseData = responseData.map((member) => ({ member }));
                        }
                        else {
                            qs.limit = this.getNodeParameter('limit', i);
                            responseData = await GenericFunctions_1.slackApiRequest.call(this, 'GET', '/conversations.members', {}, qs);
                            responseData = responseData.members.map((member) => ({ member }));
                        }
                        if (resolveData) {
                            const data = [];
                            for (const { member } of responseData) {
                                const { user } = await GenericFunctions_1.slackApiRequest.call(this, 'GET', '/users.info', {}, { user: member });
                                data.push(user);
                            }
                            responseData = data;
                        }
                    }
                    if (operation === 'open') {
                        const options = this.getNodeParameter('options', i);
                        const body = {};
                        if (options.channelId) {
                            body.channel = options.channelId;
                        }
                        if (options.returnIm) {
                            body.return_im = options.returnIm;
                        }
                        if (options.users) {
                            body.users = options.users.join(',');
                        }
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'POST', '/conversations.open', body, qs);
                        responseData = responseData.channel;
                    }
                    if (operation === 'rename') {
                        const channel = this.getNodeParameter('channelId', i, {}, { extractValue: true });
                        const name = this.getNodeParameter('name', i);
                        const body = {
                            channel,
                            name,
                        };
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'POST', '/conversations.rename', body, qs);
                        responseData = responseData.channel;
                    }
                    if (operation === 'replies') {
                        const channel = this.getNodeParameter('channelId', i, {}, { extractValue: true });
                        const ts = (_a = this.getNodeParameter('ts', i)) === null || _a === void 0 ? void 0 : _a.toString();
                        const returnAll = this.getNodeParameter('returnAll', i);
                        const filters = this.getNodeParameter('filters', i);
                        qs.channel = channel;
                        qs.ts = ts;
                        if (filters.inclusive) {
                            qs.inclusive = filters.inclusive;
                        }
                        if (filters.latest) {
                            qs.latest = new Date(filters.latest).getTime() / 1000;
                        }
                        if (filters.oldest) {
                            qs.oldest = new Date(filters.oldest).getTime() / 1000;
                        }
                        if (returnAll) {
                            responseData = await GenericFunctions_1.slackApiRequestAllItems.call(this, 'messages', 'GET', '/conversations.replies', {}, qs);
                        }
                        else {
                            qs.limit = this.getNodeParameter('limit', i);
                            responseData = await GenericFunctions_1.slackApiRequest.call(this, 'GET', '/conversations.replies', {}, qs);
                            responseData = responseData.messages;
                        }
                    }
                    if (operation === 'setPurpose') {
                        const channel = this.getNodeParameter('channelId', i, {}, { extractValue: true });
                        const purpose = this.getNodeParameter('purpose', i);
                        const body = {
                            channel,
                            purpose,
                        };
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'POST', '/conversations.setPurpose', body, qs);
                        responseData = responseData.channel;
                    }
                    if (operation === 'setTopic') {
                        const channel = this.getNodeParameter('channelId', i, {}, { extractValue: true });
                        const topic = this.getNodeParameter('topic', i);
                        const body = {
                            channel,
                            topic,
                        };
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'POST', '/conversations.setTopic', body, qs);
                        responseData = responseData.channel;
                    }
                    if (operation === 'unarchive') {
                        const channel = this.getNodeParameter('channelId', i, {}, { extractValue: true });
                        const body = {
                            channel,
                        };
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'POST', '/conversations.unarchive', body, qs);
                    }
                }
                if (resource === 'message') {
                    if (operation === 'post') {
                        const select = this.getNodeParameter('select', i);
                        const messageType = this.getNodeParameter('messageType', i);
                        let target = select === 'channel'
                            ? this.getNodeParameter('channelId', i, undefined, {
                                extractValue: true,
                            })
                            : this.getNodeParameter('user', i, undefined, {
                                extractValue: true,
                            });
                        if (select === 'user' &&
                            this.getNodeParameter('user', i).mode === 'username') {
                            target = target.slice(0, 1) === '@' ? target : `@${target}`;
                        }
                        const { sendAsUser } = this.getNodeParameter('otherOptions', i);
                        let content = {};
                        const text = this.getNodeParameter('text', i, '');
                        switch (messageType) {
                            case 'text':
                                content = { text };
                                break;
                            case 'block':
                                content = JSON.parse(this.getNodeParameter('blocksUi', i));
                                if (text) {
                                    content.text = text;
                                }
                                break;
                            case 'attachment':
                                content = { attachments: this.getNodeParameter('attachments', i) };
                                break;
                            default:
                                throw new n8n_workflow_1.NodeOperationError(this.getNode(), `The message type "${messageType}" is not known!`);
                        }
                        const body = {
                            channel: target,
                            ...content,
                        };
                        if (authentication === 'accessToken' && sendAsUser !== '' && sendAsUser !== undefined) {
                            body.username = sendAsUser;
                        }
                        const otherOptions = this.getNodeParameter('otherOptions', i);
                        let action = 'postMessage';
                        if (otherOptions.ephemeral) {
                            const ephemeral = otherOptions.ephemeral;
                            if (select === 'channel') {
                                const ephemeralValues = ephemeral.ephemeralValues;
                                const userRlc = ephemeralValues.user;
                                body.user =
                                    ((_b = userRlc.value) === null || _b === void 0 ? void 0 : _b.toString().slice(0, 1)) !== '@' && userRlc.mode === 'username'
                                        ? `@${userRlc.value}`
                                        : userRlc.value;
                                action = 'postEphemeral';
                            }
                            else if (select === 'user') {
                                body.user = target;
                                action = 'postEphemeral';
                            }
                        }
                        const replyValues = (_c = otherOptions.thread_ts) === null || _c === void 0 ? void 0 : _c.replyValues;
                        Object.assign(body, replyValues);
                        delete otherOptions.thread_ts;
                        delete otherOptions.ephemeral;
                        if (otherOptions.botProfile) {
                            const botProfile = otherOptions.botProfile;
                            const botProfileValues = botProfile.imageValues;
                            Object.assign(body, botProfileValues.profilePhotoType === 'image'
                                ? { icon_url: botProfileValues.icon_url }
                                : { icon_emoji: botProfileValues.icon_emoji });
                        }
                        delete otherOptions.botProfile;
                        Object.assign(body, otherOptions);
                        if (select === 'user' &&
                            action === 'postEphemeral' &&
                            ((_d = this.getNodeParameter('user', i)) === null || _d === void 0 ? void 0 : _d.mode) ===
                                'username') {
                            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'You cannot send ephemeral messages using User type "By username". Please use "From List" or "By ID".');
                        }
                        else {
                            responseData = await GenericFunctions_1.slackApiRequest.call(this, 'POST', `/chat.${action}`, body, qs);
                        }
                    }
                    if (operation === 'update') {
                        const channel = this.getNodeParameter('channelId', i, {}, { extractValue: true });
                        const text = this.getNodeParameter('text', i);
                        const ts = (_e = this.getNodeParameter('ts', i)) === null || _e === void 0 ? void 0 : _e.toString();
                        const body = {
                            channel,
                            text,
                            ts,
                        };
                        const jsonParameters = this.getNodeParameter('jsonParameters', i, false);
                        if (jsonParameters) {
                            const blocksJson = this.getNodeParameter('blocksJson', i, []);
                            if (blocksJson !== '' && (0, GenericFunctions_1.validateJSON)(blocksJson) === undefined) {
                                throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Blocks it is not a valid json', {
                                    itemIndex: i,
                                });
                            }
                            if (blocksJson !== '') {
                                body.blocks = blocksJson;
                            }
                        }
                        const updateFields = this.getNodeParameter('updateFields', i);
                        Object.assign(body, updateFields);
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'POST', '/chat.update', body, qs);
                    }
                    if (operation === 'delete') {
                        const select = this.getNodeParameter('select', i);
                        let target = select === 'channel'
                            ? this.getNodeParameter('channelId', i, undefined, {
                                extractValue: true,
                            })
                            : this.getNodeParameter('user', i, undefined, {
                                extractValue: true,
                            });
                        if (select === 'user' &&
                            this.getNodeParameter('user', i).mode === 'username') {
                            target = target.slice(0, 1) === '@' ? target : `@${target}`;
                        }
                        const timestamp = (_f = this.getNodeParameter('timestamp', i)) === null || _f === void 0 ? void 0 : _f.toString();
                        const body = {
                            channel: target,
                            ts: timestamp,
                        };
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'POST', '/chat.delete', body, qs);
                    }
                    if (operation === 'getPermalink') {
                        const channel = this.getNodeParameter('channelId', i, {}, { extractValue: true });
                        const timestamp = (_g = this.getNodeParameter('timestamp', i)) === null || _g === void 0 ? void 0 : _g.toString();
                        qs = {
                            channel,
                            message_ts: timestamp,
                        };
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'GET', '/chat.getPermalink', {}, qs);
                    }
                    if (operation === 'search') {
                        let query = this.getNodeParameter('query', i);
                        const sort = this.getNodeParameter('sort', i);
                        const returnAll = this.getNodeParameter('returnAll', i);
                        const options = this.getNodeParameter('options', i);
                        if (options.searchChannel) {
                            const channel = options.searchChannel;
                            for (const channelItem of channel) {
                                query += ` in:${channelItem}`;
                            }
                        }
                        qs = {
                            query,
                            sort: sort === 'relevance' ? 'score' : 'timestamp',
                            sort_dir: sort === 'asc' ? 'asc' : 'desc',
                        };
                        if (returnAll) {
                            responseData = await GenericFunctions_1.slackApiRequestAllItems.call(this, 'messages', 'GET', '/search.messages', {}, qs);
                        }
                        else {
                            qs.count = this.getNodeParameter('limit', i);
                            responseData = await GenericFunctions_1.slackApiRequest.call(this, 'POST', '/search.messages', {}, qs);
                            responseData = responseData.messages.matches;
                        }
                    }
                }
                if (resource === 'reaction') {
                    const channel = this.getNodeParameter('channelId', i, {}, { extractValue: true });
                    const timestamp = (_h = this.getNodeParameter('timestamp', i)) === null || _h === void 0 ? void 0 : _h.toString();
                    if (operation === 'add') {
                        const name = this.getNodeParameter('name', i);
                        const body = {
                            channel,
                            name,
                            timestamp,
                        };
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'POST', '/reactions.add', body, qs);
                    }
                    if (operation === 'remove') {
                        const name = this.getNodeParameter('name', i);
                        const body = {
                            channel,
                            name,
                            timestamp,
                        };
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'POST', '/reactions.remove', body, qs);
                    }
                    if (operation === 'get') {
                        qs.channel = channel;
                        qs.timestamp = timestamp;
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'GET', '/reactions.get', {}, qs);
                    }
                }
                if (resource === 'star') {
                    if (operation === 'add') {
                        const options = this.getNodeParameter('options', i);
                        const target = this.getNodeParameter('target', i);
                        const channel = this.getNodeParameter('channelId', i, {}, { extractValue: true });
                        const body = {};
                        body.channel = channel;
                        if (target === 'message') {
                            const timestamp = (_j = this.getNodeParameter('timestamp', i)) === null || _j === void 0 ? void 0 : _j.toString();
                            body.timestamp = timestamp;
                        }
                        if (target === 'file') {
                            const file = this.getNodeParameter('fileId', i);
                            body.file = file;
                        }
                        if (options.fileComment) {
                            body.file_comment = options.fileComment;
                        }
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'POST', '/stars.add', body, qs);
                    }
                    if (operation === 'delete') {
                        const options = this.getNodeParameter('options', i);
                        const body = {};
                        if (options.channelId) {
                            body.channel = options.channelId;
                        }
                        if (options.fileId) {
                            body.file = options.fileId;
                        }
                        if (options.fileComment) {
                            body.file_comment = options.fileComment;
                        }
                        if (options.timestamp) {
                            body.timestamp = options.timestamp;
                        }
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'POST', '/stars.remove', body, qs);
                    }
                    if (operation === 'getAll') {
                        const returnAll = this.getNodeParameter('returnAll', i);
                        if (returnAll) {
                            responseData = await GenericFunctions_1.slackApiRequestAllItems.call(this, 'items', 'GET', '/stars.list', {}, qs);
                        }
                        else {
                            qs.limit = this.getNodeParameter('limit', i);
                            responseData = await GenericFunctions_1.slackApiRequest.call(this, 'GET', '/stars.list', {}, qs);
                            responseData = responseData.items;
                        }
                    }
                }
                if (resource === 'file') {
                    if (operation === 'upload') {
                        const options = this.getNodeParameter('options', i);
                        const body = {};
                        if (options.channelIds) {
                            body.channels = options.channelIds.join(',');
                        }
                        if (options.fileName) {
                            body.filename = options.fileName;
                        }
                        if (options.initialComment) {
                            body.initial_comment = options.initialComment;
                        }
                        if (options.threadTs) {
                            body.thread_ts = options.threadTs;
                        }
                        if (options.title) {
                            body.title = options.title;
                        }
                        if (this.getNodeParameter('binaryData', i)) {
                            const binaryPropertyName = this.getNodeParameter('binaryPropertyName', i);
                            const binaryData = this.helpers.assertBinaryData(i, binaryPropertyName);
                            let uploadData;
                            if (binaryData.id) {
                                uploadData = this.helpers.getBinaryStream(binaryData.id);
                            }
                            else {
                                uploadData = Buffer.from(binaryData.data, n8n_workflow_1.BINARY_ENCODING);
                            }
                            body.file = {
                                value: uploadData,
                                options: {
                                    filename: binaryData.fileName,
                                    contentType: binaryData.mimeType,
                                },
                            };
                            responseData = await GenericFunctions_1.slackApiRequest.call(this, 'POST', '/files.upload', {}, qs, { 'Content-Type': 'multipart/form-data' }, { formData: body });
                            responseData = responseData.file;
                        }
                        else {
                            const fileContent = this.getNodeParameter('fileContent', i);
                            body.content = fileContent;
                            responseData = await GenericFunctions_1.slackApiRequest.call(this, 'POST', '/files.upload', body, qs, { 'Content-Type': 'application/x-www-form-urlencoded' }, { form: body });
                            responseData = responseData.file;
                        }
                    }
                    if (operation === 'getAll') {
                        const returnAll = this.getNodeParameter('returnAll', i);
                        const filters = this.getNodeParameter('filters', i);
                        if (filters.channelId) {
                            qs.channel = filters.channelId;
                        }
                        if (filters.showFilesHidden) {
                            qs.show_files_hidden_by_limit = filters.showFilesHidden;
                        }
                        if (filters.tsFrom) {
                            qs.ts_from = filters.tsFrom;
                        }
                        if (filters.tsTo) {
                            qs.ts_to = filters.tsTo;
                        }
                        if (filters.types) {
                            qs.types = filters.types.join(',');
                        }
                        if (filters.userId) {
                            qs.user = filters.userId;
                        }
                        if (returnAll) {
                            responseData = await GenericFunctions_1.slackApiRequestAllItems.call(this, 'files', 'GET', '/files.list', {}, qs);
                        }
                        else {
                            qs.count = this.getNodeParameter('limit', i);
                            responseData = await GenericFunctions_1.slackApiRequest.call(this, 'GET', '/files.list', {}, qs);
                            responseData = responseData.files;
                        }
                    }
                    if (operation === 'get') {
                        const fileId = this.getNodeParameter('fileId', i);
                        qs.file = fileId;
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'GET', '/files.info', {}, qs);
                        responseData = responseData.file;
                    }
                }
                if (resource === 'user') {
                    if (operation === 'info') {
                        qs.user = this.getNodeParameter('user', i, undefined, { extractValue: true });
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'GET', '/users.info', {}, qs);
                        responseData = responseData.user;
                    }
                    if (operation === 'getAll') {
                        const returnAll = this.getNodeParameter('returnAll', i);
                        if (returnAll) {
                            responseData = await GenericFunctions_1.slackApiRequestAllItems.call(this, 'members', 'GET', '/users.list', {}, qs);
                        }
                        else {
                            qs.limit = this.getNodeParameter('limit', i);
                            responseData = await GenericFunctions_1.slackApiRequest.call(this, 'GET', '/users.list', {}, qs);
                            responseData = responseData.members;
                        }
                    }
                    if (operation === 'getPresence') {
                        qs.user = this.getNodeParameter('user', i, undefined, { extractValue: true });
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'GET', '/users.getPresence', {}, qs);
                    }
                    if (operation === 'updateProfile') {
                        const options = this.getNodeParameter('options', i);
                        const timezone = this.getTimezone();
                        const body = {};
                        let status;
                        if (options.status) {
                            status = ((_k = options.status) === null || _k === void 0 ? void 0 : _k.set_status)[0];
                            if (status.status_expiration === undefined) {
                                status.status_expiration = 0;
                            }
                            else {
                                status.status_expiration = moment_1.default
                                    .tz(status.status_expiration, timezone)
                                    .unix();
                            }
                            Object.assign(body, status);
                            delete options.status;
                        }
                        if (options.customFieldUi) {
                            const customFields = options.customFieldUi
                                .customFieldValues;
                            const fields = {};
                            for (const customField of customFields) {
                                fields[customField.id] = {
                                    value: customField.value,
                                    alt: customField.alt,
                                };
                            }
                            options.fields = fields;
                        }
                        Object.assign(body, options);
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'POST', '/users.profile.set', { profile: body }, qs);
                        responseData = responseData.profile;
                    }
                }
                if (resource === 'userGroup') {
                    if (operation === 'create') {
                        const name = this.getNodeParameter('name', i);
                        const options = this.getNodeParameter('options', i);
                        const body = {
                            name,
                        };
                        Object.assign(body, options);
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'POST', '/usergroups.create', body, qs);
                        responseData = responseData.usergroup;
                    }
                    if (operation === 'enable') {
                        const userGroupId = this.getNodeParameter('userGroupId', i);
                        const options = this.getNodeParameter('options', i);
                        const body = {
                            usergroup: userGroupId,
                        };
                        Object.assign(body, options);
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'POST', '/usergroups.enable', body, qs);
                        responseData = responseData.usergroup;
                    }
                    if (operation === 'disable') {
                        const userGroupId = this.getNodeParameter('userGroupId', i);
                        const options = this.getNodeParameter('options', i);
                        const body = {
                            usergroup: userGroupId,
                        };
                        Object.assign(body, options);
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'POST', '/usergroups.disable', body, qs);
                        responseData = responseData.usergroup;
                    }
                    if (operation === 'getAll') {
                        const returnAll = this.getNodeParameter('returnAll', i);
                        const options = this.getNodeParameter('options', i);
                        Object.assign(qs, options);
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'GET', '/usergroups.list', {}, qs);
                        responseData = responseData.usergroups;
                        if (!returnAll) {
                            const limit = this.getNodeParameter('limit', i);
                            responseData = responseData.slice(0, limit);
                        }
                    }
                    if (operation === 'update') {
                        const userGroupId = this.getNodeParameter('userGroupId', i);
                        const updateFields = this.getNodeParameter('updateFields', i);
                        const body = {
                            usergroup: userGroupId,
                        };
                        Object.assign(body, updateFields);
                        responseData = await GenericFunctions_1.slackApiRequest.call(this, 'POST', '/usergroups.update', body, qs);
                        responseData = responseData.usergroup;
                    }
                }
                const executionData = this.helpers.constructExecutionMetaData(this.helpers.returnJsonArray(responseData), { itemData: { item: i } });
                returnData.push(...executionData);
            }
            catch (error) {
                if (this.continueOnFail()) {
                    returnData.push({ json: { error: error.message } });
                    continue;
                }
                throw error;
            }
        }
        return this.prepareOutputData(returnData);
    }
}
exports.SlackV2 = SlackV2;
//# sourceMappingURL=SlackV2.node.js.map