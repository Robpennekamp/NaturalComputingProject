"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Connections = void 0;
const ssh2_1 = require("ssh2");
const net_1 = require("net");
const pg_promise_1 = __importDefault(require("pg-promise"));
const promises_1 = require("fs/promises");
const tmp_promise_1 = require("tmp-promise");
async function createSshConnectConfig(credentials) {
    if (credentials.sshAuthenticateWith === 'password') {
        return {
            host: credentials.sshHost,
            port: credentials.sshPort,
            username: credentials.sshUser,
            password: credentials.sshPassword,
        };
    }
    else {
        const { path } = await (0, tmp_promise_1.file)({ prefix: 'n8n-ssh-' });
        await (0, promises_1.writeFile)(path, credentials.privateKey);
        const options = {
            host: credentials.host,
            username: credentials.username,
            port: credentials.port,
            privateKey: path,
        };
        if (credentials.passphrase) {
            options.passphrase = credentials.passphrase;
        }
        return options;
    }
}
async function configurePostgres(credentials, options = {}, createdSshClient) {
    const pgp = (0, pg_promise_1.default)();
    if (typeof options.nodeVersion == 'number' && options.nodeVersion >= 2.1) {
        [pgp.pg.types.builtins.TIMESTAMP, pgp.pg.types.builtins.TIMESTAMPTZ].forEach((type) => {
            pgp.pg.types.setTypeParser(type, (value) => {
                return new Date(value).toISOString();
            });
        });
    }
    if (options.largeNumbersOutput === 'numbers') {
        pgp.pg.types.setTypeParser(20, (value) => {
            return parseInt(value, 10);
        });
        pgp.pg.types.setTypeParser(1700, (value) => {
            return parseFloat(value);
        });
    }
    const dbConfig = {
        host: credentials.host,
        port: credentials.port,
        database: credentials.database,
        user: credentials.user,
        password: credentials.password,
    };
    if (options.connectionTimeout) {
        dbConfig.connectionTimeoutMillis = options.connectionTimeout * 1000;
    }
    if (credentials.allowUnauthorizedCerts === true) {
        dbConfig.ssl = {
            rejectUnauthorized: false,
        };
    }
    else {
        dbConfig.ssl = !['disable', undefined].includes(credentials.ssl);
        dbConfig.sslmode = credentials.ssl || 'disable';
    }
    if (!credentials.sshTunnel) {
        const db = pgp(dbConfig);
        return { db, pgp };
    }
    else {
        const sshClient = createdSshClient || new ssh2_1.Client();
        const tunnelConfig = await createSshConnectConfig(credentials);
        const localHost = '127.0.0.1';
        const localPort = credentials.sshPostgresPort;
        let proxy;
        const db = await new Promise((resolve, reject) => {
            let sshClientReady = false;
            proxy = (0, net_1.createServer)((socket) => {
                if (!sshClientReady)
                    return socket.destroy();
                sshClient.forwardOut(socket.remoteAddress, socket.remotePort, credentials.host, credentials.port, (err, stream) => {
                    if (err)
                        reject(err);
                    socket.pipe(stream);
                    stream.pipe(socket);
                });
            }).listen(localPort, localHost);
            proxy.on('error', (err) => {
                reject(err);
            });
            sshClient.connect(tunnelConfig);
            sshClient.on('ready', () => {
                sshClientReady = true;
                const updatedDbConfig = {
                    ...dbConfig,
                    port: localPort,
                    host: localHost,
                };
                const dbConnection = pgp(updatedDbConfig);
                resolve(dbConnection);
            });
            sshClient.on('error', (err) => {
                reject(err);
            });
            sshClient.on('end', async () => {
                if (tunnelConfig.privateKey) {
                    await (0, promises_1.rm)(tunnelConfig.privateKey, { force: true });
                }
                if (proxy)
                    proxy.close();
            });
        }).catch((err) => {
            if (proxy)
                proxy.close();
            if (sshClient)
                sshClient.end();
            let message = err.message;
            let description = err.description;
            if (err.message.includes('ECONNREFUSED')) {
                message = 'Connection refused';
                try {
                    description = err.message.split('ECONNREFUSED ')[1].trim();
                }
                catch (e) { }
            }
            if (err.message.includes('ENOTFOUND')) {
                message = 'Host not found';
                try {
                    description = err.message.split('ENOTFOUND ')[1].trim();
                }
                catch (e) { }
            }
            if (err.message.includes('ETIMEDOUT')) {
                message = 'Connection timed out';
                try {
                    description = err.message.split('ETIMEDOUT ')[1].trim();
                }
                catch (e) { }
            }
            err.message = message;
            err.description = description;
            throw err;
        });
        return { db, pgp, sshClient };
    }
}
exports.Connections = (function () {
    let instance = null;
    return {
        async getInstance(credentials = {}, options = {}, reload = false, createdSshClient, nulify = false) {
            if (nulify) {
                instance = null;
                return instance;
            }
            if (instance !== null && reload) {
                if (instance.sshClient) {
                    instance.sshClient.end();
                }
                instance.pgp.end();
                instance = null;
            }
            if (instance === null && Object.keys(credentials).length) {
                instance = await configurePostgres(credentials, options, createdSshClient);
            }
            return instance;
        },
    };
})();
//# sourceMappingURL=index.js.map