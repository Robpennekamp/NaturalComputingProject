"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkItemAgainstSchema = exports.getTableSchema = exports.prepareItem = exports.replaceEmptyStringsByNulls = exports.configureQueryRunner = exports.addReturning = exports.addSortRules = exports.addWhereClauses = exports.parsePostgresError = exports.prepareErrorItem = exports.wrapData = void 0;
const n8n_workflow_1 = require("n8n-workflow");
function wrapData(data) {
    if (!Array.isArray(data)) {
        return [{ json: data }];
    }
    return data.map((item) => ({
        json: item,
    }));
}
exports.wrapData = wrapData;
function prepareErrorItem(items, error, index) {
    return {
        json: { message: error.message, item: { ...items[index].json }, error: { ...error } },
        pairedItem: { item: index },
    };
}
exports.prepareErrorItem = prepareErrorItem;
function parsePostgresError(node, error, queries, itemIndex) {
    var _a;
    if (error.message.includes('syntax error at or near') && queries.length) {
        try {
            const snippet = error.message.match(/syntax error at or near "(.*)"/)[1];
            const failedQureryIndex = queries.findIndex((query) => query.query.includes(snippet));
            if (failedQureryIndex !== -1) {
                if (!itemIndex) {
                    itemIndex = failedQureryIndex;
                }
                const failedQuery = queries[failedQureryIndex].query;
                const lines = failedQuery.split('\n');
                const lineIndex = lines.findIndex((line) => line.includes(snippet));
                const errorMessage = `Syntax error at line ${lineIndex + 1} near "${snippet}"`;
                error.message = errorMessage;
            }
        }
        catch { }
    }
    let message = error.message;
    const errorDescription = error.description ? error.description : error.detail || error.hint;
    let description = errorDescription;
    if (!description && ((_a = queries[itemIndex || 0]) === null || _a === void 0 ? void 0 : _a.query)) {
        description = `Failed query: ${queries[itemIndex || 0].query}`;
    }
    if (error.message.includes('ECONNREFUSED')) {
        message = 'Connection refused';
        try {
            description = error.message.split('ECONNREFUSED ')[1].trim();
        }
        catch (e) { }
    }
    if (error.message.includes('ENOTFOUND')) {
        message = 'Host not found';
        try {
            description = error.message.split('ENOTFOUND ')[1].trim();
        }
        catch (e) { }
    }
    if (error.message.includes('ETIMEDOUT')) {
        message = 'Connection timed out';
        try {
            description = error.message.split('ETIMEDOUT ')[1].trim();
        }
        catch (e) { }
    }
    return new n8n_workflow_1.NodeOperationError(node, error, {
        message,
        description,
        itemIndex,
    });
}
exports.parsePostgresError = parsePostgresError;
function addWhereClauses(node, itemIndex, query, clauses, replacements, combineConditions) {
    if (clauses.length === 0)
        return [query, replacements];
    let combineWith = 'AND';
    if (combineConditions === 'OR') {
        combineWith = 'OR';
    }
    let replacementIndex = replacements.length + 1;
    let whereQuery = ' WHERE';
    const values = [];
    clauses.forEach((clause, index) => {
        if (clause.condition === 'equal') {
            clause.condition = '=';
        }
        if (['>', '<', '>=', '<='].includes(clause.condition)) {
            const value = Number(clause.value);
            if (Number.isNaN(value)) {
                throw new n8n_workflow_1.NodeOperationError(node, `Operator in entry ${index + 1} of 'Select Rows' works with numbers, but value ${clause.value} is not a number`, {
                    itemIndex,
                });
            }
            clause.value = value;
        }
        const columnReplacement = `$${replacementIndex}:name`;
        values.push(clause.column);
        replacementIndex = replacementIndex + 1;
        let valueReplacement = '';
        if (clause.condition !== 'IS NULL') {
            valueReplacement = ` $${replacementIndex}`;
            values.push(clause.value);
            replacementIndex = replacementIndex + 1;
        }
        const operator = index === clauses.length - 1 ? '' : ` ${combineWith}`;
        whereQuery += ` ${columnReplacement} ${clause.condition}${valueReplacement}${operator}`;
    });
    return [`${query}${whereQuery}`, replacements.concat(...values)];
}
exports.addWhereClauses = addWhereClauses;
function addSortRules(query, rules, replacements) {
    if (rules.length === 0)
        return [query, replacements];
    let replacementIndex = replacements.length + 1;
    let orderByQuery = ' ORDER BY';
    const values = [];
    rules.forEach((rule, index) => {
        const columnReplacement = `$${replacementIndex}:name`;
        values.push(rule.column);
        replacementIndex = replacementIndex + 1;
        const endWith = index === rules.length - 1 ? '' : ',';
        const sortDirection = rule.direction === 'DESC' ? 'DESC' : 'ASC';
        orderByQuery += ` ${columnReplacement} ${sortDirection}${endWith}`;
    });
    return [`${query}${orderByQuery}`, replacements.concat(...values)];
}
exports.addSortRules = addSortRules;
function addReturning(query, outputColumns, replacements) {
    if (outputColumns.includes('*'))
        return [`${query} RETURNING *`, replacements];
    const replacementIndex = replacements.length + 1;
    return [`${query} RETURNING $${replacementIndex}:name`, [...replacements, outputColumns]];
}
exports.addReturning = addReturning;
const configureQueryRunner = (node, constructExecutionMetaData, continueOnFail, pgp, db) => async (queries, items, options) => {
    let returnData = [];
    const queryBatching = options.queryBatching || 'single';
    if (queryBatching === 'single') {
        try {
            returnData = (await db.multi(pgp.helpers.concat(queries)))
                .map((result, i) => {
                return constructExecutionMetaData(wrapData(result), {
                    itemData: { item: i },
                });
            })
                .flat();
            returnData = returnData.length ? returnData : [{ json: { success: true } }];
        }
        catch (err) {
            const error = parsePostgresError(node, err, queries);
            if (!continueOnFail)
                throw error;
            return [
                {
                    json: {
                        message: error.message,
                        error: { ...error },
                    },
                },
            ];
        }
    }
    if (queryBatching === 'transaction') {
        returnData = await db.tx(async (transaction) => {
            const result = [];
            for (let i = 0; i < queries.length; i++) {
                try {
                    const transactionResult = await transaction.any(queries[i].query, queries[i].values);
                    const executionData = constructExecutionMetaData(wrapData(transactionResult.length ? transactionResult : [{ success: true }]), { itemData: { item: i } });
                    result.push(...executionData);
                }
                catch (err) {
                    const error = parsePostgresError(node, err, queries, i);
                    if (!continueOnFail)
                        throw error;
                    result.push(prepareErrorItem(items, error, i));
                    return result;
                }
            }
            return result;
        });
    }
    if (queryBatching === 'independently') {
        returnData = await db.task(async (t) => {
            const result = [];
            for (let i = 0; i < queries.length; i++) {
                try {
                    const transactionResult = await t.any(queries[i].query, queries[i].values);
                    const executionData = constructExecutionMetaData(wrapData(transactionResult.length ? transactionResult : [{ success: true }]), { itemData: { item: i } });
                    result.push(...executionData);
                }
                catch (err) {
                    const error = parsePostgresError(node, err, queries, i);
                    if (!continueOnFail)
                        throw error;
                    result.push(prepareErrorItem(items, error, i));
                }
            }
            return result;
        });
    }
    return returnData;
};
exports.configureQueryRunner = configureQueryRunner;
function replaceEmptyStringsByNulls(items, replace) {
    if (!replace)
        return items;
    const returnData = items.map((item) => {
        const newItem = { ...item };
        const keys = Object.keys(newItem.json);
        for (const key of keys) {
            if (newItem.json[key] === '') {
                newItem.json[key] = null;
            }
        }
        return newItem;
    });
    return returnData;
}
exports.replaceEmptyStringsByNulls = replaceEmptyStringsByNulls;
function prepareItem(values) {
    const item = values.reduce((acc, { column, value }) => {
        acc[column] = value;
        return acc;
    }, {});
    return item;
}
exports.prepareItem = prepareItem;
async function getTableSchema(db, schema, table) {
    const columns = await db.any('SELECT column_name, data_type, is_nullable FROM information_schema.columns WHERE table_schema = $1 AND table_name = $2', [schema, table]);
    return columns;
}
exports.getTableSchema = getTableSchema;
function checkItemAgainstSchema(node, item, columnsInfo, index) {
    var _a;
    if (columnsInfo.length === 0)
        return item;
    const schema = columnsInfo.reduce((acc, { column_name, data_type, is_nullable }) => {
        acc[column_name] = { type: data_type.toUpperCase(), nullable: is_nullable === 'YES' };
        return acc;
    }, {});
    for (const key of Object.keys(item)) {
        if (schema[key] === undefined) {
            throw new n8n_workflow_1.NodeOperationError(node, `Column '${key}' does not exist in selected table`, {
                itemIndex: index,
            });
        }
        if (item[key] === null && !((_a = schema[key]) === null || _a === void 0 ? void 0 : _a.nullable)) {
            throw new n8n_workflow_1.NodeOperationError(node, `Column '${key}' is not nullable`, {
                itemIndex: index,
            });
        }
    }
    return item;
}
exports.checkItemAgainstSchema = checkItemAgainstSchema;
//# sourceMappingURL=utils.js.map