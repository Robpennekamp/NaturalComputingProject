"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.elasticsearchApiRequestAllItems = exports.elasticsearchApiRequest = void 0;
const n8n_workflow_1 = require("n8n-workflow");
async function elasticsearchApiRequest(method, endpoint, body = {}, qs = {}) {
    const { baseUrl, ignoreSSLIssues } = (await this.getCredentials('elasticsearchApi'));
    const options = {
        method,
        body,
        qs,
        uri: `${baseUrl}${endpoint}`,
        json: true,
        rejectUnauthorized: !ignoreSSLIssues,
    };
    if (!Object.keys(body).length) {
        delete options.body;
    }
    if (!Object.keys(qs).length) {
        delete options.qs;
    }
    try {
        return await this.helpers.requestWithAuthentication.call(this, 'elasticsearchApi', options);
    }
    catch (error) {
        throw new n8n_workflow_1.NodeApiError(this.getNode(), error);
    }
}
exports.elasticsearchApiRequest = elasticsearchApiRequest;
async function elasticsearchApiRequestAllItems(indexId, body = {}, qs = {}) {
    var _a, _b, _c, _d;
    try {
        let pit = (_a = (await elasticsearchApiRequest.call(this, 'POST', `/${indexId}/_pit`, {}, { keep_alive: '1m' }))) === null || _a === void 0 ? void 0 : _a.id;
        let returnData = [];
        let responseData;
        let searchAfter = [];
        const requestBody = {
            ...body,
            size: 10000,
            pit: {
                id: pit,
                keep_alive: '1m',
            },
            track_total_hits: false,
        };
        responseData = await elasticsearchApiRequest.call(this, 'GET', '/_search', requestBody, qs);
        if ((_b = responseData === null || responseData === void 0 ? void 0 : responseData.hits) === null || _b === void 0 ? void 0 : _b.hits) {
            returnData = returnData.concat(responseData.hits.hits);
            const lastHitIndex = responseData.hits.hits.length - 1;
            searchAfter = responseData.hits.hits[lastHitIndex].sort;
            pit = responseData.pit_id;
        }
        else {
            return [];
        }
        while (true) {
            requestBody.search_after = searchAfter;
            requestBody.pit = { id: pit, keep_alive: '1m' };
            responseData = await elasticsearchApiRequest.call(this, 'GET', '/_search', requestBody, qs);
            if ((_d = (_c = responseData === null || responseData === void 0 ? void 0 : responseData.hits) === null || _c === void 0 ? void 0 : _c.hits) === null || _d === void 0 ? void 0 : _d.length) {
                returnData = returnData.concat(responseData.hits.hits);
                const lastHitIndex = responseData.hits.hits.length - 1;
                searchAfter = responseData.hits.hits[lastHitIndex].sort;
                pit = responseData.pit_id;
            }
            else {
                break;
            }
        }
        await elasticsearchApiRequest.call(this, 'DELETE', '/_pit', { id: pit });
        return returnData;
    }
    catch (error) {
        throw new n8n_workflow_1.NodeApiError(this.getNode(), error);
    }
}
exports.elasticsearchApiRequestAllItems = elasticsearchApiRequestAllItems;
//# sourceMappingURL=GenericFunctions.js.map