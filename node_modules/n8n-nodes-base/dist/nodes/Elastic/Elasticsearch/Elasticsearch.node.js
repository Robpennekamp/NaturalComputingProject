"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Elasticsearch = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const GenericFunctions_1 = require("./GenericFunctions");
const descriptions_1 = require("./descriptions");
const lodash_omit_1 = __importDefault(require("lodash.omit"));
class Elasticsearch {
    constructor() {
        this.description = {
            displayName: 'Elasticsearch',
            name: 'elasticsearch',
            icon: 'file:elasticsearch.svg',
            group: ['transform'],
            version: 1,
            subtitle: '={{$parameter["operation"] + ": " + $parameter["resource"]}}',
            description: 'Consume the Elasticsearch API',
            defaults: {
                name: 'Elasticsearch',
            },
            inputs: ['main'],
            outputs: ['main'],
            credentials: [
                {
                    name: 'elasticsearchApi',
                    required: true,
                },
            ],
            properties: [
                {
                    displayName: 'Resource',
                    name: 'resource',
                    type: 'options',
                    noDataExpression: true,
                    options: [
                        {
                            name: 'Document',
                            value: 'document',
                        },
                        {
                            name: 'Index',
                            value: 'index',
                        },
                    ],
                    default: 'document',
                },
                ...descriptions_1.documentOperations,
                ...descriptions_1.documentFields,
                ...descriptions_1.indexOperations,
                ...descriptions_1.indexFields,
            ],
        };
    }
    async execute() {
        const items = this.getInputData();
        const returnData = [];
        const resource = this.getNodeParameter('resource', 0);
        const operation = this.getNodeParameter('operation', 0);
        let responseData;
        for (let i = 0; i < items.length; i++) {
            if (resource === 'document') {
                if (operation === 'delete') {
                    const indexId = this.getNodeParameter('indexId', i);
                    const documentId = this.getNodeParameter('documentId', i);
                    const endpoint = `/${indexId}/_doc/${documentId}`;
                    responseData = await GenericFunctions_1.elasticsearchApiRequest.call(this, 'DELETE', endpoint);
                }
                else if (operation === 'get') {
                    const indexId = this.getNodeParameter('indexId', i);
                    const documentId = this.getNodeParameter('documentId', i);
                    const qs = {};
                    const options = this.getNodeParameter('options', i);
                    if (Object.keys(options).length) {
                        Object.assign(qs, options);
                        qs._source = true;
                    }
                    const endpoint = `/${indexId}/_doc/${documentId}`;
                    responseData = await GenericFunctions_1.elasticsearchApiRequest.call(this, 'GET', endpoint, {}, qs);
                    const simple = this.getNodeParameter('simple', i);
                    if (simple) {
                        responseData = {
                            _id: responseData._id,
                            ...responseData._source,
                        };
                    }
                }
                else if (operation === 'getAll') {
                    const indexId = this.getNodeParameter('indexId', i);
                    const body = {};
                    const qs = {};
                    const options = this.getNodeParameter('options', i);
                    if (Object.keys(options).length) {
                        const { query, ...rest } = options;
                        if (query) {
                            Object.assign(body, (0, n8n_workflow_1.jsonParse)(query, { errorMessage: "Invalid JSON in 'Query' option" }));
                        }
                        Object.assign(qs, rest);
                        qs._source = true;
                    }
                    const returnAll = this.getNodeParameter('returnAll', 0);
                    if (returnAll) {
                        qs.size = 10000;
                        if (qs.sort) {
                            responseData = await GenericFunctions_1.elasticsearchApiRequestAllItems.call(this, indexId, body, qs);
                        }
                        else {
                            responseData = await GenericFunctions_1.elasticsearchApiRequest.call(this, 'GET', `/${indexId}/_search`, body, qs);
                            responseData = responseData.hits.hits;
                        }
                    }
                    else {
                        qs.size = this.getNodeParameter('limit', 0);
                        responseData = await GenericFunctions_1.elasticsearchApiRequest.call(this, 'GET', `/${indexId}/_search`, body, qs);
                        responseData = responseData.hits.hits;
                    }
                    const simple = this.getNodeParameter('simple', 0);
                    if (simple) {
                        responseData = responseData.map((item) => {
                            return {
                                _id: item._id,
                                ...item._source,
                            };
                        });
                    }
                }
                else if (operation === 'create') {
                    const body = {};
                    const dataToSend = this.getNodeParameter('dataToSend', 0);
                    if (dataToSend === 'defineBelow') {
                        const fields = this.getNodeParameter('fieldsUi.fieldValues', i, []);
                        fields.forEach(({ fieldId, fieldValue }) => (body[fieldId] = fieldValue));
                    }
                    else {
                        const inputData = items[i].json;
                        const rawInputsToIgnore = this.getNodeParameter('inputsToIgnore', i);
                        const inputsToIgnore = rawInputsToIgnore.split(',').map((c) => c.trim());
                        for (const key of Object.keys(inputData)) {
                            if (inputsToIgnore.includes(key))
                                continue;
                            body[key] = inputData[key];
                        }
                    }
                    const qs = {};
                    const additionalFields = this.getNodeParameter('additionalFields', i);
                    if (Object.keys(additionalFields).length) {
                        Object.assign(qs, (0, lodash_omit_1.default)(additionalFields, ['documentId']));
                    }
                    const indexId = this.getNodeParameter('indexId', i);
                    const { documentId } = additionalFields;
                    if (documentId) {
                        const endpoint = `/${indexId}/_doc/${documentId}`;
                        responseData = await GenericFunctions_1.elasticsearchApiRequest.call(this, 'PUT', endpoint, body);
                    }
                    else {
                        const endpoint = `/${indexId}/_doc`;
                        responseData = await GenericFunctions_1.elasticsearchApiRequest.call(this, 'POST', endpoint, body);
                    }
                }
                else if (operation === 'update') {
                    const body = { doc: {} };
                    const dataToSend = this.getNodeParameter('dataToSend', 0);
                    if (dataToSend === 'defineBelow') {
                        const fields = this.getNodeParameter('fieldsUi.fieldValues', i, []);
                        fields.forEach(({ fieldId, fieldValue }) => (body.doc[fieldId] = fieldValue));
                    }
                    else {
                        const inputData = items[i].json;
                        const rawInputsToIgnore = this.getNodeParameter('inputsToIgnore', i);
                        const inputsToIgnore = rawInputsToIgnore.split(',').map((c) => c.trim());
                        for (const key of Object.keys(inputData)) {
                            if (inputsToIgnore.includes(key))
                                continue;
                            body.doc[key] = inputData[key];
                        }
                    }
                    const indexId = this.getNodeParameter('indexId', i);
                    const documentId = this.getNodeParameter('documentId', i);
                    const endpoint = `/${indexId}/_update/${documentId}`;
                    responseData = await GenericFunctions_1.elasticsearchApiRequest.call(this, 'POST', endpoint, body);
                }
            }
            else if (resource === 'index') {
                if (operation === 'create') {
                    const indexId = this.getNodeParameter('indexId', i);
                    const body = {};
                    const qs = {};
                    const additionalFields = this.getNodeParameter('additionalFields', i);
                    if (Object.keys(additionalFields).length) {
                        const { aliases, mappings, settings, ...rest } = additionalFields;
                        Object.assign(body, aliases, mappings, settings);
                        Object.assign(qs, rest);
                    }
                    responseData = await GenericFunctions_1.elasticsearchApiRequest.call(this, 'PUT', `/${indexId}`);
                    responseData = { id: indexId, ...responseData };
                    delete responseData.index;
                }
                else if (operation === 'delete') {
                    const indexId = this.getNodeParameter('indexId', i);
                    responseData = await GenericFunctions_1.elasticsearchApiRequest.call(this, 'DELETE', `/${indexId}`);
                    responseData = { success: true };
                }
                else if (operation === 'get') {
                    const indexId = this.getNodeParameter('indexId', i);
                    const qs = {};
                    const additionalFields = this.getNodeParameter('additionalFields', i);
                    if (Object.keys(additionalFields).length) {
                        Object.assign(qs, additionalFields);
                    }
                    responseData = await GenericFunctions_1.elasticsearchApiRequest.call(this, 'GET', `/${indexId}`, {}, qs);
                    responseData = { id: indexId, ...responseData[indexId] };
                }
                else if (operation === 'getAll') {
                    responseData = await GenericFunctions_1.elasticsearchApiRequest.call(this, 'GET', '/_aliases');
                    responseData = Object.keys(responseData).map((index) => ({
                        indexId: index,
                    }));
                    const returnAll = this.getNodeParameter('returnAll', i);
                    if (!returnAll) {
                        const limit = this.getNodeParameter('limit', i);
                        responseData = responseData.slice(0, limit);
                    }
                }
            }
            const executionData = this.helpers.constructExecutionMetaData(this.helpers.returnJsonArray(responseData), { itemData: { item: i } });
            returnData.push(...executionData);
        }
        return this.prepareOutputData(returnData);
    }
}
exports.Elasticsearch = Elasticsearch;
//# sourceMappingURL=Elasticsearch.node.js.map