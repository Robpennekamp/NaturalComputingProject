"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.get = void 0;
const transport_1 = require("../../../transport");
async function get(index) {
    const body = {};
    const requestMethod = 'GET';
    const items = this.getInputData();
    const reportId = this.getNodeParameter('reportId', index);
    const format = this.getNodeParameter('format', 0);
    const fd = this.getNodeParameter('options.fd', index, true);
    const endpoint = `reports/${reportId}/?format=${format}&fd=${fd}`;
    if (format === 'JSON') {
        const responseData = await transport_1.apiRequest.call(this, requestMethod, endpoint, body, {}, { resolveWithFullResponse: true });
        return this.helpers.returnJsonArray(responseData.body);
    }
    const output = this.getNodeParameter('output', index);
    const response = await transport_1.apiRequest.call(this, requestMethod, endpoint, body, {}, {
        encoding: null,
        json: false,
        resolveWithFullResponse: true,
    });
    let mimeType = response.headers['content-type'];
    mimeType = mimeType ? mimeType.split(';').find((value) => value.includes('/')) : undefined;
    const contentDisposition = response.headers['content-disposition'];
    const fileNameRegex = /(?<=filename=").*\b/;
    const match = fileNameRegex.exec(contentDisposition);
    let fileName = '';
    if (match !== null) {
        fileName = match[0];
    }
    const newItem = {
        json: items[index].json,
        binary: {},
    };
    if (items[index].binary !== undefined && newItem.binary) {
        Object.assign(newItem.binary, items[index].binary);
    }
    newItem.binary = {
        [output]: await this.helpers.prepareBinaryData(response.body, fileName, mimeType),
    };
    return this.prepareOutputData(newItem);
}
exports.get = get;
//# sourceMappingURL=execute.js.map