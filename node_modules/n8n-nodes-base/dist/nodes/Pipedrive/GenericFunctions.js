"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sortOptionParameters = exports.pipedriveResolveCustomProperties = exports.pipedriveEncodeCustomProperties = exports.pipedriveGetCustomProperties = exports.pipedriveApiRequestAllItems = exports.pipedriveApiRequest = void 0;
const n8n_workflow_1 = require("n8n-workflow");
async function pipedriveApiRequest(method, endpoint, body, query = {}, formData, downloadFile) {
    const authenticationMethod = this.getNodeParameter('authentication', 0);
    const options = {
        headers: {
            Accept: 'application/json',
        },
        method,
        qs: query,
        uri: `https://api.pipedrive.com/v1${endpoint}`,
    };
    if (downloadFile === true) {
        options.encoding = null;
    }
    else {
        options.json = true;
    }
    if (Object.keys(body).length !== 0) {
        options.body = body;
    }
    if (formData !== undefined && Object.keys(formData).length !== 0) {
        options.formData = formData;
    }
    if (query === undefined) {
        query = {};
    }
    try {
        const credentialType = authenticationMethod === 'apiToken' ? 'pipedriveApi' : 'pipedriveOAuth2Api';
        const responseData = await this.helpers.requestWithAuthentication.call(this, credentialType, options);
        if (downloadFile === true) {
            return {
                data: responseData,
            };
        }
        if (responseData.success === false) {
            throw new n8n_workflow_1.NodeApiError(this.getNode(), responseData);
        }
        return {
            additionalData: responseData.additional_data,
            data: responseData.data === null ? [] : responseData.data,
        };
    }
    catch (error) {
        throw new n8n_workflow_1.NodeApiError(this.getNode(), error);
    }
}
exports.pipedriveApiRequest = pipedriveApiRequest;
async function pipedriveApiRequestAllItems(method, endpoint, body, query) {
    var _a, _b;
    if (query === undefined) {
        query = {};
    }
    query.limit = 100;
    query.start = 0;
    const returnData = [];
    let responseData;
    do {
        responseData = await pipedriveApiRequest.call(this, method, endpoint, body, query);
        if (responseData.data.items) {
            returnData.push.apply(returnData, responseData.data.items);
        }
        else {
            returnData.push.apply(returnData, responseData.data);
        }
        query.start = responseData.additionalData.pagination.next_start;
    } while (((_b = (_a = responseData.additionalData) === null || _a === void 0 ? void 0 : _a.pagination) === null || _b === void 0 ? void 0 : _b.more_items_in_collection) === true);
    return {
        data: returnData,
    };
}
exports.pipedriveApiRequestAllItems = pipedriveApiRequestAllItems;
async function pipedriveGetCustomProperties(resource) {
    const endpoints = {
        activity: '/activityFields',
        deal: '/dealFields',
        organization: '/organizationFields',
        person: '/personFields',
        product: '/productFields',
    };
    if (endpoints[resource] === undefined) {
        throw new n8n_workflow_1.NodeOperationError(this.getNode(), `The resource "${resource}" is not supported for resolving custom values!`);
    }
    const requestMethod = 'GET';
    const body = {};
    const qs = {};
    const responseData = await pipedriveApiRequest.call(this, requestMethod, endpoints[resource], body, qs);
    const customProperties = {};
    for (const customPropertyData of responseData.data) {
        customProperties[customPropertyData.key] = customPropertyData;
    }
    return customProperties;
}
exports.pipedriveGetCustomProperties = pipedriveGetCustomProperties;
function pipedriveEncodeCustomProperties(customProperties, item) {
    let customPropertyData;
    for (const key of Object.keys(item)) {
        customPropertyData = Object.values(customProperties).find((propertyData) => propertyData.name === key);
        if (customPropertyData !== undefined) {
            if (item[key] !== null &&
                item[key] !== undefined &&
                customPropertyData.options !== undefined &&
                Array.isArray(customPropertyData.options)) {
                const propertyOption = customPropertyData.options.find((option) => option.label.toString() === item[key].toString());
                if (propertyOption !== undefined) {
                    item[customPropertyData.key] = propertyOption.id;
                    delete item[key];
                }
            }
            else {
                item[customPropertyData.key] = item[key];
                delete item[key];
            }
        }
    }
}
exports.pipedriveEncodeCustomProperties = pipedriveEncodeCustomProperties;
function pipedriveResolveCustomProperties(customProperties, item) {
    let customPropertyData;
    const json = item.json;
    for (const key of Object.keys(json)) {
        if (customProperties[key] !== undefined) {
            customPropertyData = customProperties[key];
            if (json[key] === null) {
                json[customPropertyData.name] = json[key];
                delete json[key];
                continue;
            }
            if ([
                'date',
                'address',
                'double',
                'monetary',
                'org',
                'people',
                'phone',
                'text',
                'time',
                'user',
                'varchar',
                'varchar_auto',
                'int',
                'time',
                'timerange',
            ].includes(customPropertyData.field_type)) {
                json[customPropertyData.name] = json[key];
                delete json[key];
            }
            else if (['enum', 'visible_to'].includes(customPropertyData.field_type) &&
                customPropertyData.options) {
                const propertyOption = customPropertyData.options.find((option) => option.id.toString() === json[key].toString());
                if (propertyOption !== undefined) {
                    json[customPropertyData.name] = propertyOption.label;
                    delete json[key];
                }
            }
            else if (['set'].includes(customPropertyData.field_type) && customPropertyData.options) {
                const selectedIds = json[key].split(',');
                const selectedLabels = customPropertyData.options
                    .filter((option) => selectedIds.includes(option.id.toString()))
                    .map((option) => option.label);
                json[customPropertyData.name] = selectedLabels;
                delete json[key];
            }
        }
    }
    item.json = json;
}
exports.pipedriveResolveCustomProperties = pipedriveResolveCustomProperties;
function sortOptionParameters(optionParameters) {
    optionParameters.sort((a, b) => {
        const aName = a.name.toLowerCase();
        const bName = b.name.toLowerCase();
        if (aName < bName) {
            return -1;
        }
        if (aName > bName) {
            return 1;
        }
        return 0;
    });
    return optionParameters;
}
exports.sortOptionParameters = sortOptionParameters;
//# sourceMappingURL=GenericFunctions.js.map