"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceEmptyStringsByNulls = exports.addSortRules = exports.addWhereClauses = exports.configureQueryRunner = exports.prepareOutput = exports.wrapData = exports.parseMySqlError = exports.prepareErrorItem = exports.prepareQueryAndReplacements = exports.copyInputItems = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const interfaces_1 = require("./interfaces");
function copyInputItems(items, properties) {
    let newItem;
    return items.map((item) => {
        newItem = {};
        for (const property of properties) {
            if (item.json[property] === undefined) {
                newItem[property] = null;
            }
            else {
                newItem[property] = (0, n8n_workflow_1.deepCopy)(item.json[property]);
            }
        }
        return newItem;
    });
}
exports.copyInputItems = copyInputItems;
const prepareQueryAndReplacements = (rawQuery, replacements) => {
    if (replacements === undefined) {
        return { query: rawQuery, values: [] };
    }
    let query = rawQuery;
    const values = [];
    const regex = /\$(\d+)(?::name)?/g;
    const matches = rawQuery.match(regex) || [];
    for (const match of matches) {
        if (match.includes(':name')) {
            const matchIndex = Number(match.replace('$', '').replace(':name', '')) - 1;
            query = query.replace(match, `\`${replacements[matchIndex]}\``);
        }
        else {
            const matchIndex = Number(match.replace('$', '')) - 1;
            query = query.replace(match, '?');
            values.push(replacements[matchIndex]);
        }
    }
    return { query, values };
};
exports.prepareQueryAndReplacements = prepareQueryAndReplacements;
function prepareErrorItem(item, error, index) {
    return {
        json: { message: error.message, item: { ...item }, itemIndex: index, error: { ...error } },
        pairedItem: { item: index },
    };
}
exports.prepareErrorItem = prepareErrorItem;
function parseMySqlError(error, itemIndex = 0, queries) {
    let message = error.message;
    const description = `sql: ${error.sql}, code: ${error.code}`;
    if ((queries === null || queries === void 0 ? void 0 : queries.length) &&
        (message || '').toLowerCase().includes('you have an error in your sql syntax')) {
        let queryIndex = itemIndex;
        const failedStatement = ((message.split("near '")[1] || '').split("' at")[0] || '').split(';')[0];
        if (failedStatement) {
            if (queryIndex === 0 && queries.length > 1) {
                const failedQueryIndex = queries.findIndex((query) => query.includes(failedStatement));
                if (failedQueryIndex !== -1) {
                    queryIndex = failedQueryIndex;
                }
            }
            const lines = queries[queryIndex].split('\n');
            const failedLine = lines.findIndex((line) => line.includes(failedStatement));
            if (failedLine !== -1) {
                message = `You have an error in your SQL syntax on line ${failedLine + 1} near '${failedStatement}'`;
            }
        }
    }
    if ((error === null || error === void 0 ? void 0 : error.message).includes('ECONNREFUSED')) {
        message = 'Connection refused';
    }
    return new n8n_workflow_1.NodeOperationError(this.getNode(), error, {
        message,
        description,
        itemIndex,
    });
}
exports.parseMySqlError = parseMySqlError;
function wrapData(data) {
    if (!Array.isArray(data)) {
        return [{ json: data }];
    }
    return data.map((item) => ({
        json: item,
    }));
}
exports.wrapData = wrapData;
function prepareOutput(response, options, statements, constructExecutionHelper) {
    const returnData = [];
    if (options.detailedOutput) {
        response.forEach((entry, index) => {
            const item = {
                sql: statements[index],
                data: entry,
            };
            const executionData = constructExecutionHelper(wrapData(item), {
                itemData: { item: index },
            });
            returnData.push(...executionData);
        });
    }
    else {
        response
            .filter((entry) => Array.isArray(entry))
            .forEach((entry, index) => {
            const executionData = constructExecutionHelper(wrapData(entry), {
                itemData: { item: index },
            });
            returnData.push(...executionData);
        });
    }
    if (!returnData.length) {
        returnData.push({ json: { success: true } });
    }
    return returnData;
}
exports.prepareOutput = prepareOutput;
function configureQueryRunner(options, pool) {
    return async (queries) => {
        if (queries.length === 0) {
            return [];
        }
        const returnData = [];
        const mode = options.queryBatching || interfaces_1.BATCH_MODE.SINGLE;
        const connection = await pool.getConnection();
        if (mode === interfaces_1.BATCH_MODE.SINGLE) {
            const formatedQueries = queries.map(({ query, values }) => connection.format(query, values));
            try {
                connection.release();
                let singleQuery = '';
                if (formatedQueries.length > 1) {
                    singleQuery = formatedQueries.map((query) => query.trim().replace(/;$/, '')).join(';');
                }
                else {
                    singleQuery = formatedQueries[0];
                }
                let response = (await pool.query(singleQuery))[0];
                if (!response)
                    return [];
                const statements = singleQuery
                    .replace(/\n/g, '')
                    .split(';')
                    .filter((statement) => statement !== '');
                if (Array.isArray(response)) {
                    if (statements.length === 1)
                        response = [response];
                }
                else {
                    response = [response];
                }
                returnData.push(...prepareOutput(response, options, statements, this.helpers.constructExecutionMetaData));
            }
            catch (err) {
                const error = parseMySqlError.call(this, err, 0, formatedQueries);
                if (!this.continueOnFail())
                    throw error;
                returnData.push({ json: { message: error.message, error: { ...error } } });
            }
        }
        else {
            if (mode === interfaces_1.BATCH_MODE.INDEPENDENTLY) {
                let formatedQuery = '';
                for (const [index, queryWithValues] of queries.entries()) {
                    try {
                        const { query, values } = queryWithValues;
                        formatedQuery = connection.format(query, values);
                        const statements = formatedQuery.split(';').map((q) => q.trim());
                        const responses = [];
                        for (const statement of statements) {
                            if (statement === '')
                                continue;
                            const response = (await connection.query(statement))[0];
                            responses.push(response);
                        }
                        returnData.push(...prepareOutput(responses, options, statements, this.helpers.constructExecutionMetaData));
                    }
                    catch (err) {
                        const error = parseMySqlError.call(this, err, index, [formatedQuery]);
                        if (!this.continueOnFail()) {
                            connection.release();
                            throw error;
                        }
                        returnData.push(prepareErrorItem(queries[index], error, index));
                    }
                }
            }
            if (mode === interfaces_1.BATCH_MODE.TRANSACTION) {
                await connection.beginTransaction();
                let formatedQuery = '';
                for (const [index, queryWithValues] of queries.entries()) {
                    try {
                        const { query, values } = queryWithValues;
                        formatedQuery = connection.format(query, values);
                        const statements = formatedQuery.split(';').map((q) => q.trim());
                        const responses = [];
                        for (const statement of statements) {
                            if (statement === '')
                                continue;
                            const response = (await connection.query(statement))[0];
                            responses.push(response);
                        }
                        returnData.push(...prepareOutput(responses, options, statements, this.helpers.constructExecutionMetaData));
                    }
                    catch (err) {
                        const error = parseMySqlError.call(this, err, index, [formatedQuery]);
                        if (connection) {
                            await connection.rollback();
                            connection.release();
                        }
                        if (!this.continueOnFail())
                            throw error;
                        returnData.push(prepareErrorItem(queries[index], error, index));
                        return returnData;
                    }
                }
                await connection.commit();
            }
            connection.release();
        }
        return returnData;
    };
}
exports.configureQueryRunner = configureQueryRunner;
function addWhereClauses(node, itemIndex, query, clauses, replacements, combineConditions) {
    if (clauses.length === 0)
        return [query, replacements];
    let combineWith = 'AND';
    if (combineConditions === 'OR') {
        combineWith = 'OR';
    }
    let whereQuery = ' WHERE';
    const values = [];
    clauses.forEach((clause, index) => {
        if (clause.condition === 'equal') {
            clause.condition = '=';
        }
        if (['>', '<', '>=', '<='].includes(clause.condition)) {
            const value = Number(clause.value);
            if (Number.isNaN(value)) {
                throw new n8n_workflow_1.NodeOperationError(node, `Operator in entry ${index + 1} of 'Select Rows' works with numbers, but value ${clause.value} is not a number`, {
                    itemIndex,
                });
            }
            clause.value = value;
        }
        let valueReplacement = ' ';
        if (clause.condition !== 'IS NULL') {
            valueReplacement = ' ?';
            values.push(clause.value);
        }
        const operator = index === clauses.length - 1 ? '' : ` ${combineWith}`;
        whereQuery += ` \`${clause.column}\` ${clause.condition}${valueReplacement}${operator}`;
    });
    return [`${query}${whereQuery}`, replacements.concat(...values)];
}
exports.addWhereClauses = addWhereClauses;
function addSortRules(query, rules, replacements) {
    if (rules.length === 0)
        return [query, replacements];
    let orderByQuery = ' ORDER BY';
    const values = [];
    rules.forEach((rule, index) => {
        const endWith = index === rules.length - 1 ? '' : ',';
        orderByQuery += ` \`${rule.column}\` ${rule.direction}${endWith}`;
    });
    return [`${query}${orderByQuery}`, replacements.concat(...values)];
}
exports.addSortRules = addSortRules;
function replaceEmptyStringsByNulls(items, replace) {
    if (!replace)
        return [...items];
    const returnData = items.map((item) => {
        const newItem = { ...item };
        const keys = Object.keys(newItem.json);
        for (const key of keys) {
            if (newItem.json[key] === '') {
                newItem.json[key] = null;
            }
        }
        return newItem;
    });
    return returnData;
}
exports.replaceEmptyStringsByNulls = replaceEmptyStringsByNulls;
//# sourceMappingURL=utils.js.map