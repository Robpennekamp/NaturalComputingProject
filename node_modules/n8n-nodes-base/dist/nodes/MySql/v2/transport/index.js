"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPool = void 0;
const promise_1 = __importDefault(require("mysql2/promise"));
const promises_1 = require("fs/promises");
const tmp_promise_1 = require("tmp-promise");
async function createSshConnectConfig(credentials) {
    if (credentials.sshAuthenticateWith === 'password') {
        return {
            host: credentials.sshHost,
            port: credentials.sshPort,
            username: credentials.sshUser,
            password: credentials.sshPassword,
        };
    }
    else {
        const { path } = await (0, tmp_promise_1.file)({ prefix: 'n8n-ssh-' });
        await (0, promises_1.writeFile)(path, credentials.privateKey);
        const options = {
            host: credentials.host,
            username: credentials.username,
            port: credentials.port,
            privateKey: path,
        };
        if (credentials.passphrase) {
            options.passphrase = credentials.passphrase;
        }
        return options;
    }
}
async function createPool(credentials, options, sshClient) {
    if (credentials === undefined) {
        throw new Error('Credentials not selected, select or add new credentials');
    }
    const { ssl, caCertificate, clientCertificate, clientPrivateKey, sshTunnel, sshHost, sshUser, sshPassword, sshPort, sshMysqlPort, privateKey, passphrase, sshAuthenticateWith, ...baseCredentials } = credentials;
    if (ssl) {
        baseCredentials.ssl = {};
        if (caCertificate) {
            baseCredentials.ssl.ca = caCertificate;
        }
        if (clientCertificate || clientPrivateKey) {
            baseCredentials.ssl.cert = clientCertificate;
            baseCredentials.ssl.key = clientPrivateKey;
        }
    }
    const connectionOptions = {
        ...baseCredentials,
        multipleStatements: true,
        supportBigNumbers: true,
    };
    if ((options === null || options === void 0 ? void 0 : options.nodeVersion) && options.nodeVersion >= 2.1) {
        connectionOptions.dateStrings = true;
    }
    if (options === null || options === void 0 ? void 0 : options.connectionLimit) {
        connectionOptions.connectionLimit = options.connectionLimit;
    }
    if (options === null || options === void 0 ? void 0 : options.connectTimeout) {
        connectionOptions.connectTimeout = options.connectTimeout;
    }
    if ((options === null || options === void 0 ? void 0 : options.largeNumbersOutput) === 'text') {
        connectionOptions.bigNumberStrings = true;
    }
    if (!sshTunnel) {
        return promise_1.default.createPool(connectionOptions);
    }
    else {
        if (!sshClient) {
            throw new Error('SSH Tunnel is enabled but no SSH Client was provided');
        }
        const tunnelConfig = await createSshConnectConfig(credentials);
        const forwardConfig = {
            srcHost: '127.0.0.1',
            srcPort: sshMysqlPort,
            dstHost: credentials.host,
            dstPort: credentials.port,
        };
        if (sshAuthenticateWith === 'privateKey') {
            sshClient.on('end', async () => {
                await (0, promises_1.rm)(tunnelConfig.privateKey);
            });
        }
        const poolSetup = new Promise((resolve, reject) => {
            sshClient
                .on('ready', () => {
                sshClient.forwardOut(forwardConfig.srcHost, forwardConfig.srcPort, forwardConfig.dstHost, forwardConfig.dstPort, (err, stream) => {
                    if (err)
                        reject(err);
                    const updatedDbServer = {
                        ...connectionOptions,
                        stream,
                    };
                    const connection = promise_1.default.createPool(updatedDbServer);
                    resolve(connection);
                });
            })
                .connect(tunnelConfig);
        });
        return poolSetup;
    }
}
exports.createPool = createPool;
//# sourceMappingURL=index.js.map