"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AmqpTrigger = void 0;
const rhea_1 = require("rhea");
const n8n_workflow_1 = require("n8n-workflow");
class AmqpTrigger {
    constructor() {
        this.description = {
            displayName: 'AMQP Trigger',
            name: 'amqpTrigger',
            icon: 'file:amqp.png',
            group: ['trigger'],
            version: 1,
            description: 'Listens to AMQP 1.0 Messages',
            defaults: {
                name: 'AMQP Trigger',
            },
            inputs: [],
            outputs: ['main'],
            credentials: [
                {
                    name: 'amqp',
                    required: true,
                },
            ],
            properties: [
                {
                    displayName: 'Queue / Topic',
                    name: 'sink',
                    type: 'string',
                    default: '',
                    placeholder: 'topic://sourcename.something',
                    description: 'Name of the queue of topic to listen to',
                },
                {
                    displayName: 'Clientname',
                    name: 'clientname',
                    type: 'string',
                    default: '',
                    placeholder: 'for durable/persistent topic subscriptions, example: "n8n"',
                    description: 'Leave empty for non-durable topic subscriptions or queues',
                },
                {
                    displayName: 'Subscription',
                    name: 'subscription',
                    type: 'string',
                    default: '',
                    placeholder: 'for durable/persistent topic subscriptions, example: "order-worker"',
                    description: 'Leave empty for non-durable topic subscriptions or queues',
                },
                {
                    displayName: 'Options',
                    name: 'options',
                    type: 'collection',
                    placeholder: 'Add Option',
                    default: {},
                    options: [
                        {
                            displayName: 'Container ID',
                            name: 'containerId',
                            type: 'string',
                            default: '',
                            description: 'Will be used to pass to the RHEA Backend as container_id',
                        },
                        {
                            displayName: 'Convert Body To String',
                            name: 'jsonConvertByteArrayToString',
                            type: 'boolean',
                            default: false,
                            description: 'Whether to convert JSON Body content (["body"]["content"]) from Byte Array to string. Needed for Azure Service Bus.',
                        },
                        {
                            displayName: 'JSON Parse Body',
                            name: 'jsonParseBody',
                            type: 'boolean',
                            default: false,
                            description: 'Whether to parse the body to an object',
                        },
                        {
                            displayName: 'Messages per Cicle',
                            name: 'pullMessagesNumber',
                            type: 'number',
                            default: 100,
                            description: 'Number of messages to pull from the bus for every cicle',
                        },
                        {
                            displayName: 'Only Body',
                            name: 'onlyBody',
                            type: 'boolean',
                            default: false,
                            description: 'Whether to return only the body property',
                        },
                        {
                            displayName: 'Reconnect',
                            name: 'reconnect',
                            type: 'boolean',
                            default: true,
                            description: 'Whether to automatically reconnect if disconnected',
                        },
                        {
                            displayName: 'Reconnect Limit',
                            name: 'reconnectLimit',
                            type: 'number',
                            default: 50,
                            description: 'Maximum number of reconnect attempts',
                        },
                        {
                            displayName: 'Sleep Time',
                            name: 'sleepTime',
                            type: 'number',
                            default: 10,
                            description: 'Milliseconds to sleep after every cicle',
                        },
                    ],
                },
            ],
        };
    }
    async trigger() {
        const credentials = await this.getCredentials('amqp');
        const sink = this.getNodeParameter('sink', '');
        const clientname = this.getNodeParameter('clientname', '');
        const subscription = this.getNodeParameter('subscription', '');
        const options = this.getNodeParameter('options', {});
        const pullMessagesNumber = options.pullMessagesNumber || 100;
        const containerId = options.containerId;
        const containerReconnect = options.reconnect || true;
        const containerReconnectLimit = options.reconnectLimit || 50;
        if (sink === '') {
            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Queue or Topic required!');
        }
        let durable = false;
        if (subscription && clientname) {
            durable = true;
        }
        const container = (0, rhea_1.create_container)();
        let lastMsgId = undefined;
        container.on('receiver_open', (context) => {
            var _a;
            (_a = context.receiver) === null || _a === void 0 ? void 0 : _a.add_credit(pullMessagesNumber);
        });
        container.on('message', (context) => {
            var _a;
            if (!context.message) {
                return;
            }
            if (context.message.message_id && context.message.message_id === lastMsgId) {
                return;
            }
            lastMsgId = context.message.message_id;
            let data = context.message;
            if (options.jsonConvertByteArrayToString === true && data.body.content !== undefined) {
                const cont = (0, n8n_workflow_1.deepCopy)(data.body.content);
                data.body = String.fromCharCode.apply(null, cont.data);
            }
            if (options.jsonConvertByteArrayToString === true && data.body.content !== undefined) {
                const cont = (0, n8n_workflow_1.deepCopy)(data.body.content);
                data.body = String.fromCharCode.apply(null, cont.data);
            }
            if (options.jsonConvertByteArrayToString === true && data.body.content !== undefined) {
                const content = (0, n8n_workflow_1.deepCopy)(data.body.content);
                data.body = String.fromCharCode.apply(null, content.data);
            }
            if (options.jsonParseBody === true) {
                data.body = (0, n8n_workflow_1.jsonParse)(data.body);
            }
            if (options.onlyBody === true) {
                data = data.body;
            }
            this.emit([this.helpers.returnJsonArray([data])]);
            if (!((_a = context.receiver) === null || _a === void 0 ? void 0 : _a.has_credit())) {
                setTimeout(() => {
                    var _a;
                    (_a = context.receiver) === null || _a === void 0 ? void 0 : _a.add_credit(pullMessagesNumber);
                }, options.sleepTime || 10);
            }
        });
        const connectOptions = {
            host: credentials.hostname,
            hostname: credentials.hostname,
            port: credentials.port,
            reconnect: containerReconnect,
            reconnect_limit: containerReconnectLimit,
            username: credentials.username ? credentials.username : undefined,
            password: credentials.password ? credentials.password : undefined,
            transport: credentials.transportType ? credentials.transportType : undefined,
            container_id: containerId ? containerId : undefined,
            id: containerId ? containerId : undefined,
        };
        const connection = container.connect(connectOptions);
        const clientOptions = {
            name: subscription ? subscription : undefined,
            source: {
                address: sink,
                durable: durable ? 2 : undefined,
                expiry_policy: durable ? 'never' : undefined,
            },
            credit_window: 0,
        };
        connection.open_receiver(clientOptions);
        async function closeFunction() {
            container.removeAllListeners('receiver_open');
            container.removeAllListeners('message');
            connection.close();
        }
        const manualTriggerFunction = async () => {
            await new Promise((resolve, reject) => {
                const timeoutHandler = setTimeout(() => {
                    reject(new Error('Aborted, no message received within 30secs. This 30sec timeout is only set for "manually triggered execution". Active Workflows will listen indefinitely.'));
                }, 30000);
                container.on('message', (context) => {
                    const message = context.message;
                    if (Object.keys(message)[0] === 'body' && Object.keys(message).length === 1) {
                        this.emit([this.helpers.returnJsonArray([message.body])]);
                    }
                    else {
                        this.emit([this.helpers.returnJsonArray([message])]);
                    }
                    clearTimeout(timeoutHandler);
                    resolve(true);
                });
            });
        };
        return {
            closeFunction,
            manualTriggerFunction,
        };
    }
}
exports.AmqpTrigger = AmqpTrigger;
//# sourceMappingURL=AmqpTrigger.node.js.map