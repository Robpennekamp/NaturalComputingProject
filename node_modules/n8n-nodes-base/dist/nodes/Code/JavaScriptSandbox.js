"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JavaScriptSandbox = void 0;
const vm2_1 = require("vm2");
const ValidationError_1 = require("./ValidationError");
const ExecutionError_1 = require("./ExecutionError");
const Sandbox_1 = require("./Sandbox");
const { NODE_FUNCTION_ALLOW_BUILTIN: builtIn, NODE_FUNCTION_ALLOW_EXTERNAL: external } = process.env;
const getSandboxOptions = (context, workflowMode) => ({
    console: workflowMode === 'manual' ? 'redirect' : 'inherit',
    sandbox: context,
    require: {
        builtin: builtIn ? builtIn.split(',') : [],
        external: external ? { modules: external.split(','), transitive: false } : false,
    },
});
class JavaScriptSandbox extends Sandbox_1.Sandbox {
    constructor(context, jsCode, itemIndex, workflowMode, helpers) {
        super({
            object: {
                singular: 'object',
                plural: 'objects',
            },
        }, itemIndex, helpers);
        this.jsCode = jsCode;
        this.vm = new vm2_1.NodeVM(getSandboxOptions(context, workflowMode));
    }
    async runCodeAllItems() {
        const script = `module.exports = async function() {${this.jsCode}\n}()`;
        let executionResult;
        try {
            executionResult = await this.vm.run(script, __dirname);
        }
        catch (error) {
            if (error.message === 'items is not defined' && !/(let|const|var) items =/.test(script)) {
                const quoted = error.message.replace('items', '`items`');
                error.message = quoted + '. Did you mean `$input.all()`?';
            }
            throw new ExecutionError_1.ExecutionError(error);
        }
        if (executionResult === null)
            return [];
        return this.validateRunCodeAllItems(executionResult);
    }
    async runCodeEachItem() {
        var _a;
        const script = `module.exports = async function() {${this.jsCode}\n}()`;
        const match = this.jsCode.match(/\$input\.(?<disallowedMethod>first|last|all|itemMatching)/);
        if ((_a = match === null || match === void 0 ? void 0 : match.groups) === null || _a === void 0 ? void 0 : _a.disallowedMethod) {
            const { disallowedMethod } = match.groups;
            const lineNumber = this.jsCode.split('\n').findIndex((line) => {
                return line.includes(disallowedMethod) && !line.startsWith('//') && !line.startsWith('*');
            }) + 1;
            const disallowedMethodFound = lineNumber !== 0;
            if (disallowedMethodFound) {
                throw new ValidationError_1.ValidationError({
                    message: `Can't use .${disallowedMethod}() here`,
                    description: "This is only available in 'Run Once for All Items' mode",
                    itemIndex: this.itemIndex,
                    lineNumber,
                });
            }
        }
        let executionResult;
        try {
            executionResult = await this.vm.run(script, __dirname);
        }
        catch (error) {
            if (error.message === 'item is not defined' && !/(let|const|var) item =/.test(script)) {
                const quoted = error.message.replace('item', '`item`');
                error.message = quoted + '. Did you mean `$input.item.json`?';
            }
            throw new ExecutionError_1.ExecutionError(error, this.itemIndex);
        }
        if (executionResult === null)
            return;
        return this.validateRunCodeEachItem(executionResult);
    }
}
exports.JavaScriptSandbox = JavaScriptSandbox;
//# sourceMappingURL=JavaScriptSandbox.js.map