"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PythonSandbox = void 0;
const Pyodide_1 = require("./Pyodide");
const Sandbox_1 = require("./Sandbox");
const envAccessBlocked = process.env.N8N_BLOCK_ENV_ACCESS_IN_NODE === 'true';
class PythonSandbox extends Sandbox_1.Sandbox {
    constructor(context, pythonCode, moduleImports, itemIndex, helpers) {
        super({
            object: {
                singular: 'dictionary',
                plural: 'dictionaries',
            },
        }, itemIndex, helpers);
        this.pythonCode = pythonCode;
        this.moduleImports = moduleImports;
        this.context = Object.keys(context).reduce((acc, key) => {
            acc[key.startsWith('$') ? key.replace(/^\$/, '_') : key] = context[key];
            return acc;
        }, {});
    }
    async runCodeAllItems() {
        const executionResult = await this.runCodeInPython();
        return this.validateRunCodeAllItems(executionResult);
    }
    async runCodeEachItem() {
        const executionResult = await this.runCodeInPython();
        return this.validateRunCodeEachItem(executionResult);
    }
    async runCodeInPython() {
        const runCode = `
from _pyodide_core import jsproxy_typedict
from js import Object
jsproxy_typedict[0] = type(Object.new().as_object_map())

if printOverwrite:
  print = printOverwrite

async def __main():
${this.pythonCode
            .split('\n')
            .map((line) => '  ' + line)
            .join('\n')}
await __main()
`;
        const pyodide = await (0, Pyodide_1.LoadPyodide)();
        const moduleImportsFiltered = this.moduleImports.filter((importModule) => !['asyncio', 'pyodide', 'math'].includes(importModule));
        if (moduleImportsFiltered.length) {
            await pyodide.loadPackage('micropip');
            const micropip = pyodide.pyimport('micropip');
            await Promise.all(moduleImportsFiltered.map((importModule) => micropip.install(importModule)));
        }
        let executionResult;
        try {
            const dict = pyodide.globals.get('dict');
            const globalsDict = dict();
            for (const key of Object.keys(this.context)) {
                if ((key === '_env' && envAccessBlocked) || key === '_node')
                    continue;
                const value = this.context[key];
                globalsDict.set(key, value);
            }
            executionResult = await pyodide.runPythonAsync(runCode, { globals: globalsDict });
            globalsDict.destroy();
        }
        catch (error) {
            throw this.getPrettyError(error);
        }
        if (executionResult === null || executionResult === void 0 ? void 0 : executionResult.toJs) {
            return executionResult.toJs({
                dict_converter: Object.fromEntries,
                create_proxies: false,
            });
        }
        return executionResult;
    }
    getPrettyError(error) {
        const errorTypeIndex = error.message.indexOf(error.type);
        if (errorTypeIndex !== -1) {
            return new Error(error.message.slice(errorTypeIndex));
        }
        return error;
    }
}
exports.PythonSandbox = PythonSandbox;
//# sourceMappingURL=PythonSandbox.js.map