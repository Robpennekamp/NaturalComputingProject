"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatColumns = exports.extractDeleteValues = exports.extractUpdateCondition = exports.extractUpdateSet = exports.extractValues = exports.executeQueryQueue = exports.createTableStruct = exports.copyInputItem = void 0;
const n8n_workflow_1 = require("n8n-workflow");
function copyInputItem(item, properties) {
    const newItem = {};
    for (const property of properties) {
        if (item.json[property] === undefined) {
            newItem[property] = null;
        }
        else {
            newItem[property] = (0, n8n_workflow_1.deepCopy)(item.json[property]);
        }
    }
    return newItem;
}
exports.copyInputItem = copyInputItem;
function createTableStruct(getNodeParam, items, additionalProperties = [], keyName) {
    return items.reduce((tables, item, index) => {
        const table = getNodeParam('table', index);
        const columnString = getNodeParam('columns', index);
        const columns = columnString.split(',').map((column) => column.trim());
        const itemCopy = copyInputItem(item, columns.concat(additionalProperties));
        const keyParam = keyName ? getNodeParam(keyName, index) : undefined;
        if (tables[table] === undefined) {
            tables[table] = {};
        }
        if (tables[table][columnString] === undefined) {
            tables[table][columnString] = [];
        }
        if (keyName) {
            itemCopy[keyName] = keyParam;
        }
        tables[table][columnString].push(itemCopy);
        return tables;
    }, {});
}
exports.createTableStruct = createTableStruct;
async function executeQueryQueue(tables, buildQueryQueue) {
    return Promise.all(Object.keys(tables).map(async (table) => {
        const columnsResults = Object.keys(tables[table]).map(async (columnString) => {
            return Promise.all(buildQueryQueue({
                table,
                columnString,
                items: tables[table][columnString],
            }));
        });
        return Promise.all(columnsResults);
    }));
}
exports.executeQueryQueue = executeQueryQueue;
function extractValues(item) {
    return `(${Object.values(item)
        .map((val) => {
        if (val === null) {
            return 'NULL';
        }
        else if (typeof val === 'string') {
            return `'${val.replace(/'/g, "''")}'`;
        }
        else if (typeof val === 'boolean') {
            return +!!val;
        }
        return val;
    })
        .join(',')})`;
}
exports.extractValues = extractValues;
function extractUpdateSet(item, columns) {
    return columns
        .map((column) => `"${column}" = ${typeof item[column] === 'string' ? `'${item[column]}'` : item[column]}`)
        .join(',');
}
exports.extractUpdateSet = extractUpdateSet;
function extractUpdateCondition(item, key) {
    return `${key} = ${typeof item[key] === 'string' ? `'${item[key]}'` : item[key]}`;
}
exports.extractUpdateCondition = extractUpdateCondition;
function extractDeleteValues(items, key) {
    return `(${items
        .map((item) => (typeof item[key] === 'string' ? `'${item[key]}'` : item[key]))
        .join(',')})`;
}
exports.extractDeleteValues = extractDeleteValues;
function formatColumns(columns) {
    return columns
        .split(',')
        .map((column) => `"${column.trim()}"`)
        .join(',');
}
exports.formatColumns = formatColumns;
//# sourceMappingURL=GenericFunctions.js.map