"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.binaryToAttachments = exports.downloadAttachments = exports.createMessage = exports.makeRecipient = exports.microsoftApiRequestAllItemsSkip = exports.microsoftApiRequestAllItems = exports.microsoftApiRequest = void 0;
const n8n_workflow_1 = require("n8n-workflow");
async function microsoftApiRequest(method, resource, body = {}, qs = {}, uri, headers = {}, option = { json: true }) {
    const credentials = await this.getCredentials('microsoftOutlookOAuth2Api');
    let apiUrl = `https://graph.microsoft.com/v1.0/me${resource}`;
    if (credentials.useShared && credentials.userPrincipalName) {
        apiUrl = `https://graph.microsoft.com/v1.0/users/${credentials.userPrincipalName}${resource}`;
    }
    const options = {
        headers: {
            'Content-Type': 'application/json',
        },
        method,
        body,
        qs,
        uri: uri || apiUrl,
    };
    try {
        Object.assign(options, option);
        if (Object.keys(headers).length !== 0) {
            options.headers = Object.assign({}, options.headers, headers);
        }
        if (Object.keys(body).length === 0) {
            delete options.body;
        }
        return await this.helpers.requestOAuth2.call(this, 'microsoftOutlookOAuth2Api', options);
    }
    catch (error) {
        throw new n8n_workflow_1.NodeApiError(this.getNode(), error);
    }
}
exports.microsoftApiRequest = microsoftApiRequest;
async function microsoftApiRequestAllItems(propertyName, method, endpoint, body = {}, query = {}, headers = {}) {
    const returnData = [];
    let responseData;
    let uri;
    query.$top = 100;
    do {
        responseData = await microsoftApiRequest.call(this, method, endpoint, body, query, uri, headers);
        uri = responseData['@odata.nextLink'];
        returnData.push.apply(returnData, responseData[propertyName]);
    } while (responseData['@odata.nextLink'] !== undefined);
    return returnData;
}
exports.microsoftApiRequestAllItems = microsoftApiRequestAllItems;
async function microsoftApiRequestAllItemsSkip(propertyName, method, endpoint, body = {}, query = {}, headers = {}) {
    const returnData = [];
    let responseData;
    query.$top = 100;
    query.$skip = 0;
    do {
        responseData = await microsoftApiRequest.call(this, method, endpoint, body, query, undefined, headers);
        query.$skip += query.$top;
        returnData.push.apply(returnData, responseData[propertyName]);
    } while (responseData.value.length !== 0);
    return returnData;
}
exports.microsoftApiRequestAllItemsSkip = microsoftApiRequestAllItemsSkip;
function makeRecipient(email) {
    return {
        emailAddress: {
            address: email,
        },
    };
}
exports.makeRecipient = makeRecipient;
function createMessage(fields) {
    const message = {};
    if (fields.bodyContent || fields.bodyContentType) {
        const bodyObject = {
            content: fields.bodyContent,
            contentType: fields.bodyContentType,
        };
        message.body = bodyObject;
        delete fields.bodyContent;
        delete fields.bodyContentType;
    }
    if ('internetMessageHeaders' in fields &&
        'headers' in fields.internetMessageHeaders) {
        fields.internetMessageHeaders = fields.internetMessageHeaders.headers;
    }
    ['bccRecipients', 'ccRecipients', 'replyTo', 'sender', 'toRecipients'].forEach((key) => {
        if (Array.isArray(fields[key])) {
            fields[key] = fields[key].map((email) => makeRecipient(email));
        }
        else if (fields[key] !== undefined) {
            fields[key] = fields[key]
                .split(',')
                .map((recipient) => makeRecipient(recipient));
        }
    });
    ['from', 'sender'].forEach((key) => {
        if (fields[key] !== undefined) {
            fields[key] = makeRecipient(fields[key]);
        }
    });
    Object.assign(message, fields);
    return message;
}
exports.createMessage = createMessage;
async function downloadAttachments(messages, prefix) {
    const elements = [];
    if (!Array.isArray(messages)) {
        messages = [messages];
    }
    for (const message of messages) {
        const element = {
            json: message,
            binary: {},
        };
        if (message.hasAttachments === true) {
            const attachments = await microsoftApiRequestAllItems.call(this, 'value', 'GET', `/messages/${message.id}/attachments`, {});
            for (const [index, attachment] of attachments.entries()) {
                const response = await microsoftApiRequest.call(this, 'GET', `/messages/${message.id}/attachments/${attachment.id}/$value`, undefined, {}, undefined, {}, { encoding: null, resolveWithFullResponse: true });
                const data = Buffer.from(response.body, 'utf8');
                element.binary[`${prefix}${index}`] = await this.helpers.prepareBinaryData(data, attachment.name, attachment.contentType);
            }
        }
        if (Object.keys(element.binary).length === 0) {
            delete element.binary;
        }
        elements.push(element);
    }
    return elements;
}
exports.downloadAttachments = downloadAttachments;
async function binaryToAttachments(attachments, items, i) {
    return Promise.all(attachments.map(async (attachment) => {
        const binaryPropertyName = attachment.binaryPropertyName;
        const binaryData = this.helpers.assertBinaryData(i, binaryPropertyName);
        const dataBuffer = await this.helpers.getBinaryDataBuffer(i, binaryPropertyName);
        return {
            '@odata.type': '#microsoft.graph.fileAttachment',
            name: binaryData.fileName,
            contentBytes: dataBuffer.toString(n8n_workflow_1.BINARY_ENCODING),
        };
    }));
}
exports.binaryToAttachments = binaryToAttachments;
//# sourceMappingURL=GenericFunctions.js.map